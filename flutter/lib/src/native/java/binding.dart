// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `io.sentry.android.replay.ReplayIntegration`
class ReplayIntegration extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ReplayIntegration> $type;

  @jni$_.internal
  ReplayIntegration.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/android/replay/ReplayIntegration');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ReplayIntegration$NullableType();
  static const type = $ReplayIntegration$Type();
  static final _id_new$ = _class.constructorId(
    r'(Landroid/content/Context;Lio/sentry/transport/ICurrentDateProvider;Lkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(android.content.Context context, io.sentry.transport.ICurrentDateProvider iCurrentDateProvider, kotlin.jvm.functions.Function0 function0, kotlin.jvm.functions.Function1 function1, kotlin.jvm.functions.Function1 function11)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ReplayIntegration(
    jni$_.JObject context,
    jni$_.JObject iCurrentDateProvider,
    jni$_.JObject? function0,
    jni$_.JObject? function1,
    jni$_.JObject? function11,
  ) {
    final _$context = context.reference;
    final _$iCurrentDateProvider = iCurrentDateProvider.reference;
    final _$function0 = function0?.reference ?? jni$_.jNullReference;
    final _$function1 = function1?.reference ?? jni$_.jNullReference;
    final _$function11 = function11?.reference ?? jni$_.jNullReference;
    return ReplayIntegration.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$iCurrentDateProvider.pointer,
            _$function0.pointer,
            _$function1.pointer,
            _$function11.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Landroid/content/Context;Lio/sentry/transport/ICurrentDateProvider;Lkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(android.content.Context context, io.sentry.transport.ICurrentDateProvider iCurrentDateProvider, kotlin.jvm.functions.Function0 function0, kotlin.jvm.functions.Function1 function1, kotlin.jvm.functions.Function1 function11, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ReplayIntegration.new$1(
    jni$_.JObject? context,
    jni$_.JObject? iCurrentDateProvider,
    jni$_.JObject? function0,
    jni$_.JObject? function1,
    jni$_.JObject? function11,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$context = context?.reference ?? jni$_.jNullReference;
    final _$iCurrentDateProvider =
        iCurrentDateProvider?.reference ?? jni$_.jNullReference;
    final _$function0 = function0?.reference ?? jni$_.jNullReference;
    final _$function1 = function1?.reference ?? jni$_.jNullReference;
    final _$function11 = function11?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return ReplayIntegration.fromReference(_new$1(
            _class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$iCurrentDateProvider.pointer,
            _$function0.pointer,
            _$function1.pointer,
            _$function11.pointer,
            i,
            _$defaultConstructorMarker.pointer)
        .reference);
  }

  static final _id_new$2 = _class.constructorId(
    r'(Landroid/content/Context;Lio/sentry/transport/ICurrentDateProvider;)V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(android.content.Context context, io.sentry.transport.ICurrentDateProvider iCurrentDateProvider)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ReplayIntegration.new$2(
    jni$_.JObject context,
    jni$_.JObject iCurrentDateProvider,
  ) {
    final _$context = context.reference;
    final _$iCurrentDateProvider = iCurrentDateProvider.reference;
    return ReplayIntegration.fromReference(_new$2(
            _class.reference.pointer,
            _id_new$2 as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$iCurrentDateProvider.pointer)
        .reference);
  }

  static final _id_new$3 = _class.constructorId(
    r'(Landroid/content/Context;Lio/sentry/transport/ICurrentDateProvider;Lkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;Lio/sentry/android/replay/util/MainLooperHandler;Lkotlin/jvm/functions/Function0;)V',
  );

  static final _new$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(android.content.Context context, io.sentry.transport.ICurrentDateProvider iCurrentDateProvider, kotlin.jvm.functions.Function0 function0, kotlin.jvm.functions.Function1 function1, kotlin.jvm.functions.Function1 function11, kotlin.jvm.functions.Function1 function12, io.sentry.android.replay.util.MainLooperHandler mainLooperHandler, kotlin.jvm.functions.Function0 function01)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ReplayIntegration.new$3(
    jni$_.JObject context,
    jni$_.JObject iCurrentDateProvider,
    jni$_.JObject? function0,
    jni$_.JObject? function1,
    jni$_.JObject? function11,
    jni$_.JObject? function12,
    jni$_.JObject? mainLooperHandler,
    jni$_.JObject? function01,
  ) {
    final _$context = context.reference;
    final _$iCurrentDateProvider = iCurrentDateProvider.reference;
    final _$function0 = function0?.reference ?? jni$_.jNullReference;
    final _$function1 = function1?.reference ?? jni$_.jNullReference;
    final _$function11 = function11?.reference ?? jni$_.jNullReference;
    final _$function12 = function12?.reference ?? jni$_.jNullReference;
    final _$mainLooperHandler =
        mainLooperHandler?.reference ?? jni$_.jNullReference;
    final _$function01 = function01?.reference ?? jni$_.jNullReference;
    return ReplayIntegration.fromReference(_new$3(
            _class.reference.pointer,
            _id_new$3 as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$iCurrentDateProvider.pointer,
            _$function0.pointer,
            _$function1.pointer,
            _$function11.pointer,
            _$function12.pointer,
            _$mainLooperHandler.pointer,
            _$function01.pointer)
        .reference);
  }

  static final _id_new$4 = _class.constructorId(
    r'(Landroid/content/Context;Lio/sentry/transport/ICurrentDateProvider;Lkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;Lio/sentry/android/replay/util/MainLooperHandler;Lkotlin/jvm/functions/Function0;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(android.content.Context context, io.sentry.transport.ICurrentDateProvider iCurrentDateProvider, kotlin.jvm.functions.Function0 function0, kotlin.jvm.functions.Function1 function1, kotlin.jvm.functions.Function1 function11, kotlin.jvm.functions.Function1 function12, io.sentry.android.replay.util.MainLooperHandler mainLooperHandler, kotlin.jvm.functions.Function0 function01, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ReplayIntegration.new$4(
    jni$_.JObject? context,
    jni$_.JObject? iCurrentDateProvider,
    jni$_.JObject? function0,
    jni$_.JObject? function1,
    jni$_.JObject? function11,
    jni$_.JObject? function12,
    jni$_.JObject? mainLooperHandler,
    jni$_.JObject? function01,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$context = context?.reference ?? jni$_.jNullReference;
    final _$iCurrentDateProvider =
        iCurrentDateProvider?.reference ?? jni$_.jNullReference;
    final _$function0 = function0?.reference ?? jni$_.jNullReference;
    final _$function1 = function1?.reference ?? jni$_.jNullReference;
    final _$function11 = function11?.reference ?? jni$_.jNullReference;
    final _$function12 = function12?.reference ?? jni$_.jNullReference;
    final _$mainLooperHandler =
        mainLooperHandler?.reference ?? jni$_.jNullReference;
    final _$function01 = function01?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return ReplayIntegration.fromReference(_new$4(
            _class.reference.pointer,
            _id_new$4 as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$iCurrentDateProvider.pointer,
            _$function0.pointer,
            _$function1.pointer,
            _$function11.pointer,
            _$function12.pointer,
            _$mainLooperHandler.pointer,
            _$function01.pointer,
            i,
            _$defaultConstructorMarker.pointer)
        .reference);
  }

  static final _id_getReplayCacheDir = _class.instanceMethodId(
    r'getReplayCacheDir',
    r'()Ljava/io/File;',
  );

  static final _getReplayCacheDir = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.io.File getReplayCacheDir()`
  /// The returned object must be released after use, by calling the [release] method.
  File? getReplayCacheDir() {
    return _getReplayCacheDir(
            reference.pointer, _id_getReplayCacheDir as jni$_.JMethodIDPtr)
        .object<File?>(const $File$NullableType());
  }

  static final _id_register = _class.instanceMethodId(
    r'register',
    r'(Lio/sentry/IScopes;Lio/sentry/SentryOptions;)V',
  );

  static final _register = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void register(io.sentry.IScopes iScopes, io.sentry.SentryOptions sentryOptions)`
  void register(
    jni$_.JObject iScopes,
    jni$_.JObject sentryOptions,
  ) {
    final _$iScopes = iScopes.reference;
    final _$sentryOptions = sentryOptions.reference;
    _register(reference.pointer, _id_register as jni$_.JMethodIDPtr,
            _$iScopes.pointer, _$sentryOptions.pointer)
        .check();
  }

  static final _id_isRecording = _class.instanceMethodId(
    r'isRecording',
    r'()Z',
  );

  static final _isRecording = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isRecording()`
  bool isRecording() {
    return _isRecording(
            reference.pointer, _id_isRecording as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_start = _class.instanceMethodId(
    r'start',
    r'()V',
  );

  static final _start = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void start()`
  void start() {
    _start(reference.pointer, _id_start as jni$_.JMethodIDPtr).check();
  }

  static final _id_resume = _class.instanceMethodId(
    r'resume',
    r'()V',
  );

  static final _resume = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void resume()`
  void resume() {
    _resume(reference.pointer, _id_resume as jni$_.JMethodIDPtr).check();
  }

  static final _id_captureReplay = _class.instanceMethodId(
    r'captureReplay',
    r'(Ljava/lang/Boolean;)V',
  );

  static final _captureReplay = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void captureReplay(java.lang.Boolean boolean)`
  void captureReplay(
    jni$_.JBoolean? boolean,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    _captureReplay(reference.pointer, _id_captureReplay as jni$_.JMethodIDPtr,
            _$boolean.pointer)
        .check();
  }

  static final _id_getReplayId = _class.instanceMethodId(
    r'getReplayId',
    r'()Lio/sentry/protocol/SentryId;',
  );

  static final _getReplayId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.SentryId getReplayId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getReplayId() {
    return _getReplayId(
            reference.pointer, _id_getReplayId as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setBreadcrumbConverter = _class.instanceMethodId(
    r'setBreadcrumbConverter',
    r'(Lio/sentry/ReplayBreadcrumbConverter;)V',
  );

  static final _setBreadcrumbConverter = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setBreadcrumbConverter(io.sentry.ReplayBreadcrumbConverter replayBreadcrumbConverter)`
  void setBreadcrumbConverter(
    jni$_.JObject replayBreadcrumbConverter,
  ) {
    final _$replayBreadcrumbConverter = replayBreadcrumbConverter.reference;
    _setBreadcrumbConverter(
            reference.pointer,
            _id_setBreadcrumbConverter as jni$_.JMethodIDPtr,
            _$replayBreadcrumbConverter.pointer)
        .check();
  }

  static final _id_getBreadcrumbConverter = _class.instanceMethodId(
    r'getBreadcrumbConverter',
    r'()Lio/sentry/ReplayBreadcrumbConverter;',
  );

  static final _getBreadcrumbConverter = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ReplayBreadcrumbConverter getBreadcrumbConverter()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getBreadcrumbConverter() {
    return _getBreadcrumbConverter(
            reference.pointer, _id_getBreadcrumbConverter as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_pause = _class.instanceMethodId(
    r'pause',
    r'()V',
  );

  static final _pause = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void pause()`
  void pause() {
    _pause(reference.pointer, _id_pause as jni$_.JMethodIDPtr).check();
  }

  static final _id_stop = _class.instanceMethodId(
    r'stop',
    r'()V',
  );

  static final _stop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void stop()`
  void stop() {
    _stop(reference.pointer, _id_stop as jni$_.JMethodIDPtr).check();
  }

  static final _id_onScreenshotRecorded = _class.instanceMethodId(
    r'onScreenshotRecorded',
    r'(Landroid/graphics/Bitmap;)V',
  );

  static final _onScreenshotRecorded = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onScreenshotRecorded(android.graphics.Bitmap bitmap)`
  void onScreenshotRecorded(
    jni$_.JObject bitmap,
  ) {
    final _$bitmap = bitmap.reference;
    _onScreenshotRecorded(reference.pointer,
            _id_onScreenshotRecorded as jni$_.JMethodIDPtr, _$bitmap.pointer)
        .check();
  }

  static final _id_onScreenshotRecorded$1 = _class.instanceMethodId(
    r'onScreenshotRecorded',
    r'(Ljava/io/File;J)V',
  );

  static final _onScreenshotRecorded$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public void onScreenshotRecorded(java.io.File file, long j)`
  void onScreenshotRecorded$1(
    File file,
    int j,
  ) {
    final _$file = file.reference;
    _onScreenshotRecorded$1(reference.pointer,
            _id_onScreenshotRecorded$1 as jni$_.JMethodIDPtr, _$file.pointer, j)
        .check();
  }

  static final _id_close = _class.instanceMethodId(
    r'close',
    r'()V',
  );

  static final _close = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_onConfigurationChanged = _class.instanceMethodId(
    r'onConfigurationChanged',
    r'(Landroid/content/res/Configuration;)V',
  );

  static final _onConfigurationChanged = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onConfigurationChanged(android.content.res.Configuration configuration)`
  void onConfigurationChanged(
    jni$_.JObject configuration,
  ) {
    final _$configuration = configuration.reference;
    _onConfigurationChanged(
            reference.pointer,
            _id_onConfigurationChanged as jni$_.JMethodIDPtr,
            _$configuration.pointer)
        .check();
  }

  static final _id_onConnectionStatusChanged = _class.instanceMethodId(
    r'onConnectionStatusChanged',
    r'(Lio/sentry/IConnectionStatusProvider$ConnectionStatus;)V',
  );

  static final _onConnectionStatusChanged = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onConnectionStatusChanged(io.sentry.IConnectionStatusProvider$ConnectionStatus connectionStatus)`
  void onConnectionStatusChanged(
    jni$_.JObject connectionStatus,
  ) {
    final _$connectionStatus = connectionStatus.reference;
    _onConnectionStatusChanged(
            reference.pointer,
            _id_onConnectionStatusChanged as jni$_.JMethodIDPtr,
            _$connectionStatus.pointer)
        .check();
  }

  static final _id_onRateLimitChanged = _class.instanceMethodId(
    r'onRateLimitChanged',
    r'(Lio/sentry/transport/RateLimiter;)V',
  );

  static final _onRateLimitChanged = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onRateLimitChanged(io.sentry.transport.RateLimiter rateLimiter)`
  void onRateLimitChanged(
    jni$_.JObject rateLimiter,
  ) {
    final _$rateLimiter = rateLimiter.reference;
    _onRateLimitChanged(reference.pointer,
            _id_onRateLimitChanged as jni$_.JMethodIDPtr, _$rateLimiter.pointer)
        .check();
  }

  static final _id_onLowMemory = _class.instanceMethodId(
    r'onLowMemory',
    r'()V',
  );

  static final _onLowMemory = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void onLowMemory()`
  void onLowMemory() {
    _onLowMemory(reference.pointer, _id_onLowMemory as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_onTouchEvent = _class.instanceMethodId(
    r'onTouchEvent',
    r'(Landroid/view/MotionEvent;)V',
  );

  static final _onTouchEvent = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onTouchEvent(android.view.MotionEvent motionEvent)`
  void onTouchEvent(
    jni$_.JObject motionEvent,
  ) {
    final _$motionEvent = motionEvent.reference;
    _onTouchEvent(reference.pointer, _id_onTouchEvent as jni$_.JMethodIDPtr,
            _$motionEvent.pointer)
        .check();
  }
}

final class $ReplayIntegration$NullableType
    extends jni$_.JObjType<ReplayIntegration?> {
  @jni$_.internal
  const $ReplayIntegration$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/replay/ReplayIntegration;';

  @jni$_.internal
  @core$_.override
  ReplayIntegration? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ReplayIntegration.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ReplayIntegration?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ReplayIntegration$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ReplayIntegration$NullableType) &&
        other is $ReplayIntegration$NullableType;
  }
}

final class $ReplayIntegration$Type extends jni$_.JObjType<ReplayIntegration> {
  @jni$_.internal
  const $ReplayIntegration$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/replay/ReplayIntegration;';

  @jni$_.internal
  @core$_.override
  ReplayIntegration fromReference(jni$_.JReference reference) =>
      ReplayIntegration.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ReplayIntegration?> get nullableType =>
      const $ReplayIntegration$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ReplayIntegration$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ReplayIntegration$Type) &&
        other is $ReplayIntegration$Type;
  }
}

/// from: `io.sentry.flutter.SentryFlutterPlugin$Companion`
class SentryFlutterPlugin$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryFlutterPlugin$Companion> $type;

  @jni$_.internal
  SentryFlutterPlugin$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/flutter/SentryFlutterPlugin$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryFlutterPlugin$Companion$NullableType();
  static const type = $SentryFlutterPlugin$Companion$Type();
  static final _id_privateSentryGetReplayIntegration = _class.instanceMethodId(
    r'privateSentryGetReplayIntegration',
    r'()Lio/sentry/android/replay/ReplayIntegration;',
  );

  static final _privateSentryGetReplayIntegration =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public final io.sentry.android.replay.ReplayIntegration privateSentryGetReplayIntegration()`
  /// The returned object must be released after use, by calling the [release] method.
  ReplayIntegration? privateSentryGetReplayIntegration() {
    return _privateSentryGetReplayIntegration(reference.pointer,
            _id_privateSentryGetReplayIntegration as jni$_.JMethodIDPtr)
        .object<ReplayIntegration?>(const $ReplayIntegration$NullableType());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryFlutterPlugin$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return SentryFlutterPlugin$Companion.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $SentryFlutterPlugin$Companion$NullableType
    extends jni$_.JObjType<SentryFlutterPlugin$Companion?> {
  @jni$_.internal
  const $SentryFlutterPlugin$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/flutter/SentryFlutterPlugin$Companion;';

  @jni$_.internal
  @core$_.override
  SentryFlutterPlugin$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryFlutterPlugin$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryFlutterPlugin$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryFlutterPlugin$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryFlutterPlugin$Companion$NullableType) &&
        other is $SentryFlutterPlugin$Companion$NullableType;
  }
}

final class $SentryFlutterPlugin$Companion$Type
    extends jni$_.JObjType<SentryFlutterPlugin$Companion> {
  @jni$_.internal
  const $SentryFlutterPlugin$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/flutter/SentryFlutterPlugin$Companion;';

  @jni$_.internal
  @core$_.override
  SentryFlutterPlugin$Companion fromReference(jni$_.JReference reference) =>
      SentryFlutterPlugin$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryFlutterPlugin$Companion?> get nullableType =>
      const $SentryFlutterPlugin$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryFlutterPlugin$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryFlutterPlugin$Companion$Type) &&
        other is $SentryFlutterPlugin$Companion$Type;
  }
}

/// from: `io.sentry.flutter.SentryFlutterPlugin`
class SentryFlutterPlugin extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryFlutterPlugin> $type;

  @jni$_.internal
  SentryFlutterPlugin.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/flutter/SentryFlutterPlugin');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryFlutterPlugin$NullableType();
  static const type = $SentryFlutterPlugin$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Lio/sentry/flutter/SentryFlutterPlugin$Companion;',
  );

  /// from: `static public final io.sentry.flutter.SentryFlutterPlugin$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryFlutterPlugin$Companion get Companion =>
      _id_Companion.get(_class, const $SentryFlutterPlugin$Companion$Type());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryFlutterPlugin() {
    return SentryFlutterPlugin.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_onAttachedToEngine = _class.instanceMethodId(
    r'onAttachedToEngine',
    r'(Lio/flutter/embedding/engine/plugins/FlutterPlugin$FlutterPluginBinding;)V',
  );

  static final _onAttachedToEngine = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onAttachedToEngine(io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding flutterPluginBinding)`
  void onAttachedToEngine(
    jni$_.JObject flutterPluginBinding,
  ) {
    final _$flutterPluginBinding = flutterPluginBinding.reference;
    _onAttachedToEngine(
            reference.pointer,
            _id_onAttachedToEngine as jni$_.JMethodIDPtr,
            _$flutterPluginBinding.pointer)
        .check();
  }

  static final _id_onMethodCall = _class.instanceMethodId(
    r'onMethodCall',
    r'(Lio/flutter/plugin/common/MethodCall;Lio/flutter/plugin/common/MethodChannel$Result;)V',
  );

  static final _onMethodCall = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onMethodCall(io.flutter.plugin.common.MethodCall methodCall, io.flutter.plugin.common.MethodChannel$Result result)`
  void onMethodCall(
    jni$_.JObject methodCall,
    jni$_.JObject result,
  ) {
    final _$methodCall = methodCall.reference;
    final _$result = result.reference;
    _onMethodCall(reference.pointer, _id_onMethodCall as jni$_.JMethodIDPtr,
            _$methodCall.pointer, _$result.pointer)
        .check();
  }

  static final _id_onDetachedFromEngine = _class.instanceMethodId(
    r'onDetachedFromEngine',
    r'(Lio/flutter/embedding/engine/plugins/FlutterPlugin$FlutterPluginBinding;)V',
  );

  static final _onDetachedFromEngine = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onDetachedFromEngine(io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding flutterPluginBinding)`
  void onDetachedFromEngine(
    jni$_.JObject flutterPluginBinding,
  ) {
    final _$flutterPluginBinding = flutterPluginBinding.reference;
    _onDetachedFromEngine(
            reference.pointer,
            _id_onDetachedFromEngine as jni$_.JMethodIDPtr,
            _$flutterPluginBinding.pointer)
        .check();
  }

  static final _id_onAttachedToActivity = _class.instanceMethodId(
    r'onAttachedToActivity',
    r'(Lio/flutter/embedding/engine/plugins/activity/ActivityPluginBinding;)V',
  );

  static final _onAttachedToActivity = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onAttachedToActivity(io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding activityPluginBinding)`
  void onAttachedToActivity(
    jni$_.JObject activityPluginBinding,
  ) {
    final _$activityPluginBinding = activityPluginBinding.reference;
    _onAttachedToActivity(
            reference.pointer,
            _id_onAttachedToActivity as jni$_.JMethodIDPtr,
            _$activityPluginBinding.pointer)
        .check();
  }

  static final _id_onDetachedFromActivity = _class.instanceMethodId(
    r'onDetachedFromActivity',
    r'()V',
  );

  static final _onDetachedFromActivity = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void onDetachedFromActivity()`
  void onDetachedFromActivity() {
    _onDetachedFromActivity(
            reference.pointer, _id_onDetachedFromActivity as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_onReattachedToActivityForConfigChanges =
      _class.instanceMethodId(
    r'onReattachedToActivityForConfigChanges',
    r'(Lio/flutter/embedding/engine/plugins/activity/ActivityPluginBinding;)V',
  );

  static final _onReattachedToActivityForConfigChanges =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onReattachedToActivityForConfigChanges(io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding activityPluginBinding)`
  void onReattachedToActivityForConfigChanges(
    jni$_.JObject activityPluginBinding,
  ) {
    final _$activityPluginBinding = activityPluginBinding.reference;
    _onReattachedToActivityForConfigChanges(
            reference.pointer,
            _id_onReattachedToActivityForConfigChanges as jni$_.JMethodIDPtr,
            _$activityPluginBinding.pointer)
        .check();
  }

  static final _id_onDetachedFromActivityForConfigChanges =
      _class.instanceMethodId(
    r'onDetachedFromActivityForConfigChanges',
    r'()V',
  );

  static final _onDetachedFromActivityForConfigChanges =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public void onDetachedFromActivityForConfigChanges()`
  void onDetachedFromActivityForConfigChanges() {
    _onDetachedFromActivityForConfigChanges(reference.pointer,
            _id_onDetachedFromActivityForConfigChanges as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_privateSentryGetReplayIntegration = _class.staticMethodId(
    r'privateSentryGetReplayIntegration',
    r'()Lio/sentry/android/replay/ReplayIntegration;',
  );

  static final _privateSentryGetReplayIntegration =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `static public final io.sentry.android.replay.ReplayIntegration privateSentryGetReplayIntegration()`
  /// The returned object must be released after use, by calling the [release] method.
  static ReplayIntegration? privateSentryGetReplayIntegration() {
    return _privateSentryGetReplayIntegration(_class.reference.pointer,
            _id_privateSentryGetReplayIntegration as jni$_.JMethodIDPtr)
        .object<ReplayIntegration?>(const $ReplayIntegration$NullableType());
  }
}

final class $SentryFlutterPlugin$NullableType
    extends jni$_.JObjType<SentryFlutterPlugin?> {
  @jni$_.internal
  const $SentryFlutterPlugin$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/flutter/SentryFlutterPlugin;';

  @jni$_.internal
  @core$_.override
  SentryFlutterPlugin? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryFlutterPlugin.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryFlutterPlugin?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryFlutterPlugin$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryFlutterPlugin$NullableType) &&
        other is $SentryFlutterPlugin$NullableType;
  }
}

final class $SentryFlutterPlugin$Type
    extends jni$_.JObjType<SentryFlutterPlugin> {
  @jni$_.internal
  const $SentryFlutterPlugin$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/flutter/SentryFlutterPlugin;';

  @jni$_.internal
  @core$_.override
  SentryFlutterPlugin fromReference(jni$_.JReference reference) =>
      SentryFlutterPlugin.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryFlutterPlugin?> get nullableType =>
      const $SentryFlutterPlugin$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryFlutterPlugin$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryFlutterPlugin$Type) &&
        other is $SentryFlutterPlugin$Type;
  }
}

/// from: `java.io.File`
class File extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<File> $type;

  @jni$_.internal
  File.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/File');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $File$NullableType();
  static const type = $File$Type();
  static final _id_pathSeparator = _class.staticFieldId(
    r'pathSeparator',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String pathSeparator`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get pathSeparator =>
      _id_pathSeparator.get(_class, const jni$_.JStringNullableType());

  static final _id_pathSeparatorChar = _class.staticFieldId(
    r'pathSeparatorChar',
    r'C',
  );

  /// from: `static public final char pathSeparatorChar`
  static int get pathSeparatorChar =>
      _id_pathSeparatorChar.get(_class, const jni$_.jcharType());

  static final _id_separator = _class.staticFieldId(
    r'separator',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String separator`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get separator =>
      _id_separator.get(_class, const jni$_.JStringNullableType());

  static final _id_separatorChar = _class.staticFieldId(
    r'separatorChar',
    r'C',
  );

  /// from: `static public final char separatorChar`
  static int get separatorChar =>
      _id_separatorChar.get(_class, const jni$_.jcharType());

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory File(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return File.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$string.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory File.new$1(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return File.fromReference(_new$1(
            _class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer)
        .reference);
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/io/File;Ljava/lang/String;)V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.io.File file, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory File.new$2(
    File? file,
    jni$_.JString? string,
  ) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return File.fromReference(_new$2(_class.reference.pointer,
            _id_new$2 as jni$_.JMethodIDPtr, _$file.pointer, _$string.pointer)
        .reference);
  }

  static final _id_new$3 = _class.constructorId(
    r'(Ljava/net/URI;)V',
  );

  static final _new$3 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.net.URI uRI)`
  /// The returned object must be released after use, by calling the [release] method.
  factory File.new$3(
    jni$_.JObject? uRI,
  ) {
    final _$uRI = uRI?.reference ?? jni$_.jNullReference;
    return File.fromReference(_new$3(_class.reference.pointer,
            _id_new$3 as jni$_.JMethodIDPtr, _$uRI.pointer)
        .reference);
  }

  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getName() {
    return _getName(reference.pointer, _id_getName as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getParent = _class.instanceMethodId(
    r'getParent',
    r'()Ljava/lang/String;',
  );

  static final _getParent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getParent()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getParent() {
    return _getParent(reference.pointer, _id_getParent as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getParentFile = _class.instanceMethodId(
    r'getParentFile',
    r'()Ljava/io/File;',
  );

  static final _getParentFile = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.io.File getParentFile()`
  /// The returned object must be released after use, by calling the [release] method.
  File? getParentFile() {
    return _getParentFile(
            reference.pointer, _id_getParentFile as jni$_.JMethodIDPtr)
        .object<File?>(const $File$NullableType());
  }

  static final _id_getPath = _class.instanceMethodId(
    r'getPath',
    r'()Ljava/lang/String;',
  );

  static final _getPath = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getPath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getPath() {
    return _getPath(reference.pointer, _id_getPath as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_isAbsolute = _class.instanceMethodId(
    r'isAbsolute',
    r'()Z',
  );

  static final _isAbsolute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isAbsolute()`
  bool isAbsolute() {
    return _isAbsolute(reference.pointer, _id_isAbsolute as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getAbsolutePath = _class.instanceMethodId(
    r'getAbsolutePath',
    r'()Ljava/lang/String;',
  );

  static final _getAbsolutePath = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getAbsolutePath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getAbsolutePath() {
    return _getAbsolutePath(
            reference.pointer, _id_getAbsolutePath as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getAbsoluteFile = _class.instanceMethodId(
    r'getAbsoluteFile',
    r'()Ljava/io/File;',
  );

  static final _getAbsoluteFile = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.io.File getAbsoluteFile()`
  /// The returned object must be released after use, by calling the [release] method.
  File? getAbsoluteFile() {
    return _getAbsoluteFile(
            reference.pointer, _id_getAbsoluteFile as jni$_.JMethodIDPtr)
        .object<File?>(const $File$NullableType());
  }

  static final _id_getCanonicalPath = _class.instanceMethodId(
    r'getCanonicalPath',
    r'()Ljava/lang/String;',
  );

  static final _getCanonicalPath = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getCanonicalPath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getCanonicalPath() {
    return _getCanonicalPath(
            reference.pointer, _id_getCanonicalPath as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getCanonicalFile = _class.instanceMethodId(
    r'getCanonicalFile',
    r'()Ljava/io/File;',
  );

  static final _getCanonicalFile = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.io.File getCanonicalFile()`
  /// The returned object must be released after use, by calling the [release] method.
  File? getCanonicalFile() {
    return _getCanonicalFile(
            reference.pointer, _id_getCanonicalFile as jni$_.JMethodIDPtr)
        .object<File?>(const $File$NullableType());
  }

  static final _id_toURL = _class.instanceMethodId(
    r'toURL',
    r'()Ljava/net/URL;',
  );

  static final _toURL = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.net.URL toURL()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? toURL() {
    return _toURL(reference.pointer, _id_toURL as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_toURI = _class.instanceMethodId(
    r'toURI',
    r'()Ljava/net/URI;',
  );

  static final _toURI = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.net.URI toURI()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? toURI() {
    return _toURI(reference.pointer, _id_toURI as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_canRead = _class.instanceMethodId(
    r'canRead',
    r'()Z',
  );

  static final _canRead = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean canRead()`
  bool canRead() {
    return _canRead(reference.pointer, _id_canRead as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_canWrite = _class.instanceMethodId(
    r'canWrite',
    r'()Z',
  );

  static final _canWrite = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean canWrite()`
  bool canWrite() {
    return _canWrite(reference.pointer, _id_canWrite as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_exists = _class.instanceMethodId(
    r'exists',
    r'()Z',
  );

  static final _exists = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean exists()`
  bool exists() {
    return _exists(reference.pointer, _id_exists as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_isDirectory = _class.instanceMethodId(
    r'isDirectory',
    r'()Z',
  );

  static final _isDirectory = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isDirectory()`
  bool isDirectory() {
    return _isDirectory(
            reference.pointer, _id_isDirectory as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_isFile = _class.instanceMethodId(
    r'isFile',
    r'()Z',
  );

  static final _isFile = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isFile()`
  bool isFile() {
    return _isFile(reference.pointer, _id_isFile as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_isHidden = _class.instanceMethodId(
    r'isHidden',
    r'()Z',
  );

  static final _isHidden = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isHidden()`
  bool isHidden() {
    return _isHidden(reference.pointer, _id_isHidden as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_lastModified = _class.instanceMethodId(
    r'lastModified',
    r'()J',
  );

  static final _lastModified = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long lastModified()`
  int lastModified() {
    return _lastModified(
            reference.pointer, _id_lastModified as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_length = _class.instanceMethodId(
    r'length',
    r'()J',
  );

  static final _length = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long length()`
  int length() {
    return _length(reference.pointer, _id_length as jni$_.JMethodIDPtr).long;
  }

  static final _id_createNewFile = _class.instanceMethodId(
    r'createNewFile',
    r'()Z',
  );

  static final _createNewFile = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean createNewFile()`
  bool createNewFile() {
    return _createNewFile(
            reference.pointer, _id_createNewFile as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_delete = _class.instanceMethodId(
    r'delete',
    r'()Z',
  );

  static final _delete = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean delete()`
  bool delete() {
    return _delete(reference.pointer, _id_delete as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_deleteOnExit = _class.instanceMethodId(
    r'deleteOnExit',
    r'()V',
  );

  static final _deleteOnExit = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void deleteOnExit()`
  void deleteOnExit() {
    _deleteOnExit(reference.pointer, _id_deleteOnExit as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_list = _class.instanceMethodId(
    r'list',
    r'()[Ljava/lang/String;',
  );

  static final _list = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String[] list()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?>? list() {
    return _list(reference.pointer, _id_list as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<jni$_.JString?>?>(
            const jni$_.JArrayNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_list$1 = _class.instanceMethodId(
    r'list',
    r'(Ljava/io/FilenameFilter;)[Ljava/lang/String;',
  );

  static final _list$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String[] list(java.io.FilenameFilter filenameFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?>? list$1(
    jni$_.JObject? filenameFilter,
  ) {
    final _$filenameFilter = filenameFilter?.reference ?? jni$_.jNullReference;
    return _list$1(reference.pointer, _id_list$1 as jni$_.JMethodIDPtr,
            _$filenameFilter.pointer)
        .object<jni$_.JArray<jni$_.JString?>?>(
            const jni$_.JArrayNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_listFiles = _class.instanceMethodId(
    r'listFiles',
    r'()[Ljava/io/File;',
  );

  static final _listFiles = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.io.File[] listFiles()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<File?>? listFiles() {
    return _listFiles(reference.pointer, _id_listFiles as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<File?>?>(
            const jni$_.JArrayNullableType<File?>($File$NullableType()));
  }

  static final _id_listFiles$1 = _class.instanceMethodId(
    r'listFiles',
    r'(Ljava/io/FilenameFilter;)[Ljava/io/File;',
  );

  static final _listFiles$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.io.File[] listFiles(java.io.FilenameFilter filenameFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<File?>? listFiles$1(
    jni$_.JObject? filenameFilter,
  ) {
    final _$filenameFilter = filenameFilter?.reference ?? jni$_.jNullReference;
    return _listFiles$1(reference.pointer,
            _id_listFiles$1 as jni$_.JMethodIDPtr, _$filenameFilter.pointer)
        .object<jni$_.JArray<File?>?>(
            const jni$_.JArrayNullableType<File?>($File$NullableType()));
  }

  static final _id_listFiles$2 = _class.instanceMethodId(
    r'listFiles',
    r'(Ljava/io/FileFilter;)[Ljava/io/File;',
  );

  static final _listFiles$2 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.io.File[] listFiles(java.io.FileFilter fileFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<File?>? listFiles$2(
    jni$_.JObject? fileFilter,
  ) {
    final _$fileFilter = fileFilter?.reference ?? jni$_.jNullReference;
    return _listFiles$2(reference.pointer,
            _id_listFiles$2 as jni$_.JMethodIDPtr, _$fileFilter.pointer)
        .object<jni$_.JArray<File?>?>(
            const jni$_.JArrayNullableType<File?>($File$NullableType()));
  }

  static final _id_mkdir = _class.instanceMethodId(
    r'mkdir',
    r'()Z',
  );

  static final _mkdir = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean mkdir()`
  bool mkdir() {
    return _mkdir(reference.pointer, _id_mkdir as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_mkdirs = _class.instanceMethodId(
    r'mkdirs',
    r'()Z',
  );

  static final _mkdirs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean mkdirs()`
  bool mkdirs() {
    return _mkdirs(reference.pointer, _id_mkdirs as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_renameTo = _class.instanceMethodId(
    r'renameTo',
    r'(Ljava/io/File;)Z',
  );

  static final _renameTo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean renameTo(java.io.File file)`
  bool renameTo(
    File? file,
  ) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return _renameTo(reference.pointer, _id_renameTo as jni$_.JMethodIDPtr,
            _$file.pointer)
        .boolean;
  }

  static final _id_setLastModified = _class.instanceMethodId(
    r'setLastModified',
    r'(J)Z',
  );

  static final _setLastModified = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public boolean setLastModified(long j)`
  bool setLastModified(
    int j,
  ) {
    return _setLastModified(
            reference.pointer, _id_setLastModified as jni$_.JMethodIDPtr, j)
        .boolean;
  }

  static final _id_setReadOnly = _class.instanceMethodId(
    r'setReadOnly',
    r'()Z',
  );

  static final _setReadOnly = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean setReadOnly()`
  bool setReadOnly() {
    return _setReadOnly(
            reference.pointer, _id_setReadOnly as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setWritable = _class.instanceMethodId(
    r'setWritable',
    r'(ZZ)Z',
  );

  static final _setWritable = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int)>();

  /// from: `public boolean setWritable(boolean z, boolean z1)`
  bool setWritable(
    bool z,
    bool z1,
  ) {
    return _setWritable(reference.pointer,
            _id_setWritable as jni$_.JMethodIDPtr, z ? 1 : 0, z1 ? 1 : 0)
        .boolean;
  }

  static final _id_setWritable$1 = _class.instanceMethodId(
    r'setWritable',
    r'(Z)Z',
  );

  static final _setWritable$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public boolean setWritable(boolean z)`
  bool setWritable$1(
    bool z,
  ) {
    return _setWritable$1(reference.pointer,
            _id_setWritable$1 as jni$_.JMethodIDPtr, z ? 1 : 0)
        .boolean;
  }

  static final _id_setReadable = _class.instanceMethodId(
    r'setReadable',
    r'(ZZ)Z',
  );

  static final _setReadable = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int)>();

  /// from: `public boolean setReadable(boolean z, boolean z1)`
  bool setReadable(
    bool z,
    bool z1,
  ) {
    return _setReadable(reference.pointer,
            _id_setReadable as jni$_.JMethodIDPtr, z ? 1 : 0, z1 ? 1 : 0)
        .boolean;
  }

  static final _id_setReadable$1 = _class.instanceMethodId(
    r'setReadable',
    r'(Z)Z',
  );

  static final _setReadable$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public boolean setReadable(boolean z)`
  bool setReadable$1(
    bool z,
  ) {
    return _setReadable$1(reference.pointer,
            _id_setReadable$1 as jni$_.JMethodIDPtr, z ? 1 : 0)
        .boolean;
  }

  static final _id_setExecutable = _class.instanceMethodId(
    r'setExecutable',
    r'(ZZ)Z',
  );

  static final _setExecutable = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int)>();

  /// from: `public boolean setExecutable(boolean z, boolean z1)`
  bool setExecutable(
    bool z,
    bool z1,
  ) {
    return _setExecutable(reference.pointer,
            _id_setExecutable as jni$_.JMethodIDPtr, z ? 1 : 0, z1 ? 1 : 0)
        .boolean;
  }

  static final _id_setExecutable$1 = _class.instanceMethodId(
    r'setExecutable',
    r'(Z)Z',
  );

  static final _setExecutable$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public boolean setExecutable(boolean z)`
  bool setExecutable$1(
    bool z,
  ) {
    return _setExecutable$1(reference.pointer,
            _id_setExecutable$1 as jni$_.JMethodIDPtr, z ? 1 : 0)
        .boolean;
  }

  static final _id_canExecute = _class.instanceMethodId(
    r'canExecute',
    r'()Z',
  );

  static final _canExecute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean canExecute()`
  bool canExecute() {
    return _canExecute(reference.pointer, _id_canExecute as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_listRoots = _class.staticMethodId(
    r'listRoots',
    r'()[Ljava/io/File;',
  );

  static final _listRoots = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.io.File[] listRoots()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<File?>? listRoots() {
    return _listRoots(
            _class.reference.pointer, _id_listRoots as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<File?>?>(
            const jni$_.JArrayNullableType<File?>($File$NullableType()));
  }

  static final _id_getTotalSpace = _class.instanceMethodId(
    r'getTotalSpace',
    r'()J',
  );

  static final _getTotalSpace = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long getTotalSpace()`
  int getTotalSpace() {
    return _getTotalSpace(
            reference.pointer, _id_getTotalSpace as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_getFreeSpace = _class.instanceMethodId(
    r'getFreeSpace',
    r'()J',
  );

  static final _getFreeSpace = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long getFreeSpace()`
  int getFreeSpace() {
    return _getFreeSpace(
            reference.pointer, _id_getFreeSpace as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_getUsableSpace = _class.instanceMethodId(
    r'getUsableSpace',
    r'()J',
  );

  static final _getUsableSpace = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long getUsableSpace()`
  int getUsableSpace() {
    return _getUsableSpace(
            reference.pointer, _id_getUsableSpace as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_createTempFile = _class.staticMethodId(
    r'createTempFile',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/io/File;)Ljava/io/File;',
  );

  static final _createTempFile = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.io.File createTempFile(java.lang.String string, java.lang.String string1, java.io.File file)`
  /// The returned object must be released after use, by calling the [release] method.
  static File? createTempFile(
    jni$_.JString? string,
    jni$_.JString? string1,
    File? file,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$file = file?.reference ?? jni$_.jNullReference;
    return _createTempFile(
            _class.reference.pointer,
            _id_createTempFile as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$file.pointer)
        .object<File?>(const $File$NullableType());
  }

  static final _id_createTempFile$1 = _class.staticMethodId(
    r'createTempFile',
    r'(Ljava/lang/String;Ljava/lang/String;)Ljava/io/File;',
  );

  static final _createTempFile$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.io.File createTempFile(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  static File? createTempFile$1(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return _createTempFile$1(
            _class.reference.pointer,
            _id_createTempFile$1 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer)
        .object<File?>(const $File$NullableType());
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/io/File;)I',
  );

  static final _compareTo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int compareTo(java.io.File file)`
  int compareTo(
    File? file,
  ) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return _compareTo(reference.pointer, _id_compareTo as jni$_.JMethodIDPtr,
            _$file.pointer)
        .integer;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_toPath = _class.instanceMethodId(
    r'toPath',
    r'()Ljava/nio/file/Path;',
  );

  static final _toPath = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.nio.file.Path toPath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? toPath() {
    return _toPath(reference.pointer, _id_toPath as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $File$NullableType extends jni$_.JObjType<File?> {
  @jni$_.internal
  const $File$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/File;';

  @jni$_.internal
  @core$_.override
  File? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : File.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<File?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($File$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($File$NullableType) &&
        other is $File$NullableType;
  }
}

final class $File$Type extends jni$_.JObjType<File> {
  @jni$_.internal
  const $File$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/File;';

  @jni$_.internal
  @core$_.override
  File fromReference(jni$_.JReference reference) => File.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<File?> get nullableType => const $File$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($File$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($File$Type) && other is $File$Type;
  }
}
