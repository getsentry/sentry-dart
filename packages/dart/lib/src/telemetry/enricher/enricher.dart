import 'package:meta/meta.dart';

import '../../../sentry.dart';
import '../span/sentry_span_v2.dart';

/// Pipeline for systematic telemetry attribute enrichment.
///
/// Attributes are merged in the following order (highest to lowest priority):
/// 1. **Item attributes** - Attributes already set on the telemetry item
/// 2. **Scope attributes** - Attributes from the current scope
/// 3. **Provider attributes** - Attributes generated by registered providers
@internal
final class TelemetryEnricher {
  final _providers = <TelemetryAttributesProvider>[];

  Future<void> enrichLog(SentryLog log, {Scope? scope}) => _enrichAttributes(
        telemetry: log,
        scope: scope,
        existingAttributes: log.attributes,
        applyAttributes: (attributes) {
          log.attributes = attributes;
        },
      );

  Future<void> enrichSpan(RecordingSentrySpanV2 span, {Scope? scope}) =>
      _enrichAttributes(
        telemetry: span,
        scope: scope,
        existingAttributes: span.attributes,
        applyAttributes: (attributes) {
          span.setAttributes(attributes);
        },
      );

  Future<void> _enrichAttributes({
    required Object telemetry,
    required Scope? scope,
    required Map<String, SentryAttribute> existingAttributes,
    required void Function(Map<String, SentryAttribute>) applyAttributes,
  }) async {
    // Create a mutable copy to handle unmodifiable maps from getters
    final mergedAttributes =
        Map<String, SentryAttribute>.from(existingAttributes);

    // Scope is also set by the SDK user so it should be merged first.
    mergedAttributes.addAllIfAbsent(scope?.attributes ?? {});

    final aggregatedAttributes = <String, SentryAttribute>{};
    for (final provider in _providers) {
      aggregatedAttributes
          .addAllIfAbsent(await provider.attributes(telemetry, scope: scope));
    }

    mergedAttributes.addAllIfAbsent(aggregatedAttributes);
    applyAttributes(mergedAttributes);
  }

  void addAttributesProvider(TelemetryAttributesProvider provider) {
    if (_providers.contains(provider)) {
      return;
    }
    _providers.add(provider);
  }
}

extension _AddAllAbsentX<K, V> on Map<K, V> {
  void addAllIfAbsent(Map<K, V> other) {
    for (final e in other.entries) {
      putIfAbsent(e.key, () => e.value);
    }
  }
}
