// AUTO GENERATED BY JNIGEN 0.14.2. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `io.sentry.android.core.InternalSentrySdk`
class InternalSentrySdk extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<InternalSentrySdk> $type;

  @jni$_.internal
  InternalSentrySdk.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/android/core/InternalSentrySdk');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $InternalSentrySdk$NullableType();
  static const type = $InternalSentrySdk$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory InternalSentrySdk() {
    return InternalSentrySdk.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_getCurrentScope = _class.staticMethodId(
    r'getCurrentScope',
    r'()Lio/sentry/IScope;',
  );

  static final _getCurrentScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.IScope getCurrentScope()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? getCurrentScope() {
    return _getCurrentScope(
            _class.reference.pointer, _id_getCurrentScope as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_serializeScope = _class.staticMethodId(
    r'serializeScope',
    r'(Landroid/content/Context;Lio/sentry/android/core/SentryAndroidOptions;Lio/sentry/IScope;)Ljava/util/Map;',
  );

  static final _serializeScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.Map<java.lang.String, java.lang.Object> serializeScope(android.content.Context context, io.sentry.android.core.SentryAndroidOptions sentryAndroidOptions, io.sentry.IScope iScope)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JMap<jni$_.JString?, jni$_.JObject?> serializeScope(
    jni$_.JObject context,
    SentryAndroidOptions sentryAndroidOptions,
    jni$_.JObject? iScope,
  ) {
    final _$context = context.reference;
    final _$sentryAndroidOptions = sentryAndroidOptions.reference;
    final _$iScope = iScope?.reference ?? jni$_.jNullReference;
    return _serializeScope(
            _class.reference.pointer,
            _id_serializeScope as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$sentryAndroidOptions.pointer,
            _$iScope.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JString?, jni$_.JObject?>(
                jni$_.JStringNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_captureEnvelope = _class.staticMethodId(
    r'captureEnvelope',
    r'([BZ)Lio/sentry/protocol/SentryId;',
  );

  static final _captureEnvelope = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `static public io.sentry.protocol.SentryId captureEnvelope(byte[] bs, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? captureEnvelope(
    jni$_.JByteArray bs,
    bool z,
  ) {
    final _$bs = bs.reference;
    return _captureEnvelope(_class.reference.pointer,
            _id_captureEnvelope as jni$_.JMethodIDPtr, _$bs.pointer, z ? 1 : 0)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getAppStartMeasurement = _class.staticMethodId(
    r'getAppStartMeasurement',
    r'()Ljava/util/Map;',
  );

  static final _getAppStartMeasurement = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.util.Map<java.lang.String, java.lang.Object> getAppStartMeasurement()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JMap<jni$_.JString?, jni$_.JObject?>? getAppStartMeasurement() {
    return _getAppStartMeasurement(_class.reference.pointer,
            _id_getAppStartMeasurement as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JObject?>(
                jni$_.JStringNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_setTrace = _class.staticMethodId(
    r'setTrace',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/Double;Ljava/lang/Double;)V',
  );

  static final _setTrace = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void setTrace(java.lang.String string, java.lang.String string1, java.lang.Double double, java.lang.Double double1)`
  static void setTrace(
    jni$_.JString string,
    jni$_.JString string1,
    jni$_.JDouble? double,
    jni$_.JDouble? double1,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$double1 = double1?.reference ?? jni$_.jNullReference;
    _setTrace(
            _class.reference.pointer,
            _id_setTrace as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$double.pointer,
            _$double1.pointer)
        .check();
  }
}

final class $InternalSentrySdk$NullableType
    extends jni$_.JObjType<InternalSentrySdk?> {
  @jni$_.internal
  const $InternalSentrySdk$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/core/InternalSentrySdk;';

  @jni$_.internal
  @core$_.override
  InternalSentrySdk? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : InternalSentrySdk.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InternalSentrySdk?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InternalSentrySdk$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InternalSentrySdk$NullableType) &&
        other is $InternalSentrySdk$NullableType;
  }
}

final class $InternalSentrySdk$Type extends jni$_.JObjType<InternalSentrySdk> {
  @jni$_.internal
  const $InternalSentrySdk$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/core/InternalSentrySdk;';

  @jni$_.internal
  @core$_.override
  InternalSentrySdk fromReference(jni$_.JReference reference) =>
      InternalSentrySdk.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InternalSentrySdk?> get nullableType =>
      const $InternalSentrySdk$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InternalSentrySdk$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InternalSentrySdk$Type) &&
        other is $InternalSentrySdk$Type;
  }
}

/// from: `io.sentry.android.core.SentryAndroidOptions$BeforeCaptureCallback`
class SentryAndroidOptions$BeforeCaptureCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryAndroidOptions$BeforeCaptureCallback> $type;

  @jni$_.internal
  SentryAndroidOptions$BeforeCaptureCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'io/sentry/android/core/SentryAndroidOptions$BeforeCaptureCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $SentryAndroidOptions$BeforeCaptureCallback$NullableType();
  static const type = $SentryAndroidOptions$BeforeCaptureCallback$Type();
  static final _id_execute = _class.instanceMethodId(
    r'execute',
    r'(Lio/sentry/SentryEvent;Lio/sentry/Hint;Z)Z',
  );

  static final _execute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `public abstract boolean execute(io.sentry.SentryEvent sentryEvent, io.sentry.Hint hint, boolean z)`
  bool execute(
    jni$_.JObject sentryEvent,
    jni$_.JObject hint,
    bool z,
  ) {
    final _$sentryEvent = sentryEvent.reference;
    final _$hint = hint.reference;
    return _execute(reference.pointer, _id_execute as jni$_.JMethodIDPtr,
            _$sentryEvent.pointer, _$hint.pointer, z ? 1 : 0)
        .boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SentryAndroidOptions$BeforeCaptureCallback>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'execute(Lio/sentry/SentryEvent;Lio/sentry/Hint;Z)Z') {
        final $r = _$impls[$p]!.execute(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![1]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![2]!
              .as(const jni$_.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $SentryAndroidOptions$BeforeCaptureCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.android.core.SentryAndroidOptions$BeforeCaptureCallback',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SentryAndroidOptions$BeforeCaptureCallback.implement(
    $SentryAndroidOptions$BeforeCaptureCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SentryAndroidOptions$BeforeCaptureCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $SentryAndroidOptions$BeforeCaptureCallback {
  factory $SentryAndroidOptions$BeforeCaptureCallback({
    required bool Function(
            jni$_.JObject sentryEvent, jni$_.JObject hint, bool z)
        execute,
  }) = _$SentryAndroidOptions$BeforeCaptureCallback;

  bool execute(jni$_.JObject sentryEvent, jni$_.JObject hint, bool z);
}

final class _$SentryAndroidOptions$BeforeCaptureCallback
    with $SentryAndroidOptions$BeforeCaptureCallback {
  _$SentryAndroidOptions$BeforeCaptureCallback({
    required bool Function(
            jni$_.JObject sentryEvent, jni$_.JObject hint, bool z)
        execute,
  }) : _execute = execute;

  final bool Function(jni$_.JObject sentryEvent, jni$_.JObject hint, bool z)
      _execute;

  bool execute(jni$_.JObject sentryEvent, jni$_.JObject hint, bool z) {
    return _execute(sentryEvent, hint, z);
  }
}

final class $SentryAndroidOptions$BeforeCaptureCallback$NullableType
    extends jni$_.JObjType<SentryAndroidOptions$BeforeCaptureCallback?> {
  @jni$_.internal
  const $SentryAndroidOptions$BeforeCaptureCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/android/core/SentryAndroidOptions$BeforeCaptureCallback;';

  @jni$_.internal
  @core$_.override
  SentryAndroidOptions$BeforeCaptureCallback? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryAndroidOptions$BeforeCaptureCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryAndroidOptions$BeforeCaptureCallback?>
      get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryAndroidOptions$BeforeCaptureCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryAndroidOptions$BeforeCaptureCallback$NullableType) &&
        other is $SentryAndroidOptions$BeforeCaptureCallback$NullableType;
  }
}

final class $SentryAndroidOptions$BeforeCaptureCallback$Type
    extends jni$_.JObjType<SentryAndroidOptions$BeforeCaptureCallback> {
  @jni$_.internal
  const $SentryAndroidOptions$BeforeCaptureCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/android/core/SentryAndroidOptions$BeforeCaptureCallback;';

  @jni$_.internal
  @core$_.override
  SentryAndroidOptions$BeforeCaptureCallback fromReference(
          jni$_.JReference reference) =>
      SentryAndroidOptions$BeforeCaptureCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryAndroidOptions$BeforeCaptureCallback?>
      get nullableType =>
          const $SentryAndroidOptions$BeforeCaptureCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryAndroidOptions$BeforeCaptureCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryAndroidOptions$BeforeCaptureCallback$Type) &&
        other is $SentryAndroidOptions$BeforeCaptureCallback$Type;
  }
}

/// from: `io.sentry.android.core.SentryAndroidOptions`
class SentryAndroidOptions extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryAndroidOptions> $type;

  @jni$_.internal
  SentryAndroidOptions.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/android/core/SentryAndroidOptions');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryAndroidOptions$NullableType();
  static const type = $SentryAndroidOptions$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryAndroidOptions() {
    return SentryAndroidOptions.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_isAnrEnabled = _class.instanceMethodId(
    r'isAnrEnabled',
    r'()Z',
  );

  static final _isAnrEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isAnrEnabled()`
  bool isAnrEnabled() {
    return _isAnrEnabled(
            reference.pointer, _id_isAnrEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setAnrEnabled = _class.instanceMethodId(
    r'setAnrEnabled',
    r'(Z)V',
  );

  static final _setAnrEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setAnrEnabled(boolean z)`
  void setAnrEnabled(
    bool z,
  ) {
    _setAnrEnabled(reference.pointer, _id_setAnrEnabled as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_getAnrTimeoutIntervalMillis = _class.instanceMethodId(
    r'getAnrTimeoutIntervalMillis',
    r'()J',
  );

  static final _getAnrTimeoutIntervalMillis =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallLongMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public long getAnrTimeoutIntervalMillis()`
  int getAnrTimeoutIntervalMillis() {
    return _getAnrTimeoutIntervalMillis(reference.pointer,
            _id_getAnrTimeoutIntervalMillis as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_setAnrTimeoutIntervalMillis = _class.instanceMethodId(
    r'setAnrTimeoutIntervalMillis',
    r'(J)V',
  );

  static final _setAnrTimeoutIntervalMillis =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setAnrTimeoutIntervalMillis(long j)`
  void setAnrTimeoutIntervalMillis(
    int j,
  ) {
    _setAnrTimeoutIntervalMillis(reference.pointer,
            _id_setAnrTimeoutIntervalMillis as jni$_.JMethodIDPtr, j)
        .check();
  }

  static final _id_isAnrReportInDebug = _class.instanceMethodId(
    r'isAnrReportInDebug',
    r'()Z',
  );

  static final _isAnrReportInDebug = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isAnrReportInDebug()`
  bool isAnrReportInDebug() {
    return _isAnrReportInDebug(
            reference.pointer, _id_isAnrReportInDebug as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setAnrReportInDebug = _class.instanceMethodId(
    r'setAnrReportInDebug',
    r'(Z)V',
  );

  static final _setAnrReportInDebug = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setAnrReportInDebug(boolean z)`
  void setAnrReportInDebug(
    bool z,
  ) {
    _setAnrReportInDebug(reference.pointer,
            _id_setAnrReportInDebug as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isEnableActivityLifecycleBreadcrumbs =
      _class.instanceMethodId(
    r'isEnableActivityLifecycleBreadcrumbs',
    r'()Z',
  );

  static final _isEnableActivityLifecycleBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEnableActivityLifecycleBreadcrumbs()`
  bool isEnableActivityLifecycleBreadcrumbs() {
    return _isEnableActivityLifecycleBreadcrumbs(reference.pointer,
            _id_isEnableActivityLifecycleBreadcrumbs as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableActivityLifecycleBreadcrumbs =
      _class.instanceMethodId(
    r'setEnableActivityLifecycleBreadcrumbs',
    r'(Z)V',
  );

  static final _setEnableActivityLifecycleBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableActivityLifecycleBreadcrumbs(boolean z)`
  void setEnableActivityLifecycleBreadcrumbs(
    bool z,
  ) {
    _setEnableActivityLifecycleBreadcrumbs(
            reference.pointer,
            _id_setEnableActivityLifecycleBreadcrumbs as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_isEnableAppLifecycleBreadcrumbs = _class.instanceMethodId(
    r'isEnableAppLifecycleBreadcrumbs',
    r'()Z',
  );

  static final _isEnableAppLifecycleBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEnableAppLifecycleBreadcrumbs()`
  bool isEnableAppLifecycleBreadcrumbs() {
    return _isEnableAppLifecycleBreadcrumbs(reference.pointer,
            _id_isEnableAppLifecycleBreadcrumbs as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableAppLifecycleBreadcrumbs = _class.instanceMethodId(
    r'setEnableAppLifecycleBreadcrumbs',
    r'(Z)V',
  );

  static final _setEnableAppLifecycleBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableAppLifecycleBreadcrumbs(boolean z)`
  void setEnableAppLifecycleBreadcrumbs(
    bool z,
  ) {
    _setEnableAppLifecycleBreadcrumbs(
            reference.pointer,
            _id_setEnableAppLifecycleBreadcrumbs as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_isEnableSystemEventBreadcrumbs = _class.instanceMethodId(
    r'isEnableSystemEventBreadcrumbs',
    r'()Z',
  );

  static final _isEnableSystemEventBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEnableSystemEventBreadcrumbs()`
  bool isEnableSystemEventBreadcrumbs() {
    return _isEnableSystemEventBreadcrumbs(reference.pointer,
            _id_isEnableSystemEventBreadcrumbs as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableSystemEventBreadcrumbs = _class.instanceMethodId(
    r'setEnableSystemEventBreadcrumbs',
    r'(Z)V',
  );

  static final _setEnableSystemEventBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableSystemEventBreadcrumbs(boolean z)`
  void setEnableSystemEventBreadcrumbs(
    bool z,
  ) {
    _setEnableSystemEventBreadcrumbs(
            reference.pointer,
            _id_setEnableSystemEventBreadcrumbs as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_isEnableAppComponentBreadcrumbs = _class.instanceMethodId(
    r'isEnableAppComponentBreadcrumbs',
    r'()Z',
  );

  static final _isEnableAppComponentBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEnableAppComponentBreadcrumbs()`
  bool isEnableAppComponentBreadcrumbs() {
    return _isEnableAppComponentBreadcrumbs(reference.pointer,
            _id_isEnableAppComponentBreadcrumbs as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableAppComponentBreadcrumbs = _class.instanceMethodId(
    r'setEnableAppComponentBreadcrumbs',
    r'(Z)V',
  );

  static final _setEnableAppComponentBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableAppComponentBreadcrumbs(boolean z)`
  void setEnableAppComponentBreadcrumbs(
    bool z,
  ) {
    _setEnableAppComponentBreadcrumbs(
            reference.pointer,
            _id_setEnableAppComponentBreadcrumbs as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_isEnableNetworkEventBreadcrumbs = _class.instanceMethodId(
    r'isEnableNetworkEventBreadcrumbs',
    r'()Z',
  );

  static final _isEnableNetworkEventBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEnableNetworkEventBreadcrumbs()`
  bool isEnableNetworkEventBreadcrumbs() {
    return _isEnableNetworkEventBreadcrumbs(reference.pointer,
            _id_isEnableNetworkEventBreadcrumbs as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableNetworkEventBreadcrumbs = _class.instanceMethodId(
    r'setEnableNetworkEventBreadcrumbs',
    r'(Z)V',
  );

  static final _setEnableNetworkEventBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableNetworkEventBreadcrumbs(boolean z)`
  void setEnableNetworkEventBreadcrumbs(
    bool z,
  ) {
    _setEnableNetworkEventBreadcrumbs(
            reference.pointer,
            _id_setEnableNetworkEventBreadcrumbs as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_enableAllAutoBreadcrumbs = _class.instanceMethodId(
    r'enableAllAutoBreadcrumbs',
    r'(Z)V',
  );

  static final _enableAllAutoBreadcrumbs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void enableAllAutoBreadcrumbs(boolean z)`
  void enableAllAutoBreadcrumbs(
    bool z,
  ) {
    _enableAllAutoBreadcrumbs(reference.pointer,
            _id_enableAllAutoBreadcrumbs as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getDebugImagesLoader = _class.instanceMethodId(
    r'getDebugImagesLoader',
    r'()Lio/sentry/android/core/IDebugImagesLoader;',
  );

  static final _getDebugImagesLoader = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.android.core.IDebugImagesLoader getDebugImagesLoader()`
  /// The returned object must be released after use, by calling the [release] method.
  IDebugImagesLoader getDebugImagesLoader() {
    return _getDebugImagesLoader(
            reference.pointer, _id_getDebugImagesLoader as jni$_.JMethodIDPtr)
        .object<IDebugImagesLoader>(const $IDebugImagesLoader$Type());
  }

  static final _id_setDebugImagesLoader = _class.instanceMethodId(
    r'setDebugImagesLoader',
    r'(Lio/sentry/android/core/IDebugImagesLoader;)V',
  );

  static final _setDebugImagesLoader = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDebugImagesLoader(io.sentry.android.core.IDebugImagesLoader iDebugImagesLoader)`
  void setDebugImagesLoader(
    IDebugImagesLoader iDebugImagesLoader,
  ) {
    final _$iDebugImagesLoader = iDebugImagesLoader.reference;
    _setDebugImagesLoader(
            reference.pointer,
            _id_setDebugImagesLoader as jni$_.JMethodIDPtr,
            _$iDebugImagesLoader.pointer)
        .check();
  }

  static final _id_isEnableAutoActivityLifecycleTracing =
      _class.instanceMethodId(
    r'isEnableAutoActivityLifecycleTracing',
    r'()Z',
  );

  static final _isEnableAutoActivityLifecycleTracing =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEnableAutoActivityLifecycleTracing()`
  bool isEnableAutoActivityLifecycleTracing() {
    return _isEnableAutoActivityLifecycleTracing(reference.pointer,
            _id_isEnableAutoActivityLifecycleTracing as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableAutoActivityLifecycleTracing =
      _class.instanceMethodId(
    r'setEnableAutoActivityLifecycleTracing',
    r'(Z)V',
  );

  static final _setEnableAutoActivityLifecycleTracing =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableAutoActivityLifecycleTracing(boolean z)`
  void setEnableAutoActivityLifecycleTracing(
    bool z,
  ) {
    _setEnableAutoActivityLifecycleTracing(
            reference.pointer,
            _id_setEnableAutoActivityLifecycleTracing as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_isEnableActivityLifecycleTracingAutoFinish =
      _class.instanceMethodId(
    r'isEnableActivityLifecycleTracingAutoFinish',
    r'()Z',
  );

  static final _isEnableActivityLifecycleTracingAutoFinish =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEnableActivityLifecycleTracingAutoFinish()`
  bool isEnableActivityLifecycleTracingAutoFinish() {
    return _isEnableActivityLifecycleTracingAutoFinish(
            reference.pointer,
            _id_isEnableActivityLifecycleTracingAutoFinish
                as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableActivityLifecycleTracingAutoFinish =
      _class.instanceMethodId(
    r'setEnableActivityLifecycleTracingAutoFinish',
    r'(Z)V',
  );

  static final _setEnableActivityLifecycleTracingAutoFinish =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableActivityLifecycleTracingAutoFinish(boolean z)`
  void setEnableActivityLifecycleTracingAutoFinish(
    bool z,
  ) {
    _setEnableActivityLifecycleTracingAutoFinish(
            reference.pointer,
            _id_setEnableActivityLifecycleTracingAutoFinish
                as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_isAttachScreenshot = _class.instanceMethodId(
    r'isAttachScreenshot',
    r'()Z',
  );

  static final _isAttachScreenshot = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isAttachScreenshot()`
  bool isAttachScreenshot() {
    return _isAttachScreenshot(
            reference.pointer, _id_isAttachScreenshot as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setAttachScreenshot = _class.instanceMethodId(
    r'setAttachScreenshot',
    r'(Z)V',
  );

  static final _setAttachScreenshot = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setAttachScreenshot(boolean z)`
  void setAttachScreenshot(
    bool z,
  ) {
    _setAttachScreenshot(reference.pointer,
            _id_setAttachScreenshot as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isAttachViewHierarchy = _class.instanceMethodId(
    r'isAttachViewHierarchy',
    r'()Z',
  );

  static final _isAttachViewHierarchy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isAttachViewHierarchy()`
  bool isAttachViewHierarchy() {
    return _isAttachViewHierarchy(
            reference.pointer, _id_isAttachViewHierarchy as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setAttachViewHierarchy = _class.instanceMethodId(
    r'setAttachViewHierarchy',
    r'(Z)V',
  );

  static final _setAttachViewHierarchy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setAttachViewHierarchy(boolean z)`
  void setAttachViewHierarchy(
    bool z,
  ) {
    _setAttachViewHierarchy(reference.pointer,
            _id_setAttachViewHierarchy as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isCollectAdditionalContext = _class.instanceMethodId(
    r'isCollectAdditionalContext',
    r'()Z',
  );

  static final _isCollectAdditionalContext =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isCollectAdditionalContext()`
  bool isCollectAdditionalContext() {
    return _isCollectAdditionalContext(reference.pointer,
            _id_isCollectAdditionalContext as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setCollectAdditionalContext = _class.instanceMethodId(
    r'setCollectAdditionalContext',
    r'(Z)V',
  );

  static final _setCollectAdditionalContext =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setCollectAdditionalContext(boolean z)`
  void setCollectAdditionalContext(
    bool z,
  ) {
    _setCollectAdditionalContext(reference.pointer,
            _id_setCollectAdditionalContext as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isEnableFramesTracking = _class.instanceMethodId(
    r'isEnableFramesTracking',
    r'()Z',
  );

  static final _isEnableFramesTracking = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEnableFramesTracking()`
  bool isEnableFramesTracking() {
    return _isEnableFramesTracking(
            reference.pointer, _id_isEnableFramesTracking as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableFramesTracking = _class.instanceMethodId(
    r'setEnableFramesTracking',
    r'(Z)V',
  );

  static final _setEnableFramesTracking = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableFramesTracking(boolean z)`
  void setEnableFramesTracking(
    bool z,
  ) {
    _setEnableFramesTracking(reference.pointer,
            _id_setEnableFramesTracking as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getStartupCrashDurationThresholdMillis =
      _class.instanceMethodId(
    r'getStartupCrashDurationThresholdMillis',
    r'()J',
  );

  static final _getStartupCrashDurationThresholdMillis =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallLongMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public long getStartupCrashDurationThresholdMillis()`
  int getStartupCrashDurationThresholdMillis() {
    return _getStartupCrashDurationThresholdMillis(reference.pointer,
            _id_getStartupCrashDurationThresholdMillis as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_setNativeSdkName = _class.instanceMethodId(
    r'setNativeSdkName',
    r'(Ljava/lang/String;)V',
  );

  static final _setNativeSdkName = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setNativeSdkName(java.lang.String string)`
  void setNativeSdkName(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setNativeSdkName(reference.pointer,
            _id_setNativeSdkName as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_setNativeHandlerStrategy = _class.instanceMethodId(
    r'setNativeHandlerStrategy',
    r'(Lio/sentry/android/core/NdkHandlerStrategy;)V',
  );

  static final _setNativeHandlerStrategy = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setNativeHandlerStrategy(io.sentry.android.core.NdkHandlerStrategy ndkHandlerStrategy)`
  void setNativeHandlerStrategy(
    jni$_.JObject ndkHandlerStrategy,
  ) {
    final _$ndkHandlerStrategy = ndkHandlerStrategy.reference;
    _setNativeHandlerStrategy(
            reference.pointer,
            _id_setNativeHandlerStrategy as jni$_.JMethodIDPtr,
            _$ndkHandlerStrategy.pointer)
        .check();
  }

  static final _id_getNdkHandlerStrategy = _class.instanceMethodId(
    r'getNdkHandlerStrategy',
    r'()I',
  );

  static final _getNdkHandlerStrategy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getNdkHandlerStrategy()`
  int getNdkHandlerStrategy() {
    return _getNdkHandlerStrategy(
            reference.pointer, _id_getNdkHandlerStrategy as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getNativeSdkName = _class.instanceMethodId(
    r'getNativeSdkName',
    r'()Ljava/lang/String;',
  );

  static final _getNativeSdkName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getNativeSdkName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getNativeSdkName() {
    return _getNativeSdkName(
            reference.pointer, _id_getNativeSdkName as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_isEnableRootCheck = _class.instanceMethodId(
    r'isEnableRootCheck',
    r'()Z',
  );

  static final _isEnableRootCheck = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEnableRootCheck()`
  bool isEnableRootCheck() {
    return _isEnableRootCheck(
            reference.pointer, _id_isEnableRootCheck as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableRootCheck = _class.instanceMethodId(
    r'setEnableRootCheck',
    r'(Z)V',
  );

  static final _setEnableRootCheck = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableRootCheck(boolean z)`
  void setEnableRootCheck(
    bool z,
  ) {
    _setEnableRootCheck(reference.pointer,
            _id_setEnableRootCheck as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getBeforeScreenshotCaptureCallback = _class.instanceMethodId(
    r'getBeforeScreenshotCaptureCallback',
    r'()Lio/sentry/android/core/SentryAndroidOptions$BeforeCaptureCallback;',
  );

  static final _getBeforeScreenshotCaptureCallback =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public io.sentry.android.core.SentryAndroidOptions$BeforeCaptureCallback getBeforeScreenshotCaptureCallback()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryAndroidOptions$BeforeCaptureCallback?
      getBeforeScreenshotCaptureCallback() {
    return _getBeforeScreenshotCaptureCallback(reference.pointer,
            _id_getBeforeScreenshotCaptureCallback as jni$_.JMethodIDPtr)
        .object<SentryAndroidOptions$BeforeCaptureCallback?>(
            const $SentryAndroidOptions$BeforeCaptureCallback$NullableType());
  }

  static final _id_setBeforeScreenshotCaptureCallback = _class.instanceMethodId(
    r'setBeforeScreenshotCaptureCallback',
    r'(Lio/sentry/android/core/SentryAndroidOptions$BeforeCaptureCallback;)V',
  );

  static final _setBeforeScreenshotCaptureCallback =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setBeforeScreenshotCaptureCallback(io.sentry.android.core.SentryAndroidOptions$BeforeCaptureCallback beforeCaptureCallback)`
  void setBeforeScreenshotCaptureCallback(
    SentryAndroidOptions$BeforeCaptureCallback beforeCaptureCallback,
  ) {
    final _$beforeCaptureCallback = beforeCaptureCallback.reference;
    _setBeforeScreenshotCaptureCallback(
            reference.pointer,
            _id_setBeforeScreenshotCaptureCallback as jni$_.JMethodIDPtr,
            _$beforeCaptureCallback.pointer)
        .check();
  }

  static final _id_getBeforeViewHierarchyCaptureCallback =
      _class.instanceMethodId(
    r'getBeforeViewHierarchyCaptureCallback',
    r'()Lio/sentry/android/core/SentryAndroidOptions$BeforeCaptureCallback;',
  );

  static final _getBeforeViewHierarchyCaptureCallback =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public io.sentry.android.core.SentryAndroidOptions$BeforeCaptureCallback getBeforeViewHierarchyCaptureCallback()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryAndroidOptions$BeforeCaptureCallback?
      getBeforeViewHierarchyCaptureCallback() {
    return _getBeforeViewHierarchyCaptureCallback(reference.pointer,
            _id_getBeforeViewHierarchyCaptureCallback as jni$_.JMethodIDPtr)
        .object<SentryAndroidOptions$BeforeCaptureCallback?>(
            const $SentryAndroidOptions$BeforeCaptureCallback$NullableType());
  }

  static final _id_setBeforeViewHierarchyCaptureCallback =
      _class.instanceMethodId(
    r'setBeforeViewHierarchyCaptureCallback',
    r'(Lio/sentry/android/core/SentryAndroidOptions$BeforeCaptureCallback;)V',
  );

  static final _setBeforeViewHierarchyCaptureCallback =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setBeforeViewHierarchyCaptureCallback(io.sentry.android.core.SentryAndroidOptions$BeforeCaptureCallback beforeCaptureCallback)`
  void setBeforeViewHierarchyCaptureCallback(
    SentryAndroidOptions$BeforeCaptureCallback beforeCaptureCallback,
  ) {
    final _$beforeCaptureCallback = beforeCaptureCallback.reference;
    _setBeforeViewHierarchyCaptureCallback(
            reference.pointer,
            _id_setBeforeViewHierarchyCaptureCallback as jni$_.JMethodIDPtr,
            _$beforeCaptureCallback.pointer)
        .check();
  }

  static final _id_isEnableNdk = _class.instanceMethodId(
    r'isEnableNdk',
    r'()Z',
  );

  static final _isEnableNdk = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEnableNdk()`
  bool isEnableNdk() {
    return _isEnableNdk(
            reference.pointer, _id_isEnableNdk as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableNdk = _class.instanceMethodId(
    r'setEnableNdk',
    r'(Z)V',
  );

  static final _setEnableNdk = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableNdk(boolean z)`
  void setEnableNdk(
    bool z,
  ) {
    _setEnableNdk(reference.pointer, _id_setEnableNdk as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_isEnableScopeSync = _class.instanceMethodId(
    r'isEnableScopeSync',
    r'()Z',
  );

  static final _isEnableScopeSync = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEnableScopeSync()`
  bool isEnableScopeSync() {
    return _isEnableScopeSync(
            reference.pointer, _id_isEnableScopeSync as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableScopeSync = _class.instanceMethodId(
    r'setEnableScopeSync',
    r'(Z)V',
  );

  static final _setEnableScopeSync = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableScopeSync(boolean z)`
  void setEnableScopeSync(
    bool z,
  ) {
    _setEnableScopeSync(reference.pointer,
            _id_setEnableScopeSync as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isReportHistoricalAnrs = _class.instanceMethodId(
    r'isReportHistoricalAnrs',
    r'()Z',
  );

  static final _isReportHistoricalAnrs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isReportHistoricalAnrs()`
  bool isReportHistoricalAnrs() {
    return _isReportHistoricalAnrs(
            reference.pointer, _id_isReportHistoricalAnrs as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setReportHistoricalAnrs = _class.instanceMethodId(
    r'setReportHistoricalAnrs',
    r'(Z)V',
  );

  static final _setReportHistoricalAnrs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setReportHistoricalAnrs(boolean z)`
  void setReportHistoricalAnrs(
    bool z,
  ) {
    _setReportHistoricalAnrs(reference.pointer,
            _id_setReportHistoricalAnrs as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isAttachAnrThreadDump = _class.instanceMethodId(
    r'isAttachAnrThreadDump',
    r'()Z',
  );

  static final _isAttachAnrThreadDump = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isAttachAnrThreadDump()`
  bool isAttachAnrThreadDump() {
    return _isAttachAnrThreadDump(
            reference.pointer, _id_isAttachAnrThreadDump as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setAttachAnrThreadDump = _class.instanceMethodId(
    r'setAttachAnrThreadDump',
    r'(Z)V',
  );

  static final _setAttachAnrThreadDump = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setAttachAnrThreadDump(boolean z)`
  void setAttachAnrThreadDump(
    bool z,
  ) {
    _setAttachAnrThreadDump(reference.pointer,
            _id_setAttachAnrThreadDump as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isEnablePerformanceV2 = _class.instanceMethodId(
    r'isEnablePerformanceV2',
    r'()Z',
  );

  static final _isEnablePerformanceV2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEnablePerformanceV2()`
  bool isEnablePerformanceV2() {
    return _isEnablePerformanceV2(
            reference.pointer, _id_isEnablePerformanceV2 as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnablePerformanceV2 = _class.instanceMethodId(
    r'setEnablePerformanceV2',
    r'(Z)V',
  );

  static final _setEnablePerformanceV2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnablePerformanceV2(boolean z)`
  void setEnablePerformanceV2(
    bool z,
  ) {
    _setEnablePerformanceV2(reference.pointer,
            _id_setEnablePerformanceV2 as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getFrameMetricsCollector = _class.instanceMethodId(
    r'getFrameMetricsCollector',
    r'()Lio/sentry/android/core/internal/util/SentryFrameMetricsCollector;',
  );

  static final _getFrameMetricsCollector = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.android.core.internal.util.SentryFrameMetricsCollector getFrameMetricsCollector()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getFrameMetricsCollector() {
    return _getFrameMetricsCollector(reference.pointer,
            _id_getFrameMetricsCollector as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setFrameMetricsCollector = _class.instanceMethodId(
    r'setFrameMetricsCollector',
    r'(Lio/sentry/android/core/internal/util/SentryFrameMetricsCollector;)V',
  );

  static final _setFrameMetricsCollector = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setFrameMetricsCollector(io.sentry.android.core.internal.util.SentryFrameMetricsCollector sentryFrameMetricsCollector)`
  void setFrameMetricsCollector(
    jni$_.JObject? sentryFrameMetricsCollector,
  ) {
    final _$sentryFrameMetricsCollector =
        sentryFrameMetricsCollector?.reference ?? jni$_.jNullReference;
    _setFrameMetricsCollector(
            reference.pointer,
            _id_setFrameMetricsCollector as jni$_.JMethodIDPtr,
            _$sentryFrameMetricsCollector.pointer)
        .check();
  }

  static final _id_isEnableAutoTraceIdGeneration = _class.instanceMethodId(
    r'isEnableAutoTraceIdGeneration',
    r'()Z',
  );

  static final _isEnableAutoTraceIdGeneration =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEnableAutoTraceIdGeneration()`
  bool isEnableAutoTraceIdGeneration() {
    return _isEnableAutoTraceIdGeneration(reference.pointer,
            _id_isEnableAutoTraceIdGeneration as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableAutoTraceIdGeneration = _class.instanceMethodId(
    r'setEnableAutoTraceIdGeneration',
    r'(Z)V',
  );

  static final _setEnableAutoTraceIdGeneration =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableAutoTraceIdGeneration(boolean z)`
  void setEnableAutoTraceIdGeneration(
    bool z,
  ) {
    _setEnableAutoTraceIdGeneration(reference.pointer,
            _id_setEnableAutoTraceIdGeneration as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isEnableSystemEventBreadcrumbsExtras =
      _class.instanceMethodId(
    r'isEnableSystemEventBreadcrumbsExtras',
    r'()Z',
  );

  static final _isEnableSystemEventBreadcrumbsExtras =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEnableSystemEventBreadcrumbsExtras()`
  bool isEnableSystemEventBreadcrumbsExtras() {
    return _isEnableSystemEventBreadcrumbsExtras(reference.pointer,
            _id_isEnableSystemEventBreadcrumbsExtras as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableSystemEventBreadcrumbsExtras =
      _class.instanceMethodId(
    r'setEnableSystemEventBreadcrumbsExtras',
    r'(Z)V',
  );

  static final _setEnableSystemEventBreadcrumbsExtras =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableSystemEventBreadcrumbsExtras(boolean z)`
  void setEnableSystemEventBreadcrumbsExtras(
    bool z,
  ) {
    _setEnableSystemEventBreadcrumbsExtras(
            reference.pointer,
            _id_setEnableSystemEventBreadcrumbsExtras as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }
}

final class $SentryAndroidOptions$NullableType
    extends jni$_.JObjType<SentryAndroidOptions?> {
  @jni$_.internal
  const $SentryAndroidOptions$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/core/SentryAndroidOptions;';

  @jni$_.internal
  @core$_.override
  SentryAndroidOptions? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryAndroidOptions.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryAndroidOptions?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryAndroidOptions$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryAndroidOptions$NullableType) &&
        other is $SentryAndroidOptions$NullableType;
  }
}

final class $SentryAndroidOptions$Type
    extends jni$_.JObjType<SentryAndroidOptions> {
  @jni$_.internal
  const $SentryAndroidOptions$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/core/SentryAndroidOptions;';

  @jni$_.internal
  @core$_.override
  SentryAndroidOptions fromReference(jni$_.JReference reference) =>
      SentryAndroidOptions.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryAndroidOptions?> get nullableType =>
      const $SentryAndroidOptions$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryAndroidOptions$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryAndroidOptions$Type) &&
        other is $SentryAndroidOptions$Type;
  }
}

/// from: `io.sentry.android.core.IDebugImagesLoader`
class IDebugImagesLoader extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<IDebugImagesLoader> $type;

  @jni$_.internal
  IDebugImagesLoader.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/android/core/IDebugImagesLoader');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $IDebugImagesLoader$NullableType();
  static const type = $IDebugImagesLoader$Type();
  static final _id_loadDebugImages = _class.instanceMethodId(
    r'loadDebugImages',
    r'()Ljava/util/List;',
  );

  static final _loadDebugImages = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.util.List<io.sentry.protocol.DebugImage> loadDebugImages()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<DebugImage?>? loadDebugImages() {
    return _loadDebugImages(
            reference.pointer, _id_loadDebugImages as jni$_.JMethodIDPtr)
        .object<jni$_.JList<DebugImage?>?>(
            const jni$_.JListNullableType<DebugImage?>(
                $DebugImage$NullableType()));
  }

  static final _id_loadDebugImagesForAddresses = _class.instanceMethodId(
    r'loadDebugImagesForAddresses',
    r'(Ljava/util/Set;)Ljava/util/Set;',
  );

  static final _loadDebugImagesForAddresses =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Set<io.sentry.protocol.DebugImage> loadDebugImagesForAddresses(java.util.Set<java.lang.String> set)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<DebugImage?>? loadDebugImagesForAddresses(
    jni$_.JSet<jni$_.JString?>? set,
  ) {
    final _$set = set?.reference ?? jni$_.jNullReference;
    return _loadDebugImagesForAddresses(
            reference.pointer,
            _id_loadDebugImagesForAddresses as jni$_.JMethodIDPtr,
            _$set.pointer)
        .object<jni$_.JSet<DebugImage?>?>(
            const jni$_.JSetNullableType<DebugImage?>(
                $DebugImage$NullableType()));
  }

  static final _id_clearDebugImages = _class.instanceMethodId(
    r'clearDebugImages',
    r'()V',
  );

  static final _clearDebugImages = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void clearDebugImages()`
  void clearDebugImages() {
    _clearDebugImages(
            reference.pointer, _id_clearDebugImages as jni$_.JMethodIDPtr)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $IDebugImagesLoader> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'loadDebugImages()Ljava/util/List;') {
        final $r = _$impls[$p]!.loadDebugImages();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'loadDebugImagesForAddresses(Ljava/util/Set;)Ljava/util/Set;') {
        final $r = _$impls[$p]!.loadDebugImagesForAddresses(
          $a![0]?.as(
              const jni$_.JSetType<jni$_.JString?>(jni$_.JStringNullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'clearDebugImages()V') {
        _$impls[$p]!.clearDebugImages();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $IDebugImagesLoader $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.android.core.IDebugImagesLoader',
      $p,
      _$invokePointer,
      [
        if ($impl.clearDebugImages$async) r'clearDebugImages()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory IDebugImagesLoader.implement(
    $IDebugImagesLoader $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return IDebugImagesLoader.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $IDebugImagesLoader {
  factory $IDebugImagesLoader({
    required jni$_.JList<DebugImage?>? Function() loadDebugImages,
    required jni$_.JSet<DebugImage?>? Function(jni$_.JSet<jni$_.JString?>? set)
        loadDebugImagesForAddresses,
    required void Function() clearDebugImages,
    bool clearDebugImages$async,
  }) = _$IDebugImagesLoader;

  jni$_.JList<DebugImage?>? loadDebugImages();
  jni$_.JSet<DebugImage?>? loadDebugImagesForAddresses(
      jni$_.JSet<jni$_.JString?>? set);
  void clearDebugImages();
  bool get clearDebugImages$async => false;
}

final class _$IDebugImagesLoader with $IDebugImagesLoader {
  _$IDebugImagesLoader({
    required jni$_.JList<DebugImage?>? Function() loadDebugImages,
    required jni$_.JSet<DebugImage?>? Function(jni$_.JSet<jni$_.JString?>? set)
        loadDebugImagesForAddresses,
    required void Function() clearDebugImages,
    this.clearDebugImages$async = false,
  })  : _loadDebugImages = loadDebugImages,
        _loadDebugImagesForAddresses = loadDebugImagesForAddresses,
        _clearDebugImages = clearDebugImages;

  final jni$_.JList<DebugImage?>? Function() _loadDebugImages;
  final jni$_.JSet<DebugImage?>? Function(jni$_.JSet<jni$_.JString?>? set)
      _loadDebugImagesForAddresses;
  final void Function() _clearDebugImages;
  final bool clearDebugImages$async;

  jni$_.JList<DebugImage?>? loadDebugImages() {
    return _loadDebugImages();
  }

  jni$_.JSet<DebugImage?>? loadDebugImagesForAddresses(
      jni$_.JSet<jni$_.JString?>? set) {
    return _loadDebugImagesForAddresses(set);
  }

  void clearDebugImages() {
    return _clearDebugImages();
  }
}

final class $IDebugImagesLoader$NullableType
    extends jni$_.JObjType<IDebugImagesLoader?> {
  @jni$_.internal
  const $IDebugImagesLoader$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/core/IDebugImagesLoader;';

  @jni$_.internal
  @core$_.override
  IDebugImagesLoader? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : IDebugImagesLoader.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<IDebugImagesLoader?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IDebugImagesLoader$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($IDebugImagesLoader$NullableType) &&
        other is $IDebugImagesLoader$NullableType;
  }
}

final class $IDebugImagesLoader$Type
    extends jni$_.JObjType<IDebugImagesLoader> {
  @jni$_.internal
  const $IDebugImagesLoader$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/core/IDebugImagesLoader;';

  @jni$_.internal
  @core$_.override
  IDebugImagesLoader fromReference(jni$_.JReference reference) =>
      IDebugImagesLoader.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<IDebugImagesLoader?> get nullableType =>
      const $IDebugImagesLoader$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IDebugImagesLoader$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($IDebugImagesLoader$Type) &&
        other is $IDebugImagesLoader$Type;
  }
}

/// from: `io.sentry.protocol.DebugImage$Deserializer`
class DebugImage$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DebugImage$Deserializer> $type;

  @jni$_.internal
  DebugImage$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/protocol/DebugImage$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DebugImage$Deserializer$NullableType();
  static const type = $DebugImage$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory DebugImage$Deserializer() {
    return DebugImage$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserialize = _class.instanceMethodId(
    r'deserialize',
    r'(Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Lio/sentry/protocol/DebugImage;',
  );

  static final _deserialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.DebugImage deserialize(io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  /// The returned object must be released after use, by calling the [release] method.
  DebugImage deserialize(
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserialize(
            reference.pointer,
            _id_deserialize as jni$_.JMethodIDPtr,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .object<DebugImage>(const $DebugImage$Type());
  }
}

final class $DebugImage$Deserializer$NullableType
    extends jni$_.JObjType<DebugImage$Deserializer?> {
  @jni$_.internal
  const $DebugImage$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/DebugImage$Deserializer;';

  @jni$_.internal
  @core$_.override
  DebugImage$Deserializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : DebugImage$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DebugImage$Deserializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DebugImage$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DebugImage$Deserializer$NullableType) &&
        other is $DebugImage$Deserializer$NullableType;
  }
}

final class $DebugImage$Deserializer$Type
    extends jni$_.JObjType<DebugImage$Deserializer> {
  @jni$_.internal
  const $DebugImage$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/DebugImage$Deserializer;';

  @jni$_.internal
  @core$_.override
  DebugImage$Deserializer fromReference(jni$_.JReference reference) =>
      DebugImage$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DebugImage$Deserializer?> get nullableType =>
      const $DebugImage$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DebugImage$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DebugImage$Deserializer$Type) &&
        other is $DebugImage$Deserializer$Type;
  }
}

/// from: `io.sentry.protocol.DebugImage$JsonKeys`
class DebugImage$JsonKeys extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DebugImage$JsonKeys> $type;

  @jni$_.internal
  DebugImage$JsonKeys.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/protocol/DebugImage$JsonKeys');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DebugImage$JsonKeys$NullableType();
  static const type = $DebugImage$JsonKeys$Type();
  static final _id_UUID = _class.staticFieldId(
    r'UUID',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String UUID`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get UUID =>
      _id_UUID.get(_class, const jni$_.JStringNullableType());

  static final _id_TYPE = _class.staticFieldId(
    r'TYPE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TYPE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TYPE =>
      _id_TYPE.get(_class, const jni$_.JStringNullableType());

  static final _id_DEBUG_ID = _class.staticFieldId(
    r'DEBUG_ID',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DEBUG_ID`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DEBUG_ID =>
      _id_DEBUG_ID.get(_class, const jni$_.JStringNullableType());

  static final _id_DEBUG_FILE = _class.staticFieldId(
    r'DEBUG_FILE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DEBUG_FILE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DEBUG_FILE =>
      _id_DEBUG_FILE.get(_class, const jni$_.JStringNullableType());

  static final _id_CODE_ID = _class.staticFieldId(
    r'CODE_ID',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CODE_ID`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CODE_ID =>
      _id_CODE_ID.get(_class, const jni$_.JStringNullableType());

  static final _id_CODE_FILE = _class.staticFieldId(
    r'CODE_FILE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CODE_FILE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CODE_FILE =>
      _id_CODE_FILE.get(_class, const jni$_.JStringNullableType());

  static final _id_IMAGE_ADDR = _class.staticFieldId(
    r'IMAGE_ADDR',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String IMAGE_ADDR`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get IMAGE_ADDR =>
      _id_IMAGE_ADDR.get(_class, const jni$_.JStringNullableType());

  static final _id_IMAGE_SIZE = _class.staticFieldId(
    r'IMAGE_SIZE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String IMAGE_SIZE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get IMAGE_SIZE =>
      _id_IMAGE_SIZE.get(_class, const jni$_.JStringNullableType());

  static final _id_ARCH = _class.staticFieldId(
    r'ARCH',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ARCH`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ARCH =>
      _id_ARCH.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory DebugImage$JsonKeys() {
    return DebugImage$JsonKeys.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $DebugImage$JsonKeys$NullableType
    extends jni$_.JObjType<DebugImage$JsonKeys?> {
  @jni$_.internal
  const $DebugImage$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/DebugImage$JsonKeys;';

  @jni$_.internal
  @core$_.override
  DebugImage$JsonKeys? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : DebugImage$JsonKeys.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DebugImage$JsonKeys?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DebugImage$JsonKeys$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DebugImage$JsonKeys$NullableType) &&
        other is $DebugImage$JsonKeys$NullableType;
  }
}

final class $DebugImage$JsonKeys$Type
    extends jni$_.JObjType<DebugImage$JsonKeys> {
  @jni$_.internal
  const $DebugImage$JsonKeys$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/DebugImage$JsonKeys;';

  @jni$_.internal
  @core$_.override
  DebugImage$JsonKeys fromReference(jni$_.JReference reference) =>
      DebugImage$JsonKeys.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DebugImage$JsonKeys?> get nullableType =>
      const $DebugImage$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DebugImage$JsonKeys$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DebugImage$JsonKeys$Type) &&
        other is $DebugImage$JsonKeys$Type;
  }
}

/// from: `io.sentry.protocol.DebugImage`
class DebugImage extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DebugImage> $type;

  @jni$_.internal
  DebugImage.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/protocol/DebugImage');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DebugImage$NullableType();
  static const type = $DebugImage$Type();
  static final _id_PROGUARD = _class.staticFieldId(
    r'PROGUARD',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PROGUARD`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get PROGUARD =>
      _id_PROGUARD.get(_class, const jni$_.JStringNullableType());

  static final _id_JVM = _class.staticFieldId(
    r'JVM',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String JVM`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get JVM =>
      _id_JVM.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory DebugImage() {
    return DebugImage.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_getUuid = _class.instanceMethodId(
    r'getUuid',
    r'()Ljava/lang/String;',
  );

  static final _getUuid = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getUuid()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getUuid() {
    return _getUuid(reference.pointer, _id_getUuid as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setUuid = _class.instanceMethodId(
    r'setUuid',
    r'(Ljava/lang/String;)V',
  );

  static final _setUuid = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setUuid(java.lang.String string)`
  void setUuid(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setUuid(reference.pointer, _id_setUuid as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getType = _class.instanceMethodId(
    r'getType',
    r'()Ljava/lang/String;',
  );

  static final _getType = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getType()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getType() {
    return _getType(reference.pointer, _id_getType as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setType = _class.instanceMethodId(
    r'setType',
    r'(Ljava/lang/String;)V',
  );

  static final _setType = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setType(java.lang.String string)`
  void setType(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setType(reference.pointer, _id_setType as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getDebugId = _class.instanceMethodId(
    r'getDebugId',
    r'()Ljava/lang/String;',
  );

  static final _getDebugId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getDebugId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDebugId() {
    return _getDebugId(reference.pointer, _id_getDebugId as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setDebugId = _class.instanceMethodId(
    r'setDebugId',
    r'(Ljava/lang/String;)V',
  );

  static final _setDebugId = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDebugId(java.lang.String string)`
  void setDebugId(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setDebugId(reference.pointer, _id_setDebugId as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getDebugFile = _class.instanceMethodId(
    r'getDebugFile',
    r'()Ljava/lang/String;',
  );

  static final _getDebugFile = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getDebugFile()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDebugFile() {
    return _getDebugFile(
            reference.pointer, _id_getDebugFile as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setDebugFile = _class.instanceMethodId(
    r'setDebugFile',
    r'(Ljava/lang/String;)V',
  );

  static final _setDebugFile = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDebugFile(java.lang.String string)`
  void setDebugFile(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setDebugFile(reference.pointer, _id_setDebugFile as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getCodeFile = _class.instanceMethodId(
    r'getCodeFile',
    r'()Ljava/lang/String;',
  );

  static final _getCodeFile = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getCodeFile()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getCodeFile() {
    return _getCodeFile(
            reference.pointer, _id_getCodeFile as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setCodeFile = _class.instanceMethodId(
    r'setCodeFile',
    r'(Ljava/lang/String;)V',
  );

  static final _setCodeFile = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setCodeFile(java.lang.String string)`
  void setCodeFile(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setCodeFile(reference.pointer, _id_setCodeFile as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getImageAddr = _class.instanceMethodId(
    r'getImageAddr',
    r'()Ljava/lang/String;',
  );

  static final _getImageAddr = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getImageAddr()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getImageAddr() {
    return _getImageAddr(
            reference.pointer, _id_getImageAddr as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setImageAddr = _class.instanceMethodId(
    r'setImageAddr',
    r'(Ljava/lang/String;)V',
  );

  static final _setImageAddr = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setImageAddr(java.lang.String string)`
  void setImageAddr(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setImageAddr(reference.pointer, _id_setImageAddr as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getImageSize = _class.instanceMethodId(
    r'getImageSize',
    r'()Ljava/lang/Long;',
  );

  static final _getImageSize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Long getImageSize()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getImageSize() {
    return _getImageSize(
            reference.pointer, _id_getImageSize as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_setImageSize = _class.instanceMethodId(
    r'setImageSize',
    r'(Ljava/lang/Long;)V',
  );

  static final _setImageSize = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setImageSize(java.lang.Long long)`
  void setImageSize(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    _setImageSize(reference.pointer, _id_setImageSize as jni$_.JMethodIDPtr,
            _$long.pointer)
        .check();
  }

  static final _id_setImageSize$1 = _class.instanceMethodId(
    r'setImageSize',
    r'(J)V',
  );

  static final _setImageSize$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setImageSize(long j)`
  void setImageSize$1(
    int j,
  ) {
    _setImageSize$1(
            reference.pointer, _id_setImageSize$1 as jni$_.JMethodIDPtr, j)
        .check();
  }

  static final _id_getArch = _class.instanceMethodId(
    r'getArch',
    r'()Ljava/lang/String;',
  );

  static final _getArch = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getArch()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getArch() {
    return _getArch(reference.pointer, _id_getArch as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setArch = _class.instanceMethodId(
    r'setArch',
    r'(Ljava/lang/String;)V',
  );

  static final _setArch = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setArch(java.lang.String string)`
  void setArch(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setArch(reference.pointer, _id_setArch as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getCodeId = _class.instanceMethodId(
    r'getCodeId',
    r'()Ljava/lang/String;',
  );

  static final _getCodeId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getCodeId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getCodeId() {
    return _getCodeId(reference.pointer, _id_getCodeId as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setCodeId = _class.instanceMethodId(
    r'setCodeId',
    r'(Ljava/lang/String;)V',
  );

  static final _setCodeId = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setCodeId(java.lang.String string)`
  void setCodeId(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setCodeId(reference.pointer, _id_setCodeId as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getUnknown = _class.instanceMethodId(
    r'getUnknown',
    r'()Ljava/util/Map;',
  );

  static final _getUnknown = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Map<java.lang.String, java.lang.Object> getUnknown()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JObject?>? getUnknown() {
    return _getUnknown(reference.pointer, _id_getUnknown as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JObject?>(
                jni$_.JStringNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_setUnknown = _class.instanceMethodId(
    r'setUnknown',
    r'(Ljava/util/Map;)V',
  );

  static final _setUnknown = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setUnknown(java.util.Map<java.lang.String, java.lang.Object> map)`
  void setUnknown(
    jni$_.JMap<jni$_.JString?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    _setUnknown(reference.pointer, _id_setUnknown as jni$_.JMethodIDPtr,
            _$map.pointer)
        .check();
  }

  static final _id_serialize = _class.instanceMethodId(
    r'serialize',
    r'(Lio/sentry/ObjectWriter;Lio/sentry/ILogger;)V',
  );

  static final _serialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void serialize(io.sentry.ObjectWriter objectWriter, io.sentry.ILogger iLogger)`
  void serialize(
    jni$_.JObject objectWriter,
    jni$_.JObject iLogger,
  ) {
    final _$objectWriter = objectWriter.reference;
    final _$iLogger = iLogger.reference;
    _serialize(reference.pointer, _id_serialize as jni$_.JMethodIDPtr,
            _$objectWriter.pointer, _$iLogger.pointer)
        .check();
  }
}

final class $DebugImage$NullableType extends jni$_.JObjType<DebugImage?> {
  @jni$_.internal
  const $DebugImage$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/DebugImage;';

  @jni$_.internal
  @core$_.override
  DebugImage? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : DebugImage.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DebugImage?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DebugImage$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DebugImage$NullableType) &&
        other is $DebugImage$NullableType;
  }
}

final class $DebugImage$Type extends jni$_.JObjType<DebugImage> {
  @jni$_.internal
  const $DebugImage$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/DebugImage;';

  @jni$_.internal
  @core$_.override
  DebugImage fromReference(jni$_.JReference reference) =>
      DebugImage.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DebugImage?> get nullableType =>
      const $DebugImage$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DebugImage$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DebugImage$Type) && other is $DebugImage$Type;
  }
}

/// from: `io.sentry.android.replay.ReplayIntegration`
class ReplayIntegration extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ReplayIntegration> $type;

  @jni$_.internal
  ReplayIntegration.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/android/replay/ReplayIntegration');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ReplayIntegration$NullableType();
  static const type = $ReplayIntegration$Type();
  static final _id_new$ = _class.constructorId(
    r'(Landroid/content/Context;Lio/sentry/transport/ICurrentDateProvider;Lkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(android.content.Context context, io.sentry.transport.ICurrentDateProvider iCurrentDateProvider, kotlin.jvm.functions.Function0<? extends io.sentry.android.replay.Recorder> function0, kotlin.jvm.functions.Function1<? super io.sentry.protocol.SentryId, io.sentry.android.replay.ReplayCache> function1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ReplayIntegration(
    jni$_.JObject context,
    jni$_.JObject iCurrentDateProvider,
    jni$_.JObject? function0,
    jni$_.JObject? function1,
  ) {
    final _$context = context.reference;
    final _$iCurrentDateProvider = iCurrentDateProvider.reference;
    final _$function0 = function0?.reference ?? jni$_.jNullReference;
    final _$function1 = function1?.reference ?? jni$_.jNullReference;
    return ReplayIntegration.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$iCurrentDateProvider.pointer,
            _$function0.pointer,
            _$function1.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Landroid/content/Context;Lio/sentry/transport/ICurrentDateProvider;Lkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(android.content.Context context, io.sentry.transport.ICurrentDateProvider iCurrentDateProvider, kotlin.jvm.functions.Function0 function0, kotlin.jvm.functions.Function1 function1, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ReplayIntegration.new$1(
    jni$_.JObject? context,
    jni$_.JObject? iCurrentDateProvider,
    jni$_.JObject? function0,
    jni$_.JObject? function1,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$context = context?.reference ?? jni$_.jNullReference;
    final _$iCurrentDateProvider =
        iCurrentDateProvider?.reference ?? jni$_.jNullReference;
    final _$function0 = function0?.reference ?? jni$_.jNullReference;
    final _$function1 = function1?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return ReplayIntegration.fromReference(_new$1(
            _class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$iCurrentDateProvider.pointer,
            _$function0.pointer,
            _$function1.pointer,
            i,
            _$defaultConstructorMarker.pointer)
        .reference);
  }

  static final _id_new$2 = _class.constructorId(
    r'(Landroid/content/Context;Lio/sentry/transport/ICurrentDateProvider;)V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(android.content.Context context, io.sentry.transport.ICurrentDateProvider iCurrentDateProvider)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ReplayIntegration.new$2(
    jni$_.JObject context,
    jni$_.JObject iCurrentDateProvider,
  ) {
    final _$context = context.reference;
    final _$iCurrentDateProvider = iCurrentDateProvider.reference;
    return ReplayIntegration.fromReference(_new$2(
            _class.reference.pointer,
            _id_new$2 as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$iCurrentDateProvider.pointer)
        .reference);
  }

  static final _id_new$3 = _class.constructorId(
    r'(Landroid/content/Context;Lio/sentry/transport/ICurrentDateProvider;Lkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;Lio/sentry/android/replay/util/MainLooperHandler;Lkotlin/jvm/functions/Function0;)V',
  );

  static final _new$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(android.content.Context context, io.sentry.transport.ICurrentDateProvider iCurrentDateProvider, kotlin.jvm.functions.Function0<? extends io.sentry.android.replay.Recorder> function0, kotlin.jvm.functions.Function1<? super io.sentry.protocol.SentryId, io.sentry.android.replay.ReplayCache> function1, kotlin.jvm.functions.Function1<? super java.lang.Boolean, ? extends io.sentry.android.replay.capture.CaptureStrategy> function11, io.sentry.android.replay.util.MainLooperHandler mainLooperHandler, kotlin.jvm.functions.Function0<io.sentry.android.replay.gestures.GestureRecorder> function01)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ReplayIntegration.new$3(
    jni$_.JObject context,
    jni$_.JObject iCurrentDateProvider,
    jni$_.JObject? function0,
    jni$_.JObject? function1,
    jni$_.JObject? function11,
    jni$_.JObject? mainLooperHandler,
    jni$_.JObject? function01,
  ) {
    final _$context = context.reference;
    final _$iCurrentDateProvider = iCurrentDateProvider.reference;
    final _$function0 = function0?.reference ?? jni$_.jNullReference;
    final _$function1 = function1?.reference ?? jni$_.jNullReference;
    final _$function11 = function11?.reference ?? jni$_.jNullReference;
    final _$mainLooperHandler =
        mainLooperHandler?.reference ?? jni$_.jNullReference;
    final _$function01 = function01?.reference ?? jni$_.jNullReference;
    return ReplayIntegration.fromReference(_new$3(
            _class.reference.pointer,
            _id_new$3 as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$iCurrentDateProvider.pointer,
            _$function0.pointer,
            _$function1.pointer,
            _$function11.pointer,
            _$mainLooperHandler.pointer,
            _$function01.pointer)
        .reference);
  }

  static final _id_new$4 = _class.constructorId(
    r'(Landroid/content/Context;Lio/sentry/transport/ICurrentDateProvider;Lkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;Lio/sentry/android/replay/util/MainLooperHandler;Lkotlin/jvm/functions/Function0;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(android.content.Context context, io.sentry.transport.ICurrentDateProvider iCurrentDateProvider, kotlin.jvm.functions.Function0 function0, kotlin.jvm.functions.Function1 function1, kotlin.jvm.functions.Function1 function11, io.sentry.android.replay.util.MainLooperHandler mainLooperHandler, kotlin.jvm.functions.Function0 function01, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ReplayIntegration.new$4(
    jni$_.JObject? context,
    jni$_.JObject? iCurrentDateProvider,
    jni$_.JObject? function0,
    jni$_.JObject? function1,
    jni$_.JObject? function11,
    jni$_.JObject? mainLooperHandler,
    jni$_.JObject? function01,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$context = context?.reference ?? jni$_.jNullReference;
    final _$iCurrentDateProvider =
        iCurrentDateProvider?.reference ?? jni$_.jNullReference;
    final _$function0 = function0?.reference ?? jni$_.jNullReference;
    final _$function1 = function1?.reference ?? jni$_.jNullReference;
    final _$function11 = function11?.reference ?? jni$_.jNullReference;
    final _$mainLooperHandler =
        mainLooperHandler?.reference ?? jni$_.jNullReference;
    final _$function01 = function01?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return ReplayIntegration.fromReference(_new$4(
            _class.reference.pointer,
            _id_new$4 as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$iCurrentDateProvider.pointer,
            _$function0.pointer,
            _$function1.pointer,
            _$function11.pointer,
            _$mainLooperHandler.pointer,
            _$function01.pointer,
            i,
            _$defaultConstructorMarker.pointer)
        .reference);
  }

  static final _id_getReplayCacheDir = _class.instanceMethodId(
    r'getReplayCacheDir',
    r'()Ljava/io/File;',
  );

  static final _getReplayCacheDir = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.io.File getReplayCacheDir()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getReplayCacheDir() {
    return _getReplayCacheDir(
            reference.pointer, _id_getReplayCacheDir as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_register = _class.instanceMethodId(
    r'register',
    r'(Lio/sentry/IScopes;Lio/sentry/SentryOptions;)V',
  );

  static final _register = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void register(io.sentry.IScopes iScopes, io.sentry.SentryOptions sentryOptions)`
  void register(
    jni$_.JObject iScopes,
    jni$_.JObject sentryOptions,
  ) {
    final _$iScopes = iScopes.reference;
    final _$sentryOptions = sentryOptions.reference;
    _register(reference.pointer, _id_register as jni$_.JMethodIDPtr,
            _$iScopes.pointer, _$sentryOptions.pointer)
        .check();
  }

  static final _id_isRecording = _class.instanceMethodId(
    r'isRecording',
    r'()Z',
  );

  static final _isRecording = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isRecording()`
  bool isRecording() {
    return _isRecording(
            reference.pointer, _id_isRecording as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_start = _class.instanceMethodId(
    r'start',
    r'()V',
  );

  static final _start = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void start()`
  void start() {
    _start(reference.pointer, _id_start as jni$_.JMethodIDPtr).check();
  }

  static final _id_resume = _class.instanceMethodId(
    r'resume',
    r'()V',
  );

  static final _resume = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void resume()`
  void resume() {
    _resume(reference.pointer, _id_resume as jni$_.JMethodIDPtr).check();
  }

  static final _id_captureReplay = _class.instanceMethodId(
    r'captureReplay',
    r'(Ljava/lang/Boolean;)V',
  );

  static final _captureReplay = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void captureReplay(java.lang.Boolean boolean)`
  void captureReplay(
    jni$_.JBoolean? boolean,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    _captureReplay(reference.pointer, _id_captureReplay as jni$_.JMethodIDPtr,
            _$boolean.pointer)
        .check();
  }

  static final _id_getReplayId = _class.instanceMethodId(
    r'getReplayId',
    r'()Lio/sentry/protocol/SentryId;',
  );

  static final _getReplayId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.SentryId getReplayId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getReplayId() {
    return _getReplayId(
            reference.pointer, _id_getReplayId as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setBreadcrumbConverter = _class.instanceMethodId(
    r'setBreadcrumbConverter',
    r'(Lio/sentry/ReplayBreadcrumbConverter;)V',
  );

  static final _setBreadcrumbConverter = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setBreadcrumbConverter(io.sentry.ReplayBreadcrumbConverter replayBreadcrumbConverter)`
  void setBreadcrumbConverter(
    jni$_.JObject replayBreadcrumbConverter,
  ) {
    final _$replayBreadcrumbConverter = replayBreadcrumbConverter.reference;
    _setBreadcrumbConverter(
            reference.pointer,
            _id_setBreadcrumbConverter as jni$_.JMethodIDPtr,
            _$replayBreadcrumbConverter.pointer)
        .check();
  }

  static final _id_getBreadcrumbConverter = _class.instanceMethodId(
    r'getBreadcrumbConverter',
    r'()Lio/sentry/ReplayBreadcrumbConverter;',
  );

  static final _getBreadcrumbConverter = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ReplayBreadcrumbConverter getBreadcrumbConverter()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getBreadcrumbConverter() {
    return _getBreadcrumbConverter(
            reference.pointer, _id_getBreadcrumbConverter as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_pause = _class.instanceMethodId(
    r'pause',
    r'()V',
  );

  static final _pause = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void pause()`
  void pause() {
    _pause(reference.pointer, _id_pause as jni$_.JMethodIDPtr).check();
  }

  static final _id_enableDebugMaskingOverlay = _class.instanceMethodId(
    r'enableDebugMaskingOverlay',
    r'()V',
  );

  static final _enableDebugMaskingOverlay = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void enableDebugMaskingOverlay()`
  void enableDebugMaskingOverlay() {
    _enableDebugMaskingOverlay(reference.pointer,
            _id_enableDebugMaskingOverlay as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_disableDebugMaskingOverlay = _class.instanceMethodId(
    r'disableDebugMaskingOverlay',
    r'()V',
  );

  static final _disableDebugMaskingOverlay =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public void disableDebugMaskingOverlay()`
  void disableDebugMaskingOverlay() {
    _disableDebugMaskingOverlay(reference.pointer,
            _id_disableDebugMaskingOverlay as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_isDebugMaskingOverlayEnabled = _class.instanceMethodId(
    r'isDebugMaskingOverlayEnabled',
    r'()Z',
  );

  static final _isDebugMaskingOverlayEnabled =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isDebugMaskingOverlayEnabled()`
  bool isDebugMaskingOverlayEnabled() {
    return _isDebugMaskingOverlayEnabled(reference.pointer,
            _id_isDebugMaskingOverlayEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_stop = _class.instanceMethodId(
    r'stop',
    r'()V',
  );

  static final _stop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void stop()`
  void stop() {
    _stop(reference.pointer, _id_stop as jni$_.JMethodIDPtr).check();
  }

  static final _id_onScreenshotRecorded = _class.instanceMethodId(
    r'onScreenshotRecorded',
    r'(Landroid/graphics/Bitmap;)V',
  );

  static final _onScreenshotRecorded = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onScreenshotRecorded(android.graphics.Bitmap bitmap)`
  void onScreenshotRecorded(
    Bitmap bitmap,
  ) {
    final _$bitmap = bitmap.reference;
    _onScreenshotRecorded(reference.pointer,
            _id_onScreenshotRecorded as jni$_.JMethodIDPtr, _$bitmap.pointer)
        .check();
  }

  static final _id_onScreenshotRecorded$1 = _class.instanceMethodId(
    r'onScreenshotRecorded',
    r'(Ljava/io/File;J)V',
  );

  static final _onScreenshotRecorded$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public void onScreenshotRecorded(java.io.File file, long j)`
  void onScreenshotRecorded$1(
    jni$_.JObject file,
    int j,
  ) {
    final _$file = file.reference;
    _onScreenshotRecorded$1(reference.pointer,
            _id_onScreenshotRecorded$1 as jni$_.JMethodIDPtr, _$file.pointer, j)
        .check();
  }

  static final _id_close = _class.instanceMethodId(
    r'close',
    r'()V',
  );

  static final _close = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_onConnectionStatusChanged = _class.instanceMethodId(
    r'onConnectionStatusChanged',
    r'(Lio/sentry/IConnectionStatusProvider$ConnectionStatus;)V',
  );

  static final _onConnectionStatusChanged = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onConnectionStatusChanged(io.sentry.IConnectionStatusProvider$ConnectionStatus connectionStatus)`
  void onConnectionStatusChanged(
    jni$_.JObject connectionStatus,
  ) {
    final _$connectionStatus = connectionStatus.reference;
    _onConnectionStatusChanged(
            reference.pointer,
            _id_onConnectionStatusChanged as jni$_.JMethodIDPtr,
            _$connectionStatus.pointer)
        .check();
  }

  static final _id_onRateLimitChanged = _class.instanceMethodId(
    r'onRateLimitChanged',
    r'(Lio/sentry/transport/RateLimiter;)V',
  );

  static final _onRateLimitChanged = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onRateLimitChanged(io.sentry.transport.RateLimiter rateLimiter)`
  void onRateLimitChanged(
    jni$_.JObject rateLimiter,
  ) {
    final _$rateLimiter = rateLimiter.reference;
    _onRateLimitChanged(reference.pointer,
            _id_onRateLimitChanged as jni$_.JMethodIDPtr, _$rateLimiter.pointer)
        .check();
  }

  static final _id_onTouchEvent = _class.instanceMethodId(
    r'onTouchEvent',
    r'(Landroid/view/MotionEvent;)V',
  );

  static final _onTouchEvent = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onTouchEvent(android.view.MotionEvent motionEvent)`
  void onTouchEvent(
    jni$_.JObject motionEvent,
  ) {
    final _$motionEvent = motionEvent.reference;
    _onTouchEvent(reference.pointer, _id_onTouchEvent as jni$_.JMethodIDPtr,
            _$motionEvent.pointer)
        .check();
  }

  static final _id_onWindowSizeChanged = _class.instanceMethodId(
    r'onWindowSizeChanged',
    r'(II)V',
  );

  static final _onWindowSizeChanged = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int)>();

  /// from: `public void onWindowSizeChanged(int i, int i1)`
  void onWindowSizeChanged(
    int i,
    int i1,
  ) {
    _onWindowSizeChanged(reference.pointer,
            _id_onWindowSizeChanged as jni$_.JMethodIDPtr, i, i1)
        .check();
  }

  static final _id_onConfigurationChanged = _class.instanceMethodId(
    r'onConfigurationChanged',
    r'(Lio/sentry/android/replay/ScreenshotRecorderConfig;)V',
  );

  static final _onConfigurationChanged = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void onConfigurationChanged(io.sentry.android.replay.ScreenshotRecorderConfig screenshotRecorderConfig)`
  void onConfigurationChanged(
    jni$_.JObject screenshotRecorderConfig,
  ) {
    final _$screenshotRecorderConfig = screenshotRecorderConfig.reference;
    _onConfigurationChanged(
            reference.pointer,
            _id_onConfigurationChanged as jni$_.JMethodIDPtr,
            _$screenshotRecorderConfig.pointer)
        .check();
  }
}

final class $ReplayIntegration$NullableType
    extends jni$_.JObjType<ReplayIntegration?> {
  @jni$_.internal
  const $ReplayIntegration$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/replay/ReplayIntegration;';

  @jni$_.internal
  @core$_.override
  ReplayIntegration? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ReplayIntegration.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ReplayIntegration?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ReplayIntegration$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ReplayIntegration$NullableType) &&
        other is $ReplayIntegration$NullableType;
  }
}

final class $ReplayIntegration$Type extends jni$_.JObjType<ReplayIntegration> {
  @jni$_.internal
  const $ReplayIntegration$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/replay/ReplayIntegration;';

  @jni$_.internal
  @core$_.override
  ReplayIntegration fromReference(jni$_.JReference reference) =>
      ReplayIntegration.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ReplayIntegration?> get nullableType =>
      const $ReplayIntegration$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ReplayIntegration$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ReplayIntegration$Type) &&
        other is $ReplayIntegration$Type;
  }
}

/// from: `io.sentry.flutter.SentryFlutterPlugin$Companion`
class SentryFlutterPlugin$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryFlutterPlugin$Companion> $type;

  @jni$_.internal
  SentryFlutterPlugin$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/flutter/SentryFlutterPlugin$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryFlutterPlugin$Companion$NullableType();
  static const type = $SentryFlutterPlugin$Companion$Type();
  static final _id_privateSentryGetReplayIntegration = _class.instanceMethodId(
    r'privateSentryGetReplayIntegration',
    r'()Lio/sentry/android/replay/ReplayIntegration;',
  );

  static final _privateSentryGetReplayIntegration =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public final io.sentry.android.replay.ReplayIntegration privateSentryGetReplayIntegration()`
  /// The returned object must be released after use, by calling the [release] method.
  ReplayIntegration? privateSentryGetReplayIntegration() {
    return _privateSentryGetReplayIntegration(reference.pointer,
            _id_privateSentryGetReplayIntegration as jni$_.JMethodIDPtr)
        .object<ReplayIntegration?>(const $ReplayIntegration$NullableType());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryFlutterPlugin$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return SentryFlutterPlugin$Companion.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $SentryFlutterPlugin$Companion$NullableType
    extends jni$_.JObjType<SentryFlutterPlugin$Companion?> {
  @jni$_.internal
  const $SentryFlutterPlugin$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/flutter/SentryFlutterPlugin$Companion;';

  @jni$_.internal
  @core$_.override
  SentryFlutterPlugin$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryFlutterPlugin$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryFlutterPlugin$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryFlutterPlugin$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryFlutterPlugin$Companion$NullableType) &&
        other is $SentryFlutterPlugin$Companion$NullableType;
  }
}

final class $SentryFlutterPlugin$Companion$Type
    extends jni$_.JObjType<SentryFlutterPlugin$Companion> {
  @jni$_.internal
  const $SentryFlutterPlugin$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/flutter/SentryFlutterPlugin$Companion;';

  @jni$_.internal
  @core$_.override
  SentryFlutterPlugin$Companion fromReference(jni$_.JReference reference) =>
      SentryFlutterPlugin$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryFlutterPlugin$Companion?> get nullableType =>
      const $SentryFlutterPlugin$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryFlutterPlugin$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryFlutterPlugin$Companion$Type) &&
        other is $SentryFlutterPlugin$Companion$Type;
  }
}

/// from: `io.sentry.flutter.SentryFlutterPlugin`
class SentryFlutterPlugin extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryFlutterPlugin> $type;

  @jni$_.internal
  SentryFlutterPlugin.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/flutter/SentryFlutterPlugin');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryFlutterPlugin$NullableType();
  static const type = $SentryFlutterPlugin$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Lio/sentry/flutter/SentryFlutterPlugin$Companion;',
  );

  /// from: `static public final io.sentry.flutter.SentryFlutterPlugin$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryFlutterPlugin$Companion get Companion =>
      _id_Companion.get(_class, const $SentryFlutterPlugin$Companion$Type());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryFlutterPlugin() {
    return SentryFlutterPlugin.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_onAttachedToEngine = _class.instanceMethodId(
    r'onAttachedToEngine',
    r'(Lio/flutter/embedding/engine/plugins/FlutterPlugin$FlutterPluginBinding;)V',
  );

  static final _onAttachedToEngine = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onAttachedToEngine(io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding flutterPluginBinding)`
  void onAttachedToEngine(
    jni$_.JObject flutterPluginBinding,
  ) {
    final _$flutterPluginBinding = flutterPluginBinding.reference;
    _onAttachedToEngine(
            reference.pointer,
            _id_onAttachedToEngine as jni$_.JMethodIDPtr,
            _$flutterPluginBinding.pointer)
        .check();
  }

  static final _id_onMethodCall = _class.instanceMethodId(
    r'onMethodCall',
    r'(Lio/flutter/plugin/common/MethodCall;Lio/flutter/plugin/common/MethodChannel$Result;)V',
  );

  static final _onMethodCall = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onMethodCall(io.flutter.plugin.common.MethodCall methodCall, io.flutter.plugin.common.MethodChannel$Result result)`
  void onMethodCall(
    jni$_.JObject methodCall,
    jni$_.JObject result,
  ) {
    final _$methodCall = methodCall.reference;
    final _$result = result.reference;
    _onMethodCall(reference.pointer, _id_onMethodCall as jni$_.JMethodIDPtr,
            _$methodCall.pointer, _$result.pointer)
        .check();
  }

  static final _id_onDetachedFromEngine = _class.instanceMethodId(
    r'onDetachedFromEngine',
    r'(Lio/flutter/embedding/engine/plugins/FlutterPlugin$FlutterPluginBinding;)V',
  );

  static final _onDetachedFromEngine = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onDetachedFromEngine(io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding flutterPluginBinding)`
  void onDetachedFromEngine(
    jni$_.JObject flutterPluginBinding,
  ) {
    final _$flutterPluginBinding = flutterPluginBinding.reference;
    _onDetachedFromEngine(
            reference.pointer,
            _id_onDetachedFromEngine as jni$_.JMethodIDPtr,
            _$flutterPluginBinding.pointer)
        .check();
  }

  static final _id_onAttachedToActivity = _class.instanceMethodId(
    r'onAttachedToActivity',
    r'(Lio/flutter/embedding/engine/plugins/activity/ActivityPluginBinding;)V',
  );

  static final _onAttachedToActivity = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onAttachedToActivity(io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding activityPluginBinding)`
  void onAttachedToActivity(
    jni$_.JObject activityPluginBinding,
  ) {
    final _$activityPluginBinding = activityPluginBinding.reference;
    _onAttachedToActivity(
            reference.pointer,
            _id_onAttachedToActivity as jni$_.JMethodIDPtr,
            _$activityPluginBinding.pointer)
        .check();
  }

  static final _id_onDetachedFromActivity = _class.instanceMethodId(
    r'onDetachedFromActivity',
    r'()V',
  );

  static final _onDetachedFromActivity = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void onDetachedFromActivity()`
  void onDetachedFromActivity() {
    _onDetachedFromActivity(
            reference.pointer, _id_onDetachedFromActivity as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_onReattachedToActivityForConfigChanges =
      _class.instanceMethodId(
    r'onReattachedToActivityForConfigChanges',
    r'(Lio/flutter/embedding/engine/plugins/activity/ActivityPluginBinding;)V',
  );

  static final _onReattachedToActivityForConfigChanges =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onReattachedToActivityForConfigChanges(io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding activityPluginBinding)`
  void onReattachedToActivityForConfigChanges(
    jni$_.JObject activityPluginBinding,
  ) {
    final _$activityPluginBinding = activityPluginBinding.reference;
    _onReattachedToActivityForConfigChanges(
            reference.pointer,
            _id_onReattachedToActivityForConfigChanges as jni$_.JMethodIDPtr,
            _$activityPluginBinding.pointer)
        .check();
  }

  static final _id_onDetachedFromActivityForConfigChanges =
      _class.instanceMethodId(
    r'onDetachedFromActivityForConfigChanges',
    r'()V',
  );

  static final _onDetachedFromActivityForConfigChanges =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public void onDetachedFromActivityForConfigChanges()`
  void onDetachedFromActivityForConfigChanges() {
    _onDetachedFromActivityForConfigChanges(reference.pointer,
            _id_onDetachedFromActivityForConfigChanges as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_privateSentryGetReplayIntegration = _class.staticMethodId(
    r'privateSentryGetReplayIntegration',
    r'()Lio/sentry/android/replay/ReplayIntegration;',
  );

  static final _privateSentryGetReplayIntegration =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `static public final io.sentry.android.replay.ReplayIntegration privateSentryGetReplayIntegration()`
  /// The returned object must be released after use, by calling the [release] method.
  static ReplayIntegration? privateSentryGetReplayIntegration() {
    return _privateSentryGetReplayIntegration(_class.reference.pointer,
            _id_privateSentryGetReplayIntegration as jni$_.JMethodIDPtr)
        .object<ReplayIntegration?>(const $ReplayIntegration$NullableType());
  }
}

final class $SentryFlutterPlugin$NullableType
    extends jni$_.JObjType<SentryFlutterPlugin?> {
  @jni$_.internal
  const $SentryFlutterPlugin$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/flutter/SentryFlutterPlugin;';

  @jni$_.internal
  @core$_.override
  SentryFlutterPlugin? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryFlutterPlugin.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryFlutterPlugin?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryFlutterPlugin$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryFlutterPlugin$NullableType) &&
        other is $SentryFlutterPlugin$NullableType;
  }
}

final class $SentryFlutterPlugin$Type
    extends jni$_.JObjType<SentryFlutterPlugin> {
  @jni$_.internal
  const $SentryFlutterPlugin$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/flutter/SentryFlutterPlugin;';

  @jni$_.internal
  @core$_.override
  SentryFlutterPlugin fromReference(jni$_.JReference reference) =>
      SentryFlutterPlugin.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryFlutterPlugin?> get nullableType =>
      const $SentryFlutterPlugin$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryFlutterPlugin$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryFlutterPlugin$Type) &&
        other is $SentryFlutterPlugin$Type;
  }
}

/// from: `io.sentry.ScopesAdapter`
class ScopesAdapter extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ScopesAdapter> $type;

  @jni$_.internal
  ScopesAdapter.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/ScopesAdapter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ScopesAdapter$NullableType();
  static const type = $ScopesAdapter$Type();
  static final _id_getInstance = _class.staticMethodId(
    r'getInstance',
    r'()Lio/sentry/ScopesAdapter;',
  );

  static final _getInstance = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.ScopesAdapter getInstance()`
  /// The returned object must be released after use, by calling the [release] method.
  static ScopesAdapter? getInstance() {
    return _getInstance(
            _class.reference.pointer, _id_getInstance as jni$_.JMethodIDPtr)
        .object<ScopesAdapter?>(const $ScopesAdapter$NullableType());
  }

  static final _id_isEnabled = _class.instanceMethodId(
    r'isEnabled',
    r'()Z',
  );

  static final _isEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEnabled()`
  bool isEnabled() {
    return _isEnabled(reference.pointer, _id_isEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_captureEvent = _class.instanceMethodId(
    r'captureEvent',
    r'(Lio/sentry/SentryEvent;Lio/sentry/Hint;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureEvent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureEvent(io.sentry.SentryEvent sentryEvent, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureEvent(
    jni$_.JObject sentryEvent,
    jni$_.JObject? hint,
  ) {
    final _$sentryEvent = sentryEvent.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    return _captureEvent(
            reference.pointer,
            _id_captureEvent as jni$_.JMethodIDPtr,
            _$sentryEvent.pointer,
            _$hint.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureEvent$1 = _class.instanceMethodId(
    r'captureEvent',
    r'(Lio/sentry/SentryEvent;Lio/sentry/Hint;Lio/sentry/ScopeCallback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureEvent$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureEvent(io.sentry.SentryEvent sentryEvent, io.sentry.Hint hint, io.sentry.ScopeCallback scopeCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureEvent$1(
    jni$_.JObject sentryEvent,
    jni$_.JObject? hint,
    jni$_.JObject scopeCallback,
  ) {
    final _$sentryEvent = sentryEvent.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    final _$scopeCallback = scopeCallback.reference;
    return _captureEvent$1(
            reference.pointer,
            _id_captureEvent$1 as jni$_.JMethodIDPtr,
            _$sentryEvent.pointer,
            _$hint.pointer,
            _$scopeCallback.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureMessage = _class.instanceMethodId(
    r'captureMessage',
    r'(Ljava/lang/String;Lio/sentry/SentryLevel;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureMessage = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureMessage(java.lang.String string, io.sentry.SentryLevel sentryLevel)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureMessage(
    jni$_.JString string,
    jni$_.JObject sentryLevel,
  ) {
    final _$string = string.reference;
    final _$sentryLevel = sentryLevel.reference;
    return _captureMessage(
            reference.pointer,
            _id_captureMessage as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$sentryLevel.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureMessage$1 = _class.instanceMethodId(
    r'captureMessage',
    r'(Ljava/lang/String;Lio/sentry/SentryLevel;Lio/sentry/ScopeCallback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureMessage$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureMessage(java.lang.String string, io.sentry.SentryLevel sentryLevel, io.sentry.ScopeCallback scopeCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureMessage$1(
    jni$_.JString string,
    jni$_.JObject sentryLevel,
    jni$_.JObject scopeCallback,
  ) {
    final _$string = string.reference;
    final _$sentryLevel = sentryLevel.reference;
    final _$scopeCallback = scopeCallback.reference;
    return _captureMessage$1(
            reference.pointer,
            _id_captureMessage$1 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$sentryLevel.pointer,
            _$scopeCallback.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureFeedback = _class.instanceMethodId(
    r'captureFeedback',
    r'(Lio/sentry/protocol/Feedback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureFeedback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureFeedback(io.sentry.protocol.Feedback feedback)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureFeedback(
    jni$_.JObject feedback,
  ) {
    final _$feedback = feedback.reference;
    return _captureFeedback(reference.pointer,
            _id_captureFeedback as jni$_.JMethodIDPtr, _$feedback.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureFeedback$1 = _class.instanceMethodId(
    r'captureFeedback',
    r'(Lio/sentry/protocol/Feedback;Lio/sentry/Hint;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureFeedback$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureFeedback(io.sentry.protocol.Feedback feedback, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureFeedback$1(
    jni$_.JObject feedback,
    jni$_.JObject? hint,
  ) {
    final _$feedback = feedback.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    return _captureFeedback$1(
            reference.pointer,
            _id_captureFeedback$1 as jni$_.JMethodIDPtr,
            _$feedback.pointer,
            _$hint.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureFeedback$2 = _class.instanceMethodId(
    r'captureFeedback',
    r'(Lio/sentry/protocol/Feedback;Lio/sentry/Hint;Lio/sentry/ScopeCallback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureFeedback$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureFeedback(io.sentry.protocol.Feedback feedback, io.sentry.Hint hint, io.sentry.ScopeCallback scopeCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureFeedback$2(
    jni$_.JObject feedback,
    jni$_.JObject? hint,
    jni$_.JObject? scopeCallback,
  ) {
    final _$feedback = feedback.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    final _$scopeCallback = scopeCallback?.reference ?? jni$_.jNullReference;
    return _captureFeedback$2(
            reference.pointer,
            _id_captureFeedback$2 as jni$_.JMethodIDPtr,
            _$feedback.pointer,
            _$hint.pointer,
            _$scopeCallback.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureEnvelope = _class.instanceMethodId(
    r'captureEnvelope',
    r'(Lio/sentry/SentryEnvelope;Lio/sentry/Hint;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureEnvelope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureEnvelope(io.sentry.SentryEnvelope sentryEnvelope, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureEnvelope(
    jni$_.JObject sentryEnvelope,
    jni$_.JObject? hint,
  ) {
    final _$sentryEnvelope = sentryEnvelope.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    return _captureEnvelope(
            reference.pointer,
            _id_captureEnvelope as jni$_.JMethodIDPtr,
            _$sentryEnvelope.pointer,
            _$hint.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureException = _class.instanceMethodId(
    r'captureException',
    r'(Ljava/lang/Throwable;Lio/sentry/Hint;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureException = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureException(java.lang.Throwable throwable, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureException(
    jni$_.JObject throwable,
    jni$_.JObject? hint,
  ) {
    final _$throwable = throwable.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    return _captureException(
            reference.pointer,
            _id_captureException as jni$_.JMethodIDPtr,
            _$throwable.pointer,
            _$hint.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureException$1 = _class.instanceMethodId(
    r'captureException',
    r'(Ljava/lang/Throwable;Lio/sentry/Hint;Lio/sentry/ScopeCallback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureException$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureException(java.lang.Throwable throwable, io.sentry.Hint hint, io.sentry.ScopeCallback scopeCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureException$1(
    jni$_.JObject throwable,
    jni$_.JObject? hint,
    jni$_.JObject scopeCallback,
  ) {
    final _$throwable = throwable.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    final _$scopeCallback = scopeCallback.reference;
    return _captureException$1(
            reference.pointer,
            _id_captureException$1 as jni$_.JMethodIDPtr,
            _$throwable.pointer,
            _$hint.pointer,
            _$scopeCallback.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureUserFeedback = _class.instanceMethodId(
    r'captureUserFeedback',
    r'(Lio/sentry/UserFeedback;)V',
  );

  static final _captureUserFeedback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void captureUserFeedback(io.sentry.UserFeedback userFeedback)`
  void captureUserFeedback(
    jni$_.JObject userFeedback,
  ) {
    final _$userFeedback = userFeedback.reference;
    _captureUserFeedback(
            reference.pointer,
            _id_captureUserFeedback as jni$_.JMethodIDPtr,
            _$userFeedback.pointer)
        .check();
  }

  static final _id_startSession = _class.instanceMethodId(
    r'startSession',
    r'()V',
  );

  static final _startSession = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void startSession()`
  void startSession() {
    _startSession(reference.pointer, _id_startSession as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_endSession = _class.instanceMethodId(
    r'endSession',
    r'()V',
  );

  static final _endSession = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void endSession()`
  void endSession() {
    _endSession(reference.pointer, _id_endSession as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_close = _class.instanceMethodId(
    r'close',
    r'(Z)V',
  );

  static final _close = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void close(boolean z)`
  void close(
    bool z,
  ) {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_close$1 = _class.instanceMethodId(
    r'close',
    r'()V',
  );

  static final _close$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void close()`
  void close$1() {
    _close$1(reference.pointer, _id_close$1 as jni$_.JMethodIDPtr).check();
  }

  static final _id_addBreadcrumb = _class.instanceMethodId(
    r'addBreadcrumb',
    r'(Lio/sentry/Breadcrumb;Lio/sentry/Hint;)V',
  );

  static final _addBreadcrumb = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addBreadcrumb(io.sentry.Breadcrumb breadcrumb, io.sentry.Hint hint)`
  void addBreadcrumb(
    jni$_.JObject breadcrumb,
    jni$_.JObject? hint,
  ) {
    final _$breadcrumb = breadcrumb.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    _addBreadcrumb(reference.pointer, _id_addBreadcrumb as jni$_.JMethodIDPtr,
            _$breadcrumb.pointer, _$hint.pointer)
        .check();
  }

  static final _id_addBreadcrumb$1 = _class.instanceMethodId(
    r'addBreadcrumb',
    r'(Lio/sentry/Breadcrumb;)V',
  );

  static final _addBreadcrumb$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addBreadcrumb(io.sentry.Breadcrumb breadcrumb)`
  void addBreadcrumb$1(
    jni$_.JObject breadcrumb,
  ) {
    final _$breadcrumb = breadcrumb.reference;
    _addBreadcrumb$1(reference.pointer,
            _id_addBreadcrumb$1 as jni$_.JMethodIDPtr, _$breadcrumb.pointer)
        .check();
  }

  static final _id_setLevel = _class.instanceMethodId(
    r'setLevel',
    r'(Lio/sentry/SentryLevel;)V',
  );

  static final _setLevel = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setLevel(io.sentry.SentryLevel sentryLevel)`
  void setLevel(
    jni$_.JObject? sentryLevel,
  ) {
    final _$sentryLevel = sentryLevel?.reference ?? jni$_.jNullReference;
    _setLevel(reference.pointer, _id_setLevel as jni$_.JMethodIDPtr,
            _$sentryLevel.pointer)
        .check();
  }

  static final _id_setTransaction = _class.instanceMethodId(
    r'setTransaction',
    r'(Ljava/lang/String;)V',
  );

  static final _setTransaction = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTransaction(java.lang.String string)`
  void setTransaction(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setTransaction(reference.pointer, _id_setTransaction as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_setUser = _class.instanceMethodId(
    r'setUser',
    r'(Lio/sentry/protocol/User;)V',
  );

  static final _setUser = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setUser(io.sentry.protocol.User user)`
  void setUser(
    jni$_.JObject? user,
  ) {
    final _$user = user?.reference ?? jni$_.jNullReference;
    _setUser(reference.pointer, _id_setUser as jni$_.JMethodIDPtr,
            _$user.pointer)
        .check();
  }

  static final _id_setFingerprint = _class.instanceMethodId(
    r'setFingerprint',
    r'(Ljava/util/List;)V',
  );

  static final _setFingerprint = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setFingerprint(java.util.List<java.lang.String> list)`
  void setFingerprint(
    jni$_.JList<jni$_.JString?> list,
  ) {
    final _$list = list.reference;
    _setFingerprint(reference.pointer, _id_setFingerprint as jni$_.JMethodIDPtr,
            _$list.pointer)
        .check();
  }

  static final _id_clearBreadcrumbs = _class.instanceMethodId(
    r'clearBreadcrumbs',
    r'()V',
  );

  static final _clearBreadcrumbs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void clearBreadcrumbs()`
  void clearBreadcrumbs() {
    _clearBreadcrumbs(
            reference.pointer, _id_clearBreadcrumbs as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_setTag = _class.instanceMethodId(
    r'setTag',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setTag = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTag(java.lang.String string, java.lang.String string1)`
  void setTag(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setTag(reference.pointer, _id_setTag as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  static final _id_removeTag = _class.instanceMethodId(
    r'removeTag',
    r'(Ljava/lang/String;)V',
  );

  static final _removeTag = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeTag(java.lang.String string)`
  void removeTag(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _removeTag(reference.pointer, _id_removeTag as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_setExtra = _class.instanceMethodId(
    r'setExtra',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setExtra = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setExtra(java.lang.String string, java.lang.String string1)`
  void setExtra(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setExtra(reference.pointer, _id_setExtra as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  static final _id_removeExtra = _class.instanceMethodId(
    r'removeExtra',
    r'(Ljava/lang/String;)V',
  );

  static final _removeExtra = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeExtra(java.lang.String string)`
  void removeExtra(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _removeExtra(reference.pointer, _id_removeExtra as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getLastEventId = _class.instanceMethodId(
    r'getLastEventId',
    r'()Lio/sentry/protocol/SentryId;',
  );

  static final _getLastEventId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.SentryId getLastEventId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getLastEventId() {
    return _getLastEventId(
            reference.pointer, _id_getLastEventId as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_pushScope = _class.instanceMethodId(
    r'pushScope',
    r'()Lio/sentry/ISentryLifecycleToken;',
  );

  static final _pushScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ISentryLifecycleToken pushScope()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject pushScope() {
    return _pushScope(reference.pointer, _id_pushScope as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_pushIsolationScope = _class.instanceMethodId(
    r'pushIsolationScope',
    r'()Lio/sentry/ISentryLifecycleToken;',
  );

  static final _pushIsolationScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ISentryLifecycleToken pushIsolationScope()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject pushIsolationScope() {
    return _pushIsolationScope(
            reference.pointer, _id_pushIsolationScope as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_popScope = _class.instanceMethodId(
    r'popScope',
    r'()V',
  );

  static final _popScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void popScope()`
  void popScope() {
    _popScope(reference.pointer, _id_popScope as jni$_.JMethodIDPtr).check();
  }

  static final _id_withScope = _class.instanceMethodId(
    r'withScope',
    r'(Lio/sentry/ScopeCallback;)V',
  );

  static final _withScope = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void withScope(io.sentry.ScopeCallback scopeCallback)`
  void withScope(
    jni$_.JObject scopeCallback,
  ) {
    final _$scopeCallback = scopeCallback.reference;
    _withScope(reference.pointer, _id_withScope as jni$_.JMethodIDPtr,
            _$scopeCallback.pointer)
        .check();
  }

  static final _id_withIsolationScope = _class.instanceMethodId(
    r'withIsolationScope',
    r'(Lio/sentry/ScopeCallback;)V',
  );

  static final _withIsolationScope = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void withIsolationScope(io.sentry.ScopeCallback scopeCallback)`
  void withIsolationScope(
    jni$_.JObject scopeCallback,
  ) {
    final _$scopeCallback = scopeCallback.reference;
    _withIsolationScope(
            reference.pointer,
            _id_withIsolationScope as jni$_.JMethodIDPtr,
            _$scopeCallback.pointer)
        .check();
  }

  static final _id_configureScope = _class.instanceMethodId(
    r'configureScope',
    r'(Lio/sentry/ScopeType;Lio/sentry/ScopeCallback;)V',
  );

  static final _configureScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void configureScope(io.sentry.ScopeType scopeType, io.sentry.ScopeCallback scopeCallback)`
  void configureScope(
    jni$_.JObject? scopeType,
    jni$_.JObject scopeCallback,
  ) {
    final _$scopeType = scopeType?.reference ?? jni$_.jNullReference;
    final _$scopeCallback = scopeCallback.reference;
    _configureScope(reference.pointer, _id_configureScope as jni$_.JMethodIDPtr,
            _$scopeType.pointer, _$scopeCallback.pointer)
        .check();
  }

  static final _id_bindClient = _class.instanceMethodId(
    r'bindClient',
    r'(Lio/sentry/ISentryClient;)V',
  );

  static final _bindClient = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void bindClient(io.sentry.ISentryClient iSentryClient)`
  void bindClient(
    jni$_.JObject iSentryClient,
  ) {
    final _$iSentryClient = iSentryClient.reference;
    _bindClient(reference.pointer, _id_bindClient as jni$_.JMethodIDPtr,
            _$iSentryClient.pointer)
        .check();
  }

  static final _id_isHealthy = _class.instanceMethodId(
    r'isHealthy',
    r'()Z',
  );

  static final _isHealthy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isHealthy()`
  bool isHealthy() {
    return _isHealthy(reference.pointer, _id_isHealthy as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_flush = _class.instanceMethodId(
    r'flush',
    r'(J)V',
  );

  static final _flush = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void flush(long j)`
  void flush(
    int j,
  ) {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr, j).check();
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Lio/sentry/IHub;',
  );

  static final _clone = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.IHub clone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject clone() {
    return _clone(reference.pointer, _id_clone as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_forkedScopes = _class.instanceMethodId(
    r'forkedScopes',
    r'(Ljava/lang/String;)Lio/sentry/IScopes;',
  );

  static final _forkedScopes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.IScopes forkedScopes(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject forkedScopes(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _forkedScopes(reference.pointer,
            _id_forkedScopes as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_forkedCurrentScope = _class.instanceMethodId(
    r'forkedCurrentScope',
    r'(Ljava/lang/String;)Lio/sentry/IScopes;',
  );

  static final _forkedCurrentScope = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.IScopes forkedCurrentScope(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject forkedCurrentScope(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _forkedCurrentScope(reference.pointer,
            _id_forkedCurrentScope as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_forkedRootScopes = _class.instanceMethodId(
    r'forkedRootScopes',
    r'(Ljava/lang/String;)Lio/sentry/IScopes;',
  );

  static final _forkedRootScopes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.IScopes forkedRootScopes(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject forkedRootScopes(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _forkedRootScopes(reference.pointer,
            _id_forkedRootScopes as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_makeCurrent = _class.instanceMethodId(
    r'makeCurrent',
    r'()Lio/sentry/ISentryLifecycleToken;',
  );

  static final _makeCurrent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ISentryLifecycleToken makeCurrent()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject makeCurrent() {
    return _makeCurrent(
            reference.pointer, _id_makeCurrent as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getScope = _class.instanceMethodId(
    r'getScope',
    r'()Lio/sentry/IScope;',
  );

  static final _getScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.IScope getScope()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getScope() {
    return _getScope(reference.pointer, _id_getScope as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getIsolationScope = _class.instanceMethodId(
    r'getIsolationScope',
    r'()Lio/sentry/IScope;',
  );

  static final _getIsolationScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.IScope getIsolationScope()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getIsolationScope() {
    return _getIsolationScope(
            reference.pointer, _id_getIsolationScope as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getGlobalScope = _class.instanceMethodId(
    r'getGlobalScope',
    r'()Lio/sentry/IScope;',
  );

  static final _getGlobalScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.IScope getGlobalScope()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getGlobalScope() {
    return _getGlobalScope(
            reference.pointer, _id_getGlobalScope as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getParentScopes = _class.instanceMethodId(
    r'getParentScopes',
    r'()Lio/sentry/IScopes;',
  );

  static final _getParentScopes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.IScopes getParentScopes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getParentScopes() {
    return _getParentScopes(
            reference.pointer, _id_getParentScopes as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_isAncestorOf = _class.instanceMethodId(
    r'isAncestorOf',
    r'(Lio/sentry/IScopes;)Z',
  );

  static final _isAncestorOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean isAncestorOf(io.sentry.IScopes iScopes)`
  bool isAncestorOf(
    jni$_.JObject? iScopes,
  ) {
    final _$iScopes = iScopes?.reference ?? jni$_.jNullReference;
    return _isAncestorOf(reference.pointer,
            _id_isAncestorOf as jni$_.JMethodIDPtr, _$iScopes.pointer)
        .boolean;
  }

  static final _id_captureTransaction = _class.instanceMethodId(
    r'captureTransaction',
    r'(Lio/sentry/protocol/SentryTransaction;Lio/sentry/TraceContext;Lio/sentry/Hint;Lio/sentry/ProfilingTraceData;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureTransaction = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureTransaction(io.sentry.protocol.SentryTransaction sentryTransaction, io.sentry.TraceContext traceContext, io.sentry.Hint hint, io.sentry.ProfilingTraceData profilingTraceData)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureTransaction(
    jni$_.JObject sentryTransaction,
    jni$_.JObject? traceContext,
    jni$_.JObject? hint,
    jni$_.JObject? profilingTraceData,
  ) {
    final _$sentryTransaction = sentryTransaction.reference;
    final _$traceContext = traceContext?.reference ?? jni$_.jNullReference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    final _$profilingTraceData =
        profilingTraceData?.reference ?? jni$_.jNullReference;
    return _captureTransaction(
            reference.pointer,
            _id_captureTransaction as jni$_.JMethodIDPtr,
            _$sentryTransaction.pointer,
            _$traceContext.pointer,
            _$hint.pointer,
            _$profilingTraceData.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureProfileChunk = _class.instanceMethodId(
    r'captureProfileChunk',
    r'(Lio/sentry/ProfileChunk;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureProfileChunk = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureProfileChunk(io.sentry.ProfileChunk profileChunk)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureProfileChunk(
    jni$_.JObject profileChunk,
  ) {
    final _$profileChunk = profileChunk.reference;
    return _captureProfileChunk(
            reference.pointer,
            _id_captureProfileChunk as jni$_.JMethodIDPtr,
            _$profileChunk.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_startTransaction = _class.instanceMethodId(
    r'startTransaction',
    r'(Lio/sentry/TransactionContext;Lio/sentry/TransactionOptions;)Lio/sentry/ITransaction;',
  );

  static final _startTransaction = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.ITransaction startTransaction(io.sentry.TransactionContext transactionContext, io.sentry.TransactionOptions transactionOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject startTransaction(
    jni$_.JObject transactionContext,
    jni$_.JObject transactionOptions,
  ) {
    final _$transactionContext = transactionContext.reference;
    final _$transactionOptions = transactionOptions.reference;
    return _startTransaction(
            reference.pointer,
            _id_startTransaction as jni$_.JMethodIDPtr,
            _$transactionContext.pointer,
            _$transactionOptions.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_startProfiler = _class.instanceMethodId(
    r'startProfiler',
    r'()V',
  );

  static final _startProfiler = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void startProfiler()`
  void startProfiler() {
    _startProfiler(reference.pointer, _id_startProfiler as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_stopProfiler = _class.instanceMethodId(
    r'stopProfiler',
    r'()V',
  );

  static final _stopProfiler = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void stopProfiler()`
  void stopProfiler() {
    _stopProfiler(reference.pointer, _id_stopProfiler as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_setSpanContext = _class.instanceMethodId(
    r'setSpanContext',
    r'(Ljava/lang/Throwable;Lio/sentry/ISpan;Ljava/lang/String;)V',
  );

  static final _setSpanContext = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setSpanContext(java.lang.Throwable throwable, io.sentry.ISpan iSpan, java.lang.String string)`
  void setSpanContext(
    jni$_.JObject throwable,
    jni$_.JObject iSpan,
    jni$_.JString string,
  ) {
    final _$throwable = throwable.reference;
    final _$iSpan = iSpan.reference;
    final _$string = string.reference;
    _setSpanContext(reference.pointer, _id_setSpanContext as jni$_.JMethodIDPtr,
            _$throwable.pointer, _$iSpan.pointer, _$string.pointer)
        .check();
  }

  static final _id_getSpan = _class.instanceMethodId(
    r'getSpan',
    r'()Lio/sentry/ISpan;',
  );

  static final _getSpan = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ISpan getSpan()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getSpan() {
    return _getSpan(reference.pointer, _id_getSpan as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setActiveSpan = _class.instanceMethodId(
    r'setActiveSpan',
    r'(Lio/sentry/ISpan;)V',
  );

  static final _setActiveSpan = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setActiveSpan(io.sentry.ISpan iSpan)`
  void setActiveSpan(
    jni$_.JObject? iSpan,
  ) {
    final _$iSpan = iSpan?.reference ?? jni$_.jNullReference;
    _setActiveSpan(reference.pointer, _id_setActiveSpan as jni$_.JMethodIDPtr,
            _$iSpan.pointer)
        .check();
  }

  static final _id_getTransaction = _class.instanceMethodId(
    r'getTransaction',
    r'()Lio/sentry/ITransaction;',
  );

  static final _getTransaction = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ITransaction getTransaction()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getTransaction() {
    return _getTransaction(
            reference.pointer, _id_getTransaction as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getOptions = _class.instanceMethodId(
    r'getOptions',
    r'()Lio/sentry/SentryOptions;',
  );

  static final _getOptions = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryOptions getOptions()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getOptions() {
    return _getOptions(reference.pointer, _id_getOptions as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_isCrashedLastRun = _class.instanceMethodId(
    r'isCrashedLastRun',
    r'()Ljava/lang/Boolean;',
  );

  static final _isCrashedLastRun = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Boolean isCrashedLastRun()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? isCrashedLastRun() {
    return _isCrashedLastRun(
            reference.pointer, _id_isCrashedLastRun as jni$_.JMethodIDPtr)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_reportFullyDisplayed = _class.instanceMethodId(
    r'reportFullyDisplayed',
    r'()V',
  );

  static final _reportFullyDisplayed = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void reportFullyDisplayed()`
  void reportFullyDisplayed() {
    _reportFullyDisplayed(
            reference.pointer, _id_reportFullyDisplayed as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_continueTrace = _class.instanceMethodId(
    r'continueTrace',
    r'(Ljava/lang/String;Ljava/util/List;)Lio/sentry/TransactionContext;',
  );

  static final _continueTrace = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.TransactionContext continueTrace(java.lang.String string, java.util.List<java.lang.String> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? continueTrace(
    jni$_.JString? string,
    jni$_.JList<jni$_.JString?>? list,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _continueTrace(
            reference.pointer,
            _id_continueTrace as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$list.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getTraceparent = _class.instanceMethodId(
    r'getTraceparent',
    r'()Lio/sentry/SentryTraceHeader;',
  );

  static final _getTraceparent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryTraceHeader getTraceparent()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getTraceparent() {
    return _getTraceparent(
            reference.pointer, _id_getTraceparent as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getBaggage = _class.instanceMethodId(
    r'getBaggage',
    r'()Lio/sentry/BaggageHeader;',
  );

  static final _getBaggage = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.BaggageHeader getBaggage()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getBaggage() {
    return _getBaggage(reference.pointer, _id_getBaggage as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_captureCheckIn = _class.instanceMethodId(
    r'captureCheckIn',
    r'(Lio/sentry/CheckIn;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureCheckIn = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureCheckIn(io.sentry.CheckIn checkIn)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureCheckIn(
    jni$_.JObject checkIn,
  ) {
    final _$checkIn = checkIn.reference;
    return _captureCheckIn(reference.pointer,
            _id_captureCheckIn as jni$_.JMethodIDPtr, _$checkIn.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getRateLimiter = _class.instanceMethodId(
    r'getRateLimiter',
    r'()Lio/sentry/transport/RateLimiter;',
  );

  static final _getRateLimiter = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.transport.RateLimiter getRateLimiter()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getRateLimiter() {
    return _getRateLimiter(
            reference.pointer, _id_getRateLimiter as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_captureReplay = _class.instanceMethodId(
    r'captureReplay',
    r'(Lio/sentry/SentryReplayEvent;Lio/sentry/Hint;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureReplay = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureReplay(io.sentry.SentryReplayEvent sentryReplayEvent, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureReplay(
    jni$_.JObject sentryReplayEvent,
    jni$_.JObject? hint,
  ) {
    final _$sentryReplayEvent = sentryReplayEvent.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    return _captureReplay(
            reference.pointer,
            _id_captureReplay as jni$_.JMethodIDPtr,
            _$sentryReplayEvent.pointer,
            _$hint.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_logger = _class.instanceMethodId(
    r'logger',
    r'()Lio/sentry/logger/ILoggerApi;',
  );

  static final _logger = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.logger.ILoggerApi logger()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject logger() {
    return _logger(reference.pointer, _id_logger as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }
}

final class $ScopesAdapter$NullableType extends jni$_.JObjType<ScopesAdapter?> {
  @jni$_.internal
  const $ScopesAdapter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/ScopesAdapter;';

  @jni$_.internal
  @core$_.override
  ScopesAdapter? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : ScopesAdapter.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ScopesAdapter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ScopesAdapter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ScopesAdapter$NullableType) &&
        other is $ScopesAdapter$NullableType;
  }
}

final class $ScopesAdapter$Type extends jni$_.JObjType<ScopesAdapter> {
  @jni$_.internal
  const $ScopesAdapter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/ScopesAdapter;';

  @jni$_.internal
  @core$_.override
  ScopesAdapter fromReference(jni$_.JReference reference) =>
      ScopesAdapter.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ScopesAdapter?> get nullableType =>
      const $ScopesAdapter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ScopesAdapter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ScopesAdapter$Type) &&
        other is $ScopesAdapter$Type;
  }
}

/// from: `android.graphics.Bitmap$CompressFormat`
class Bitmap$CompressFormat extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Bitmap$CompressFormat> $type;

  @jni$_.internal
  Bitmap$CompressFormat.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'android/graphics/Bitmap$CompressFormat');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Bitmap$CompressFormat$NullableType();
  static const type = $Bitmap$CompressFormat$Type();
  static final _id_JPEG = _class.staticFieldId(
    r'JPEG',
    r'Landroid/graphics/Bitmap$CompressFormat;',
  );

  /// from: `static public final android.graphics.Bitmap$CompressFormat JPEG`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat get JPEG =>
      _id_JPEG.get(_class, const $Bitmap$CompressFormat$Type());

  static final _id_PNG = _class.staticFieldId(
    r'PNG',
    r'Landroid/graphics/Bitmap$CompressFormat;',
  );

  /// from: `static public final android.graphics.Bitmap$CompressFormat PNG`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat get PNG =>
      _id_PNG.get(_class, const $Bitmap$CompressFormat$Type());

  static final _id_WEBP = _class.staticFieldId(
    r'WEBP',
    r'Landroid/graphics/Bitmap$CompressFormat;',
  );

  /// from: `static public final android.graphics.Bitmap$CompressFormat WEBP`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat get WEBP =>
      _id_WEBP.get(_class, const $Bitmap$CompressFormat$Type());

  static final _id_WEBP_LOSSY = _class.staticFieldId(
    r'WEBP_LOSSY',
    r'Landroid/graphics/Bitmap$CompressFormat;',
  );

  /// from: `static public final android.graphics.Bitmap$CompressFormat WEBP_LOSSY`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat get WEBP_LOSSY =>
      _id_WEBP_LOSSY.get(_class, const $Bitmap$CompressFormat$Type());

  static final _id_WEBP_LOSSLESS = _class.staticFieldId(
    r'WEBP_LOSSLESS',
    r'Landroid/graphics/Bitmap$CompressFormat;',
  );

  /// from: `static public final android.graphics.Bitmap$CompressFormat WEBP_LOSSLESS`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat get WEBP_LOSSLESS =>
      _id_WEBP_LOSSLESS.get(_class, const $Bitmap$CompressFormat$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Landroid/graphics/Bitmap$CompressFormat;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public android.graphics.Bitmap$CompressFormat[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Bitmap$CompressFormat?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<Bitmap$CompressFormat?>?>(
            const jni$_.JArrayNullableType<Bitmap$CompressFormat?>(
                $Bitmap$CompressFormat$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Landroid/graphics/Bitmap$CompressFormat;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap$CompressFormat valueOf(java.lang.String synthetic)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat? valueOf(
    jni$_.JString? synthetic,
  ) {
    final _$synthetic = synthetic?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$synthetic.pointer)
        .object<Bitmap$CompressFormat?>(
            const $Bitmap$CompressFormat$NullableType());
  }
}

final class $Bitmap$CompressFormat$NullableType
    extends jni$_.JObjType<Bitmap$CompressFormat?> {
  @jni$_.internal
  const $Bitmap$CompressFormat$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap$CompressFormat;';

  @jni$_.internal
  @core$_.override
  Bitmap$CompressFormat? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Bitmap$CompressFormat.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Bitmap$CompressFormat?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$CompressFormat$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$CompressFormat$NullableType) &&
        other is $Bitmap$CompressFormat$NullableType;
  }
}

final class $Bitmap$CompressFormat$Type
    extends jni$_.JObjType<Bitmap$CompressFormat> {
  @jni$_.internal
  const $Bitmap$CompressFormat$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap$CompressFormat;';

  @jni$_.internal
  @core$_.override
  Bitmap$CompressFormat fromReference(jni$_.JReference reference) =>
      Bitmap$CompressFormat.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Bitmap$CompressFormat?> get nullableType =>
      const $Bitmap$CompressFormat$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$CompressFormat$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$CompressFormat$Type) &&
        other is $Bitmap$CompressFormat$Type;
  }
}

/// from: `android.graphics.Bitmap$Config`
class Bitmap$Config extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Bitmap$Config> $type;

  @jni$_.internal
  Bitmap$Config.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/graphics/Bitmap$Config');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Bitmap$Config$NullableType();
  static const type = $Bitmap$Config$Type();
  static final _id_ALPHA_8 = _class.staticFieldId(
    r'ALPHA_8',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config ALPHA_8`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get ALPHA_8 =>
      _id_ALPHA_8.get(_class, const $Bitmap$Config$Type());

  static final _id_RGB_565 = _class.staticFieldId(
    r'RGB_565',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config RGB_565`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get RGB_565 =>
      _id_RGB_565.get(_class, const $Bitmap$Config$Type());

  static final _id_ARGB_4444 = _class.staticFieldId(
    r'ARGB_4444',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config ARGB_4444`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get ARGB_4444 =>
      _id_ARGB_4444.get(_class, const $Bitmap$Config$Type());

  static final _id_ARGB_8888 = _class.staticFieldId(
    r'ARGB_8888',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config ARGB_8888`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get ARGB_8888 =>
      _id_ARGB_8888.get(_class, const $Bitmap$Config$Type());

  static final _id_RGBA_F16 = _class.staticFieldId(
    r'RGBA_F16',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config RGBA_F16`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get RGBA_F16 =>
      _id_RGBA_F16.get(_class, const $Bitmap$Config$Type());

  static final _id_HARDWARE = _class.staticFieldId(
    r'HARDWARE',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config HARDWARE`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get HARDWARE =>
      _id_HARDWARE.get(_class, const $Bitmap$Config$Type());

  static final _id_RGBA_1010102 = _class.staticFieldId(
    r'RGBA_1010102',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config RGBA_1010102`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get RGBA_1010102 =>
      _id_RGBA_1010102.get(_class, const $Bitmap$Config$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Landroid/graphics/Bitmap$Config;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public android.graphics.Bitmap$Config[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Bitmap$Config?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<Bitmap$Config?>?>(
            const jni$_.JArrayNullableType<Bitmap$Config?>(
                $Bitmap$Config$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Landroid/graphics/Bitmap$Config;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap$Config valueOf(java.lang.String synthetic)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config? valueOf(
    jni$_.JString? synthetic,
  ) {
    final _$synthetic = synthetic?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$synthetic.pointer)
        .object<Bitmap$Config?>(const $Bitmap$Config$NullableType());
  }
}

final class $Bitmap$Config$NullableType extends jni$_.JObjType<Bitmap$Config?> {
  @jni$_.internal
  const $Bitmap$Config$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap$Config;';

  @jni$_.internal
  @core$_.override
  Bitmap$Config? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Bitmap$Config.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Bitmap$Config?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$Config$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$Config$NullableType) &&
        other is $Bitmap$Config$NullableType;
  }
}

final class $Bitmap$Config$Type extends jni$_.JObjType<Bitmap$Config> {
  @jni$_.internal
  const $Bitmap$Config$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap$Config;';

  @jni$_.internal
  @core$_.override
  Bitmap$Config fromReference(jni$_.JReference reference) =>
      Bitmap$Config.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Bitmap$Config?> get nullableType =>
      const $Bitmap$Config$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$Config$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$Config$Type) &&
        other is $Bitmap$Config$Type;
  }
}

/// from: `android.graphics.Bitmap`
class Bitmap extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Bitmap> $type;

  @jni$_.internal
  Bitmap.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/graphics/Bitmap');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Bitmap$NullableType();
  static const type = $Bitmap$Type();
  static final _id_CREATOR = _class.staticFieldId(
    r'CREATOR',
    r'Landroid/os/Parcelable$Creator;',
  );

  /// from: `static public final android.os.Parcelable$Creator<android.graphics.Bitmap> CREATOR`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? get CREATOR =>
      _id_CREATOR.get(_class, const jni$_.JObjectNullableType());

  /// from: `static public final int DENSITY_NONE`
  static const DENSITY_NONE = 0;
  static final _id_getDensity = _class.instanceMethodId(
    r'getDensity',
    r'()I',
  );

  static final _getDensity = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getDensity()`
  int getDensity() {
    return _getDensity(reference.pointer, _id_getDensity as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_setDensity = _class.instanceMethodId(
    r'setDensity',
    r'(I)V',
  );

  static final _setDensity = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setDensity(int i)`
  void setDensity(
    int i,
  ) {
    _setDensity(reference.pointer, _id_setDensity as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_reconfigure = _class.instanceMethodId(
    r'reconfigure',
    r'(IILandroid/graphics/Bitmap$Config;)V',
  );

  static final _reconfigure = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void reconfigure(int i, int i1, android.graphics.Bitmap$Config config)`
  void reconfigure(
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    _reconfigure(reference.pointer, _id_reconfigure as jni$_.JMethodIDPtr, i,
            i1, _$config.pointer)
        .check();
  }

  static final _id_setWidth = _class.instanceMethodId(
    r'setWidth',
    r'(I)V',
  );

  static final _setWidth = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setWidth(int i)`
  void setWidth(
    int i,
  ) {
    _setWidth(reference.pointer, _id_setWidth as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_setHeight = _class.instanceMethodId(
    r'setHeight',
    r'(I)V',
  );

  static final _setHeight = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setHeight(int i)`
  void setHeight(
    int i,
  ) {
    _setHeight(reference.pointer, _id_setHeight as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_setConfig = _class.instanceMethodId(
    r'setConfig',
    r'(Landroid/graphics/Bitmap$Config;)V',
  );

  static final _setConfig = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setConfig(android.graphics.Bitmap$Config config)`
  void setConfig(
    Bitmap$Config? config,
  ) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    _setConfig(reference.pointer, _id_setConfig as jni$_.JMethodIDPtr,
            _$config.pointer)
        .check();
  }

  static final _id_recycle = _class.instanceMethodId(
    r'recycle',
    r'()V',
  );

  static final _recycle = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void recycle()`
  void recycle() {
    _recycle(reference.pointer, _id_recycle as jni$_.JMethodIDPtr).check();
  }

  static final _id_isRecycled = _class.instanceMethodId(
    r'isRecycled',
    r'()Z',
  );

  static final _isRecycled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isRecycled()`
  bool isRecycled() {
    return _isRecycled(reference.pointer, _id_isRecycled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getGenerationId = _class.instanceMethodId(
    r'getGenerationId',
    r'()I',
  );

  static final _getGenerationId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getGenerationId()`
  int getGenerationId() {
    return _getGenerationId(
            reference.pointer, _id_getGenerationId as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_copyPixelsToBuffer = _class.instanceMethodId(
    r'copyPixelsToBuffer',
    r'(Ljava/nio/Buffer;)V',
  );

  static final _copyPixelsToBuffer = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void copyPixelsToBuffer(java.nio.Buffer buffer)`
  void copyPixelsToBuffer(
    jni$_.JBuffer? buffer,
  ) {
    final _$buffer = buffer?.reference ?? jni$_.jNullReference;
    _copyPixelsToBuffer(reference.pointer,
            _id_copyPixelsToBuffer as jni$_.JMethodIDPtr, _$buffer.pointer)
        .check();
  }

  static final _id_copyPixelsFromBuffer = _class.instanceMethodId(
    r'copyPixelsFromBuffer',
    r'(Ljava/nio/Buffer;)V',
  );

  static final _copyPixelsFromBuffer = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void copyPixelsFromBuffer(java.nio.Buffer buffer)`
  void copyPixelsFromBuffer(
    jni$_.JBuffer? buffer,
  ) {
    final _$buffer = buffer?.reference ?? jni$_.jNullReference;
    _copyPixelsFromBuffer(reference.pointer,
            _id_copyPixelsFromBuffer as jni$_.JMethodIDPtr, _$buffer.pointer)
        .check();
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(Landroid/graphics/Bitmap$Config;Z)Landroid/graphics/Bitmap;',
  );

  static final _copy = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public android.graphics.Bitmap copy(android.graphics.Bitmap$Config config, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap? copy(
    Bitmap$Config? config,
    bool z,
  ) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _copy(reference.pointer, _id_copy as jni$_.JMethodIDPtr,
            _$config.pointer, z ? 1 : 0)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_asShared = _class.instanceMethodId(
    r'asShared',
    r'()Landroid/graphics/Bitmap;',
  );

  static final _asShared = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public android.graphics.Bitmap asShared()`
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap? asShared() {
    return _asShared(reference.pointer, _id_asShared as jni$_.JMethodIDPtr)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_wrapHardwareBuffer = _class.staticMethodId(
    r'wrapHardwareBuffer',
    r'(Landroid/hardware/HardwareBuffer;Landroid/graphics/ColorSpace;)Landroid/graphics/Bitmap;',
  );

  static final _wrapHardwareBuffer = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap wrapHardwareBuffer(android.hardware.HardwareBuffer hardwareBuffer, android.graphics.ColorSpace colorSpace)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? wrapHardwareBuffer(
    jni$_.JObject? hardwareBuffer,
    jni$_.JObject? colorSpace,
  ) {
    final _$hardwareBuffer = hardwareBuffer?.reference ?? jni$_.jNullReference;
    final _$colorSpace = colorSpace?.reference ?? jni$_.jNullReference;
    return _wrapHardwareBuffer(
            _class.reference.pointer,
            _id_wrapHardwareBuffer as jni$_.JMethodIDPtr,
            _$hardwareBuffer.pointer,
            _$colorSpace.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createScaledBitmap = _class.staticMethodId(
    r'createScaledBitmap',
    r'(Landroid/graphics/Bitmap;IIZ)Landroid/graphics/Bitmap;',
  );

  static final _createScaledBitmap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int, int, int)>();

  /// from: `static public android.graphics.Bitmap createScaledBitmap(android.graphics.Bitmap bitmap, int i, int i1, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createScaledBitmap(
    Bitmap? bitmap,
    int i,
    int i1,
    bool z,
  ) {
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    return _createScaledBitmap(
            _class.reference.pointer,
            _id_createScaledBitmap as jni$_.JMethodIDPtr,
            _$bitmap.pointer,
            i,
            i1,
            z ? 1 : 0)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/graphics/Bitmap;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.graphics.Bitmap bitmap)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap(
    Bitmap? bitmap,
  ) {
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    return _createBitmap(_class.reference.pointer,
            _id_createBitmap as jni$_.JMethodIDPtr, _$bitmap.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$1 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/graphics/Bitmap;IIII)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.graphics.Bitmap bitmap, int i, int i1, int i2, int i3)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$1(
    Bitmap? bitmap,
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    return _createBitmap$1(
            _class.reference.pointer,
            _id_createBitmap$1 as jni$_.JMethodIDPtr,
            _$bitmap.pointer,
            i,
            i1,
            i2,
            i3)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$2 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/graphics/Bitmap;IIIILandroid/graphics/Matrix;Z)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.graphics.Bitmap bitmap, int i, int i1, int i2, int i3, android.graphics.Matrix matrix, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$2(
    Bitmap? bitmap,
    int i,
    int i1,
    int i2,
    int i3,
    jni$_.JObject? matrix,
    bool z,
  ) {
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    final _$matrix = matrix?.reference ?? jni$_.jNullReference;
    return _createBitmap$2(
            _class.reference.pointer,
            _id_createBitmap$2 as jni$_.JMethodIDPtr,
            _$bitmap.pointer,
            i,
            i1,
            i2,
            i3,
            _$matrix.pointer,
            z ? 1 : 0)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$3 = _class.staticMethodId(
    r'createBitmap',
    r'(IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(int i, int i1, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$3(
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$3(_class.reference.pointer,
            _id_createBitmap$3 as jni$_.JMethodIDPtr, i, i1, _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$4 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/util/DisplayMetrics;IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int i, int i1, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$4(
    jni$_.JObject? displayMetrics,
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$4(
            _class.reference.pointer,
            _id_createBitmap$4 as jni$_.JMethodIDPtr,
            _$displayMetrics.pointer,
            i,
            i1,
            _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$5 = _class.staticMethodId(
    r'createBitmap',
    r'(IILandroid/graphics/Bitmap$Config;Z)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$5 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `static public android.graphics.Bitmap createBitmap(int i, int i1, android.graphics.Bitmap$Config config, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$5(
    int i,
    int i1,
    Bitmap$Config? config,
    bool z,
  ) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$5(
            _class.reference.pointer,
            _id_createBitmap$5 as jni$_.JMethodIDPtr,
            i,
            i1,
            _$config.pointer,
            z ? 1 : 0)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$6 = _class.staticMethodId(
    r'createBitmap',
    r'(IILandroid/graphics/Bitmap$Config;ZLandroid/graphics/ColorSpace;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$6 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(int i, int i1, android.graphics.Bitmap$Config config, boolean z, android.graphics.ColorSpace colorSpace)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$6(
    int i,
    int i1,
    Bitmap$Config? config,
    bool z,
    jni$_.JObject? colorSpace,
  ) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    final _$colorSpace = colorSpace?.reference ?? jni$_.jNullReference;
    return _createBitmap$6(
            _class.reference.pointer,
            _id_createBitmap$6 as jni$_.JMethodIDPtr,
            i,
            i1,
            _$config.pointer,
            z ? 1 : 0,
            _$colorSpace.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$7 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/util/DisplayMetrics;IILandroid/graphics/Bitmap$Config;Z)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$7 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int i, int i1, android.graphics.Bitmap$Config config, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$7(
    jni$_.JObject? displayMetrics,
    int i,
    int i1,
    Bitmap$Config? config,
    bool z,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$7(
            _class.reference.pointer,
            _id_createBitmap$7 as jni$_.JMethodIDPtr,
            _$displayMetrics.pointer,
            i,
            i1,
            _$config.pointer,
            z ? 1 : 0)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$8 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/util/DisplayMetrics;IILandroid/graphics/Bitmap$Config;ZLandroid/graphics/ColorSpace;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$8 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int i, int i1, android.graphics.Bitmap$Config config, boolean z, android.graphics.ColorSpace colorSpace)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$8(
    jni$_.JObject? displayMetrics,
    int i,
    int i1,
    Bitmap$Config? config,
    bool z,
    jni$_.JObject? colorSpace,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    final _$colorSpace = colorSpace?.reference ?? jni$_.jNullReference;
    return _createBitmap$8(
            _class.reference.pointer,
            _id_createBitmap$8 as jni$_.JMethodIDPtr,
            _$displayMetrics.pointer,
            i,
            i1,
            _$config.pointer,
            z ? 1 : 0,
            _$colorSpace.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$9 = _class.staticMethodId(
    r'createBitmap',
    r'([IIIIILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$9 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(int[] is, int i, int i1, int i2, int i3, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$9(
    jni$_.JIntArray? is$,
    int i,
    int i1,
    int i2,
    int i3,
    Bitmap$Config? config,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$9(
            _class.reference.pointer,
            _id_createBitmap$9 as jni$_.JMethodIDPtr,
            _$is$.pointer,
            i,
            i1,
            i2,
            i3,
            _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$10 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/util/DisplayMetrics;[IIIIILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$10 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int[] is, int i, int i1, int i2, int i3, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$10(
    jni$_.JObject? displayMetrics,
    jni$_.JIntArray? is$,
    int i,
    int i1,
    int i2,
    int i3,
    Bitmap$Config? config,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$10(
            _class.reference.pointer,
            _id_createBitmap$10 as jni$_.JMethodIDPtr,
            _$displayMetrics.pointer,
            _$is$.pointer,
            i,
            i1,
            i2,
            i3,
            _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$11 = _class.staticMethodId(
    r'createBitmap',
    r'([IIILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$11 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(int[] is, int i, int i1, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$11(
    jni$_.JIntArray? is$,
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$11(
            _class.reference.pointer,
            _id_createBitmap$11 as jni$_.JMethodIDPtr,
            _$is$.pointer,
            i,
            i1,
            _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$12 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/util/DisplayMetrics;[IIILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$12 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int[] is, int i, int i1, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$12(
    jni$_.JObject? displayMetrics,
    jni$_.JIntArray? is$,
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$12(
            _class.reference.pointer,
            _id_createBitmap$12 as jni$_.JMethodIDPtr,
            _$displayMetrics.pointer,
            _$is$.pointer,
            i,
            i1,
            _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$13 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/graphics/Picture;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$13 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.graphics.Picture picture)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$13(
    jni$_.JObject? picture,
  ) {
    final _$picture = picture?.reference ?? jni$_.jNullReference;
    return _createBitmap$13(_class.reference.pointer,
            _id_createBitmap$13 as jni$_.JMethodIDPtr, _$picture.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$14 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/graphics/Picture;IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$14 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.graphics.Picture picture, int i, int i1, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$14(
    jni$_.JObject? picture,
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$picture = picture?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$14(
            _class.reference.pointer,
            _id_createBitmap$14 as jni$_.JMethodIDPtr,
            _$picture.pointer,
            i,
            i1,
            _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_getNinePatchChunk = _class.instanceMethodId(
    r'getNinePatchChunk',
    r'()[B',
  );

  static final _getNinePatchChunk = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public byte[] getNinePatchChunk()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? getNinePatchChunk() {
    return _getNinePatchChunk(
            reference.pointer, _id_getNinePatchChunk as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_compress = _class.instanceMethodId(
    r'compress',
    r'(Landroid/graphics/Bitmap$CompressFormat;ILjava/io/OutputStream;)Z',
  );

  static final _compress = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean compress(android.graphics.Bitmap$CompressFormat compressFormat, int i, java.io.OutputStream outputStream)`
  bool compress(
    Bitmap$CompressFormat? compressFormat,
    int i,
    jni$_.JObject? outputStream,
  ) {
    final _$compressFormat = compressFormat?.reference ?? jni$_.jNullReference;
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return _compress(reference.pointer, _id_compress as jni$_.JMethodIDPtr,
            _$compressFormat.pointer, i, _$outputStream.pointer)
        .boolean;
  }

  static final _id_isMutable = _class.instanceMethodId(
    r'isMutable',
    r'()Z',
  );

  static final _isMutable = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isMutable()`
  bool isMutable() {
    return _isMutable(reference.pointer, _id_isMutable as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_isPremultiplied = _class.instanceMethodId(
    r'isPremultiplied',
    r'()Z',
  );

  static final _isPremultiplied = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isPremultiplied()`
  bool isPremultiplied() {
    return _isPremultiplied(
            reference.pointer, _id_isPremultiplied as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setPremultiplied = _class.instanceMethodId(
    r'setPremultiplied',
    r'(Z)V',
  );

  static final _setPremultiplied = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setPremultiplied(boolean z)`
  void setPremultiplied(
    bool z,
  ) {
    _setPremultiplied(reference.pointer,
            _id_setPremultiplied as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getWidth = _class.instanceMethodId(
    r'getWidth',
    r'()I',
  );

  static final _getWidth = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getWidth()`
  int getWidth() {
    return _getWidth(reference.pointer, _id_getWidth as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getHeight = _class.instanceMethodId(
    r'getHeight',
    r'()I',
  );

  static final _getHeight = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getHeight()`
  int getHeight() {
    return _getHeight(reference.pointer, _id_getHeight as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getScaledWidth = _class.instanceMethodId(
    r'getScaledWidth',
    r'(Landroid/graphics/Canvas;)I',
  );

  static final _getScaledWidth = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int getScaledWidth(android.graphics.Canvas canvas)`
  int getScaledWidth(
    jni$_.JObject? canvas,
  ) {
    final _$canvas = canvas?.reference ?? jni$_.jNullReference;
    return _getScaledWidth(reference.pointer,
            _id_getScaledWidth as jni$_.JMethodIDPtr, _$canvas.pointer)
        .integer;
  }

  static final _id_getScaledHeight = _class.instanceMethodId(
    r'getScaledHeight',
    r'(Landroid/graphics/Canvas;)I',
  );

  static final _getScaledHeight = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int getScaledHeight(android.graphics.Canvas canvas)`
  int getScaledHeight(
    jni$_.JObject? canvas,
  ) {
    final _$canvas = canvas?.reference ?? jni$_.jNullReference;
    return _getScaledHeight(reference.pointer,
            _id_getScaledHeight as jni$_.JMethodIDPtr, _$canvas.pointer)
        .integer;
  }

  static final _id_getScaledWidth$1 = _class.instanceMethodId(
    r'getScaledWidth',
    r'(Landroid/util/DisplayMetrics;)I',
  );

  static final _getScaledWidth$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int getScaledWidth(android.util.DisplayMetrics displayMetrics)`
  int getScaledWidth$1(
    jni$_.JObject? displayMetrics,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    return _getScaledWidth$1(
            reference.pointer,
            _id_getScaledWidth$1 as jni$_.JMethodIDPtr,
            _$displayMetrics.pointer)
        .integer;
  }

  static final _id_getScaledHeight$1 = _class.instanceMethodId(
    r'getScaledHeight',
    r'(Landroid/util/DisplayMetrics;)I',
  );

  static final _getScaledHeight$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int getScaledHeight(android.util.DisplayMetrics displayMetrics)`
  int getScaledHeight$1(
    jni$_.JObject? displayMetrics,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    return _getScaledHeight$1(
            reference.pointer,
            _id_getScaledHeight$1 as jni$_.JMethodIDPtr,
            _$displayMetrics.pointer)
        .integer;
  }

  static final _id_getScaledWidth$2 = _class.instanceMethodId(
    r'getScaledWidth',
    r'(I)I',
  );

  static final _getScaledWidth$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public int getScaledWidth(int i)`
  int getScaledWidth$2(
    int i,
  ) {
    return _getScaledWidth$2(
            reference.pointer, _id_getScaledWidth$2 as jni$_.JMethodIDPtr, i)
        .integer;
  }

  static final _id_getScaledHeight$2 = _class.instanceMethodId(
    r'getScaledHeight',
    r'(I)I',
  );

  static final _getScaledHeight$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public int getScaledHeight(int i)`
  int getScaledHeight$2(
    int i,
  ) {
    return _getScaledHeight$2(
            reference.pointer, _id_getScaledHeight$2 as jni$_.JMethodIDPtr, i)
        .integer;
  }

  static final _id_getRowBytes = _class.instanceMethodId(
    r'getRowBytes',
    r'()I',
  );

  static final _getRowBytes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getRowBytes()`
  int getRowBytes() {
    return _getRowBytes(
            reference.pointer, _id_getRowBytes as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getByteCount = _class.instanceMethodId(
    r'getByteCount',
    r'()I',
  );

  static final _getByteCount = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getByteCount()`
  int getByteCount() {
    return _getByteCount(
            reference.pointer, _id_getByteCount as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getAllocationByteCount = _class.instanceMethodId(
    r'getAllocationByteCount',
    r'()I',
  );

  static final _getAllocationByteCount = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getAllocationByteCount()`
  int getAllocationByteCount() {
    return _getAllocationByteCount(
            reference.pointer, _id_getAllocationByteCount as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getConfig = _class.instanceMethodId(
    r'getConfig',
    r'()Landroid/graphics/Bitmap$Config;',
  );

  static final _getConfig = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public android.graphics.Bitmap$Config getConfig()`
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap$Config? getConfig() {
    return _getConfig(reference.pointer, _id_getConfig as jni$_.JMethodIDPtr)
        .object<Bitmap$Config?>(const $Bitmap$Config$NullableType());
  }

  static final _id_hasAlpha = _class.instanceMethodId(
    r'hasAlpha',
    r'()Z',
  );

  static final _hasAlpha = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean hasAlpha()`
  bool hasAlpha() {
    return _hasAlpha(reference.pointer, _id_hasAlpha as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setHasAlpha = _class.instanceMethodId(
    r'setHasAlpha',
    r'(Z)V',
  );

  static final _setHasAlpha = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setHasAlpha(boolean z)`
  void setHasAlpha(
    bool z,
  ) {
    _setHasAlpha(
            reference.pointer, _id_setHasAlpha as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_hasMipMap = _class.instanceMethodId(
    r'hasMipMap',
    r'()Z',
  );

  static final _hasMipMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean hasMipMap()`
  bool hasMipMap() {
    return _hasMipMap(reference.pointer, _id_hasMipMap as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setHasMipMap = _class.instanceMethodId(
    r'setHasMipMap',
    r'(Z)V',
  );

  static final _setHasMipMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setHasMipMap(boolean z)`
  void setHasMipMap(
    bool z,
  ) {
    _setHasMipMap(reference.pointer, _id_setHasMipMap as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_getColorSpace = _class.instanceMethodId(
    r'getColorSpace',
    r'()Landroid/graphics/ColorSpace;',
  );

  static final _getColorSpace = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public android.graphics.ColorSpace getColorSpace()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getColorSpace() {
    return _getColorSpace(
            reference.pointer, _id_getColorSpace as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setColorSpace = _class.instanceMethodId(
    r'setColorSpace',
    r'(Landroid/graphics/ColorSpace;)V',
  );

  static final _setColorSpace = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setColorSpace(android.graphics.ColorSpace colorSpace)`
  void setColorSpace(
    jni$_.JObject? colorSpace,
  ) {
    final _$colorSpace = colorSpace?.reference ?? jni$_.jNullReference;
    _setColorSpace(reference.pointer, _id_setColorSpace as jni$_.JMethodIDPtr,
            _$colorSpace.pointer)
        .check();
  }

  static final _id_hasGainmap = _class.instanceMethodId(
    r'hasGainmap',
    r'()Z',
  );

  static final _hasGainmap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean hasGainmap()`
  bool hasGainmap() {
    return _hasGainmap(reference.pointer, _id_hasGainmap as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getGainmap = _class.instanceMethodId(
    r'getGainmap',
    r'()Landroid/graphics/Gainmap;',
  );

  static final _getGainmap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public android.graphics.Gainmap getGainmap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getGainmap() {
    return _getGainmap(reference.pointer, _id_getGainmap as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setGainmap = _class.instanceMethodId(
    r'setGainmap',
    r'(Landroid/graphics/Gainmap;)V',
  );

  static final _setGainmap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setGainmap(android.graphics.Gainmap gainmap)`
  void setGainmap(
    jni$_.JObject? gainmap,
  ) {
    final _$gainmap = gainmap?.reference ?? jni$_.jNullReference;
    _setGainmap(reference.pointer, _id_setGainmap as jni$_.JMethodIDPtr,
            _$gainmap.pointer)
        .check();
  }

  static final _id_eraseColor = _class.instanceMethodId(
    r'eraseColor',
    r'(I)V',
  );

  static final _eraseColor = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void eraseColor(int i)`
  void eraseColor(
    int i,
  ) {
    _eraseColor(reference.pointer, _id_eraseColor as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_eraseColor$1 = _class.instanceMethodId(
    r'eraseColor',
    r'(J)V',
  );

  static final _eraseColor$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void eraseColor(long j)`
  void eraseColor$1(
    int j,
  ) {
    _eraseColor$1(reference.pointer, _id_eraseColor$1 as jni$_.JMethodIDPtr, j)
        .check();
  }

  static final _id_getPixel = _class.instanceMethodId(
    r'getPixel',
    r'(II)I',
  );

  static final _getPixel = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int)>();

  /// from: `public int getPixel(int i, int i1)`
  int getPixel(
    int i,
    int i1,
  ) {
    return _getPixel(
            reference.pointer, _id_getPixel as jni$_.JMethodIDPtr, i, i1)
        .integer;
  }

  static final _id_getColor = _class.instanceMethodId(
    r'getColor',
    r'(II)Landroid/graphics/Color;',
  );

  static final _getColor = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int)>();

  /// from: `public android.graphics.Color getColor(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getColor(
    int i,
    int i1,
  ) {
    return _getColor(
            reference.pointer, _id_getColor as jni$_.JMethodIDPtr, i, i1)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getPixels = _class.instanceMethodId(
    r'getPixels',
    r'([IIIIIII)V',
  );

  static final _getPixels = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              int,
              int)>();

  /// from: `public void getPixels(int[] is, int i, int i1, int i2, int i3, int i4, int i5)`
  void getPixels(
    jni$_.JIntArray? is$,
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    _getPixels(reference.pointer, _id_getPixels as jni$_.JMethodIDPtr,
            _$is$.pointer, i, i1, i2, i3, i4, i5)
        .check();
  }

  static final _id_setPixel = _class.instanceMethodId(
    r'setPixel',
    r'(III)V',
  );

  static final _setPixel = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int, int)>();

  /// from: `public void setPixel(int i, int i1, int i2)`
  void setPixel(
    int i,
    int i1,
    int i2,
  ) {
    _setPixel(reference.pointer, _id_setPixel as jni$_.JMethodIDPtr, i, i1, i2)
        .check();
  }

  static final _id_setPixels = _class.instanceMethodId(
    r'setPixels',
    r'([IIIIIII)V',
  );

  static final _setPixels = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              int,
              int)>();

  /// from: `public void setPixels(int[] is, int i, int i1, int i2, int i3, int i4, int i5)`
  void setPixels(
    jni$_.JIntArray? is$,
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    _setPixels(reference.pointer, _id_setPixels as jni$_.JMethodIDPtr,
            _$is$.pointer, i, i1, i2, i3, i4, i5)
        .check();
  }

  static final _id_describeContents = _class.instanceMethodId(
    r'describeContents',
    r'()I',
  );

  static final _describeContents = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int describeContents()`
  int describeContents() {
    return _describeContents(
            reference.pointer, _id_describeContents as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_writeToParcel = _class.instanceMethodId(
    r'writeToParcel',
    r'(Landroid/os/Parcel;I)V',
  );

  static final _writeToParcel = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public void writeToParcel(android.os.Parcel parcel, int i)`
  void writeToParcel(
    jni$_.JObject? parcel,
    int i,
  ) {
    final _$parcel = parcel?.reference ?? jni$_.jNullReference;
    _writeToParcel(reference.pointer, _id_writeToParcel as jni$_.JMethodIDPtr,
            _$parcel.pointer, i)
        .check();
  }

  static final _id_extractAlpha = _class.instanceMethodId(
    r'extractAlpha',
    r'()Landroid/graphics/Bitmap;',
  );

  static final _extractAlpha = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public android.graphics.Bitmap extractAlpha()`
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap? extractAlpha() {
    return _extractAlpha(
            reference.pointer, _id_extractAlpha as jni$_.JMethodIDPtr)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_extractAlpha$1 = _class.instanceMethodId(
    r'extractAlpha',
    r'(Landroid/graphics/Paint;[I)Landroid/graphics/Bitmap;',
  );

  static final _extractAlpha$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public android.graphics.Bitmap extractAlpha(android.graphics.Paint paint, int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap? extractAlpha$1(
    jni$_.JObject? paint,
    jni$_.JIntArray? is$,
  ) {
    final _$paint = paint?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _extractAlpha$1(
            reference.pointer,
            _id_extractAlpha$1 as jni$_.JMethodIDPtr,
            _$paint.pointer,
            _$is$.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_sameAs = _class.instanceMethodId(
    r'sameAs',
    r'(Landroid/graphics/Bitmap;)Z',
  );

  static final _sameAs = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean sameAs(android.graphics.Bitmap bitmap)`
  bool sameAs(
    Bitmap? bitmap,
  ) {
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    return _sameAs(reference.pointer, _id_sameAs as jni$_.JMethodIDPtr,
            _$bitmap.pointer)
        .boolean;
  }

  static final _id_prepareToDraw = _class.instanceMethodId(
    r'prepareToDraw',
    r'()V',
  );

  static final _prepareToDraw = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void prepareToDraw()`
  void prepareToDraw() {
    _prepareToDraw(reference.pointer, _id_prepareToDraw as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_getHardwareBuffer = _class.instanceMethodId(
    r'getHardwareBuffer',
    r'()Landroid/hardware/HardwareBuffer;',
  );

  static final _getHardwareBuffer = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public android.hardware.HardwareBuffer getHardwareBuffer()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getHardwareBuffer() {
    return _getHardwareBuffer(
            reference.pointer, _id_getHardwareBuffer as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $Bitmap$NullableType extends jni$_.JObjType<Bitmap?> {
  @jni$_.internal
  const $Bitmap$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap;';

  @jni$_.internal
  @core$_.override
  Bitmap? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Bitmap.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Bitmap?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$NullableType) &&
        other is $Bitmap$NullableType;
  }
}

final class $Bitmap$Type extends jni$_.JObjType<Bitmap> {
  @jni$_.internal
  const $Bitmap$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap;';

  @jni$_.internal
  @core$_.override
  Bitmap fromReference(jni$_.JReference reference) => Bitmap.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Bitmap?> get nullableType => const $Bitmap$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$Type) && other is $Bitmap$Type;
  }
}
