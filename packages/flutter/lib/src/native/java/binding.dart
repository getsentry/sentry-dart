// AUTO GENERATED BY JNIGEN 0.14.2. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `io.sentry.android.core.SentryAndroidOptions$BeforeCaptureCallback`
class SentryAndroidOptions$BeforeCaptureCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryAndroidOptions$BeforeCaptureCallback> $type;

  @jni$_.internal
  SentryAndroidOptions$BeforeCaptureCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'io/sentry/android/core/SentryAndroidOptions$BeforeCaptureCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $SentryAndroidOptions$BeforeCaptureCallback$NullableType();
  static const type = $SentryAndroidOptions$BeforeCaptureCallback$Type();
  static final _id_execute = _class.instanceMethodId(
    r'execute',
    r'(Lio/sentry/SentryEvent;Lio/sentry/Hint;Z)Z',
  );

  static final _execute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `public abstract boolean execute(io.sentry.SentryEvent sentryEvent, io.sentry.Hint hint, boolean z)`
  bool execute(
    SentryEvent sentryEvent,
    Hint hint,
    bool z,
  ) {
    final _$sentryEvent = sentryEvent.reference;
    final _$hint = hint.reference;
    return _execute(reference.pointer, _id_execute as jni$_.JMethodIDPtr,
            _$sentryEvent.pointer, _$hint.pointer, z ? 1 : 0)
        .boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SentryAndroidOptions$BeforeCaptureCallback>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'execute(Lio/sentry/SentryEvent;Lio/sentry/Hint;Z)Z') {
        final $r = _$impls[$p]!.execute(
          $a![0]!.as(const $SentryEvent$Type(), releaseOriginal: true),
          $a![1]!.as(const $Hint$Type(), releaseOriginal: true),
          $a![2]!
              .as(const jni$_.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $SentryAndroidOptions$BeforeCaptureCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.android.core.SentryAndroidOptions$BeforeCaptureCallback',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SentryAndroidOptions$BeforeCaptureCallback.implement(
    $SentryAndroidOptions$BeforeCaptureCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SentryAndroidOptions$BeforeCaptureCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $SentryAndroidOptions$BeforeCaptureCallback {
  factory $SentryAndroidOptions$BeforeCaptureCallback({
    required bool Function(SentryEvent sentryEvent, Hint hint, bool z) execute,
  }) = _$SentryAndroidOptions$BeforeCaptureCallback;

  bool execute(SentryEvent sentryEvent, Hint hint, bool z);
}

final class _$SentryAndroidOptions$BeforeCaptureCallback
    with $SentryAndroidOptions$BeforeCaptureCallback {
  _$SentryAndroidOptions$BeforeCaptureCallback({
    required bool Function(SentryEvent sentryEvent, Hint hint, bool z) execute,
  }) : _execute = execute;

  final bool Function(SentryEvent sentryEvent, Hint hint, bool z) _execute;

  bool execute(SentryEvent sentryEvent, Hint hint, bool z) {
    return _execute(sentryEvent, hint, z);
  }
}

final class $SentryAndroidOptions$BeforeCaptureCallback$NullableType
    extends jni$_.JObjType<SentryAndroidOptions$BeforeCaptureCallback?> {
  @jni$_.internal
  const $SentryAndroidOptions$BeforeCaptureCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/android/core/SentryAndroidOptions$BeforeCaptureCallback;';

  @jni$_.internal
  @core$_.override
  SentryAndroidOptions$BeforeCaptureCallback? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryAndroidOptions$BeforeCaptureCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryAndroidOptions$BeforeCaptureCallback?>
      get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryAndroidOptions$BeforeCaptureCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryAndroidOptions$BeforeCaptureCallback$NullableType) &&
        other is $SentryAndroidOptions$BeforeCaptureCallback$NullableType;
  }
}

final class $SentryAndroidOptions$BeforeCaptureCallback$Type
    extends jni$_.JObjType<SentryAndroidOptions$BeforeCaptureCallback> {
  @jni$_.internal
  const $SentryAndroidOptions$BeforeCaptureCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/android/core/SentryAndroidOptions$BeforeCaptureCallback;';

  @jni$_.internal
  @core$_.override
  SentryAndroidOptions$BeforeCaptureCallback fromReference(
          jni$_.JReference reference) =>
      SentryAndroidOptions$BeforeCaptureCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryAndroidOptions$BeforeCaptureCallback?>
      get nullableType =>
          const $SentryAndroidOptions$BeforeCaptureCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryAndroidOptions$BeforeCaptureCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryAndroidOptions$BeforeCaptureCallback$Type) &&
        other is $SentryAndroidOptions$BeforeCaptureCallback$Type;
  }
}

/// from: `io.sentry.android.core.SentryAndroidOptions`
class SentryAndroidOptions extends SentryOptions {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryAndroidOptions> $type;

  @jni$_.internal
  SentryAndroidOptions.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/android/core/SentryAndroidOptions');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryAndroidOptions$NullableType();
  static const type = $SentryAndroidOptions$Type();
  static final _id_setAnrEnabled = _class.instanceMethodId(
    r'setAnrEnabled',
    r'(Z)V',
  );

  static final _setAnrEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setAnrEnabled(boolean z)`
  void setAnrEnabled(
    bool z,
  ) {
    _setAnrEnabled(reference.pointer, _id_setAnrEnabled as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_setAnrTimeoutIntervalMillis = _class.instanceMethodId(
    r'setAnrTimeoutIntervalMillis',
    r'(J)V',
  );

  static final _setAnrTimeoutIntervalMillis =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setAnrTimeoutIntervalMillis(long j)`
  void setAnrTimeoutIntervalMillis(
    int j,
  ) {
    _setAnrTimeoutIntervalMillis(reference.pointer,
            _id_setAnrTimeoutIntervalMillis as jni$_.JMethodIDPtr, j)
        .check();
  }

  static final _id_setEnableActivityLifecycleBreadcrumbs =
      _class.instanceMethodId(
    r'setEnableActivityLifecycleBreadcrumbs',
    r'(Z)V',
  );

  static final _setEnableActivityLifecycleBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableActivityLifecycleBreadcrumbs(boolean z)`
  void setEnableActivityLifecycleBreadcrumbs(
    bool z,
  ) {
    _setEnableActivityLifecycleBreadcrumbs(
            reference.pointer,
            _id_setEnableActivityLifecycleBreadcrumbs as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_setEnableAppLifecycleBreadcrumbs = _class.instanceMethodId(
    r'setEnableAppLifecycleBreadcrumbs',
    r'(Z)V',
  );

  static final _setEnableAppLifecycleBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableAppLifecycleBreadcrumbs(boolean z)`
  void setEnableAppLifecycleBreadcrumbs(
    bool z,
  ) {
    _setEnableAppLifecycleBreadcrumbs(
            reference.pointer,
            _id_setEnableAppLifecycleBreadcrumbs as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_setEnableSystemEventBreadcrumbs = _class.instanceMethodId(
    r'setEnableSystemEventBreadcrumbs',
    r'(Z)V',
  );

  static final _setEnableSystemEventBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableSystemEventBreadcrumbs(boolean z)`
  void setEnableSystemEventBreadcrumbs(
    bool z,
  ) {
    _setEnableSystemEventBreadcrumbs(
            reference.pointer,
            _id_setEnableSystemEventBreadcrumbs as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_setEnableAppComponentBreadcrumbs = _class.instanceMethodId(
    r'setEnableAppComponentBreadcrumbs',
    r'(Z)V',
  );

  static final _setEnableAppComponentBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableAppComponentBreadcrumbs(boolean z)`
  void setEnableAppComponentBreadcrumbs(
    bool z,
  ) {
    _setEnableAppComponentBreadcrumbs(
            reference.pointer,
            _id_setEnableAppComponentBreadcrumbs as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_setNativeSdkName = _class.instanceMethodId(
    r'setNativeSdkName',
    r'(Ljava/lang/String;)V',
  );

  static final _setNativeSdkName = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setNativeSdkName(java.lang.String string)`
  void setNativeSdkName(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setNativeSdkName(reference.pointer,
            _id_setNativeSdkName as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_setEnableScopeSync = _class.instanceMethodId(
    r'setEnableScopeSync',
    r'(Z)V',
  );

  static final _setEnableScopeSync = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableScopeSync(boolean z)`
  void setEnableScopeSync(
    bool z,
  ) {
    _setEnableScopeSync(reference.pointer,
            _id_setEnableScopeSync as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }
}

final class $SentryAndroidOptions$NullableType
    extends jni$_.JObjType<SentryAndroidOptions?> {
  @jni$_.internal
  const $SentryAndroidOptions$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/core/SentryAndroidOptions;';

  @jni$_.internal
  @core$_.override
  SentryAndroidOptions? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryAndroidOptions.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $SentryOptions$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryAndroidOptions?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($SentryAndroidOptions$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryAndroidOptions$NullableType) &&
        other is $SentryAndroidOptions$NullableType;
  }
}

final class $SentryAndroidOptions$Type
    extends jni$_.JObjType<SentryAndroidOptions> {
  @jni$_.internal
  const $SentryAndroidOptions$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/core/SentryAndroidOptions;';

  @jni$_.internal
  @core$_.override
  SentryAndroidOptions fromReference(jni$_.JReference reference) =>
      SentryAndroidOptions.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $SentryOptions$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryAndroidOptions?> get nullableType =>
      const $SentryAndroidOptions$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($SentryAndroidOptions$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryAndroidOptions$Type) &&
        other is $SentryAndroidOptions$Type;
  }
}

/// from: `io.sentry.android.core.SentryAndroid`
class SentryAndroid extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryAndroid> $type;

  @jni$_.internal
  SentryAndroid.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/android/core/SentryAndroid');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryAndroid$NullableType();
  static const type = $SentryAndroid$Type();
  static final _id_init = _class.staticMethodId(
    r'init',
    r'(Landroid/content/Context;)V',
  );

  static final _init = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void init(android.content.Context context)`
  static void init(
    jni$_.JObject context,
  ) {
    final _$context = context.reference;
    _init(_class.reference.pointer, _id_init as jni$_.JMethodIDPtr,
            _$context.pointer)
        .check();
  }

  static final _id_init$1 = _class.staticMethodId(
    r'init',
    r'(Landroid/content/Context;Lio/sentry/ILogger;)V',
  );

  static final _init$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void init(android.content.Context context, io.sentry.ILogger iLogger)`
  static void init$1(
    jni$_.JObject context,
    jni$_.JObject iLogger,
  ) {
    final _$context = context.reference;
    final _$iLogger = iLogger.reference;
    _init$1(_class.reference.pointer, _id_init$1 as jni$_.JMethodIDPtr,
            _$context.pointer, _$iLogger.pointer)
        .check();
  }

  static final _id_init$2 = _class.staticMethodId(
    r'init',
    r'(Landroid/content/Context;Lio/sentry/Sentry$OptionsConfiguration;)V',
  );

  static final _init$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void init(android.content.Context context, io.sentry.Sentry$OptionsConfiguration<io.sentry.android.core.SentryAndroidOptions> optionsConfiguration)`
  static void init$2(
    jni$_.JObject context,
    Sentry$OptionsConfiguration<SentryAndroidOptions?> optionsConfiguration,
  ) {
    final _$context = context.reference;
    final _$optionsConfiguration = optionsConfiguration.reference;
    _init$2(_class.reference.pointer, _id_init$2 as jni$_.JMethodIDPtr,
            _$context.pointer, _$optionsConfiguration.pointer)
        .check();
  }

  static final _id_init$3 = _class.staticMethodId(
    r'init',
    r'(Landroid/content/Context;Lio/sentry/ILogger;Lio/sentry/Sentry$OptionsConfiguration;)V',
  );

  static final _init$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void init(android.content.Context context, io.sentry.ILogger iLogger, io.sentry.Sentry$OptionsConfiguration<io.sentry.android.core.SentryAndroidOptions> optionsConfiguration)`
  static void init$3(
    jni$_.JObject context,
    jni$_.JObject iLogger,
    Sentry$OptionsConfiguration<SentryAndroidOptions?> optionsConfiguration,
  ) {
    final _$context = context.reference;
    final _$iLogger = iLogger.reference;
    final _$optionsConfiguration = optionsConfiguration.reference;
    _init$3(
            _class.reference.pointer,
            _id_init$3 as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$iLogger.pointer,
            _$optionsConfiguration.pointer)
        .check();
  }
}

final class $SentryAndroid$NullableType extends jni$_.JObjType<SentryAndroid?> {
  @jni$_.internal
  const $SentryAndroid$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/core/SentryAndroid;';

  @jni$_.internal
  @core$_.override
  SentryAndroid? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : SentryAndroid.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryAndroid?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryAndroid$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryAndroid$NullableType) &&
        other is $SentryAndroid$NullableType;
  }
}

final class $SentryAndroid$Type extends jni$_.JObjType<SentryAndroid> {
  @jni$_.internal
  const $SentryAndroid$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/core/SentryAndroid;';

  @jni$_.internal
  @core$_.override
  SentryAndroid fromReference(jni$_.JReference reference) =>
      SentryAndroid.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryAndroid?> get nullableType =>
      const $SentryAndroid$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryAndroid$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryAndroid$Type) &&
        other is $SentryAndroid$Type;
  }
}

/// from: `io.sentry.android.core.BuildConfig`
class BuildConfig extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<BuildConfig> $type;

  @jni$_.internal
  BuildConfig.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/android/core/BuildConfig');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $BuildConfig$NullableType();
  static const type = $BuildConfig$Type();
  static final _id_VERSION_NAME = _class.staticFieldId(
    r'VERSION_NAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String VERSION_NAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get VERSION_NAME =>
      _id_VERSION_NAME.get(_class, const jni$_.JStringNullableType());
}

final class $BuildConfig$NullableType extends jni$_.JObjType<BuildConfig?> {
  @jni$_.internal
  const $BuildConfig$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/core/BuildConfig;';

  @jni$_.internal
  @core$_.override
  BuildConfig? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : BuildConfig.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<BuildConfig?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($BuildConfig$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($BuildConfig$NullableType) &&
        other is $BuildConfig$NullableType;
  }
}

final class $BuildConfig$Type extends jni$_.JObjType<BuildConfig> {
  @jni$_.internal
  const $BuildConfig$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/core/BuildConfig;';

  @jni$_.internal
  @core$_.override
  BuildConfig fromReference(jni$_.JReference reference) =>
      BuildConfig.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<BuildConfig?> get nullableType =>
      const $BuildConfig$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($BuildConfig$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($BuildConfig$Type) &&
        other is $BuildConfig$Type;
  }
}

/// from: `io.sentry.flutter.SentryFlutterPlugin$Companion`
class SentryFlutterPlugin$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryFlutterPlugin$Companion> $type;

  @jni$_.internal
  SentryFlutterPlugin$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/flutter/SentryFlutterPlugin$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryFlutterPlugin$Companion$NullableType();
  static const type = $SentryFlutterPlugin$Companion$Type();
  static final _id_privateSentryGetReplayIntegration = _class.instanceMethodId(
    r'privateSentryGetReplayIntegration',
    r'()Lio/sentry/android/replay/ReplayIntegration;',
  );

  static final _privateSentryGetReplayIntegration =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public final io.sentry.android.replay.ReplayIntegration privateSentryGetReplayIntegration()`
  /// The returned object must be released after use, by calling the [release] method.
  ReplayIntegration? privateSentryGetReplayIntegration() {
    return _privateSentryGetReplayIntegration(reference.pointer,
            _id_privateSentryGetReplayIntegration as jni$_.JMethodIDPtr)
        .object<ReplayIntegration?>(const $ReplayIntegration$NullableType());
  }

  static final _id_setupReplay = _class.instanceMethodId(
    r'setupReplay',
    r'(Lio/sentry/android/core/SentryAndroidOptions;Lio/sentry/flutter/ReplayRecorderCallbacks;)V',
  );

  static final _setupReplay = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setupReplay(io.sentry.android.core.SentryAndroidOptions sentryAndroidOptions, io.sentry.flutter.ReplayRecorderCallbacks replayRecorderCallbacks)`
  void setupReplay(
    SentryAndroidOptions sentryAndroidOptions,
    ReplayRecorderCallbacks? replayRecorderCallbacks,
  ) {
    final _$sentryAndroidOptions = sentryAndroidOptions.reference;
    final _$replayRecorderCallbacks =
        replayRecorderCallbacks?.reference ?? jni$_.jNullReference;
    _setupReplay(reference.pointer, _id_setupReplay as jni$_.JMethodIDPtr,
            _$sentryAndroidOptions.pointer, _$replayRecorderCallbacks.pointer)
        .check();
  }

  static final _id_crash = _class.instanceMethodId(
    r'crash',
    r'()V',
  );

  static final _crash = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final void crash()`
  void crash() {
    _crash(reference.pointer, _id_crash as jni$_.JMethodIDPtr).check();
  }

  static final _id_getDisplayRefreshRate = _class.instanceMethodId(
    r'getDisplayRefreshRate',
    r'()Ljava/lang/Integer;',
  );

  static final _getDisplayRefreshRate = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Integer getDisplayRefreshRate()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JInteger? getDisplayRefreshRate() {
    return _getDisplayRefreshRate(
            reference.pointer, _id_getDisplayRefreshRate as jni$_.JMethodIDPtr)
        .object<jni$_.JInteger?>(const jni$_.JIntegerNullableType());
  }

  static final _id_fetchNativeAppStartAsBytes = _class.instanceMethodId(
    r'fetchNativeAppStartAsBytes',
    r'()[B',
  );

  static final _fetchNativeAppStartAsBytes =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public final byte[] fetchNativeAppStartAsBytes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? fetchNativeAppStartAsBytes() {
    return _fetchNativeAppStartAsBytes(reference.pointer,
            _id_fetchNativeAppStartAsBytes as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_getApplicationContext = _class.instanceMethodId(
    r'getApplicationContext',
    r'()Landroid/content/Context;',
  );

  static final _getApplicationContext = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final android.content.Context getApplicationContext()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getApplicationContext() {
    return _getApplicationContext(
            reference.pointer, _id_getApplicationContext as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_loadContextsAsBytes = _class.instanceMethodId(
    r'loadContextsAsBytes',
    r'()[B',
  );

  static final _loadContextsAsBytes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final byte[] loadContextsAsBytes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? loadContextsAsBytes() {
    return _loadContextsAsBytes(
            reference.pointer, _id_loadContextsAsBytes as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_loadDebugImagesAsBytes = _class.instanceMethodId(
    r'loadDebugImagesAsBytes',
    r'(Ljava/util/Set;)[B',
  );

  static final _loadDebugImagesAsBytes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final byte[] loadDebugImagesAsBytes(java.util.Set<java.lang.String> set)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? loadDebugImagesAsBytes(
    jni$_.JSet<jni$_.JString> set,
  ) {
    final _$set = set.reference;
    return _loadDebugImagesAsBytes(reference.pointer,
            _id_loadDebugImagesAsBytes as jni$_.JMethodIDPtr, _$set.pointer)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryFlutterPlugin$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return SentryFlutterPlugin$Companion.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $SentryFlutterPlugin$Companion$NullableType
    extends jni$_.JObjType<SentryFlutterPlugin$Companion?> {
  @jni$_.internal
  const $SentryFlutterPlugin$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/flutter/SentryFlutterPlugin$Companion;';

  @jni$_.internal
  @core$_.override
  SentryFlutterPlugin$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryFlutterPlugin$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryFlutterPlugin$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryFlutterPlugin$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryFlutterPlugin$Companion$NullableType) &&
        other is $SentryFlutterPlugin$Companion$NullableType;
  }
}

final class $SentryFlutterPlugin$Companion$Type
    extends jni$_.JObjType<SentryFlutterPlugin$Companion> {
  @jni$_.internal
  const $SentryFlutterPlugin$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/flutter/SentryFlutterPlugin$Companion;';

  @jni$_.internal
  @core$_.override
  SentryFlutterPlugin$Companion fromReference(jni$_.JReference reference) =>
      SentryFlutterPlugin$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryFlutterPlugin$Companion?> get nullableType =>
      const $SentryFlutterPlugin$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryFlutterPlugin$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryFlutterPlugin$Companion$Type) &&
        other is $SentryFlutterPlugin$Companion$Type;
  }
}

/// from: `io.sentry.flutter.SentryFlutterPlugin`
class SentryFlutterPlugin extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryFlutterPlugin> $type;

  @jni$_.internal
  SentryFlutterPlugin.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/flutter/SentryFlutterPlugin');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryFlutterPlugin$NullableType();
  static const type = $SentryFlutterPlugin$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Lio/sentry/flutter/SentryFlutterPlugin$Companion;',
  );

  /// from: `static public final io.sentry.flutter.SentryFlutterPlugin$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryFlutterPlugin$Companion get Companion =>
      _id_Companion.get(_class, const $SentryFlutterPlugin$Companion$Type());

  static final _id_privateSentryGetReplayIntegration = _class.staticMethodId(
    r'privateSentryGetReplayIntegration',
    r'()Lio/sentry/android/replay/ReplayIntegration;',
  );

  static final _privateSentryGetReplayIntegration =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `static public final io.sentry.android.replay.ReplayIntegration privateSentryGetReplayIntegration()`
  /// The returned object must be released after use, by calling the [release] method.
  static ReplayIntegration? privateSentryGetReplayIntegration() {
    return _privateSentryGetReplayIntegration(_class.reference.pointer,
            _id_privateSentryGetReplayIntegration as jni$_.JMethodIDPtr)
        .object<ReplayIntegration?>(const $ReplayIntegration$NullableType());
  }

  static final _id_setupReplay = _class.staticMethodId(
    r'setupReplay',
    r'(Lio/sentry/android/core/SentryAndroidOptions;Lio/sentry/flutter/ReplayRecorderCallbacks;)V',
  );

  static final _setupReplay = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public final void setupReplay(io.sentry.android.core.SentryAndroidOptions sentryAndroidOptions, io.sentry.flutter.ReplayRecorderCallbacks replayRecorderCallbacks)`
  static void setupReplay(
    SentryAndroidOptions sentryAndroidOptions,
    ReplayRecorderCallbacks? replayRecorderCallbacks,
  ) {
    final _$sentryAndroidOptions = sentryAndroidOptions.reference;
    final _$replayRecorderCallbacks =
        replayRecorderCallbacks?.reference ?? jni$_.jNullReference;
    _setupReplay(
            _class.reference.pointer,
            _id_setupReplay as jni$_.JMethodIDPtr,
            _$sentryAndroidOptions.pointer,
            _$replayRecorderCallbacks.pointer)
        .check();
  }

  static final _id_crash = _class.staticMethodId(
    r'crash',
    r'()V',
  );

  static final _crash = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public final void crash()`
  static void crash() {
    _crash(_class.reference.pointer, _id_crash as jni$_.JMethodIDPtr).check();
  }

  static final _id_getDisplayRefreshRate = _class.staticMethodId(
    r'getDisplayRefreshRate',
    r'()Ljava/lang/Integer;',
  );

  static final _getDisplayRefreshRate = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public final java.lang.Integer getDisplayRefreshRate()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JInteger? getDisplayRefreshRate() {
    return _getDisplayRefreshRate(_class.reference.pointer,
            _id_getDisplayRefreshRate as jni$_.JMethodIDPtr)
        .object<jni$_.JInteger?>(const jni$_.JIntegerNullableType());
  }

  static final _id_fetchNativeAppStartAsBytes = _class.staticMethodId(
    r'fetchNativeAppStartAsBytes',
    r'()[B',
  );

  static final _fetchNativeAppStartAsBytes =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `static public final byte[] fetchNativeAppStartAsBytes()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JByteArray? fetchNativeAppStartAsBytes() {
    return _fetchNativeAppStartAsBytes(_class.reference.pointer,
            _id_fetchNativeAppStartAsBytes as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_getApplicationContext = _class.staticMethodId(
    r'getApplicationContext',
    r'()Landroid/content/Context;',
  );

  static final _getApplicationContext = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public final android.content.Context getApplicationContext()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? getApplicationContext() {
    return _getApplicationContext(_class.reference.pointer,
            _id_getApplicationContext as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_loadContextsAsBytes = _class.staticMethodId(
    r'loadContextsAsBytes',
    r'()[B',
  );

  static final _loadContextsAsBytes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public final byte[] loadContextsAsBytes()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JByteArray? loadContextsAsBytes() {
    return _loadContextsAsBytes(_class.reference.pointer,
            _id_loadContextsAsBytes as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_loadDebugImagesAsBytes = _class.staticMethodId(
    r'loadDebugImagesAsBytes',
    r'(Ljava/util/Set;)[B',
  );

  static final _loadDebugImagesAsBytes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public final byte[] loadDebugImagesAsBytes(java.util.Set<java.lang.String> set)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JByteArray? loadDebugImagesAsBytes(
    jni$_.JSet<jni$_.JString?> set,
  ) {
    final _$set = set.reference;
    return _loadDebugImagesAsBytes(_class.reference.pointer,
            _id_loadDebugImagesAsBytes as jni$_.JMethodIDPtr, _$set.pointer)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }
}

final class $SentryFlutterPlugin$NullableType
    extends jni$_.JObjType<SentryFlutterPlugin?> {
  @jni$_.internal
  const $SentryFlutterPlugin$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/flutter/SentryFlutterPlugin;';

  @jni$_.internal
  @core$_.override
  SentryFlutterPlugin? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryFlutterPlugin.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryFlutterPlugin?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryFlutterPlugin$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryFlutterPlugin$NullableType) &&
        other is $SentryFlutterPlugin$NullableType;
  }
}

final class $SentryFlutterPlugin$Type
    extends jni$_.JObjType<SentryFlutterPlugin> {
  @jni$_.internal
  const $SentryFlutterPlugin$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/flutter/SentryFlutterPlugin;';

  @jni$_.internal
  @core$_.override
  SentryFlutterPlugin fromReference(jni$_.JReference reference) =>
      SentryFlutterPlugin.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryFlutterPlugin?> get nullableType =>
      const $SentryFlutterPlugin$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryFlutterPlugin$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryFlutterPlugin$Type) &&
        other is $SentryFlutterPlugin$Type;
  }
}

/// from: `io.sentry.flutter.ReplayRecorderCallbacks`
class ReplayRecorderCallbacks extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ReplayRecorderCallbacks> $type;

  @jni$_.internal
  ReplayRecorderCallbacks.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/flutter/ReplayRecorderCallbacks');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ReplayRecorderCallbacks$NullableType();
  static const type = $ReplayRecorderCallbacks$Type();
  static final _id_replayStarted = _class.instanceMethodId(
    r'replayStarted',
    r'(Ljava/lang/String;Z)V',
  );

  static final _replayStarted = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public abstract void replayStarted(java.lang.String string, boolean z)`
  void replayStarted(
    jni$_.JString string,
    bool z,
  ) {
    final _$string = string.reference;
    _replayStarted(reference.pointer, _id_replayStarted as jni$_.JMethodIDPtr,
            _$string.pointer, z ? 1 : 0)
        .check();
  }

  static final _id_replayResumed = _class.instanceMethodId(
    r'replayResumed',
    r'()V',
  );

  static final _replayResumed = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void replayResumed()`
  void replayResumed() {
    _replayResumed(reference.pointer, _id_replayResumed as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_replayPaused = _class.instanceMethodId(
    r'replayPaused',
    r'()V',
  );

  static final _replayPaused = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void replayPaused()`
  void replayPaused() {
    _replayPaused(reference.pointer, _id_replayPaused as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_replayStopped = _class.instanceMethodId(
    r'replayStopped',
    r'()V',
  );

  static final _replayStopped = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void replayStopped()`
  void replayStopped() {
    _replayStopped(reference.pointer, _id_replayStopped as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_replayReset = _class.instanceMethodId(
    r'replayReset',
    r'()V',
  );

  static final _replayReset = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void replayReset()`
  void replayReset() {
    _replayReset(reference.pointer, _id_replayReset as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_replayConfigChanged = _class.instanceMethodId(
    r'replayConfigChanged',
    r'(III)V',
  );

  static final _replayConfigChanged = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int, int)>();

  /// from: `public abstract void replayConfigChanged(int i, int i1, int i2)`
  void replayConfigChanged(
    int i,
    int i1,
    int i2,
  ) {
    _replayConfigChanged(reference.pointer,
            _id_replayConfigChanged as jni$_.JMethodIDPtr, i, i1, i2)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ReplayRecorderCallbacks> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'replayStarted(Ljava/lang/String;Z)V') {
        _$impls[$p]!.replayStarted(
          $a![0]!.as(const jni$_.JStringType(), releaseOriginal: true),
          $a![1]!
              .as(const jni$_.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'replayResumed()V') {
        _$impls[$p]!.replayResumed();
        return jni$_.nullptr;
      }
      if ($d == r'replayPaused()V') {
        _$impls[$p]!.replayPaused();
        return jni$_.nullptr;
      }
      if ($d == r'replayStopped()V') {
        _$impls[$p]!.replayStopped();
        return jni$_.nullptr;
      }
      if ($d == r'replayReset()V') {
        _$impls[$p]!.replayReset();
        return jni$_.nullptr;
      }
      if ($d == r'replayConfigChanged(III)V') {
        _$impls[$p]!.replayConfigChanged(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![1]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![2]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $ReplayRecorderCallbacks $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.flutter.ReplayRecorderCallbacks',
      $p,
      _$invokePointer,
      [
        if ($impl.replayStarted$async) r'replayStarted(Ljava/lang/String;Z)V',
        if ($impl.replayResumed$async) r'replayResumed()V',
        if ($impl.replayPaused$async) r'replayPaused()V',
        if ($impl.replayStopped$async) r'replayStopped()V',
        if ($impl.replayReset$async) r'replayReset()V',
        if ($impl.replayConfigChanged$async) r'replayConfigChanged(III)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ReplayRecorderCallbacks.implement(
    $ReplayRecorderCallbacks $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ReplayRecorderCallbacks.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $ReplayRecorderCallbacks {
  factory $ReplayRecorderCallbacks({
    required void Function(jni$_.JString string, bool z) replayStarted,
    bool replayStarted$async,
    required void Function() replayResumed,
    bool replayResumed$async,
    required void Function() replayPaused,
    bool replayPaused$async,
    required void Function() replayStopped,
    bool replayStopped$async,
    required void Function() replayReset,
    bool replayReset$async,
    required void Function(int i, int i1, int i2) replayConfigChanged,
    bool replayConfigChanged$async,
  }) = _$ReplayRecorderCallbacks;

  void replayStarted(jni$_.JString string, bool z);
  bool get replayStarted$async => false;
  void replayResumed();
  bool get replayResumed$async => false;
  void replayPaused();
  bool get replayPaused$async => false;
  void replayStopped();
  bool get replayStopped$async => false;
  void replayReset();
  bool get replayReset$async => false;
  void replayConfigChanged(int i, int i1, int i2);
  bool get replayConfigChanged$async => false;
}

final class _$ReplayRecorderCallbacks with $ReplayRecorderCallbacks {
  _$ReplayRecorderCallbacks({
    required void Function(jni$_.JString string, bool z) replayStarted,
    this.replayStarted$async = false,
    required void Function() replayResumed,
    this.replayResumed$async = false,
    required void Function() replayPaused,
    this.replayPaused$async = false,
    required void Function() replayStopped,
    this.replayStopped$async = false,
    required void Function() replayReset,
    this.replayReset$async = false,
    required void Function(int i, int i1, int i2) replayConfigChanged,
    this.replayConfigChanged$async = false,
  })  : _replayStarted = replayStarted,
        _replayResumed = replayResumed,
        _replayPaused = replayPaused,
        _replayStopped = replayStopped,
        _replayReset = replayReset,
        _replayConfigChanged = replayConfigChanged;

  final void Function(jni$_.JString string, bool z) _replayStarted;
  final bool replayStarted$async;
  final void Function() _replayResumed;
  final bool replayResumed$async;
  final void Function() _replayPaused;
  final bool replayPaused$async;
  final void Function() _replayStopped;
  final bool replayStopped$async;
  final void Function() _replayReset;
  final bool replayReset$async;
  final void Function(int i, int i1, int i2) _replayConfigChanged;
  final bool replayConfigChanged$async;

  void replayStarted(jni$_.JString string, bool z) {
    return _replayStarted(string, z);
  }

  void replayResumed() {
    return _replayResumed();
  }

  void replayPaused() {
    return _replayPaused();
  }

  void replayStopped() {
    return _replayStopped();
  }

  void replayReset() {
    return _replayReset();
  }

  void replayConfigChanged(int i, int i1, int i2) {
    return _replayConfigChanged(i, i1, i2);
  }
}

final class $ReplayRecorderCallbacks$NullableType
    extends jni$_.JObjType<ReplayRecorderCallbacks?> {
  @jni$_.internal
  const $ReplayRecorderCallbacks$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/flutter/ReplayRecorderCallbacks;';

  @jni$_.internal
  @core$_.override
  ReplayRecorderCallbacks? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ReplayRecorderCallbacks.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ReplayRecorderCallbacks?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ReplayRecorderCallbacks$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ReplayRecorderCallbacks$NullableType) &&
        other is $ReplayRecorderCallbacks$NullableType;
  }
}

final class $ReplayRecorderCallbacks$Type
    extends jni$_.JObjType<ReplayRecorderCallbacks> {
  @jni$_.internal
  const $ReplayRecorderCallbacks$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/flutter/ReplayRecorderCallbacks;';

  @jni$_.internal
  @core$_.override
  ReplayRecorderCallbacks fromReference(jni$_.JReference reference) =>
      ReplayRecorderCallbacks.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ReplayRecorderCallbacks?> get nullableType =>
      const $ReplayRecorderCallbacks$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ReplayRecorderCallbacks$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ReplayRecorderCallbacks$Type) &&
        other is $ReplayRecorderCallbacks$Type;
  }
}

/// from: `io.sentry.android.core.InternalSentrySdk`
class InternalSentrySdk extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<InternalSentrySdk> $type;

  @jni$_.internal
  InternalSentrySdk.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/android/core/InternalSentrySdk');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $InternalSentrySdk$NullableType();
  static const type = $InternalSentrySdk$Type();
  static final _id_captureEnvelope = _class.staticMethodId(
    r'captureEnvelope',
    r'([BZ)Lio/sentry/protocol/SentryId;',
  );

  static final _captureEnvelope = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `static public io.sentry.protocol.SentryId captureEnvelope(byte[] bs, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryId? captureEnvelope(
    jni$_.JByteArray bs,
    bool z,
  ) {
    final _$bs = bs.reference;
    return _captureEnvelope(_class.reference.pointer,
            _id_captureEnvelope as jni$_.JMethodIDPtr, _$bs.pointer, z ? 1 : 0)
        .object<SentryId?>(const $SentryId$NullableType());
  }
}

final class $InternalSentrySdk$NullableType
    extends jni$_.JObjType<InternalSentrySdk?> {
  @jni$_.internal
  const $InternalSentrySdk$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/core/InternalSentrySdk;';

  @jni$_.internal
  @core$_.override
  InternalSentrySdk? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : InternalSentrySdk.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InternalSentrySdk?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InternalSentrySdk$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InternalSentrySdk$NullableType) &&
        other is $InternalSentrySdk$NullableType;
  }
}

final class $InternalSentrySdk$Type extends jni$_.JObjType<InternalSentrySdk> {
  @jni$_.internal
  const $InternalSentrySdk$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/core/InternalSentrySdk;';

  @jni$_.internal
  @core$_.override
  InternalSentrySdk fromReference(jni$_.JReference reference) =>
      InternalSentrySdk.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InternalSentrySdk?> get nullableType =>
      const $InternalSentrySdk$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InternalSentrySdk$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InternalSentrySdk$Type) &&
        other is $InternalSentrySdk$Type;
  }
}

/// from: `io.sentry.ScopesAdapter`
class ScopesAdapter extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ScopesAdapter> $type;

  @jni$_.internal
  ScopesAdapter.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/ScopesAdapter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ScopesAdapter$NullableType();
  static const type = $ScopesAdapter$Type();
  static final _id_getInstance = _class.staticMethodId(
    r'getInstance',
    r'()Lio/sentry/ScopesAdapter;',
  );

  static final _getInstance = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.ScopesAdapter getInstance()`
  /// The returned object must be released after use, by calling the [release] method.
  static ScopesAdapter? getInstance() {
    return _getInstance(
            _class.reference.pointer, _id_getInstance as jni$_.JMethodIDPtr)
        .object<ScopesAdapter?>(const $ScopesAdapter$NullableType());
  }

  static final _id_getOptions = _class.instanceMethodId(
    r'getOptions',
    r'()Lio/sentry/SentryOptions;',
  );

  static final _getOptions = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryOptions getOptions()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryOptions getOptions() {
    return _getOptions(reference.pointer, _id_getOptions as jni$_.JMethodIDPtr)
        .object<SentryOptions>(const $SentryOptions$Type());
  }
}

final class $ScopesAdapter$NullableType extends jni$_.JObjType<ScopesAdapter?> {
  @jni$_.internal
  const $ScopesAdapter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/ScopesAdapter;';

  @jni$_.internal
  @core$_.override
  ScopesAdapter? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : ScopesAdapter.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ScopesAdapter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ScopesAdapter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ScopesAdapter$NullableType) &&
        other is $ScopesAdapter$NullableType;
  }
}

final class $ScopesAdapter$Type extends jni$_.JObjType<ScopesAdapter> {
  @jni$_.internal
  const $ScopesAdapter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/ScopesAdapter;';

  @jni$_.internal
  @core$_.override
  ScopesAdapter fromReference(jni$_.JReference reference) =>
      ScopesAdapter.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ScopesAdapter?> get nullableType =>
      const $ScopesAdapter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ScopesAdapter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ScopesAdapter$Type) &&
        other is $ScopesAdapter$Type;
  }
}

/// from: `io.sentry.Breadcrumb$Deserializer`
class Breadcrumb$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Breadcrumb$Deserializer> $type;

  @jni$_.internal
  Breadcrumb$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/Breadcrumb$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Breadcrumb$Deserializer$NullableType();
  static const type = $Breadcrumb$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Breadcrumb$Deserializer() {
    return Breadcrumb$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserialize = _class.instanceMethodId(
    r'deserialize',
    r'(Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Lio/sentry/Breadcrumb;',
  );

  static final _deserialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.Breadcrumb deserialize(io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  /// The returned object must be released after use, by calling the [release] method.
  Breadcrumb deserialize(
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserialize(
            reference.pointer,
            _id_deserialize as jni$_.JMethodIDPtr,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }
}

final class $Breadcrumb$Deserializer$NullableType
    extends jni$_.JObjType<Breadcrumb$Deserializer?> {
  @jni$_.internal
  const $Breadcrumb$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Breadcrumb$Deserializer;';

  @jni$_.internal
  @core$_.override
  Breadcrumb$Deserializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Breadcrumb$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Breadcrumb$Deserializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Breadcrumb$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Breadcrumb$Deserializer$NullableType) &&
        other is $Breadcrumb$Deserializer$NullableType;
  }
}

final class $Breadcrumb$Deserializer$Type
    extends jni$_.JObjType<Breadcrumb$Deserializer> {
  @jni$_.internal
  const $Breadcrumb$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Breadcrumb$Deserializer;';

  @jni$_.internal
  @core$_.override
  Breadcrumb$Deserializer fromReference(jni$_.JReference reference) =>
      Breadcrumb$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Breadcrumb$Deserializer?> get nullableType =>
      const $Breadcrumb$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Breadcrumb$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Breadcrumb$Deserializer$Type) &&
        other is $Breadcrumb$Deserializer$Type;
  }
}

/// from: `io.sentry.Breadcrumb$JsonKeys`
class Breadcrumb$JsonKeys extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Breadcrumb$JsonKeys> $type;

  @jni$_.internal
  Breadcrumb$JsonKeys.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/Breadcrumb$JsonKeys');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Breadcrumb$JsonKeys$NullableType();
  static const type = $Breadcrumb$JsonKeys$Type();
  static final _id_TIMESTAMP = _class.staticFieldId(
    r'TIMESTAMP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TIMESTAMP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TIMESTAMP =>
      _id_TIMESTAMP.get(_class, const jni$_.JStringNullableType());

  static final _id_MESSAGE = _class.staticFieldId(
    r'MESSAGE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MESSAGE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get MESSAGE =>
      _id_MESSAGE.get(_class, const jni$_.JStringNullableType());

  static final _id_TYPE = _class.staticFieldId(
    r'TYPE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TYPE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TYPE =>
      _id_TYPE.get(_class, const jni$_.JStringNullableType());

  static final _id_DATA = _class.staticFieldId(
    r'DATA',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DATA`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DATA =>
      _id_DATA.get(_class, const jni$_.JStringNullableType());

  static final _id_CATEGORY = _class.staticFieldId(
    r'CATEGORY',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CATEGORY`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CATEGORY =>
      _id_CATEGORY.get(_class, const jni$_.JStringNullableType());

  static final _id_ORIGIN = _class.staticFieldId(
    r'ORIGIN',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ORIGIN`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ORIGIN =>
      _id_ORIGIN.get(_class, const jni$_.JStringNullableType());

  static final _id_LEVEL = _class.staticFieldId(
    r'LEVEL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LEVEL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get LEVEL =>
      _id_LEVEL.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Breadcrumb$JsonKeys() {
    return Breadcrumb$JsonKeys.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $Breadcrumb$JsonKeys$NullableType
    extends jni$_.JObjType<Breadcrumb$JsonKeys?> {
  @jni$_.internal
  const $Breadcrumb$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Breadcrumb$JsonKeys;';

  @jni$_.internal
  @core$_.override
  Breadcrumb$JsonKeys? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Breadcrumb$JsonKeys.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Breadcrumb$JsonKeys?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Breadcrumb$JsonKeys$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Breadcrumb$JsonKeys$NullableType) &&
        other is $Breadcrumb$JsonKeys$NullableType;
  }
}

final class $Breadcrumb$JsonKeys$Type
    extends jni$_.JObjType<Breadcrumb$JsonKeys> {
  @jni$_.internal
  const $Breadcrumb$JsonKeys$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Breadcrumb$JsonKeys;';

  @jni$_.internal
  @core$_.override
  Breadcrumb$JsonKeys fromReference(jni$_.JReference reference) =>
      Breadcrumb$JsonKeys.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Breadcrumb$JsonKeys?> get nullableType =>
      const $Breadcrumb$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Breadcrumb$JsonKeys$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Breadcrumb$JsonKeys$Type) &&
        other is $Breadcrumb$JsonKeys$Type;
  }
}

/// from: `io.sentry.Breadcrumb`
class Breadcrumb extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Breadcrumb> $type;

  @jni$_.internal
  Breadcrumb.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/Breadcrumb');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Breadcrumb$NullableType();
  static const type = $Breadcrumb$Type();
  static final _id_fromMap = _class.staticMethodId(
    r'fromMap',
    r'(Ljava/util/Map;Lio/sentry/SentryOptions;)Lio/sentry/Breadcrumb;',
  );

  static final _fromMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb fromMap(java.util.Map<java.lang.String, java.lang.Object> map, io.sentry.SentryOptions sentryOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb? fromMap(
    jni$_.JMap<jni$_.JString?, jni$_.JObject?> map,
    SentryOptions sentryOptions,
  ) {
    final _$map = map.reference;
    final _$sentryOptions = sentryOptions.reference;
    return _fromMap(_class.reference.pointer, _id_fromMap as jni$_.JMethodIDPtr,
            _$map.pointer, _$sentryOptions.pointer)
        .object<Breadcrumb?>(const $Breadcrumb$NullableType());
  }
}

final class $Breadcrumb$NullableType extends jni$_.JObjType<Breadcrumb?> {
  @jni$_.internal
  const $Breadcrumb$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Breadcrumb;';

  @jni$_.internal
  @core$_.override
  Breadcrumb? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Breadcrumb.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Breadcrumb?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Breadcrumb$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Breadcrumb$NullableType) &&
        other is $Breadcrumb$NullableType;
  }
}

final class $Breadcrumb$Type extends jni$_.JObjType<Breadcrumb> {
  @jni$_.internal
  const $Breadcrumb$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Breadcrumb;';

  @jni$_.internal
  @core$_.override
  Breadcrumb fromReference(jni$_.JReference reference) =>
      Breadcrumb.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Breadcrumb?> get nullableType =>
      const $Breadcrumb$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Breadcrumb$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Breadcrumb$Type) && other is $Breadcrumb$Type;
  }
}

/// from: `io.sentry.Sentry$OptionsConfiguration`
class Sentry$OptionsConfiguration<$T extends jni$_.JObject?>
    extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Sentry$OptionsConfiguration<$T>> $type;

  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  Sentry$OptionsConfiguration.fromReference(
    this.T,
    jni$_.JReference reference,
  )   : $type = type<$T>(T),
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/Sentry$OptionsConfiguration');

  /// The type which includes information such as the signature of this class.
  static $Sentry$OptionsConfiguration$NullableType<$T>
      nullableType<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) {
    return $Sentry$OptionsConfiguration$NullableType<$T>(
      T,
    );
  }

  static $Sentry$OptionsConfiguration$Type<$T> type<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) {
    return $Sentry$OptionsConfiguration$Type<$T>(
      T,
    );
  }

  static final _id_configure = _class.instanceMethodId(
    r'configure',
    r'(Lio/sentry/SentryOptions;)V',
  );

  static final _configure = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void configure(T sentryOptions)`
  void configure(
    $T sentryOptions,
  ) {
    final _$sentryOptions = sentryOptions?.reference ?? jni$_.jNullReference;
    _configure(reference.pointer, _id_configure as jni$_.JMethodIDPtr,
            _$sentryOptions.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Sentry$OptionsConfiguration> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'configure(Lio/sentry/SentryOptions;)V') {
        _$impls[$p]!.configure(
          $a![0]?.as(_$impls[$p]!.T, releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn<$T extends jni$_.JObject?>(
    jni$_.JImplementer implementer,
    $Sentry$OptionsConfiguration<$T> $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.Sentry$OptionsConfiguration',
      $p,
      _$invokePointer,
      [
        if ($impl.configure$async) r'configure(Lio/sentry/SentryOptions;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Sentry$OptionsConfiguration.implement(
    $Sentry$OptionsConfiguration<$T> $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Sentry$OptionsConfiguration<$T>.fromReference(
      $impl.T,
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Sentry$OptionsConfiguration<
    $T extends jni$_.JObject?> {
  factory $Sentry$OptionsConfiguration({
    required jni$_.JObjType<$T> T,
    required void Function($T sentryOptions) configure,
    bool configure$async,
  }) = _$Sentry$OptionsConfiguration<$T>;

  jni$_.JObjType<$T> get T;

  void configure($T sentryOptions);
  bool get configure$async => false;
}

final class _$Sentry$OptionsConfiguration<$T extends jni$_.JObject?>
    with $Sentry$OptionsConfiguration<$T> {
  _$Sentry$OptionsConfiguration({
    required this.T,
    required void Function($T sentryOptions) configure,
    this.configure$async = false,
  }) : _configure = configure;

  @core$_.override
  final jni$_.JObjType<$T> T;

  final void Function($T sentryOptions) _configure;
  final bool configure$async;

  void configure($T sentryOptions) {
    return _configure(sentryOptions);
  }
}

final class $Sentry$OptionsConfiguration$NullableType<$T extends jni$_.JObject?>
    extends jni$_.JObjType<Sentry$OptionsConfiguration<$T>?> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $Sentry$OptionsConfiguration$NullableType(
    this.T,
  );

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Sentry$OptionsConfiguration;';

  @jni$_.internal
  @core$_.override
  Sentry$OptionsConfiguration<$T>? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Sentry$OptionsConfiguration<$T>.fromReference(
              T,
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Sentry$OptionsConfiguration<$T>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($Sentry$OptionsConfiguration$NullableType, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($Sentry$OptionsConfiguration$NullableType<$T>) &&
        other is $Sentry$OptionsConfiguration$NullableType<$T> &&
        T == other.T;
  }
}

final class $Sentry$OptionsConfiguration$Type<$T extends jni$_.JObject?>
    extends jni$_.JObjType<Sentry$OptionsConfiguration<$T>> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $Sentry$OptionsConfiguration$Type(
    this.T,
  );

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Sentry$OptionsConfiguration;';

  @jni$_.internal
  @core$_.override
  Sentry$OptionsConfiguration<$T> fromReference(jni$_.JReference reference) =>
      Sentry$OptionsConfiguration<$T>.fromReference(
        T,
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Sentry$OptionsConfiguration<$T>?> get nullableType =>
      $Sentry$OptionsConfiguration$NullableType<$T>(T);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($Sentry$OptionsConfiguration$Type, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Sentry$OptionsConfiguration$Type<$T>) &&
        other is $Sentry$OptionsConfiguration$Type<$T> &&
        T == other.T;
  }
}

/// from: `io.sentry.Sentry`
class Sentry extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Sentry> $type;

  @jni$_.internal
  Sentry.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/Sentry');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Sentry$NullableType();
  static const type = $Sentry$Type();
  static final _id_addBreadcrumb = _class.staticMethodId(
    r'addBreadcrumb',
    r'(Lio/sentry/Breadcrumb;Lio/sentry/Hint;)V',
  );

  static final _addBreadcrumb = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void addBreadcrumb(io.sentry.Breadcrumb breadcrumb, io.sentry.Hint hint)`
  static void addBreadcrumb(
    Breadcrumb breadcrumb,
    Hint? hint,
  ) {
    final _$breadcrumb = breadcrumb.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    _addBreadcrumb(
            _class.reference.pointer,
            _id_addBreadcrumb as jni$_.JMethodIDPtr,
            _$breadcrumb.pointer,
            _$hint.pointer)
        .check();
  }

  static final _id_addBreadcrumb$1 = _class.staticMethodId(
    r'addBreadcrumb',
    r'(Lio/sentry/Breadcrumb;)V',
  );

  static final _addBreadcrumb$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void addBreadcrumb(io.sentry.Breadcrumb breadcrumb)`
  static void addBreadcrumb$1(
    Breadcrumb breadcrumb,
  ) {
    final _$breadcrumb = breadcrumb.reference;
    _addBreadcrumb$1(_class.reference.pointer,
            _id_addBreadcrumb$1 as jni$_.JMethodIDPtr, _$breadcrumb.pointer)
        .check();
  }

  static final _id_addBreadcrumb$2 = _class.staticMethodId(
    r'addBreadcrumb',
    r'(Ljava/lang/String;)V',
  );

  static final _addBreadcrumb$2 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void addBreadcrumb(java.lang.String string)`
  static void addBreadcrumb$2(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _addBreadcrumb$2(_class.reference.pointer,
            _id_addBreadcrumb$2 as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_addBreadcrumb$3 = _class.staticMethodId(
    r'addBreadcrumb',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _addBreadcrumb$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void addBreadcrumb(java.lang.String string, java.lang.String string1)`
  static void addBreadcrumb$3(
    jni$_.JString string,
    jni$_.JString string1,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    _addBreadcrumb$3(
            _class.reference.pointer,
            _id_addBreadcrumb$3 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer)
        .check();
  }

  static final _id_setUser = _class.staticMethodId(
    r'setUser',
    r'(Lio/sentry/protocol/User;)V',
  );

  static final _setUser = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void setUser(io.sentry.protocol.User user)`
  static void setUser(
    User? user,
  ) {
    final _$user = user?.reference ?? jni$_.jNullReference;
    _setUser(_class.reference.pointer, _id_setUser as jni$_.JMethodIDPtr,
            _$user.pointer)
        .check();
  }

  static final _id_clearBreadcrumbs = _class.staticMethodId(
    r'clearBreadcrumbs',
    r'()V',
  );

  static final _clearBreadcrumbs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public void clearBreadcrumbs()`
  static void clearBreadcrumbs() {
    _clearBreadcrumbs(_class.reference.pointer,
            _id_clearBreadcrumbs as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_setTag = _class.staticMethodId(
    r'setTag',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setTag = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void setTag(java.lang.String string, java.lang.String string1)`
  static void setTag(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setTag(_class.reference.pointer, _id_setTag as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  static final _id_removeTag = _class.staticMethodId(
    r'removeTag',
    r'(Ljava/lang/String;)V',
  );

  static final _removeTag = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void removeTag(java.lang.String string)`
  static void removeTag(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _removeTag(_class.reference.pointer, _id_removeTag as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_setExtra = _class.staticMethodId(
    r'setExtra',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setExtra = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void setExtra(java.lang.String string, java.lang.String string1)`
  static void setExtra(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setExtra(_class.reference.pointer, _id_setExtra as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  static final _id_removeExtra = _class.staticMethodId(
    r'removeExtra',
    r'(Ljava/lang/String;)V',
  );

  static final _removeExtra = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void removeExtra(java.lang.String string)`
  static void removeExtra(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _removeExtra(_class.reference.pointer,
            _id_removeExtra as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_configureScope = _class.staticMethodId(
    r'configureScope',
    r'(Lio/sentry/ScopeCallback;)V',
  );

  static final _configureScope = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void configureScope(io.sentry.ScopeCallback scopeCallback)`
  static void configureScope(
    ScopeCallback scopeCallback,
  ) {
    final _$scopeCallback = scopeCallback.reference;
    _configureScope(_class.reference.pointer,
            _id_configureScope as jni$_.JMethodIDPtr, _$scopeCallback.pointer)
        .check();
  }

  static final _id_configureScope$1 = _class.staticMethodId(
    r'configureScope',
    r'(Lio/sentry/ScopeType;Lio/sentry/ScopeCallback;)V',
  );

  static final _configureScope$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void configureScope(io.sentry.ScopeType scopeType, io.sentry.ScopeCallback scopeCallback)`
  static void configureScope$1(
    jni$_.JObject? scopeType,
    ScopeCallback scopeCallback,
  ) {
    final _$scopeType = scopeType?.reference ?? jni$_.jNullReference;
    final _$scopeCallback = scopeCallback.reference;
    _configureScope$1(
            _class.reference.pointer,
            _id_configureScope$1 as jni$_.JMethodIDPtr,
            _$scopeType.pointer,
            _$scopeCallback.pointer)
        .check();
  }
}

final class $Sentry$NullableType extends jni$_.JObjType<Sentry?> {
  @jni$_.internal
  const $Sentry$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Sentry;';

  @jni$_.internal
  @core$_.override
  Sentry? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Sentry.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Sentry?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Sentry$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Sentry$NullableType) &&
        other is $Sentry$NullableType;
  }
}

final class $Sentry$Type extends jni$_.JObjType<Sentry> {
  @jni$_.internal
  const $Sentry$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Sentry;';

  @jni$_.internal
  @core$_.override
  Sentry fromReference(jni$_.JReference reference) => Sentry.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Sentry?> get nullableType => const $Sentry$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Sentry$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Sentry$Type) && other is $Sentry$Type;
  }
}

/// from: `io.sentry.SentryOptions$BeforeBreadcrumbCallback`
class SentryOptions$BeforeBreadcrumbCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$BeforeBreadcrumbCallback> $type;

  @jni$_.internal
  SentryOptions$BeforeBreadcrumbCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryOptions$BeforeBreadcrumbCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $SentryOptions$BeforeBreadcrumbCallback$NullableType();
  static const type = $SentryOptions$BeforeBreadcrumbCallback$Type();
  static final _id_execute = _class.instanceMethodId(
    r'execute',
    r'(Lio/sentry/Breadcrumb;Lio/sentry/Hint;)Lio/sentry/Breadcrumb;',
  );

  static final _execute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract io.sentry.Breadcrumb execute(io.sentry.Breadcrumb breadcrumb, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  Breadcrumb? execute(
    Breadcrumb breadcrumb,
    Hint hint,
  ) {
    final _$breadcrumb = breadcrumb.reference;
    final _$hint = hint.reference;
    return _execute(reference.pointer, _id_execute as jni$_.JMethodIDPtr,
            _$breadcrumb.pointer, _$hint.pointer)
        .object<Breadcrumb?>(const $Breadcrumb$NullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SentryOptions$BeforeBreadcrumbCallback>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'execute(Lio/sentry/Breadcrumb;Lio/sentry/Hint;)Lio/sentry/Breadcrumb;') {
        final $r = _$impls[$p]!.execute(
          $a![0]!.as(const $Breadcrumb$Type(), releaseOriginal: true),
          $a![1]!.as(const $Hint$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $SentryOptions$BeforeBreadcrumbCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.SentryOptions$BeforeBreadcrumbCallback',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SentryOptions$BeforeBreadcrumbCallback.implement(
    $SentryOptions$BeforeBreadcrumbCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SentryOptions$BeforeBreadcrumbCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $SentryOptions$BeforeBreadcrumbCallback {
  factory $SentryOptions$BeforeBreadcrumbCallback({
    required Breadcrumb? Function(Breadcrumb breadcrumb, Hint hint) execute,
  }) = _$SentryOptions$BeforeBreadcrumbCallback;

  Breadcrumb? execute(Breadcrumb breadcrumb, Hint hint);
}

final class _$SentryOptions$BeforeBreadcrumbCallback
    with $SentryOptions$BeforeBreadcrumbCallback {
  _$SentryOptions$BeforeBreadcrumbCallback({
    required Breadcrumb? Function(Breadcrumb breadcrumb, Hint hint) execute,
  }) : _execute = execute;

  final Breadcrumb? Function(Breadcrumb breadcrumb, Hint hint) _execute;

  Breadcrumb? execute(Breadcrumb breadcrumb, Hint hint) {
    return _execute(breadcrumb, hint);
  }
}

final class $SentryOptions$BeforeBreadcrumbCallback$NullableType
    extends jni$_.JObjType<SentryOptions$BeforeBreadcrumbCallback?> {
  @jni$_.internal
  const $SentryOptions$BeforeBreadcrumbCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$BeforeBreadcrumbCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$BeforeBreadcrumbCallback? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$BeforeBreadcrumbCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$BeforeBreadcrumbCallback?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryOptions$BeforeBreadcrumbCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$BeforeBreadcrumbCallback$NullableType) &&
        other is $SentryOptions$BeforeBreadcrumbCallback$NullableType;
  }
}

final class $SentryOptions$BeforeBreadcrumbCallback$Type
    extends jni$_.JObjType<SentryOptions$BeforeBreadcrumbCallback> {
  @jni$_.internal
  const $SentryOptions$BeforeBreadcrumbCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$BeforeBreadcrumbCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$BeforeBreadcrumbCallback fromReference(
          jni$_.JReference reference) =>
      SentryOptions$BeforeBreadcrumbCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$BeforeBreadcrumbCallback?> get nullableType =>
      const $SentryOptions$BeforeBreadcrumbCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$BeforeBreadcrumbCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$BeforeBreadcrumbCallback$Type) &&
        other is $SentryOptions$BeforeBreadcrumbCallback$Type;
  }
}

/// from: `io.sentry.SentryOptions$BeforeEmitMetricCallback`
class SentryOptions$BeforeEmitMetricCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$BeforeEmitMetricCallback> $type;

  @jni$_.internal
  SentryOptions$BeforeEmitMetricCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryOptions$BeforeEmitMetricCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $SentryOptions$BeforeEmitMetricCallback$NullableType();
  static const type = $SentryOptions$BeforeEmitMetricCallback$Type();
  static final _id_execute = _class.instanceMethodId(
    r'execute',
    r'(Ljava/lang/String;Ljava/util/Map;)Z',
  );

  static final _execute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract boolean execute(java.lang.String string, java.util.Map<java.lang.String, java.lang.String> map)`
  bool execute(
    jni$_.JString string,
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) {
    final _$string = string.reference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _execute(reference.pointer, _id_execute as jni$_.JMethodIDPtr,
            _$string.pointer, _$map.pointer)
        .boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SentryOptions$BeforeEmitMetricCallback>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'execute(Ljava/lang/String;Ljava/util/Map;)Z') {
        final $r = _$impls[$p]!.execute(
          $a![0]!.as(const jni$_.JStringType(), releaseOriginal: true),
          $a![1]?.as(
              const jni$_.JMapType<jni$_.JString?, jni$_.JString?>(
                  jni$_.JStringNullableType(), jni$_.JStringNullableType()),
              releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $SentryOptions$BeforeEmitMetricCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.SentryOptions$BeforeEmitMetricCallback',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SentryOptions$BeforeEmitMetricCallback.implement(
    $SentryOptions$BeforeEmitMetricCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SentryOptions$BeforeEmitMetricCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $SentryOptions$BeforeEmitMetricCallback {
  factory $SentryOptions$BeforeEmitMetricCallback({
    required bool Function(jni$_.JString string,
            jni$_.JMap<jni$_.JString?, jni$_.JString?>? map)
        execute,
  }) = _$SentryOptions$BeforeEmitMetricCallback;

  bool execute(
      jni$_.JString string, jni$_.JMap<jni$_.JString?, jni$_.JString?>? map);
}

final class _$SentryOptions$BeforeEmitMetricCallback
    with $SentryOptions$BeforeEmitMetricCallback {
  _$SentryOptions$BeforeEmitMetricCallback({
    required bool Function(jni$_.JString string,
            jni$_.JMap<jni$_.JString?, jni$_.JString?>? map)
        execute,
  }) : _execute = execute;

  final bool Function(
          jni$_.JString string, jni$_.JMap<jni$_.JString?, jni$_.JString?>? map)
      _execute;

  bool execute(
      jni$_.JString string, jni$_.JMap<jni$_.JString?, jni$_.JString?>? map) {
    return _execute(string, map);
  }
}

final class $SentryOptions$BeforeEmitMetricCallback$NullableType
    extends jni$_.JObjType<SentryOptions$BeforeEmitMetricCallback?> {
  @jni$_.internal
  const $SentryOptions$BeforeEmitMetricCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$BeforeEmitMetricCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$BeforeEmitMetricCallback? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$BeforeEmitMetricCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$BeforeEmitMetricCallback?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryOptions$BeforeEmitMetricCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$BeforeEmitMetricCallback$NullableType) &&
        other is $SentryOptions$BeforeEmitMetricCallback$NullableType;
  }
}

final class $SentryOptions$BeforeEmitMetricCallback$Type
    extends jni$_.JObjType<SentryOptions$BeforeEmitMetricCallback> {
  @jni$_.internal
  const $SentryOptions$BeforeEmitMetricCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$BeforeEmitMetricCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$BeforeEmitMetricCallback fromReference(
          jni$_.JReference reference) =>
      SentryOptions$BeforeEmitMetricCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$BeforeEmitMetricCallback?> get nullableType =>
      const $SentryOptions$BeforeEmitMetricCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$BeforeEmitMetricCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$BeforeEmitMetricCallback$Type) &&
        other is $SentryOptions$BeforeEmitMetricCallback$Type;
  }
}

/// from: `io.sentry.SentryOptions$BeforeEnvelopeCallback`
class SentryOptions$BeforeEnvelopeCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$BeforeEnvelopeCallback> $type;

  @jni$_.internal
  SentryOptions$BeforeEnvelopeCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryOptions$BeforeEnvelopeCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $SentryOptions$BeforeEnvelopeCallback$NullableType();
  static const type = $SentryOptions$BeforeEnvelopeCallback$Type();
  static final _id_execute = _class.instanceMethodId(
    r'execute',
    r'(Lio/sentry/SentryEnvelope;Lio/sentry/Hint;)V',
  );

  static final _execute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void execute(io.sentry.SentryEnvelope sentryEnvelope, io.sentry.Hint hint)`
  void execute(
    jni$_.JObject sentryEnvelope,
    Hint? hint,
  ) {
    final _$sentryEnvelope = sentryEnvelope.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    _execute(reference.pointer, _id_execute as jni$_.JMethodIDPtr,
            _$sentryEnvelope.pointer, _$hint.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SentryOptions$BeforeEnvelopeCallback> _$impls =
      {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'execute(Lio/sentry/SentryEnvelope;Lio/sentry/Hint;)V') {
        _$impls[$p]!.execute(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![1]?.as(const $Hint$Type(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $SentryOptions$BeforeEnvelopeCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.SentryOptions$BeforeEnvelopeCallback',
      $p,
      _$invokePointer,
      [
        if ($impl.execute$async)
          r'execute(Lio/sentry/SentryEnvelope;Lio/sentry/Hint;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SentryOptions$BeforeEnvelopeCallback.implement(
    $SentryOptions$BeforeEnvelopeCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SentryOptions$BeforeEnvelopeCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $SentryOptions$BeforeEnvelopeCallback {
  factory $SentryOptions$BeforeEnvelopeCallback({
    required void Function(jni$_.JObject sentryEnvelope, Hint? hint) execute,
    bool execute$async,
  }) = _$SentryOptions$BeforeEnvelopeCallback;

  void execute(jni$_.JObject sentryEnvelope, Hint? hint);
  bool get execute$async => false;
}

final class _$SentryOptions$BeforeEnvelopeCallback
    with $SentryOptions$BeforeEnvelopeCallback {
  _$SentryOptions$BeforeEnvelopeCallback({
    required void Function(jni$_.JObject sentryEnvelope, Hint? hint) execute,
    this.execute$async = false,
  }) : _execute = execute;

  final void Function(jni$_.JObject sentryEnvelope, Hint? hint) _execute;
  final bool execute$async;

  void execute(jni$_.JObject sentryEnvelope, Hint? hint) {
    return _execute(sentryEnvelope, hint);
  }
}

final class $SentryOptions$BeforeEnvelopeCallback$NullableType
    extends jni$_.JObjType<SentryOptions$BeforeEnvelopeCallback?> {
  @jni$_.internal
  const $SentryOptions$BeforeEnvelopeCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$BeforeEnvelopeCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$BeforeEnvelopeCallback? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$BeforeEnvelopeCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$BeforeEnvelopeCallback?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryOptions$BeforeEnvelopeCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$BeforeEnvelopeCallback$NullableType) &&
        other is $SentryOptions$BeforeEnvelopeCallback$NullableType;
  }
}

final class $SentryOptions$BeforeEnvelopeCallback$Type
    extends jni$_.JObjType<SentryOptions$BeforeEnvelopeCallback> {
  @jni$_.internal
  const $SentryOptions$BeforeEnvelopeCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$BeforeEnvelopeCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$BeforeEnvelopeCallback fromReference(
          jni$_.JReference reference) =>
      SentryOptions$BeforeEnvelopeCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$BeforeEnvelopeCallback?> get nullableType =>
      const $SentryOptions$BeforeEnvelopeCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$BeforeEnvelopeCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$BeforeEnvelopeCallback$Type) &&
        other is $SentryOptions$BeforeEnvelopeCallback$Type;
  }
}

/// from: `io.sentry.SentryOptions$BeforeSendCallback`
class SentryOptions$BeforeSendCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$BeforeSendCallback> $type;

  @jni$_.internal
  SentryOptions$BeforeSendCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryOptions$BeforeSendCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryOptions$BeforeSendCallback$NullableType();
  static const type = $SentryOptions$BeforeSendCallback$Type();
  static final _id_execute = _class.instanceMethodId(
    r'execute',
    r'(Lio/sentry/SentryEvent;Lio/sentry/Hint;)Lio/sentry/SentryEvent;',
  );

  static final _execute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract io.sentry.SentryEvent execute(io.sentry.SentryEvent sentryEvent, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryEvent? execute(
    SentryEvent sentryEvent,
    Hint hint,
  ) {
    final _$sentryEvent = sentryEvent.reference;
    final _$hint = hint.reference;
    return _execute(reference.pointer, _id_execute as jni$_.JMethodIDPtr,
            _$sentryEvent.pointer, _$hint.pointer)
        .object<SentryEvent?>(const $SentryEvent$NullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SentryOptions$BeforeSendCallback> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'execute(Lio/sentry/SentryEvent;Lio/sentry/Hint;)Lio/sentry/SentryEvent;') {
        final $r = _$impls[$p]!.execute(
          $a![0]!.as(const $SentryEvent$Type(), releaseOriginal: true),
          $a![1]!.as(const $Hint$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $SentryOptions$BeforeSendCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.SentryOptions$BeforeSendCallback',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SentryOptions$BeforeSendCallback.implement(
    $SentryOptions$BeforeSendCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SentryOptions$BeforeSendCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $SentryOptions$BeforeSendCallback {
  factory $SentryOptions$BeforeSendCallback({
    required SentryEvent? Function(SentryEvent sentryEvent, Hint hint) execute,
  }) = _$SentryOptions$BeforeSendCallback;

  SentryEvent? execute(SentryEvent sentryEvent, Hint hint);
}

final class _$SentryOptions$BeforeSendCallback
    with $SentryOptions$BeforeSendCallback {
  _$SentryOptions$BeforeSendCallback({
    required SentryEvent? Function(SentryEvent sentryEvent, Hint hint) execute,
  }) : _execute = execute;

  final SentryEvent? Function(SentryEvent sentryEvent, Hint hint) _execute;

  SentryEvent? execute(SentryEvent sentryEvent, Hint hint) {
    return _execute(sentryEvent, hint);
  }
}

final class $SentryOptions$BeforeSendCallback$NullableType
    extends jni$_.JObjType<SentryOptions$BeforeSendCallback?> {
  @jni$_.internal
  const $SentryOptions$BeforeSendCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$BeforeSendCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$BeforeSendCallback? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$BeforeSendCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$BeforeSendCallback?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$BeforeSendCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$BeforeSendCallback$NullableType) &&
        other is $SentryOptions$BeforeSendCallback$NullableType;
  }
}

final class $SentryOptions$BeforeSendCallback$Type
    extends jni$_.JObjType<SentryOptions$BeforeSendCallback> {
  @jni$_.internal
  const $SentryOptions$BeforeSendCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$BeforeSendCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$BeforeSendCallback fromReference(jni$_.JReference reference) =>
      SentryOptions$BeforeSendCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$BeforeSendCallback?> get nullableType =>
      const $SentryOptions$BeforeSendCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$BeforeSendCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$BeforeSendCallback$Type) &&
        other is $SentryOptions$BeforeSendCallback$Type;
  }
}

/// from: `io.sentry.SentryOptions$BeforeSendReplayCallback`
class SentryOptions$BeforeSendReplayCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$BeforeSendReplayCallback> $type;

  @jni$_.internal
  SentryOptions$BeforeSendReplayCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryOptions$BeforeSendReplayCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $SentryOptions$BeforeSendReplayCallback$NullableType();
  static const type = $SentryOptions$BeforeSendReplayCallback$Type();
  static final _id_execute = _class.instanceMethodId(
    r'execute',
    r'(Lio/sentry/SentryReplayEvent;Lio/sentry/Hint;)Lio/sentry/SentryReplayEvent;',
  );

  static final _execute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract io.sentry.SentryReplayEvent execute(io.sentry.SentryReplayEvent sentryReplayEvent, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryReplayEvent? execute(
    SentryReplayEvent sentryReplayEvent,
    Hint hint,
  ) {
    final _$sentryReplayEvent = sentryReplayEvent.reference;
    final _$hint = hint.reference;
    return _execute(reference.pointer, _id_execute as jni$_.JMethodIDPtr,
            _$sentryReplayEvent.pointer, _$hint.pointer)
        .object<SentryReplayEvent?>(const $SentryReplayEvent$NullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SentryOptions$BeforeSendReplayCallback>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'execute(Lio/sentry/SentryReplayEvent;Lio/sentry/Hint;)Lio/sentry/SentryReplayEvent;') {
        final $r = _$impls[$p]!.execute(
          $a![0]!.as(const $SentryReplayEvent$Type(), releaseOriginal: true),
          $a![1]!.as(const $Hint$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $SentryOptions$BeforeSendReplayCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.SentryOptions$BeforeSendReplayCallback',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SentryOptions$BeforeSendReplayCallback.implement(
    $SentryOptions$BeforeSendReplayCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SentryOptions$BeforeSendReplayCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $SentryOptions$BeforeSendReplayCallback {
  factory $SentryOptions$BeforeSendReplayCallback({
    required SentryReplayEvent? Function(
            SentryReplayEvent sentryReplayEvent, Hint hint)
        execute,
  }) = _$SentryOptions$BeforeSendReplayCallback;

  SentryReplayEvent? execute(SentryReplayEvent sentryReplayEvent, Hint hint);
}

final class _$SentryOptions$BeforeSendReplayCallback
    with $SentryOptions$BeforeSendReplayCallback {
  _$SentryOptions$BeforeSendReplayCallback({
    required SentryReplayEvent? Function(
            SentryReplayEvent sentryReplayEvent, Hint hint)
        execute,
  }) : _execute = execute;

  final SentryReplayEvent? Function(
      SentryReplayEvent sentryReplayEvent, Hint hint) _execute;

  SentryReplayEvent? execute(SentryReplayEvent sentryReplayEvent, Hint hint) {
    return _execute(sentryReplayEvent, hint);
  }
}

final class $SentryOptions$BeforeSendReplayCallback$NullableType
    extends jni$_.JObjType<SentryOptions$BeforeSendReplayCallback?> {
  @jni$_.internal
  const $SentryOptions$BeforeSendReplayCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$BeforeSendReplayCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$BeforeSendReplayCallback? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$BeforeSendReplayCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$BeforeSendReplayCallback?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryOptions$BeforeSendReplayCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$BeforeSendReplayCallback$NullableType) &&
        other is $SentryOptions$BeforeSendReplayCallback$NullableType;
  }
}

final class $SentryOptions$BeforeSendReplayCallback$Type
    extends jni$_.JObjType<SentryOptions$BeforeSendReplayCallback> {
  @jni$_.internal
  const $SentryOptions$BeforeSendReplayCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$BeforeSendReplayCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$BeforeSendReplayCallback fromReference(
          jni$_.JReference reference) =>
      SentryOptions$BeforeSendReplayCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$BeforeSendReplayCallback?> get nullableType =>
      const $SentryOptions$BeforeSendReplayCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$BeforeSendReplayCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$BeforeSendReplayCallback$Type) &&
        other is $SentryOptions$BeforeSendReplayCallback$Type;
  }
}

/// from: `io.sentry.SentryOptions$BeforeSendTransactionCallback`
class SentryOptions$BeforeSendTransactionCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$BeforeSendTransactionCallback> $type;

  @jni$_.internal
  SentryOptions$BeforeSendTransactionCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'io/sentry/SentryOptions$BeforeSendTransactionCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $SentryOptions$BeforeSendTransactionCallback$NullableType();
  static const type = $SentryOptions$BeforeSendTransactionCallback$Type();
  static final _id_execute = _class.instanceMethodId(
    r'execute',
    r'(Lio/sentry/protocol/SentryTransaction;Lio/sentry/Hint;)Lio/sentry/protocol/SentryTransaction;',
  );

  static final _execute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract io.sentry.protocol.SentryTransaction execute(io.sentry.protocol.SentryTransaction sentryTransaction, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? execute(
    jni$_.JObject sentryTransaction,
    Hint hint,
  ) {
    final _$sentryTransaction = sentryTransaction.reference;
    final _$hint = hint.reference;
    return _execute(reference.pointer, _id_execute as jni$_.JMethodIDPtr,
            _$sentryTransaction.pointer, _$hint.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SentryOptions$BeforeSendTransactionCallback>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'execute(Lio/sentry/protocol/SentryTransaction;Lio/sentry/Hint;)Lio/sentry/protocol/SentryTransaction;') {
        final $r = _$impls[$p]!.execute(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![1]!.as(const $Hint$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $SentryOptions$BeforeSendTransactionCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.SentryOptions$BeforeSendTransactionCallback',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SentryOptions$BeforeSendTransactionCallback.implement(
    $SentryOptions$BeforeSendTransactionCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SentryOptions$BeforeSendTransactionCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $SentryOptions$BeforeSendTransactionCallback {
  factory $SentryOptions$BeforeSendTransactionCallback({
    required jni$_.JObject? Function(jni$_.JObject sentryTransaction, Hint hint)
        execute,
  }) = _$SentryOptions$BeforeSendTransactionCallback;

  jni$_.JObject? execute(jni$_.JObject sentryTransaction, Hint hint);
}

final class _$SentryOptions$BeforeSendTransactionCallback
    with $SentryOptions$BeforeSendTransactionCallback {
  _$SentryOptions$BeforeSendTransactionCallback({
    required jni$_.JObject? Function(jni$_.JObject sentryTransaction, Hint hint)
        execute,
  }) : _execute = execute;

  final jni$_.JObject? Function(jni$_.JObject sentryTransaction, Hint hint)
      _execute;

  jni$_.JObject? execute(jni$_.JObject sentryTransaction, Hint hint) {
    return _execute(sentryTransaction, hint);
  }
}

final class $SentryOptions$BeforeSendTransactionCallback$NullableType
    extends jni$_.JObjType<SentryOptions$BeforeSendTransactionCallback?> {
  @jni$_.internal
  const $SentryOptions$BeforeSendTransactionCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/SentryOptions$BeforeSendTransactionCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$BeforeSendTransactionCallback? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$BeforeSendTransactionCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$BeforeSendTransactionCallback?>
      get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryOptions$BeforeSendTransactionCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$BeforeSendTransactionCallback$NullableType) &&
        other is $SentryOptions$BeforeSendTransactionCallback$NullableType;
  }
}

final class $SentryOptions$BeforeSendTransactionCallback$Type
    extends jni$_.JObjType<SentryOptions$BeforeSendTransactionCallback> {
  @jni$_.internal
  const $SentryOptions$BeforeSendTransactionCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/SentryOptions$BeforeSendTransactionCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$BeforeSendTransactionCallback fromReference(
          jni$_.JReference reference) =>
      SentryOptions$BeforeSendTransactionCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$BeforeSendTransactionCallback?>
      get nullableType =>
          const $SentryOptions$BeforeSendTransactionCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryOptions$BeforeSendTransactionCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$BeforeSendTransactionCallback$Type) &&
        other is $SentryOptions$BeforeSendTransactionCallback$Type;
  }
}

/// from: `io.sentry.SentryOptions$Cron`
class SentryOptions$Cron extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$Cron> $type;

  @jni$_.internal
  SentryOptions$Cron.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/SentryOptions$Cron');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryOptions$Cron$NullableType();
  static const type = $SentryOptions$Cron$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryOptions$Cron() {
    return SentryOptions$Cron.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_getDefaultCheckinMargin = _class.instanceMethodId(
    r'getDefaultCheckinMargin',
    r'()Ljava/lang/Long;',
  );

  static final _getDefaultCheckinMargin = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Long getDefaultCheckinMargin()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getDefaultCheckinMargin() {
    return _getDefaultCheckinMargin(reference.pointer,
            _id_getDefaultCheckinMargin as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_setDefaultCheckinMargin = _class.instanceMethodId(
    r'setDefaultCheckinMargin',
    r'(Ljava/lang/Long;)V',
  );

  static final _setDefaultCheckinMargin = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDefaultCheckinMargin(java.lang.Long long)`
  void setDefaultCheckinMargin(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    _setDefaultCheckinMargin(reference.pointer,
            _id_setDefaultCheckinMargin as jni$_.JMethodIDPtr, _$long.pointer)
        .check();
  }

  static final _id_getDefaultMaxRuntime = _class.instanceMethodId(
    r'getDefaultMaxRuntime',
    r'()Ljava/lang/Long;',
  );

  static final _getDefaultMaxRuntime = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Long getDefaultMaxRuntime()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getDefaultMaxRuntime() {
    return _getDefaultMaxRuntime(
            reference.pointer, _id_getDefaultMaxRuntime as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_setDefaultMaxRuntime = _class.instanceMethodId(
    r'setDefaultMaxRuntime',
    r'(Ljava/lang/Long;)V',
  );

  static final _setDefaultMaxRuntime = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDefaultMaxRuntime(java.lang.Long long)`
  void setDefaultMaxRuntime(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    _setDefaultMaxRuntime(reference.pointer,
            _id_setDefaultMaxRuntime as jni$_.JMethodIDPtr, _$long.pointer)
        .check();
  }

  static final _id_getDefaultTimezone = _class.instanceMethodId(
    r'getDefaultTimezone',
    r'()Ljava/lang/String;',
  );

  static final _getDefaultTimezone = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getDefaultTimezone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDefaultTimezone() {
    return _getDefaultTimezone(
            reference.pointer, _id_getDefaultTimezone as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setDefaultTimezone = _class.instanceMethodId(
    r'setDefaultTimezone',
    r'(Ljava/lang/String;)V',
  );

  static final _setDefaultTimezone = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDefaultTimezone(java.lang.String string)`
  void setDefaultTimezone(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setDefaultTimezone(reference.pointer,
            _id_setDefaultTimezone as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_getDefaultFailureIssueThreshold = _class.instanceMethodId(
    r'getDefaultFailureIssueThreshold',
    r'()Ljava/lang/Long;',
  );

  static final _getDefaultFailureIssueThreshold =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public java.lang.Long getDefaultFailureIssueThreshold()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getDefaultFailureIssueThreshold() {
    return _getDefaultFailureIssueThreshold(reference.pointer,
            _id_getDefaultFailureIssueThreshold as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_setDefaultFailureIssueThreshold = _class.instanceMethodId(
    r'setDefaultFailureIssueThreshold',
    r'(Ljava/lang/Long;)V',
  );

  static final _setDefaultFailureIssueThreshold =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDefaultFailureIssueThreshold(java.lang.Long long)`
  void setDefaultFailureIssueThreshold(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    _setDefaultFailureIssueThreshold(
            reference.pointer,
            _id_setDefaultFailureIssueThreshold as jni$_.JMethodIDPtr,
            _$long.pointer)
        .check();
  }

  static final _id_getDefaultRecoveryThreshold = _class.instanceMethodId(
    r'getDefaultRecoveryThreshold',
    r'()Ljava/lang/Long;',
  );

  static final _getDefaultRecoveryThreshold =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public java.lang.Long getDefaultRecoveryThreshold()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getDefaultRecoveryThreshold() {
    return _getDefaultRecoveryThreshold(reference.pointer,
            _id_getDefaultRecoveryThreshold as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_setDefaultRecoveryThreshold = _class.instanceMethodId(
    r'setDefaultRecoveryThreshold',
    r'(Ljava/lang/Long;)V',
  );

  static final _setDefaultRecoveryThreshold =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDefaultRecoveryThreshold(java.lang.Long long)`
  void setDefaultRecoveryThreshold(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    _setDefaultRecoveryThreshold(
            reference.pointer,
            _id_setDefaultRecoveryThreshold as jni$_.JMethodIDPtr,
            _$long.pointer)
        .check();
  }
}

final class $SentryOptions$Cron$NullableType
    extends jni$_.JObjType<SentryOptions$Cron?> {
  @jni$_.internal
  const $SentryOptions$Cron$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$Cron;';

  @jni$_.internal
  @core$_.override
  SentryOptions$Cron? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$Cron.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$Cron?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$Cron$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$Cron$NullableType) &&
        other is $SentryOptions$Cron$NullableType;
  }
}

final class $SentryOptions$Cron$Type
    extends jni$_.JObjType<SentryOptions$Cron> {
  @jni$_.internal
  const $SentryOptions$Cron$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$Cron;';

  @jni$_.internal
  @core$_.override
  SentryOptions$Cron fromReference(jni$_.JReference reference) =>
      SentryOptions$Cron.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$Cron?> get nullableType =>
      const $SentryOptions$Cron$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$Cron$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$Cron$Type) &&
        other is $SentryOptions$Cron$Type;
  }
}

/// from: `io.sentry.SentryOptions$Logs$BeforeSendLogCallback`
class SentryOptions$Logs$BeforeSendLogCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$Logs$BeforeSendLogCallback> $type;

  @jni$_.internal
  SentryOptions$Logs$BeforeSendLogCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'io/sentry/SentryOptions$Logs$BeforeSendLogCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $SentryOptions$Logs$BeforeSendLogCallback$NullableType();
  static const type = $SentryOptions$Logs$BeforeSendLogCallback$Type();
  static final _id_execute = _class.instanceMethodId(
    r'execute',
    r'(Lio/sentry/SentryLogEvent;)Lio/sentry/SentryLogEvent;',
  );

  static final _execute = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract io.sentry.SentryLogEvent execute(io.sentry.SentryLogEvent sentryLogEvent)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? execute(
    jni$_.JObject sentryLogEvent,
  ) {
    final _$sentryLogEvent = sentryLogEvent.reference;
    return _execute(reference.pointer, _id_execute as jni$_.JMethodIDPtr,
            _$sentryLogEvent.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SentryOptions$Logs$BeforeSendLogCallback>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'execute(Lio/sentry/SentryLogEvent;)Lio/sentry/SentryLogEvent;') {
        final $r = _$impls[$p]!.execute(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $SentryOptions$Logs$BeforeSendLogCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.SentryOptions$Logs$BeforeSendLogCallback',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SentryOptions$Logs$BeforeSendLogCallback.implement(
    $SentryOptions$Logs$BeforeSendLogCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SentryOptions$Logs$BeforeSendLogCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $SentryOptions$Logs$BeforeSendLogCallback {
  factory $SentryOptions$Logs$BeforeSendLogCallback({
    required jni$_.JObject? Function(jni$_.JObject sentryLogEvent) execute,
  }) = _$SentryOptions$Logs$BeforeSendLogCallback;

  jni$_.JObject? execute(jni$_.JObject sentryLogEvent);
}

final class _$SentryOptions$Logs$BeforeSendLogCallback
    with $SentryOptions$Logs$BeforeSendLogCallback {
  _$SentryOptions$Logs$BeforeSendLogCallback({
    required jni$_.JObject? Function(jni$_.JObject sentryLogEvent) execute,
  }) : _execute = execute;

  final jni$_.JObject? Function(jni$_.JObject sentryLogEvent) _execute;

  jni$_.JObject? execute(jni$_.JObject sentryLogEvent) {
    return _execute(sentryLogEvent);
  }
}

final class $SentryOptions$Logs$BeforeSendLogCallback$NullableType
    extends jni$_.JObjType<SentryOptions$Logs$BeforeSendLogCallback?> {
  @jni$_.internal
  const $SentryOptions$Logs$BeforeSendLogCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/SentryOptions$Logs$BeforeSendLogCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$Logs$BeforeSendLogCallback? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$Logs$BeforeSendLogCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$Logs$BeforeSendLogCallback?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryOptions$Logs$BeforeSendLogCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$Logs$BeforeSendLogCallback$NullableType) &&
        other is $SentryOptions$Logs$BeforeSendLogCallback$NullableType;
  }
}

final class $SentryOptions$Logs$BeforeSendLogCallback$Type
    extends jni$_.JObjType<SentryOptions$Logs$BeforeSendLogCallback> {
  @jni$_.internal
  const $SentryOptions$Logs$BeforeSendLogCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/SentryOptions$Logs$BeforeSendLogCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$Logs$BeforeSendLogCallback fromReference(
          jni$_.JReference reference) =>
      SentryOptions$Logs$BeforeSendLogCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$Logs$BeforeSendLogCallback?> get nullableType =>
      const $SentryOptions$Logs$BeforeSendLogCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$Logs$BeforeSendLogCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$Logs$BeforeSendLogCallback$Type) &&
        other is $SentryOptions$Logs$BeforeSendLogCallback$Type;
  }
}

/// from: `io.sentry.SentryOptions$Logs`
class SentryOptions$Logs extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$Logs> $type;

  @jni$_.internal
  SentryOptions$Logs.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/SentryOptions$Logs');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryOptions$Logs$NullableType();
  static const type = $SentryOptions$Logs$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryOptions$Logs() {
    return SentryOptions$Logs.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_isEnabled = _class.instanceMethodId(
    r'isEnabled',
    r'()Z',
  );

  static final _isEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEnabled()`
  bool isEnabled() {
    return _isEnabled(reference.pointer, _id_isEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnabled = _class.instanceMethodId(
    r'setEnabled',
    r'(Z)V',
  );

  static final _setEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnabled(boolean z)`
  void setEnabled(
    bool z,
  ) {
    _setEnabled(
            reference.pointer, _id_setEnabled as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getBeforeSend = _class.instanceMethodId(
    r'getBeforeSend',
    r'()Lio/sentry/SentryOptions$Logs$BeforeSendLogCallback;',
  );

  static final _getBeforeSend = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryOptions$Logs$BeforeSendLogCallback getBeforeSend()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryOptions$Logs$BeforeSendLogCallback? getBeforeSend() {
    return _getBeforeSend(
            reference.pointer, _id_getBeforeSend as jni$_.JMethodIDPtr)
        .object<SentryOptions$Logs$BeforeSendLogCallback?>(
            const $SentryOptions$Logs$BeforeSendLogCallback$NullableType());
  }

  static final _id_setBeforeSend = _class.instanceMethodId(
    r'setBeforeSend',
    r'(Lio/sentry/SentryOptions$Logs$BeforeSendLogCallback;)V',
  );

  static final _setBeforeSend = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setBeforeSend(io.sentry.SentryOptions$Logs$BeforeSendLogCallback beforeSendLogCallback)`
  void setBeforeSend(
    SentryOptions$Logs$BeforeSendLogCallback? beforeSendLogCallback,
  ) {
    final _$beforeSendLogCallback =
        beforeSendLogCallback?.reference ?? jni$_.jNullReference;
    _setBeforeSend(reference.pointer, _id_setBeforeSend as jni$_.JMethodIDPtr,
            _$beforeSendLogCallback.pointer)
        .check();
  }
}

final class $SentryOptions$Logs$NullableType
    extends jni$_.JObjType<SentryOptions$Logs?> {
  @jni$_.internal
  const $SentryOptions$Logs$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$Logs;';

  @jni$_.internal
  @core$_.override
  SentryOptions$Logs? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$Logs.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$Logs?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$Logs$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$Logs$NullableType) &&
        other is $SentryOptions$Logs$NullableType;
  }
}

final class $SentryOptions$Logs$Type
    extends jni$_.JObjType<SentryOptions$Logs> {
  @jni$_.internal
  const $SentryOptions$Logs$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$Logs;';

  @jni$_.internal
  @core$_.override
  SentryOptions$Logs fromReference(jni$_.JReference reference) =>
      SentryOptions$Logs.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$Logs?> get nullableType =>
      const $SentryOptions$Logs$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$Logs$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$Logs$Type) &&
        other is $SentryOptions$Logs$Type;
  }
}

/// from: `io.sentry.SentryOptions$OnDiscardCallback`
class SentryOptions$OnDiscardCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$OnDiscardCallback> $type;

  @jni$_.internal
  SentryOptions$OnDiscardCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryOptions$OnDiscardCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryOptions$OnDiscardCallback$NullableType();
  static const type = $SentryOptions$OnDiscardCallback$Type();
  static final _id_execute = _class.instanceMethodId(
    r'execute',
    r'(Lio/sentry/clientreport/DiscardReason;Lio/sentry/DataCategory;Ljava/lang/Long;)V',
  );

  static final _execute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void execute(io.sentry.clientreport.DiscardReason discardReason, io.sentry.DataCategory dataCategory, java.lang.Long long)`
  void execute(
    jni$_.JObject discardReason,
    jni$_.JObject dataCategory,
    jni$_.JLong long,
  ) {
    final _$discardReason = discardReason.reference;
    final _$dataCategory = dataCategory.reference;
    final _$long = long.reference;
    _execute(reference.pointer, _id_execute as jni$_.JMethodIDPtr,
            _$discardReason.pointer, _$dataCategory.pointer, _$long.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SentryOptions$OnDiscardCallback> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'execute(Lio/sentry/clientreport/DiscardReason;Lio/sentry/DataCategory;Ljava/lang/Long;)V') {
        _$impls[$p]!.execute(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![1]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![2]!.as(const jni$_.JLongType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $SentryOptions$OnDiscardCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.SentryOptions$OnDiscardCallback',
      $p,
      _$invokePointer,
      [
        if ($impl.execute$async)
          r'execute(Lio/sentry/clientreport/DiscardReason;Lio/sentry/DataCategory;Ljava/lang/Long;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SentryOptions$OnDiscardCallback.implement(
    $SentryOptions$OnDiscardCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SentryOptions$OnDiscardCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $SentryOptions$OnDiscardCallback {
  factory $SentryOptions$OnDiscardCallback({
    required void Function(jni$_.JObject discardReason,
            jni$_.JObject dataCategory, jni$_.JLong long)
        execute,
    bool execute$async,
  }) = _$SentryOptions$OnDiscardCallback;

  void execute(jni$_.JObject discardReason, jni$_.JObject dataCategory,
      jni$_.JLong long);
  bool get execute$async => false;
}

final class _$SentryOptions$OnDiscardCallback
    with $SentryOptions$OnDiscardCallback {
  _$SentryOptions$OnDiscardCallback({
    required void Function(jni$_.JObject discardReason,
            jni$_.JObject dataCategory, jni$_.JLong long)
        execute,
    this.execute$async = false,
  }) : _execute = execute;

  final void Function(jni$_.JObject discardReason, jni$_.JObject dataCategory,
      jni$_.JLong long) _execute;
  final bool execute$async;

  void execute(jni$_.JObject discardReason, jni$_.JObject dataCategory,
      jni$_.JLong long) {
    return _execute(discardReason, dataCategory, long);
  }
}

final class $SentryOptions$OnDiscardCallback$NullableType
    extends jni$_.JObjType<SentryOptions$OnDiscardCallback?> {
  @jni$_.internal
  const $SentryOptions$OnDiscardCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$OnDiscardCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$OnDiscardCallback? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$OnDiscardCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$OnDiscardCallback?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$OnDiscardCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$OnDiscardCallback$NullableType) &&
        other is $SentryOptions$OnDiscardCallback$NullableType;
  }
}

final class $SentryOptions$OnDiscardCallback$Type
    extends jni$_.JObjType<SentryOptions$OnDiscardCallback> {
  @jni$_.internal
  const $SentryOptions$OnDiscardCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$OnDiscardCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$OnDiscardCallback fromReference(jni$_.JReference reference) =>
      SentryOptions$OnDiscardCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$OnDiscardCallback?> get nullableType =>
      const $SentryOptions$OnDiscardCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$OnDiscardCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$OnDiscardCallback$Type) &&
        other is $SentryOptions$OnDiscardCallback$Type;
  }
}

/// from: `io.sentry.SentryOptions$ProfilesSamplerCallback`
class SentryOptions$ProfilesSamplerCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$ProfilesSamplerCallback> $type;

  @jni$_.internal
  SentryOptions$ProfilesSamplerCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryOptions$ProfilesSamplerCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $SentryOptions$ProfilesSamplerCallback$NullableType();
  static const type = $SentryOptions$ProfilesSamplerCallback$Type();
  static final _id_sample = _class.instanceMethodId(
    r'sample',
    r'(Lio/sentry/SamplingContext;)Ljava/lang/Double;',
  );

  static final _sample = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Double sample(io.sentry.SamplingContext samplingContext)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? sample(
    jni$_.JObject samplingContext,
  ) {
    final _$samplingContext = samplingContext.reference;
    return _sample(reference.pointer, _id_sample as jni$_.JMethodIDPtr,
            _$samplingContext.pointer)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SentryOptions$ProfilesSamplerCallback> _$impls =
      {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'sample(Lio/sentry/SamplingContext;)Ljava/lang/Double;') {
        final $r = _$impls[$p]!.sample(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $SentryOptions$ProfilesSamplerCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.SentryOptions$ProfilesSamplerCallback',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SentryOptions$ProfilesSamplerCallback.implement(
    $SentryOptions$ProfilesSamplerCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SentryOptions$ProfilesSamplerCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $SentryOptions$ProfilesSamplerCallback {
  factory $SentryOptions$ProfilesSamplerCallback({
    required jni$_.JDouble? Function(jni$_.JObject samplingContext) sample,
  }) = _$SentryOptions$ProfilesSamplerCallback;

  jni$_.JDouble? sample(jni$_.JObject samplingContext);
}

final class _$SentryOptions$ProfilesSamplerCallback
    with $SentryOptions$ProfilesSamplerCallback {
  _$SentryOptions$ProfilesSamplerCallback({
    required jni$_.JDouble? Function(jni$_.JObject samplingContext) sample,
  }) : _sample = sample;

  final jni$_.JDouble? Function(jni$_.JObject samplingContext) _sample;

  jni$_.JDouble? sample(jni$_.JObject samplingContext) {
    return _sample(samplingContext);
  }
}

final class $SentryOptions$ProfilesSamplerCallback$NullableType
    extends jni$_.JObjType<SentryOptions$ProfilesSamplerCallback?> {
  @jni$_.internal
  const $SentryOptions$ProfilesSamplerCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$ProfilesSamplerCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$ProfilesSamplerCallback? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$ProfilesSamplerCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$ProfilesSamplerCallback?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryOptions$ProfilesSamplerCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$ProfilesSamplerCallback$NullableType) &&
        other is $SentryOptions$ProfilesSamplerCallback$NullableType;
  }
}

final class $SentryOptions$ProfilesSamplerCallback$Type
    extends jni$_.JObjType<SentryOptions$ProfilesSamplerCallback> {
  @jni$_.internal
  const $SentryOptions$ProfilesSamplerCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$ProfilesSamplerCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$ProfilesSamplerCallback fromReference(
          jni$_.JReference reference) =>
      SentryOptions$ProfilesSamplerCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$ProfilesSamplerCallback?> get nullableType =>
      const $SentryOptions$ProfilesSamplerCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$ProfilesSamplerCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$ProfilesSamplerCallback$Type) &&
        other is $SentryOptions$ProfilesSamplerCallback$Type;
  }
}

/// from: `io.sentry.SentryOptions$Proxy`
class SentryOptions$Proxy extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$Proxy> $type;

  @jni$_.internal
  SentryOptions$Proxy.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/SentryOptions$Proxy');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryOptions$Proxy$NullableType();
  static const type = $SentryOptions$Proxy$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryOptions$Proxy() {
    return SentryOptions$Proxy.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryOptions$Proxy.new$1(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return SentryOptions$Proxy.fromReference(_new$1(
            _class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer)
        .reference);
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/net/Proxy$Type;)V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1, java.net.Proxy$Type type)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryOptions$Proxy.new$2(
    jni$_.JString? string,
    jni$_.JString? string1,
    Proxy$Type? type,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$type = type?.reference ?? jni$_.jNullReference;
    return SentryOptions$Proxy.fromReference(_new$2(
            _class.reference.pointer,
            _id_new$2 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$type.pointer)
        .reference);
  }

  static final _id_new$3 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryOptions$Proxy.new$3(
    jni$_.JString? string,
    jni$_.JString? string1,
    jni$_.JString? string2,
    jni$_.JString? string3,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    final _$string3 = string3?.reference ?? jni$_.jNullReference;
    return SentryOptions$Proxy.fromReference(_new$3(
            _class.reference.pointer,
            _id_new$3 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$string2.pointer,
            _$string3.pointer)
        .reference);
  }

  static final _id_new$4 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/net/Proxy$Type;Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1, java.net.Proxy$Type type, java.lang.String string2, java.lang.String string3)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryOptions$Proxy.new$4(
    jni$_.JString? string,
    jni$_.JString? string1,
    Proxy$Type? type,
    jni$_.JString? string2,
    jni$_.JString? string3,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$type = type?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    final _$string3 = string3?.reference ?? jni$_.jNullReference;
    return SentryOptions$Proxy.fromReference(_new$4(
            _class.reference.pointer,
            _id_new$4 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$type.pointer,
            _$string2.pointer,
            _$string3.pointer)
        .reference);
  }

  static final _id_setHost = _class.instanceMethodId(
    r'setHost',
    r'(Ljava/lang/String;)V',
  );

  static final _setHost = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setHost(java.lang.String string)`
  void setHost(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setHost(reference.pointer, _id_setHost as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_setPort = _class.instanceMethodId(
    r'setPort',
    r'(Ljava/lang/String;)V',
  );

  static final _setPort = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setPort(java.lang.String string)`
  void setPort(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setPort(reference.pointer, _id_setPort as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_setUser = _class.instanceMethodId(
    r'setUser',
    r'(Ljava/lang/String;)V',
  );

  static final _setUser = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setUser(java.lang.String string)`
  void setUser(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setUser(reference.pointer, _id_setUser as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_setPass = _class.instanceMethodId(
    r'setPass',
    r'(Ljava/lang/String;)V',
  );

  static final _setPass = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setPass(java.lang.String string)`
  void setPass(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setPass(reference.pointer, _id_setPass as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_setType = _class.instanceMethodId(
    r'setType',
    r'(Ljava/net/Proxy$Type;)V',
  );

  static final _setType = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setType(java.net.Proxy$Type type)`
  void setType(
    Proxy$Type? type,
  ) {
    final _$type = type?.reference ?? jni$_.jNullReference;
    _setType(reference.pointer, _id_setType as jni$_.JMethodIDPtr,
            _$type.pointer)
        .check();
  }
}

final class $SentryOptions$Proxy$NullableType
    extends jni$_.JObjType<SentryOptions$Proxy?> {
  @jni$_.internal
  const $SentryOptions$Proxy$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$Proxy;';

  @jni$_.internal
  @core$_.override
  SentryOptions$Proxy? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$Proxy.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$Proxy?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$Proxy$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$Proxy$NullableType) &&
        other is $SentryOptions$Proxy$NullableType;
  }
}

final class $SentryOptions$Proxy$Type
    extends jni$_.JObjType<SentryOptions$Proxy> {
  @jni$_.internal
  const $SentryOptions$Proxy$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$Proxy;';

  @jni$_.internal
  @core$_.override
  SentryOptions$Proxy fromReference(jni$_.JReference reference) =>
      SentryOptions$Proxy.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$Proxy?> get nullableType =>
      const $SentryOptions$Proxy$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$Proxy$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$Proxy$Type) &&
        other is $SentryOptions$Proxy$Type;
  }
}

/// from: `io.sentry.SentryOptions$RequestSize`
class SentryOptions$RequestSize extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$RequestSize> $type;

  @jni$_.internal
  SentryOptions$RequestSize.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryOptions$RequestSize');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryOptions$RequestSize$NullableType();
  static const type = $SentryOptions$RequestSize$Type();
  static final _id_NONE = _class.staticFieldId(
    r'NONE',
    r'Lio/sentry/SentryOptions$RequestSize;',
  );

  /// from: `static public final io.sentry.SentryOptions$RequestSize NONE`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryOptions$RequestSize get NONE =>
      _id_NONE.get(_class, const $SentryOptions$RequestSize$Type());

  static final _id_SMALL = _class.staticFieldId(
    r'SMALL',
    r'Lio/sentry/SentryOptions$RequestSize;',
  );

  /// from: `static public final io.sentry.SentryOptions$RequestSize SMALL`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryOptions$RequestSize get SMALL =>
      _id_SMALL.get(_class, const $SentryOptions$RequestSize$Type());

  static final _id_MEDIUM = _class.staticFieldId(
    r'MEDIUM',
    r'Lio/sentry/SentryOptions$RequestSize;',
  );

  /// from: `static public final io.sentry.SentryOptions$RequestSize MEDIUM`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryOptions$RequestSize get MEDIUM =>
      _id_MEDIUM.get(_class, const $SentryOptions$RequestSize$Type());

  static final _id_ALWAYS = _class.staticFieldId(
    r'ALWAYS',
    r'Lio/sentry/SentryOptions$RequestSize;',
  );

  /// from: `static public final io.sentry.SentryOptions$RequestSize ALWAYS`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryOptions$RequestSize get ALWAYS =>
      _id_ALWAYS.get(_class, const $SentryOptions$RequestSize$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Lio/sentry/SentryOptions$RequestSize;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.SentryOptions$RequestSize[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<SentryOptions$RequestSize?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<SentryOptions$RequestSize?>?>(
            const jni$_.JArrayNullableType<SentryOptions$RequestSize?>(
                $SentryOptions$RequestSize$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Lio/sentry/SentryOptions$RequestSize;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.SentryOptions$RequestSize valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryOptions$RequestSize? valueOf(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<SentryOptions$RequestSize?>(
            const $SentryOptions$RequestSize$NullableType());
  }
}

final class $SentryOptions$RequestSize$NullableType
    extends jni$_.JObjType<SentryOptions$RequestSize?> {
  @jni$_.internal
  const $SentryOptions$RequestSize$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$RequestSize;';

  @jni$_.internal
  @core$_.override
  SentryOptions$RequestSize? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$RequestSize.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$RequestSize?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$RequestSize$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$RequestSize$NullableType) &&
        other is $SentryOptions$RequestSize$NullableType;
  }
}

final class $SentryOptions$RequestSize$Type
    extends jni$_.JObjType<SentryOptions$RequestSize> {
  @jni$_.internal
  const $SentryOptions$RequestSize$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$RequestSize;';

  @jni$_.internal
  @core$_.override
  SentryOptions$RequestSize fromReference(jni$_.JReference reference) =>
      SentryOptions$RequestSize.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$RequestSize?> get nullableType =>
      const $SentryOptions$RequestSize$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$RequestSize$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$RequestSize$Type) &&
        other is $SentryOptions$RequestSize$Type;
  }
}

/// from: `io.sentry.SentryOptions$TracesSamplerCallback`
class SentryOptions$TracesSamplerCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$TracesSamplerCallback> $type;

  @jni$_.internal
  SentryOptions$TracesSamplerCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryOptions$TracesSamplerCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $SentryOptions$TracesSamplerCallback$NullableType();
  static const type = $SentryOptions$TracesSamplerCallback$Type();
  static final _id_sample = _class.instanceMethodId(
    r'sample',
    r'(Lio/sentry/SamplingContext;)Ljava/lang/Double;',
  );

  static final _sample = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Double sample(io.sentry.SamplingContext samplingContext)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? sample(
    jni$_.JObject samplingContext,
  ) {
    final _$samplingContext = samplingContext.reference;
    return _sample(reference.pointer, _id_sample as jni$_.JMethodIDPtr,
            _$samplingContext.pointer)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SentryOptions$TracesSamplerCallback> _$impls =
      {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'sample(Lio/sentry/SamplingContext;)Ljava/lang/Double;') {
        final $r = _$impls[$p]!.sample(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $SentryOptions$TracesSamplerCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.SentryOptions$TracesSamplerCallback',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SentryOptions$TracesSamplerCallback.implement(
    $SentryOptions$TracesSamplerCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SentryOptions$TracesSamplerCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $SentryOptions$TracesSamplerCallback {
  factory $SentryOptions$TracesSamplerCallback({
    required jni$_.JDouble? Function(jni$_.JObject samplingContext) sample,
  }) = _$SentryOptions$TracesSamplerCallback;

  jni$_.JDouble? sample(jni$_.JObject samplingContext);
}

final class _$SentryOptions$TracesSamplerCallback
    with $SentryOptions$TracesSamplerCallback {
  _$SentryOptions$TracesSamplerCallback({
    required jni$_.JDouble? Function(jni$_.JObject samplingContext) sample,
  }) : _sample = sample;

  final jni$_.JDouble? Function(jni$_.JObject samplingContext) _sample;

  jni$_.JDouble? sample(jni$_.JObject samplingContext) {
    return _sample(samplingContext);
  }
}

final class $SentryOptions$TracesSamplerCallback$NullableType
    extends jni$_.JObjType<SentryOptions$TracesSamplerCallback?> {
  @jni$_.internal
  const $SentryOptions$TracesSamplerCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$TracesSamplerCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$TracesSamplerCallback? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$TracesSamplerCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$TracesSamplerCallback?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryOptions$TracesSamplerCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$TracesSamplerCallback$NullableType) &&
        other is $SentryOptions$TracesSamplerCallback$NullableType;
  }
}

final class $SentryOptions$TracesSamplerCallback$Type
    extends jni$_.JObjType<SentryOptions$TracesSamplerCallback> {
  @jni$_.internal
  const $SentryOptions$TracesSamplerCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$TracesSamplerCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$TracesSamplerCallback fromReference(
          jni$_.JReference reference) =>
      SentryOptions$TracesSamplerCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$TracesSamplerCallback?> get nullableType =>
      const $SentryOptions$TracesSamplerCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$TracesSamplerCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$TracesSamplerCallback$Type) &&
        other is $SentryOptions$TracesSamplerCallback$Type;
  }
}

/// from: `io.sentry.SentryOptions`
class SentryOptions extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions> $type;

  @jni$_.internal
  SentryOptions.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/SentryOptions');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryOptions$NullableType();
  static const type = $SentryOptions$Type();
  static final _id_setDsn = _class.instanceMethodId(
    r'setDsn',
    r'(Ljava/lang/String;)V',
  );

  static final _setDsn = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDsn(java.lang.String string)`
  void setDsn(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setDsn(reference.pointer, _id_setDsn as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_setDebug = _class.instanceMethodId(
    r'setDebug',
    r'(Z)V',
  );

  static final _setDebug = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setDebug(boolean z)`
  void setDebug(
    bool z,
  ) {
    _setDebug(reference.pointer, _id_setDebug as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_setDiagnosticLevel = _class.instanceMethodId(
    r'setDiagnosticLevel',
    r'(Lio/sentry/SentryLevel;)V',
  );

  static final _setDiagnosticLevel = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDiagnosticLevel(io.sentry.SentryLevel sentryLevel)`
  void setDiagnosticLevel(
    SentryLevel? sentryLevel,
  ) {
    final _$sentryLevel = sentryLevel?.reference ?? jni$_.jNullReference;
    _setDiagnosticLevel(reference.pointer,
            _id_setDiagnosticLevel as jni$_.JMethodIDPtr, _$sentryLevel.pointer)
        .check();
  }

  static final _id_setSentryClientName = _class.instanceMethodId(
    r'setSentryClientName',
    r'(Ljava/lang/String;)V',
  );

  static final _setSentryClientName = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setSentryClientName(java.lang.String string)`
  void setSentryClientName(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setSentryClientName(reference.pointer,
            _id_setSentryClientName as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_setBeforeSend = _class.instanceMethodId(
    r'setBeforeSend',
    r'(Lio/sentry/SentryOptions$BeforeSendCallback;)V',
  );

  static final _setBeforeSend = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setBeforeSend(io.sentry.SentryOptions$BeforeSendCallback beforeSendCallback)`
  void setBeforeSend(
    SentryOptions$BeforeSendCallback? beforeSendCallback,
  ) {
    final _$beforeSendCallback =
        beforeSendCallback?.reference ?? jni$_.jNullReference;
    _setBeforeSend(reference.pointer, _id_setBeforeSend as jni$_.JMethodIDPtr,
            _$beforeSendCallback.pointer)
        .check();
  }

  static final _id_setBeforeSendReplay = _class.instanceMethodId(
    r'setBeforeSendReplay',
    r'(Lio/sentry/SentryOptions$BeforeSendReplayCallback;)V',
  );

  static final _setBeforeSendReplay = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setBeforeSendReplay(io.sentry.SentryOptions$BeforeSendReplayCallback beforeSendReplayCallback)`
  void setBeforeSendReplay(
    SentryOptions$BeforeSendReplayCallback? beforeSendReplayCallback,
  ) {
    final _$beforeSendReplayCallback =
        beforeSendReplayCallback?.reference ?? jni$_.jNullReference;
    _setBeforeSendReplay(
            reference.pointer,
            _id_setBeforeSendReplay as jni$_.JMethodIDPtr,
            _$beforeSendReplayCallback.pointer)
        .check();
  }

  static final _id_setMaxBreadcrumbs = _class.instanceMethodId(
    r'setMaxBreadcrumbs',
    r'(I)V',
  );

  static final _setMaxBreadcrumbs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setMaxBreadcrumbs(int i)`
  void setMaxBreadcrumbs(
    int i,
  ) {
    _setMaxBreadcrumbs(
            reference.pointer, _id_setMaxBreadcrumbs as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_setRelease = _class.instanceMethodId(
    r'setRelease',
    r'(Ljava/lang/String;)V',
  );

  static final _setRelease = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setRelease(java.lang.String string)`
  void setRelease(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setRelease(reference.pointer, _id_setRelease as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_setEnvironment = _class.instanceMethodId(
    r'setEnvironment',
    r'(Ljava/lang/String;)V',
  );

  static final _setEnvironment = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setEnvironment(java.lang.String string)`
  void setEnvironment(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setEnvironment(reference.pointer, _id_setEnvironment as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_setProxy = _class.instanceMethodId(
    r'setProxy',
    r'(Lio/sentry/SentryOptions$Proxy;)V',
  );

  static final _setProxy = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setProxy(io.sentry.SentryOptions$Proxy proxy)`
  void setProxy(
    SentryOptions$Proxy? proxy,
  ) {
    final _$proxy = proxy?.reference ?? jni$_.jNullReference;
    _setProxy(reference.pointer, _id_setProxy as jni$_.JMethodIDPtr,
            _$proxy.pointer)
        .check();
  }

  static final _id_setDist = _class.instanceMethodId(
    r'setDist',
    r'(Ljava/lang/String;)V',
  );

  static final _setDist = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDist(java.lang.String string)`
  void setDist(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setDist(reference.pointer, _id_setDist as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_setAttachStacktrace = _class.instanceMethodId(
    r'setAttachStacktrace',
    r'(Z)V',
  );

  static final _setAttachStacktrace = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setAttachStacktrace(boolean z)`
  void setAttachStacktrace(
    bool z,
  ) {
    _setAttachStacktrace(reference.pointer,
            _id_setAttachStacktrace as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_setAttachThreads = _class.instanceMethodId(
    r'setAttachThreads',
    r'(Z)V',
  );

  static final _setAttachThreads = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setAttachThreads(boolean z)`
  void setAttachThreads(
    bool z,
  ) {
    _setAttachThreads(reference.pointer,
            _id_setAttachThreads as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_setEnableAutoSessionTracking = _class.instanceMethodId(
    r'setEnableAutoSessionTracking',
    r'(Z)V',
  );

  static final _setEnableAutoSessionTracking =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableAutoSessionTracking(boolean z)`
  void setEnableAutoSessionTracking(
    bool z,
  ) {
    _setEnableAutoSessionTracking(reference.pointer,
            _id_setEnableAutoSessionTracking as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_setSessionTrackingIntervalMillis = _class.instanceMethodId(
    r'setSessionTrackingIntervalMillis',
    r'(J)V',
  );

  static final _setSessionTrackingIntervalMillis =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setSessionTrackingIntervalMillis(long j)`
  void setSessionTrackingIntervalMillis(
    int j,
  ) {
    _setSessionTrackingIntervalMillis(reference.pointer,
            _id_setSessionTrackingIntervalMillis as jni$_.JMethodIDPtr, j)
        .check();
  }

  static final _id_setEnableUncaughtExceptionHandler = _class.instanceMethodId(
    r'setEnableUncaughtExceptionHandler',
    r'(Z)V',
  );

  static final _setEnableUncaughtExceptionHandler =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableUncaughtExceptionHandler(boolean z)`
  void setEnableUncaughtExceptionHandler(
    bool z,
  ) {
    _setEnableUncaughtExceptionHandler(
            reference.pointer,
            _id_setEnableUncaughtExceptionHandler as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_setConnectionTimeoutMillis = _class.instanceMethodId(
    r'setConnectionTimeoutMillis',
    r'(I)V',
  );

  static final _setConnectionTimeoutMillis =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setConnectionTimeoutMillis(int i)`
  void setConnectionTimeoutMillis(
    int i,
  ) {
    _setConnectionTimeoutMillis(reference.pointer,
            _id_setConnectionTimeoutMillis as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_setReadTimeoutMillis = _class.instanceMethodId(
    r'setReadTimeoutMillis',
    r'(I)V',
  );

  static final _setReadTimeoutMillis = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setReadTimeoutMillis(int i)`
  void setReadTimeoutMillis(
    int i,
  ) {
    _setReadTimeoutMillis(reference.pointer,
            _id_setReadTimeoutMillis as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_getSdkVersion = _class.instanceMethodId(
    r'getSdkVersion',
    r'()Lio/sentry/protocol/SdkVersion;',
  );

  static final _getSdkVersion = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.SdkVersion getSdkVersion()`
  /// The returned object must be released after use, by calling the [release] method.
  SdkVersion? getSdkVersion() {
    return _getSdkVersion(
            reference.pointer, _id_getSdkVersion as jni$_.JMethodIDPtr)
        .object<SdkVersion?>(const $SdkVersion$NullableType());
  }

  static final _id_setSendDefaultPii = _class.instanceMethodId(
    r'setSendDefaultPii',
    r'(Z)V',
  );

  static final _setSendDefaultPii = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setSendDefaultPii(boolean z)`
  void setSendDefaultPii(
    bool z,
  ) {
    _setSendDefaultPii(reference.pointer,
            _id_setSendDefaultPii as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_setMaxAttachmentSize = _class.instanceMethodId(
    r'setMaxAttachmentSize',
    r'(J)V',
  );

  static final _setMaxAttachmentSize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setMaxAttachmentSize(long j)`
  void setMaxAttachmentSize(
    int j,
  ) {
    _setMaxAttachmentSize(reference.pointer,
            _id_setMaxAttachmentSize as jni$_.JMethodIDPtr, j)
        .check();
  }

  static final _id_setMaxCacheItems = _class.instanceMethodId(
    r'setMaxCacheItems',
    r'(I)V',
  );

  static final _setMaxCacheItems = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setMaxCacheItems(int i)`
  void setMaxCacheItems(
    int i,
  ) {
    _setMaxCacheItems(
            reference.pointer, _id_setMaxCacheItems as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_setProguardUuid = _class.instanceMethodId(
    r'setProguardUuid',
    r'(Ljava/lang/String;)V',
  );

  static final _setProguardUuid = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setProguardUuid(java.lang.String string)`
  void setProguardUuid(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setProguardUuid(reference.pointer,
            _id_setProguardUuid as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_setSendClientReports = _class.instanceMethodId(
    r'setSendClientReports',
    r'(Z)V',
  );

  static final _setSendClientReports = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setSendClientReports(boolean z)`
  void setSendClientReports(
    bool z,
  ) {
    _setSendClientReports(reference.pointer,
            _id_setSendClientReports as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_setEnableUserInteractionBreadcrumbs =
      _class.instanceMethodId(
    r'setEnableUserInteractionBreadcrumbs',
    r'(Z)V',
  );

  static final _setEnableUserInteractionBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableUserInteractionBreadcrumbs(boolean z)`
  void setEnableUserInteractionBreadcrumbs(
    bool z,
  ) {
    _setEnableUserInteractionBreadcrumbs(
            reference.pointer,
            _id_setEnableUserInteractionBreadcrumbs as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_setSpotlightConnectionUrl = _class.instanceMethodId(
    r'setSpotlightConnectionUrl',
    r'(Ljava/lang/String;)V',
  );

  static final _setSpotlightConnectionUrl = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setSpotlightConnectionUrl(java.lang.String string)`
  void setSpotlightConnectionUrl(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setSpotlightConnectionUrl(
            reference.pointer,
            _id_setSpotlightConnectionUrl as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_setEnableSpotlight = _class.instanceMethodId(
    r'setEnableSpotlight',
    r'(Z)V',
  );

  static final _setEnableSpotlight = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableSpotlight(boolean z)`
  void setEnableSpotlight(
    bool z,
  ) {
    _setEnableSpotlight(reference.pointer,
            _id_setEnableSpotlight as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getSessionReplay = _class.instanceMethodId(
    r'getSessionReplay',
    r'()Lio/sentry/SentryReplayOptions;',
  );

  static final _getSessionReplay = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryReplayOptions getSessionReplay()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryReplayOptions getSessionReplay() {
    return _getSessionReplay(
            reference.pointer, _id_getSessionReplay as jni$_.JMethodIDPtr)
        .object<SentryReplayOptions>(const $SentryReplayOptions$Type());
  }
}

final class $SentryOptions$NullableType extends jni$_.JObjType<SentryOptions?> {
  @jni$_.internal
  const $SentryOptions$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions;';

  @jni$_.internal
  @core$_.override
  SentryOptions? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : SentryOptions.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$NullableType) &&
        other is $SentryOptions$NullableType;
  }
}

final class $SentryOptions$Type extends jni$_.JObjType<SentryOptions> {
  @jni$_.internal
  const $SentryOptions$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions;';

  @jni$_.internal
  @core$_.override
  SentryOptions fromReference(jni$_.JReference reference) =>
      SentryOptions.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions?> get nullableType =>
      const $SentryOptions$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$Type) &&
        other is $SentryOptions$Type;
  }
}

/// from: `io.sentry.protocol.User$Deserializer`
class User$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<User$Deserializer> $type;

  @jni$_.internal
  User$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/protocol/User$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $User$Deserializer$NullableType();
  static const type = $User$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory User$Deserializer() {
    return User$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserialize = _class.instanceMethodId(
    r'deserialize',
    r'(Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Lio/sentry/protocol/User;',
  );

  static final _deserialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.User deserialize(io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  /// The returned object must be released after use, by calling the [release] method.
  User deserialize(
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserialize(
            reference.pointer,
            _id_deserialize as jni$_.JMethodIDPtr,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .object<User>(const $User$Type());
  }
}

final class $User$Deserializer$NullableType
    extends jni$_.JObjType<User$Deserializer?> {
  @jni$_.internal
  const $User$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/User$Deserializer;';

  @jni$_.internal
  @core$_.override
  User$Deserializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : User$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<User$Deserializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($User$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($User$Deserializer$NullableType) &&
        other is $User$Deserializer$NullableType;
  }
}

final class $User$Deserializer$Type extends jni$_.JObjType<User$Deserializer> {
  @jni$_.internal
  const $User$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/User$Deserializer;';

  @jni$_.internal
  @core$_.override
  User$Deserializer fromReference(jni$_.JReference reference) =>
      User$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<User$Deserializer?> get nullableType =>
      const $User$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($User$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($User$Deserializer$Type) &&
        other is $User$Deserializer$Type;
  }
}

/// from: `io.sentry.protocol.User$JsonKeys`
class User$JsonKeys extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<User$JsonKeys> $type;

  @jni$_.internal
  User$JsonKeys.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/protocol/User$JsonKeys');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $User$JsonKeys$NullableType();
  static const type = $User$JsonKeys$Type();
  static final _id_EMAIL = _class.staticFieldId(
    r'EMAIL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EMAIL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EMAIL =>
      _id_EMAIL.get(_class, const jni$_.JStringNullableType());

  static final _id_ID = _class.staticFieldId(
    r'ID',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ID`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ID =>
      _id_ID.get(_class, const jni$_.JStringNullableType());

  static final _id_USERNAME = _class.staticFieldId(
    r'USERNAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String USERNAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get USERNAME =>
      _id_USERNAME.get(_class, const jni$_.JStringNullableType());

  static final _id_IP_ADDRESS = _class.staticFieldId(
    r'IP_ADDRESS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String IP_ADDRESS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get IP_ADDRESS =>
      _id_IP_ADDRESS.get(_class, const jni$_.JStringNullableType());

  static final _id_NAME = _class.staticFieldId(
    r'NAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String NAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get NAME =>
      _id_NAME.get(_class, const jni$_.JStringNullableType());

  static final _id_GEO = _class.staticFieldId(
    r'GEO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String GEO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get GEO =>
      _id_GEO.get(_class, const jni$_.JStringNullableType());

  static final _id_DATA = _class.staticFieldId(
    r'DATA',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DATA`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DATA =>
      _id_DATA.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory User$JsonKeys() {
    return User$JsonKeys.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $User$JsonKeys$NullableType extends jni$_.JObjType<User$JsonKeys?> {
  @jni$_.internal
  const $User$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/User$JsonKeys;';

  @jni$_.internal
  @core$_.override
  User$JsonKeys? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : User$JsonKeys.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<User$JsonKeys?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($User$JsonKeys$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($User$JsonKeys$NullableType) &&
        other is $User$JsonKeys$NullableType;
  }
}

final class $User$JsonKeys$Type extends jni$_.JObjType<User$JsonKeys> {
  @jni$_.internal
  const $User$JsonKeys$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/User$JsonKeys;';

  @jni$_.internal
  @core$_.override
  User$JsonKeys fromReference(jni$_.JReference reference) =>
      User$JsonKeys.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<User$JsonKeys?> get nullableType =>
      const $User$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($User$JsonKeys$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($User$JsonKeys$Type) &&
        other is $User$JsonKeys$Type;
  }
}

/// from: `io.sentry.protocol.User`
class User extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<User> $type;

  @jni$_.internal
  User.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/protocol/User');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $User$NullableType();
  static const type = $User$Type();
  static final _id_fromMap = _class.staticMethodId(
    r'fromMap',
    r'(Ljava/util/Map;Lio/sentry/SentryOptions;)Lio/sentry/protocol/User;',
  );

  static final _fromMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.User fromMap(java.util.Map<java.lang.String, java.lang.Object> map, io.sentry.SentryOptions sentryOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  static User? fromMap(
    jni$_.JMap<jni$_.JString?, jni$_.JObject?> map,
    SentryOptions sentryOptions,
  ) {
    final _$map = map.reference;
    final _$sentryOptions = sentryOptions.reference;
    return _fromMap(_class.reference.pointer, _id_fromMap as jni$_.JMethodIDPtr,
            _$map.pointer, _$sentryOptions.pointer)
        .object<User?>(const $User$NullableType());
  }
}

final class $User$NullableType extends jni$_.JObjType<User?> {
  @jni$_.internal
  const $User$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/User;';

  @jni$_.internal
  @core$_.override
  User? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : User.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<User?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($User$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($User$NullableType) &&
        other is $User$NullableType;
  }
}

final class $User$Type extends jni$_.JObjType<User> {
  @jni$_.internal
  const $User$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/User;';

  @jni$_.internal
  @core$_.override
  User fromReference(jni$_.JReference reference) => User.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<User?> get nullableType => const $User$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($User$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($User$Type) && other is $User$Type;
  }
}

/// from: `io.sentry.protocol.SentryId$Deserializer`
class SentryId$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryId$Deserializer> $type;

  @jni$_.internal
  SentryId$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/protocol/SentryId$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryId$Deserializer$NullableType();
  static const type = $SentryId$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryId$Deserializer() {
    return SentryId$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserialize = _class.instanceMethodId(
    r'deserialize',
    r'(Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Lio/sentry/protocol/SentryId;',
  );

  static final _deserialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId deserialize(io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryId deserialize(
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserialize(
            reference.pointer,
            _id_deserialize as jni$_.JMethodIDPtr,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .object<SentryId>(const $SentryId$Type());
  }
}

final class $SentryId$Deserializer$NullableType
    extends jni$_.JObjType<SentryId$Deserializer?> {
  @jni$_.internal
  const $SentryId$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/SentryId$Deserializer;';

  @jni$_.internal
  @core$_.override
  SentryId$Deserializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryId$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryId$Deserializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryId$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryId$Deserializer$NullableType) &&
        other is $SentryId$Deserializer$NullableType;
  }
}

final class $SentryId$Deserializer$Type
    extends jni$_.JObjType<SentryId$Deserializer> {
  @jni$_.internal
  const $SentryId$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/SentryId$Deserializer;';

  @jni$_.internal
  @core$_.override
  SentryId$Deserializer fromReference(jni$_.JReference reference) =>
      SentryId$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryId$Deserializer?> get nullableType =>
      const $SentryId$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryId$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryId$Deserializer$Type) &&
        other is $SentryId$Deserializer$Type;
  }
}

/// from: `io.sentry.protocol.SentryId`
class SentryId extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryId> $type;

  @jni$_.internal
  SentryId.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/protocol/SentryId');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryId$NullableType();
  static const type = $SentryId$Type();
  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $SentryId$NullableType extends jni$_.JObjType<SentryId?> {
  @jni$_.internal
  const $SentryId$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/SentryId;';

  @jni$_.internal
  @core$_.override
  SentryId? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : SentryId.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryId?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryId$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryId$NullableType) &&
        other is $SentryId$NullableType;
  }
}

final class $SentryId$Type extends jni$_.JObjType<SentryId> {
  @jni$_.internal
  const $SentryId$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/SentryId;';

  @jni$_.internal
  @core$_.override
  SentryId fromReference(jni$_.JReference reference) => SentryId.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryId?> get nullableType => const $SentryId$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryId$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryId$Type) && other is $SentryId$Type;
  }
}

/// from: `io.sentry.ScopeCallback`
class ScopeCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ScopeCallback> $type;

  @jni$_.internal
  ScopeCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/ScopeCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ScopeCallback$NullableType();
  static const type = $ScopeCallback$Type();
  static final _id_run = _class.instanceMethodId(
    r'run',
    r'(Lio/sentry/IScope;)V',
  );

  static final _run = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void run(io.sentry.IScope iScope)`
  void run(
    jni$_.JObject iScope,
  ) {
    final _$iScope = iScope.reference;
    _run(reference.pointer, _id_run as jni$_.JMethodIDPtr, _$iScope.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ScopeCallback> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'run(Lio/sentry/IScope;)V') {
        _$impls[$p]!.run(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $ScopeCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.ScopeCallback',
      $p,
      _$invokePointer,
      [
        if ($impl.run$async) r'run(Lio/sentry/IScope;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ScopeCallback.implement(
    $ScopeCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ScopeCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $ScopeCallback {
  factory $ScopeCallback({
    required void Function(jni$_.JObject iScope) run,
    bool run$async,
  }) = _$ScopeCallback;

  void run(jni$_.JObject iScope);
  bool get run$async => false;
}

final class _$ScopeCallback with $ScopeCallback {
  _$ScopeCallback({
    required void Function(jni$_.JObject iScope) run,
    this.run$async = false,
  }) : _run = run;

  final void Function(jni$_.JObject iScope) _run;
  final bool run$async;

  void run(jni$_.JObject iScope) {
    return _run(iScope);
  }
}

final class $ScopeCallback$NullableType extends jni$_.JObjType<ScopeCallback?> {
  @jni$_.internal
  const $ScopeCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/ScopeCallback;';

  @jni$_.internal
  @core$_.override
  ScopeCallback? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : ScopeCallback.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ScopeCallback?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ScopeCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ScopeCallback$NullableType) &&
        other is $ScopeCallback$NullableType;
  }
}

final class $ScopeCallback$Type extends jni$_.JObjType<ScopeCallback> {
  @jni$_.internal
  const $ScopeCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/ScopeCallback;';

  @jni$_.internal
  @core$_.override
  ScopeCallback fromReference(jni$_.JReference reference) =>
      ScopeCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ScopeCallback?> get nullableType =>
      const $ScopeCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ScopeCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ScopeCallback$Type) &&
        other is $ScopeCallback$Type;
  }
}

/// from: `io.sentry.protocol.SdkVersion$Deserializer`
class SdkVersion$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SdkVersion$Deserializer> $type;

  @jni$_.internal
  SdkVersion$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/protocol/SdkVersion$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SdkVersion$Deserializer$NullableType();
  static const type = $SdkVersion$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SdkVersion$Deserializer() {
    return SdkVersion$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserialize = _class.instanceMethodId(
    r'deserialize',
    r'(Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Lio/sentry/protocol/SdkVersion;',
  );

  static final _deserialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SdkVersion deserialize(io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  /// The returned object must be released after use, by calling the [release] method.
  SdkVersion deserialize(
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserialize(
            reference.pointer,
            _id_deserialize as jni$_.JMethodIDPtr,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .object<SdkVersion>(const $SdkVersion$Type());
  }
}

final class $SdkVersion$Deserializer$NullableType
    extends jni$_.JObjType<SdkVersion$Deserializer?> {
  @jni$_.internal
  const $SdkVersion$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/SdkVersion$Deserializer;';

  @jni$_.internal
  @core$_.override
  SdkVersion$Deserializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SdkVersion$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SdkVersion$Deserializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SdkVersion$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SdkVersion$Deserializer$NullableType) &&
        other is $SdkVersion$Deserializer$NullableType;
  }
}

final class $SdkVersion$Deserializer$Type
    extends jni$_.JObjType<SdkVersion$Deserializer> {
  @jni$_.internal
  const $SdkVersion$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/SdkVersion$Deserializer;';

  @jni$_.internal
  @core$_.override
  SdkVersion$Deserializer fromReference(jni$_.JReference reference) =>
      SdkVersion$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SdkVersion$Deserializer?> get nullableType =>
      const $SdkVersion$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SdkVersion$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SdkVersion$Deserializer$Type) &&
        other is $SdkVersion$Deserializer$Type;
  }
}

/// from: `io.sentry.protocol.SdkVersion$JsonKeys`
class SdkVersion$JsonKeys extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SdkVersion$JsonKeys> $type;

  @jni$_.internal
  SdkVersion$JsonKeys.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/protocol/SdkVersion$JsonKeys');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SdkVersion$JsonKeys$NullableType();
  static const type = $SdkVersion$JsonKeys$Type();
  static final _id_NAME = _class.staticFieldId(
    r'NAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String NAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get NAME =>
      _id_NAME.get(_class, const jni$_.JStringNullableType());

  static final _id_VERSION = _class.staticFieldId(
    r'VERSION',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String VERSION`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get VERSION =>
      _id_VERSION.get(_class, const jni$_.JStringNullableType());

  static final _id_PACKAGES = _class.staticFieldId(
    r'PACKAGES',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PACKAGES`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get PACKAGES =>
      _id_PACKAGES.get(_class, const jni$_.JStringNullableType());

  static final _id_INTEGRATIONS = _class.staticFieldId(
    r'INTEGRATIONS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String INTEGRATIONS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get INTEGRATIONS =>
      _id_INTEGRATIONS.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SdkVersion$JsonKeys() {
    return SdkVersion$JsonKeys.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $SdkVersion$JsonKeys$NullableType
    extends jni$_.JObjType<SdkVersion$JsonKeys?> {
  @jni$_.internal
  const $SdkVersion$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/SdkVersion$JsonKeys;';

  @jni$_.internal
  @core$_.override
  SdkVersion$JsonKeys? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SdkVersion$JsonKeys.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SdkVersion$JsonKeys?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SdkVersion$JsonKeys$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SdkVersion$JsonKeys$NullableType) &&
        other is $SdkVersion$JsonKeys$NullableType;
  }
}

final class $SdkVersion$JsonKeys$Type
    extends jni$_.JObjType<SdkVersion$JsonKeys> {
  @jni$_.internal
  const $SdkVersion$JsonKeys$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/SdkVersion$JsonKeys;';

  @jni$_.internal
  @core$_.override
  SdkVersion$JsonKeys fromReference(jni$_.JReference reference) =>
      SdkVersion$JsonKeys.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SdkVersion$JsonKeys?> get nullableType =>
      const $SdkVersion$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SdkVersion$JsonKeys$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SdkVersion$JsonKeys$Type) &&
        other is $SdkVersion$JsonKeys$Type;
  }
}

/// from: `io.sentry.protocol.SdkVersion`
class SdkVersion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SdkVersion> $type;

  @jni$_.internal
  SdkVersion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/protocol/SdkVersion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SdkVersion$NullableType();
  static const type = $SdkVersion$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SdkVersion(
    jni$_.JString string,
    jni$_.JString string1,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    return SdkVersion.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$string.pointer, _$string1.pointer)
        .reference);
  }

  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getName() {
    return _getName(reference.pointer, _id_getName as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_setName = _class.instanceMethodId(
    r'setName',
    r'(Ljava/lang/String;)V',
  );

  static final _setName = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setName(java.lang.String string)`
  void setName(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _setName(reference.pointer, _id_setName as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_addPackage = _class.instanceMethodId(
    r'addPackage',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _addPackage = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addPackage(java.lang.String string, java.lang.String string1)`
  void addPackage(
    jni$_.JString string,
    jni$_.JString string1,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    _addPackage(reference.pointer, _id_addPackage as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  static final _id_addIntegration = _class.instanceMethodId(
    r'addIntegration',
    r'(Ljava/lang/String;)V',
  );

  static final _addIntegration = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addIntegration(java.lang.String string)`
  void addIntegration(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _addIntegration(reference.pointer, _id_addIntegration as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }
}

final class $SdkVersion$NullableType extends jni$_.JObjType<SdkVersion?> {
  @jni$_.internal
  const $SdkVersion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/SdkVersion;';

  @jni$_.internal
  @core$_.override
  SdkVersion? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : SdkVersion.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SdkVersion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SdkVersion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SdkVersion$NullableType) &&
        other is $SdkVersion$NullableType;
  }
}

final class $SdkVersion$Type extends jni$_.JObjType<SdkVersion> {
  @jni$_.internal
  const $SdkVersion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/SdkVersion;';

  @jni$_.internal
  @core$_.override
  SdkVersion fromReference(jni$_.JReference reference) =>
      SdkVersion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SdkVersion?> get nullableType =>
      const $SdkVersion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SdkVersion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SdkVersion$Type) && other is $SdkVersion$Type;
  }
}

/// from: `io.sentry.Scope$IWithPropagationContext`
class Scope$IWithPropagationContext extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Scope$IWithPropagationContext> $type;

  @jni$_.internal
  Scope$IWithPropagationContext.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/Scope$IWithPropagationContext');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Scope$IWithPropagationContext$NullableType();
  static const type = $Scope$IWithPropagationContext$Type();
  static final _id_accept = _class.instanceMethodId(
    r'accept',
    r'(Lio/sentry/PropagationContext;)V',
  );

  static final _accept = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void accept(io.sentry.PropagationContext propagationContext)`
  void accept(
    jni$_.JObject propagationContext,
  ) {
    final _$propagationContext = propagationContext.reference;
    _accept(reference.pointer, _id_accept as jni$_.JMethodIDPtr,
            _$propagationContext.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Scope$IWithPropagationContext> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'accept(Lio/sentry/PropagationContext;)V') {
        _$impls[$p]!.accept(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Scope$IWithPropagationContext $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.Scope$IWithPropagationContext',
      $p,
      _$invokePointer,
      [
        if ($impl.accept$async) r'accept(Lio/sentry/PropagationContext;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Scope$IWithPropagationContext.implement(
    $Scope$IWithPropagationContext $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Scope$IWithPropagationContext.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Scope$IWithPropagationContext {
  factory $Scope$IWithPropagationContext({
    required void Function(jni$_.JObject propagationContext) accept,
    bool accept$async,
  }) = _$Scope$IWithPropagationContext;

  void accept(jni$_.JObject propagationContext);
  bool get accept$async => false;
}

final class _$Scope$IWithPropagationContext
    with $Scope$IWithPropagationContext {
  _$Scope$IWithPropagationContext({
    required void Function(jni$_.JObject propagationContext) accept,
    this.accept$async = false,
  }) : _accept = accept;

  final void Function(jni$_.JObject propagationContext) _accept;
  final bool accept$async;

  void accept(jni$_.JObject propagationContext) {
    return _accept(propagationContext);
  }
}

final class $Scope$IWithPropagationContext$NullableType
    extends jni$_.JObjType<Scope$IWithPropagationContext?> {
  @jni$_.internal
  const $Scope$IWithPropagationContext$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Scope$IWithPropagationContext;';

  @jni$_.internal
  @core$_.override
  Scope$IWithPropagationContext? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Scope$IWithPropagationContext.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Scope$IWithPropagationContext?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Scope$IWithPropagationContext$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Scope$IWithPropagationContext$NullableType) &&
        other is $Scope$IWithPropagationContext$NullableType;
  }
}

final class $Scope$IWithPropagationContext$Type
    extends jni$_.JObjType<Scope$IWithPropagationContext> {
  @jni$_.internal
  const $Scope$IWithPropagationContext$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Scope$IWithPropagationContext;';

  @jni$_.internal
  @core$_.override
  Scope$IWithPropagationContext fromReference(jni$_.JReference reference) =>
      Scope$IWithPropagationContext.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Scope$IWithPropagationContext?> get nullableType =>
      const $Scope$IWithPropagationContext$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Scope$IWithPropagationContext$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Scope$IWithPropagationContext$Type) &&
        other is $Scope$IWithPropagationContext$Type;
  }
}

/// from: `io.sentry.Scope$IWithTransaction`
class Scope$IWithTransaction extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Scope$IWithTransaction> $type;

  @jni$_.internal
  Scope$IWithTransaction.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/Scope$IWithTransaction');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Scope$IWithTransaction$NullableType();
  static const type = $Scope$IWithTransaction$Type();
  static final _id_accept = _class.instanceMethodId(
    r'accept',
    r'(Lio/sentry/ITransaction;)V',
  );

  static final _accept = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void accept(io.sentry.ITransaction iTransaction)`
  void accept(
    jni$_.JObject? iTransaction,
  ) {
    final _$iTransaction = iTransaction?.reference ?? jni$_.jNullReference;
    _accept(reference.pointer, _id_accept as jni$_.JMethodIDPtr,
            _$iTransaction.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Scope$IWithTransaction> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'accept(Lio/sentry/ITransaction;)V') {
        _$impls[$p]!.accept(
          $a![0]?.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Scope$IWithTransaction $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.Scope$IWithTransaction',
      $p,
      _$invokePointer,
      [
        if ($impl.accept$async) r'accept(Lio/sentry/ITransaction;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Scope$IWithTransaction.implement(
    $Scope$IWithTransaction $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Scope$IWithTransaction.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Scope$IWithTransaction {
  factory $Scope$IWithTransaction({
    required void Function(jni$_.JObject? iTransaction) accept,
    bool accept$async,
  }) = _$Scope$IWithTransaction;

  void accept(jni$_.JObject? iTransaction);
  bool get accept$async => false;
}

final class _$Scope$IWithTransaction with $Scope$IWithTransaction {
  _$Scope$IWithTransaction({
    required void Function(jni$_.JObject? iTransaction) accept,
    this.accept$async = false,
  }) : _accept = accept;

  final void Function(jni$_.JObject? iTransaction) _accept;
  final bool accept$async;

  void accept(jni$_.JObject? iTransaction) {
    return _accept(iTransaction);
  }
}

final class $Scope$IWithTransaction$NullableType
    extends jni$_.JObjType<Scope$IWithTransaction?> {
  @jni$_.internal
  const $Scope$IWithTransaction$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Scope$IWithTransaction;';

  @jni$_.internal
  @core$_.override
  Scope$IWithTransaction? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Scope$IWithTransaction.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Scope$IWithTransaction?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Scope$IWithTransaction$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Scope$IWithTransaction$NullableType) &&
        other is $Scope$IWithTransaction$NullableType;
  }
}

final class $Scope$IWithTransaction$Type
    extends jni$_.JObjType<Scope$IWithTransaction> {
  @jni$_.internal
  const $Scope$IWithTransaction$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Scope$IWithTransaction;';

  @jni$_.internal
  @core$_.override
  Scope$IWithTransaction fromReference(jni$_.JReference reference) =>
      Scope$IWithTransaction.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Scope$IWithTransaction?> get nullableType =>
      const $Scope$IWithTransaction$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Scope$IWithTransaction$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Scope$IWithTransaction$Type) &&
        other is $Scope$IWithTransaction$Type;
  }
}

/// from: `io.sentry.Scope`
class Scope extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Scope> $type;

  @jni$_.internal
  Scope.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/Scope');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Scope$NullableType();
  static const type = $Scope$Type();
  static final _id_setContexts = _class.instanceMethodId(
    r'setContexts',
    r'(Ljava/lang/String;Ljava/lang/Object;)V',
  );

  static final _setContexts = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setContexts(java.lang.String string, java.lang.Object object)`
  void setContexts(
    jni$_.JString? string,
    jni$_.JObject? object,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    _setContexts(reference.pointer, _id_setContexts as jni$_.JMethodIDPtr,
            _$string.pointer, _$object.pointer)
        .check();
  }

  static final _id_setContexts$1 = _class.instanceMethodId(
    r'setContexts',
    r'(Ljava/lang/String;Ljava/lang/Boolean;)V',
  );

  static final _setContexts$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setContexts(java.lang.String string, java.lang.Boolean boolean)`
  void setContexts$1(
    jni$_.JString? string,
    jni$_.JBoolean? boolean,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    _setContexts$1(reference.pointer, _id_setContexts$1 as jni$_.JMethodIDPtr,
            _$string.pointer, _$boolean.pointer)
        .check();
  }

  static final _id_setContexts$2 = _class.instanceMethodId(
    r'setContexts',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setContexts$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setContexts(java.lang.String string, java.lang.String string1)`
  void setContexts$2(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setContexts$2(reference.pointer, _id_setContexts$2 as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  static final _id_setContexts$3 = _class.instanceMethodId(
    r'setContexts',
    r'(Ljava/lang/String;Ljava/lang/Number;)V',
  );

  static final _setContexts$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setContexts(java.lang.String string, java.lang.Number number)`
  void setContexts$3(
    jni$_.JString? string,
    jni$_.JNumber? number,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$number = number?.reference ?? jni$_.jNullReference;
    _setContexts$3(reference.pointer, _id_setContexts$3 as jni$_.JMethodIDPtr,
            _$string.pointer, _$number.pointer)
        .check();
  }

  static final _id_setContexts$4 = _class.instanceMethodId(
    r'setContexts',
    r'(Ljava/lang/String;Ljava/util/Collection;)V',
  );

  static final _setContexts$4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setContexts(java.lang.String string, java.util.Collection<?> collection)`
  void setContexts$4(
    jni$_.JString? string,
    jni$_.JObject? collection,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$collection = collection?.reference ?? jni$_.jNullReference;
    _setContexts$4(reference.pointer, _id_setContexts$4 as jni$_.JMethodIDPtr,
            _$string.pointer, _$collection.pointer)
        .check();
  }

  static final _id_setContexts$5 = _class.instanceMethodId(
    r'setContexts',
    r'(Ljava/lang/String;[Ljava/lang/Object;)V',
  );

  static final _setContexts$5 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setContexts(java.lang.String string, java.lang.Object[] objects)`
  void setContexts$5(
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    _setContexts$5(reference.pointer, _id_setContexts$5 as jni$_.JMethodIDPtr,
            _$string.pointer, _$objects.pointer)
        .check();
  }

  static final _id_setContexts$6 = _class.instanceMethodId(
    r'setContexts',
    r'(Ljava/lang/String;Ljava/lang/Character;)V',
  );

  static final _setContexts$6 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setContexts(java.lang.String string, java.lang.Character character)`
  void setContexts$6(
    jni$_.JString? string,
    jni$_.JCharacter? character,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$character = character?.reference ?? jni$_.jNullReference;
    _setContexts$6(reference.pointer, _id_setContexts$6 as jni$_.JMethodIDPtr,
            _$string.pointer, _$character.pointer)
        .check();
  }

  static final _id_removeContexts = _class.instanceMethodId(
    r'removeContexts',
    r'(Ljava/lang/String;)V',
  );

  static final _removeContexts = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeContexts(java.lang.String string)`
  void removeContexts(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _removeContexts(reference.pointer, _id_removeContexts as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }
}

final class $Scope$NullableType extends jni$_.JObjType<Scope?> {
  @jni$_.internal
  const $Scope$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Scope;';

  @jni$_.internal
  @core$_.override
  Scope? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Scope.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Scope?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Scope$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Scope$NullableType) &&
        other is $Scope$NullableType;
  }
}

final class $Scope$Type extends jni$_.JObjType<Scope> {
  @jni$_.internal
  const $Scope$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Scope;';

  @jni$_.internal
  @core$_.override
  Scope fromReference(jni$_.JReference reference) => Scope.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Scope?> get nullableType => const $Scope$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Scope$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Scope$Type) && other is $Scope$Type;
  }
}

/// from: `io.sentry.android.replay.ScreenshotRecorderConfig$Companion`
class ScreenshotRecorderConfig$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ScreenshotRecorderConfig$Companion> $type;

  @jni$_.internal
  ScreenshotRecorderConfig$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'io/sentry/android/replay/ScreenshotRecorderConfig$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $ScreenshotRecorderConfig$Companion$NullableType();
  static const type = $ScreenshotRecorderConfig$Companion$Type();
  static final _id_fromSize = _class.instanceMethodId(
    r'fromSize',
    r'(Landroid/content/Context;Lio/sentry/SentryReplayOptions;II)Lio/sentry/android/replay/ScreenshotRecorderConfig;',
  );

  static final _fromSize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int)>();

  /// from: `public final io.sentry.android.replay.ScreenshotRecorderConfig fromSize(android.content.Context context, io.sentry.SentryReplayOptions sentryReplayOptions, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  ScreenshotRecorderConfig fromSize(
    jni$_.JObject context,
    SentryReplayOptions sentryReplayOptions,
    int i,
    int i1,
  ) {
    final _$context = context.reference;
    final _$sentryReplayOptions = sentryReplayOptions.reference;
    return _fromSize(reference.pointer, _id_fromSize as jni$_.JMethodIDPtr,
            _$context.pointer, _$sentryReplayOptions.pointer, i, i1)
        .object<ScreenshotRecorderConfig>(
            const $ScreenshotRecorderConfig$Type());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ScreenshotRecorderConfig$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return ScreenshotRecorderConfig$Companion.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $ScreenshotRecorderConfig$Companion$NullableType
    extends jni$_.JObjType<ScreenshotRecorderConfig$Companion?> {
  @jni$_.internal
  const $ScreenshotRecorderConfig$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/android/replay/ScreenshotRecorderConfig$Companion;';

  @jni$_.internal
  @core$_.override
  ScreenshotRecorderConfig$Companion? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ScreenshotRecorderConfig$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ScreenshotRecorderConfig$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($ScreenshotRecorderConfig$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ScreenshotRecorderConfig$Companion$NullableType) &&
        other is $ScreenshotRecorderConfig$Companion$NullableType;
  }
}

final class $ScreenshotRecorderConfig$Companion$Type
    extends jni$_.JObjType<ScreenshotRecorderConfig$Companion> {
  @jni$_.internal
  const $ScreenshotRecorderConfig$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/android/replay/ScreenshotRecorderConfig$Companion;';

  @jni$_.internal
  @core$_.override
  ScreenshotRecorderConfig$Companion fromReference(
          jni$_.JReference reference) =>
      ScreenshotRecorderConfig$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ScreenshotRecorderConfig$Companion?> get nullableType =>
      const $ScreenshotRecorderConfig$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ScreenshotRecorderConfig$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ScreenshotRecorderConfig$Companion$Type) &&
        other is $ScreenshotRecorderConfig$Companion$Type;
  }
}

/// from: `io.sentry.android.replay.ScreenshotRecorderConfig`
class ScreenshotRecorderConfig extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ScreenshotRecorderConfig> $type;

  @jni$_.internal
  ScreenshotRecorderConfig.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'io/sentry/android/replay/ScreenshotRecorderConfig');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ScreenshotRecorderConfig$NullableType();
  static const type = $ScreenshotRecorderConfig$Type();
  static final _id_new$ = _class.constructorId(
    r'(IIFFII)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Double,
                        jni$_.Double,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, double, double, int, int)>();

  /// from: `public void <init>(int i, int i1, float f, float f1, int i2, int i3)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ScreenshotRecorderConfig(
    int i,
    int i1,
    double f,
    double f1,
    int i2,
    int i3,
  ) {
    return ScreenshotRecorderConfig.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            i,
            i1,
            f,
            f1,
            i2,
            i3)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(FF)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Double, jni$_.Double)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double, double)>();

  /// from: `public void <init>(float f, float f1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ScreenshotRecorderConfig.new$1(
    double f,
    double f1,
  ) {
    return ScreenshotRecorderConfig.fromReference(
        _new$1(_class.reference.pointer, _id_new$1 as jni$_.JMethodIDPtr, f, f1)
            .reference);
  }
}

final class $ScreenshotRecorderConfig$NullableType
    extends jni$_.JObjType<ScreenshotRecorderConfig?> {
  @jni$_.internal
  const $ScreenshotRecorderConfig$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/android/replay/ScreenshotRecorderConfig;';

  @jni$_.internal
  @core$_.override
  ScreenshotRecorderConfig? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ScreenshotRecorderConfig.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ScreenshotRecorderConfig?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ScreenshotRecorderConfig$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ScreenshotRecorderConfig$NullableType) &&
        other is $ScreenshotRecorderConfig$NullableType;
  }
}

final class $ScreenshotRecorderConfig$Type
    extends jni$_.JObjType<ScreenshotRecorderConfig> {
  @jni$_.internal
  const $ScreenshotRecorderConfig$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/android/replay/ScreenshotRecorderConfig;';

  @jni$_.internal
  @core$_.override
  ScreenshotRecorderConfig fromReference(jni$_.JReference reference) =>
      ScreenshotRecorderConfig.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ScreenshotRecorderConfig?> get nullableType =>
      const $ScreenshotRecorderConfig$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ScreenshotRecorderConfig$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ScreenshotRecorderConfig$Type) &&
        other is $ScreenshotRecorderConfig$Type;
  }
}

/// from: `io.sentry.android.replay.ReplayIntegration`
class ReplayIntegration extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ReplayIntegration> $type;

  @jni$_.internal
  ReplayIntegration.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/android/replay/ReplayIntegration');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ReplayIntegration$NullableType();
  static const type = $ReplayIntegration$Type();
  static final _id_captureReplay = _class.instanceMethodId(
    r'captureReplay',
    r'(Ljava/lang/Boolean;)V',
  );

  static final _captureReplay = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void captureReplay(java.lang.Boolean boolean)`
  void captureReplay(
    jni$_.JBoolean? boolean,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    _captureReplay(reference.pointer, _id_captureReplay as jni$_.JMethodIDPtr,
            _$boolean.pointer)
        .check();
  }

  static final _id_getReplayId = _class.instanceMethodId(
    r'getReplayId',
    r'()Lio/sentry/protocol/SentryId;',
  );

  static final _getReplayId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.SentryId getReplayId()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryId getReplayId() {
    return _getReplayId(
            reference.pointer, _id_getReplayId as jni$_.JMethodIDPtr)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_onScreenshotRecorded = _class.instanceMethodId(
    r'onScreenshotRecorded',
    r'(Landroid/graphics/Bitmap;)V',
  );

  static final _onScreenshotRecorded = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onScreenshotRecorded(android.graphics.Bitmap bitmap)`
  void onScreenshotRecorded(
    Bitmap bitmap,
  ) {
    final _$bitmap = bitmap.reference;
    _onScreenshotRecorded(reference.pointer,
            _id_onScreenshotRecorded as jni$_.JMethodIDPtr, _$bitmap.pointer)
        .check();
  }

  static final _id_onScreenshotRecorded$1 = _class.instanceMethodId(
    r'onScreenshotRecorded',
    r'(Ljava/io/File;J)V',
  );

  static final _onScreenshotRecorded$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public void onScreenshotRecorded(java.io.File file, long j)`
  void onScreenshotRecorded$1(
    jni$_.JObject file,
    int j,
  ) {
    final _$file = file.reference;
    _onScreenshotRecorded$1(reference.pointer,
            _id_onScreenshotRecorded$1 as jni$_.JMethodIDPtr, _$file.pointer, j)
        .check();
  }

  static final _id_onConfigurationChanged = _class.instanceMethodId(
    r'onConfigurationChanged',
    r'(Lio/sentry/android/replay/ScreenshotRecorderConfig;)V',
  );

  static final _onConfigurationChanged = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void onConfigurationChanged(io.sentry.android.replay.ScreenshotRecorderConfig screenshotRecorderConfig)`
  void onConfigurationChanged(
    ScreenshotRecorderConfig screenshotRecorderConfig,
  ) {
    final _$screenshotRecorderConfig = screenshotRecorderConfig.reference;
    _onConfigurationChanged(
            reference.pointer,
            _id_onConfigurationChanged as jni$_.JMethodIDPtr,
            _$screenshotRecorderConfig.pointer)
        .check();
  }
}

final class $ReplayIntegration$NullableType
    extends jni$_.JObjType<ReplayIntegration?> {
  @jni$_.internal
  const $ReplayIntegration$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/replay/ReplayIntegration;';

  @jni$_.internal
  @core$_.override
  ReplayIntegration? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ReplayIntegration.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ReplayIntegration?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ReplayIntegration$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ReplayIntegration$NullableType) &&
        other is $ReplayIntegration$NullableType;
  }
}

final class $ReplayIntegration$Type extends jni$_.JObjType<ReplayIntegration> {
  @jni$_.internal
  const $ReplayIntegration$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/replay/ReplayIntegration;';

  @jni$_.internal
  @core$_.override
  ReplayIntegration fromReference(jni$_.JReference reference) =>
      ReplayIntegration.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ReplayIntegration?> get nullableType =>
      const $ReplayIntegration$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ReplayIntegration$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ReplayIntegration$Type) &&
        other is $ReplayIntegration$Type;
  }
}

/// from: `io.sentry.SentryEvent$Deserializer`
class SentryEvent$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryEvent$Deserializer> $type;

  @jni$_.internal
  SentryEvent$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryEvent$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryEvent$Deserializer$NullableType();
  static const type = $SentryEvent$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryEvent$Deserializer() {
    return SentryEvent$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserialize = _class.instanceMethodId(
    r'deserialize',
    r'(Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Lio/sentry/SentryEvent;',
  );

  static final _deserialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.SentryEvent deserialize(io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryEvent deserialize(
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserialize(
            reference.pointer,
            _id_deserialize as jni$_.JMethodIDPtr,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .object<SentryEvent>(const $SentryEvent$Type());
  }
}

final class $SentryEvent$Deserializer$NullableType
    extends jni$_.JObjType<SentryEvent$Deserializer?> {
  @jni$_.internal
  const $SentryEvent$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryEvent$Deserializer;';

  @jni$_.internal
  @core$_.override
  SentryEvent$Deserializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryEvent$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryEvent$Deserializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryEvent$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryEvent$Deserializer$NullableType) &&
        other is $SentryEvent$Deserializer$NullableType;
  }
}

final class $SentryEvent$Deserializer$Type
    extends jni$_.JObjType<SentryEvent$Deserializer> {
  @jni$_.internal
  const $SentryEvent$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryEvent$Deserializer;';

  @jni$_.internal
  @core$_.override
  SentryEvent$Deserializer fromReference(jni$_.JReference reference) =>
      SentryEvent$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryEvent$Deserializer?> get nullableType =>
      const $SentryEvent$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryEvent$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryEvent$Deserializer$Type) &&
        other is $SentryEvent$Deserializer$Type;
  }
}

/// from: `io.sentry.SentryEvent$JsonKeys`
class SentryEvent$JsonKeys extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryEvent$JsonKeys> $type;

  @jni$_.internal
  SentryEvent$JsonKeys.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/SentryEvent$JsonKeys');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryEvent$JsonKeys$NullableType();
  static const type = $SentryEvent$JsonKeys$Type();
  static final _id_TIMESTAMP = _class.staticFieldId(
    r'TIMESTAMP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TIMESTAMP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TIMESTAMP =>
      _id_TIMESTAMP.get(_class, const jni$_.JStringNullableType());

  static final _id_MESSAGE = _class.staticFieldId(
    r'MESSAGE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MESSAGE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get MESSAGE =>
      _id_MESSAGE.get(_class, const jni$_.JStringNullableType());

  static final _id_LOGGER = _class.staticFieldId(
    r'LOGGER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LOGGER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get LOGGER =>
      _id_LOGGER.get(_class, const jni$_.JStringNullableType());

  static final _id_THREADS = _class.staticFieldId(
    r'THREADS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String THREADS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get THREADS =>
      _id_THREADS.get(_class, const jni$_.JStringNullableType());

  static final _id_EXCEPTION = _class.staticFieldId(
    r'EXCEPTION',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EXCEPTION`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EXCEPTION =>
      _id_EXCEPTION.get(_class, const jni$_.JStringNullableType());

  static final _id_LEVEL = _class.staticFieldId(
    r'LEVEL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LEVEL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get LEVEL =>
      _id_LEVEL.get(_class, const jni$_.JStringNullableType());

  static final _id_TRANSACTION = _class.staticFieldId(
    r'TRANSACTION',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TRANSACTION`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TRANSACTION =>
      _id_TRANSACTION.get(_class, const jni$_.JStringNullableType());

  static final _id_FINGERPRINT = _class.staticFieldId(
    r'FINGERPRINT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FINGERPRINT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get FINGERPRINT =>
      _id_FINGERPRINT.get(_class, const jni$_.JStringNullableType());

  static final _id_MODULES = _class.staticFieldId(
    r'MODULES',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MODULES`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get MODULES =>
      _id_MODULES.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryEvent$JsonKeys() {
    return SentryEvent$JsonKeys.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $SentryEvent$JsonKeys$NullableType
    extends jni$_.JObjType<SentryEvent$JsonKeys?> {
  @jni$_.internal
  const $SentryEvent$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryEvent$JsonKeys;';

  @jni$_.internal
  @core$_.override
  SentryEvent$JsonKeys? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryEvent$JsonKeys.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryEvent$JsonKeys?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryEvent$JsonKeys$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryEvent$JsonKeys$NullableType) &&
        other is $SentryEvent$JsonKeys$NullableType;
  }
}

final class $SentryEvent$JsonKeys$Type
    extends jni$_.JObjType<SentryEvent$JsonKeys> {
  @jni$_.internal
  const $SentryEvent$JsonKeys$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryEvent$JsonKeys;';

  @jni$_.internal
  @core$_.override
  SentryEvent$JsonKeys fromReference(jni$_.JReference reference) =>
      SentryEvent$JsonKeys.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryEvent$JsonKeys?> get nullableType =>
      const $SentryEvent$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryEvent$JsonKeys$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryEvent$JsonKeys$Type) &&
        other is $SentryEvent$JsonKeys$Type;
  }
}

/// from: `io.sentry.SentryEvent`
class SentryEvent extends SentryBaseEvent {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryEvent> $type;

  @jni$_.internal
  SentryEvent.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/SentryEvent');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryEvent$NullableType();
  static const type = $SentryEvent$Type();
}

final class $SentryEvent$NullableType extends jni$_.JObjType<SentryEvent?> {
  @jni$_.internal
  const $SentryEvent$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryEvent;';

  @jni$_.internal
  @core$_.override
  SentryEvent? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : SentryEvent.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $SentryBaseEvent$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryEvent?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($SentryEvent$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryEvent$NullableType) &&
        other is $SentryEvent$NullableType;
  }
}

final class $SentryEvent$Type extends jni$_.JObjType<SentryEvent> {
  @jni$_.internal
  const $SentryEvent$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryEvent;';

  @jni$_.internal
  @core$_.override
  SentryEvent fromReference(jni$_.JReference reference) =>
      SentryEvent.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $SentryBaseEvent$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryEvent?> get nullableType =>
      const $SentryEvent$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($SentryEvent$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryEvent$Type) &&
        other is $SentryEvent$Type;
  }
}

/// from: `io.sentry.SentryBaseEvent$Deserializer`
class SentryBaseEvent$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryBaseEvent$Deserializer> $type;

  @jni$_.internal
  SentryBaseEvent$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryBaseEvent$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryBaseEvent$Deserializer$NullableType();
  static const type = $SentryBaseEvent$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryBaseEvent$Deserializer() {
    return SentryBaseEvent$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserializeValue = _class.instanceMethodId(
    r'deserializeValue',
    r'(Lio/sentry/SentryBaseEvent;Ljava/lang/String;Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Z',
  );

  static final _deserializeValue = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean deserializeValue(io.sentry.SentryBaseEvent sentryBaseEvent, java.lang.String string, io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  bool deserializeValue(
    SentryBaseEvent sentryBaseEvent,
    jni$_.JString string,
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$sentryBaseEvent = sentryBaseEvent.reference;
    final _$string = string.reference;
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserializeValue(
            reference.pointer,
            _id_deserializeValue as jni$_.JMethodIDPtr,
            _$sentryBaseEvent.pointer,
            _$string.pointer,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .boolean;
  }
}

final class $SentryBaseEvent$Deserializer$NullableType
    extends jni$_.JObjType<SentryBaseEvent$Deserializer?> {
  @jni$_.internal
  const $SentryBaseEvent$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryBaseEvent$Deserializer;';

  @jni$_.internal
  @core$_.override
  SentryBaseEvent$Deserializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryBaseEvent$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryBaseEvent$Deserializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryBaseEvent$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryBaseEvent$Deserializer$NullableType) &&
        other is $SentryBaseEvent$Deserializer$NullableType;
  }
}

final class $SentryBaseEvent$Deserializer$Type
    extends jni$_.JObjType<SentryBaseEvent$Deserializer> {
  @jni$_.internal
  const $SentryBaseEvent$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryBaseEvent$Deserializer;';

  @jni$_.internal
  @core$_.override
  SentryBaseEvent$Deserializer fromReference(jni$_.JReference reference) =>
      SentryBaseEvent$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryBaseEvent$Deserializer?> get nullableType =>
      const $SentryBaseEvent$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryBaseEvent$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryBaseEvent$Deserializer$Type) &&
        other is $SentryBaseEvent$Deserializer$Type;
  }
}

/// from: `io.sentry.SentryBaseEvent$JsonKeys`
class SentryBaseEvent$JsonKeys extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryBaseEvent$JsonKeys> $type;

  @jni$_.internal
  SentryBaseEvent$JsonKeys.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryBaseEvent$JsonKeys');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryBaseEvent$JsonKeys$NullableType();
  static const type = $SentryBaseEvent$JsonKeys$Type();
  static final _id_EVENT_ID = _class.staticFieldId(
    r'EVENT_ID',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EVENT_ID`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EVENT_ID =>
      _id_EVENT_ID.get(_class, const jni$_.JStringNullableType());

  static final _id_CONTEXTS = _class.staticFieldId(
    r'CONTEXTS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CONTEXTS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CONTEXTS =>
      _id_CONTEXTS.get(_class, const jni$_.JStringNullableType());

  static final _id_SDK = _class.staticFieldId(
    r'SDK',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SDK`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SDK =>
      _id_SDK.get(_class, const jni$_.JStringNullableType());

  static final _id_REQUEST = _class.staticFieldId(
    r'REQUEST',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String REQUEST`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get REQUEST =>
      _id_REQUEST.get(_class, const jni$_.JStringNullableType());

  static final _id_TAGS = _class.staticFieldId(
    r'TAGS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TAGS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TAGS =>
      _id_TAGS.get(_class, const jni$_.JStringNullableType());

  static final _id_RELEASE = _class.staticFieldId(
    r'RELEASE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RELEASE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get RELEASE =>
      _id_RELEASE.get(_class, const jni$_.JStringNullableType());

  static final _id_ENVIRONMENT = _class.staticFieldId(
    r'ENVIRONMENT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ENVIRONMENT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ENVIRONMENT =>
      _id_ENVIRONMENT.get(_class, const jni$_.JStringNullableType());

  static final _id_PLATFORM = _class.staticFieldId(
    r'PLATFORM',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PLATFORM`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get PLATFORM =>
      _id_PLATFORM.get(_class, const jni$_.JStringNullableType());

  static final _id_USER = _class.staticFieldId(
    r'USER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String USER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get USER =>
      _id_USER.get(_class, const jni$_.JStringNullableType());

  static final _id_SERVER_NAME = _class.staticFieldId(
    r'SERVER_NAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SERVER_NAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SERVER_NAME =>
      _id_SERVER_NAME.get(_class, const jni$_.JStringNullableType());

  static final _id_DIST = _class.staticFieldId(
    r'DIST',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DIST`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DIST =>
      _id_DIST.get(_class, const jni$_.JStringNullableType());

  static final _id_BREADCRUMBS = _class.staticFieldId(
    r'BREADCRUMBS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BREADCRUMBS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BREADCRUMBS =>
      _id_BREADCRUMBS.get(_class, const jni$_.JStringNullableType());

  static final _id_DEBUG_META = _class.staticFieldId(
    r'DEBUG_META',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DEBUG_META`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DEBUG_META =>
      _id_DEBUG_META.get(_class, const jni$_.JStringNullableType());

  static final _id_EXTRA = _class.staticFieldId(
    r'EXTRA',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EXTRA`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EXTRA =>
      _id_EXTRA.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryBaseEvent$JsonKeys() {
    return SentryBaseEvent$JsonKeys.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $SentryBaseEvent$JsonKeys$NullableType
    extends jni$_.JObjType<SentryBaseEvent$JsonKeys?> {
  @jni$_.internal
  const $SentryBaseEvent$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryBaseEvent$JsonKeys;';

  @jni$_.internal
  @core$_.override
  SentryBaseEvent$JsonKeys? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryBaseEvent$JsonKeys.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryBaseEvent$JsonKeys?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryBaseEvent$JsonKeys$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryBaseEvent$JsonKeys$NullableType) &&
        other is $SentryBaseEvent$JsonKeys$NullableType;
  }
}

final class $SentryBaseEvent$JsonKeys$Type
    extends jni$_.JObjType<SentryBaseEvent$JsonKeys> {
  @jni$_.internal
  const $SentryBaseEvent$JsonKeys$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryBaseEvent$JsonKeys;';

  @jni$_.internal
  @core$_.override
  SentryBaseEvent$JsonKeys fromReference(jni$_.JReference reference) =>
      SentryBaseEvent$JsonKeys.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryBaseEvent$JsonKeys?> get nullableType =>
      const $SentryBaseEvent$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryBaseEvent$JsonKeys$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryBaseEvent$JsonKeys$Type) &&
        other is $SentryBaseEvent$JsonKeys$Type;
  }
}

/// from: `io.sentry.SentryBaseEvent$Serializer`
class SentryBaseEvent$Serializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryBaseEvent$Serializer> $type;

  @jni$_.internal
  SentryBaseEvent$Serializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryBaseEvent$Serializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryBaseEvent$Serializer$NullableType();
  static const type = $SentryBaseEvent$Serializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryBaseEvent$Serializer() {
    return SentryBaseEvent$Serializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_serialize = _class.instanceMethodId(
    r'serialize',
    r'(Lio/sentry/SentryBaseEvent;Lio/sentry/ObjectWriter;Lio/sentry/ILogger;)V',
  );

  static final _serialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void serialize(io.sentry.SentryBaseEvent sentryBaseEvent, io.sentry.ObjectWriter objectWriter, io.sentry.ILogger iLogger)`
  void serialize(
    SentryBaseEvent sentryBaseEvent,
    jni$_.JObject objectWriter,
    jni$_.JObject iLogger,
  ) {
    final _$sentryBaseEvent = sentryBaseEvent.reference;
    final _$objectWriter = objectWriter.reference;
    final _$iLogger = iLogger.reference;
    _serialize(
            reference.pointer,
            _id_serialize as jni$_.JMethodIDPtr,
            _$sentryBaseEvent.pointer,
            _$objectWriter.pointer,
            _$iLogger.pointer)
        .check();
  }
}

final class $SentryBaseEvent$Serializer$NullableType
    extends jni$_.JObjType<SentryBaseEvent$Serializer?> {
  @jni$_.internal
  const $SentryBaseEvent$Serializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryBaseEvent$Serializer;';

  @jni$_.internal
  @core$_.override
  SentryBaseEvent$Serializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryBaseEvent$Serializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryBaseEvent$Serializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryBaseEvent$Serializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryBaseEvent$Serializer$NullableType) &&
        other is $SentryBaseEvent$Serializer$NullableType;
  }
}

final class $SentryBaseEvent$Serializer$Type
    extends jni$_.JObjType<SentryBaseEvent$Serializer> {
  @jni$_.internal
  const $SentryBaseEvent$Serializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryBaseEvent$Serializer;';

  @jni$_.internal
  @core$_.override
  SentryBaseEvent$Serializer fromReference(jni$_.JReference reference) =>
      SentryBaseEvent$Serializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryBaseEvent$Serializer?> get nullableType =>
      const $SentryBaseEvent$Serializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryBaseEvent$Serializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryBaseEvent$Serializer$Type) &&
        other is $SentryBaseEvent$Serializer$Type;
  }
}

/// from: `io.sentry.SentryBaseEvent`
class SentryBaseEvent extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryBaseEvent> $type;

  @jni$_.internal
  SentryBaseEvent.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/SentryBaseEvent');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryBaseEvent$NullableType();
  static const type = $SentryBaseEvent$Type();
  static final _id_getSdk = _class.instanceMethodId(
    r'getSdk',
    r'()Lio/sentry/protocol/SdkVersion;',
  );

  static final _getSdk = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.SdkVersion getSdk()`
  /// The returned object must be released after use, by calling the [release] method.
  SdkVersion? getSdk() {
    return _getSdk(reference.pointer, _id_getSdk as jni$_.JMethodIDPtr)
        .object<SdkVersion?>(const $SdkVersion$NullableType());
  }

  static final _id_setTag = _class.instanceMethodId(
    r'setTag',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setTag = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTag(java.lang.String string, java.lang.String string1)`
  void setTag(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setTag(reference.pointer, _id_setTag as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }
}

final class $SentryBaseEvent$NullableType
    extends jni$_.JObjType<SentryBaseEvent?> {
  @jni$_.internal
  const $SentryBaseEvent$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryBaseEvent;';

  @jni$_.internal
  @core$_.override
  SentryBaseEvent? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : SentryBaseEvent.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryBaseEvent?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryBaseEvent$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryBaseEvent$NullableType) &&
        other is $SentryBaseEvent$NullableType;
  }
}

final class $SentryBaseEvent$Type extends jni$_.JObjType<SentryBaseEvent> {
  @jni$_.internal
  const $SentryBaseEvent$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryBaseEvent;';

  @jni$_.internal
  @core$_.override
  SentryBaseEvent fromReference(jni$_.JReference reference) =>
      SentryBaseEvent.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryBaseEvent?> get nullableType =>
      const $SentryBaseEvent$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryBaseEvent$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryBaseEvent$Type) &&
        other is $SentryBaseEvent$Type;
  }
}

/// from: `io.sentry.SentryReplayEvent$Deserializer`
class SentryReplayEvent$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryReplayEvent$Deserializer> $type;

  @jni$_.internal
  SentryReplayEvent$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryReplayEvent$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryReplayEvent$Deserializer$NullableType();
  static const type = $SentryReplayEvent$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryReplayEvent$Deserializer() {
    return SentryReplayEvent$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserialize = _class.instanceMethodId(
    r'deserialize',
    r'(Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Lio/sentry/SentryReplayEvent;',
  );

  static final _deserialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.SentryReplayEvent deserialize(io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryReplayEvent deserialize(
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserialize(
            reference.pointer,
            _id_deserialize as jni$_.JMethodIDPtr,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .object<SentryReplayEvent>(const $SentryReplayEvent$Type());
  }
}

final class $SentryReplayEvent$Deserializer$NullableType
    extends jni$_.JObjType<SentryReplayEvent$Deserializer?> {
  @jni$_.internal
  const $SentryReplayEvent$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryReplayEvent$Deserializer;';

  @jni$_.internal
  @core$_.override
  SentryReplayEvent$Deserializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryReplayEvent$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayEvent$Deserializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryReplayEvent$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryReplayEvent$Deserializer$NullableType) &&
        other is $SentryReplayEvent$Deserializer$NullableType;
  }
}

final class $SentryReplayEvent$Deserializer$Type
    extends jni$_.JObjType<SentryReplayEvent$Deserializer> {
  @jni$_.internal
  const $SentryReplayEvent$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryReplayEvent$Deserializer;';

  @jni$_.internal
  @core$_.override
  SentryReplayEvent$Deserializer fromReference(jni$_.JReference reference) =>
      SentryReplayEvent$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayEvent$Deserializer?> get nullableType =>
      const $SentryReplayEvent$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryReplayEvent$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryReplayEvent$Deserializer$Type) &&
        other is $SentryReplayEvent$Deserializer$Type;
  }
}

/// from: `io.sentry.SentryReplayEvent$JsonKeys`
class SentryReplayEvent$JsonKeys extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryReplayEvent$JsonKeys> $type;

  @jni$_.internal
  SentryReplayEvent$JsonKeys.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryReplayEvent$JsonKeys');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryReplayEvent$JsonKeys$NullableType();
  static const type = $SentryReplayEvent$JsonKeys$Type();
  static final _id_TYPE = _class.staticFieldId(
    r'TYPE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TYPE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TYPE =>
      _id_TYPE.get(_class, const jni$_.JStringNullableType());

  static final _id_REPLAY_TYPE = _class.staticFieldId(
    r'REPLAY_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String REPLAY_TYPE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get REPLAY_TYPE =>
      _id_REPLAY_TYPE.get(_class, const jni$_.JStringNullableType());

  static final _id_REPLAY_ID = _class.staticFieldId(
    r'REPLAY_ID',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String REPLAY_ID`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get REPLAY_ID =>
      _id_REPLAY_ID.get(_class, const jni$_.JStringNullableType());

  static final _id_SEGMENT_ID = _class.staticFieldId(
    r'SEGMENT_ID',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SEGMENT_ID`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SEGMENT_ID =>
      _id_SEGMENT_ID.get(_class, const jni$_.JStringNullableType());

  static final _id_TIMESTAMP = _class.staticFieldId(
    r'TIMESTAMP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TIMESTAMP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TIMESTAMP =>
      _id_TIMESTAMP.get(_class, const jni$_.JStringNullableType());

  static final _id_REPLAY_START_TIMESTAMP = _class.staticFieldId(
    r'REPLAY_START_TIMESTAMP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String REPLAY_START_TIMESTAMP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get REPLAY_START_TIMESTAMP =>
      _id_REPLAY_START_TIMESTAMP.get(_class, const jni$_.JStringNullableType());

  static final _id_URLS = _class.staticFieldId(
    r'URLS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String URLS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get URLS =>
      _id_URLS.get(_class, const jni$_.JStringNullableType());

  static final _id_ERROR_IDS = _class.staticFieldId(
    r'ERROR_IDS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ERROR_IDS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ERROR_IDS =>
      _id_ERROR_IDS.get(_class, const jni$_.JStringNullableType());

  static final _id_TRACE_IDS = _class.staticFieldId(
    r'TRACE_IDS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TRACE_IDS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TRACE_IDS =>
      _id_TRACE_IDS.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryReplayEvent$JsonKeys() {
    return SentryReplayEvent$JsonKeys.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $SentryReplayEvent$JsonKeys$NullableType
    extends jni$_.JObjType<SentryReplayEvent$JsonKeys?> {
  @jni$_.internal
  const $SentryReplayEvent$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryReplayEvent$JsonKeys;';

  @jni$_.internal
  @core$_.override
  SentryReplayEvent$JsonKeys? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryReplayEvent$JsonKeys.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayEvent$JsonKeys?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryReplayEvent$JsonKeys$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryReplayEvent$JsonKeys$NullableType) &&
        other is $SentryReplayEvent$JsonKeys$NullableType;
  }
}

final class $SentryReplayEvent$JsonKeys$Type
    extends jni$_.JObjType<SentryReplayEvent$JsonKeys> {
  @jni$_.internal
  const $SentryReplayEvent$JsonKeys$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryReplayEvent$JsonKeys;';

  @jni$_.internal
  @core$_.override
  SentryReplayEvent$JsonKeys fromReference(jni$_.JReference reference) =>
      SentryReplayEvent$JsonKeys.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayEvent$JsonKeys?> get nullableType =>
      const $SentryReplayEvent$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryReplayEvent$JsonKeys$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryReplayEvent$JsonKeys$Type) &&
        other is $SentryReplayEvent$JsonKeys$Type;
  }
}

/// from: `io.sentry.SentryReplayEvent$ReplayType$Deserializer`
class SentryReplayEvent$ReplayType$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryReplayEvent$ReplayType$Deserializer> $type;

  @jni$_.internal
  SentryReplayEvent$ReplayType$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'io/sentry/SentryReplayEvent$ReplayType$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $SentryReplayEvent$ReplayType$Deserializer$NullableType();
  static const type = $SentryReplayEvent$ReplayType$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryReplayEvent$ReplayType$Deserializer() {
    return SentryReplayEvent$ReplayType$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserialize = _class.instanceMethodId(
    r'deserialize',
    r'(Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Lio/sentry/SentryReplayEvent$ReplayType;',
  );

  static final _deserialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.SentryReplayEvent$ReplayType deserialize(io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryReplayEvent$ReplayType deserialize(
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserialize(
            reference.pointer,
            _id_deserialize as jni$_.JMethodIDPtr,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .object<SentryReplayEvent$ReplayType>(
            const $SentryReplayEvent$ReplayType$Type());
  }
}

final class $SentryReplayEvent$ReplayType$Deserializer$NullableType
    extends jni$_.JObjType<SentryReplayEvent$ReplayType$Deserializer?> {
  @jni$_.internal
  const $SentryReplayEvent$ReplayType$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/SentryReplayEvent$ReplayType$Deserializer;';

  @jni$_.internal
  @core$_.override
  SentryReplayEvent$ReplayType$Deserializer? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryReplayEvent$ReplayType$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayEvent$ReplayType$Deserializer?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryReplayEvent$ReplayType$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryReplayEvent$ReplayType$Deserializer$NullableType) &&
        other is $SentryReplayEvent$ReplayType$Deserializer$NullableType;
  }
}

final class $SentryReplayEvent$ReplayType$Deserializer$Type
    extends jni$_.JObjType<SentryReplayEvent$ReplayType$Deserializer> {
  @jni$_.internal
  const $SentryReplayEvent$ReplayType$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/SentryReplayEvent$ReplayType$Deserializer;';

  @jni$_.internal
  @core$_.override
  SentryReplayEvent$ReplayType$Deserializer fromReference(
          jni$_.JReference reference) =>
      SentryReplayEvent$ReplayType$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayEvent$ReplayType$Deserializer?> get nullableType =>
      const $SentryReplayEvent$ReplayType$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryReplayEvent$ReplayType$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryReplayEvent$ReplayType$Deserializer$Type) &&
        other is $SentryReplayEvent$ReplayType$Deserializer$Type;
  }
}

/// from: `io.sentry.SentryReplayEvent$ReplayType`
class SentryReplayEvent$ReplayType extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryReplayEvent$ReplayType> $type;

  @jni$_.internal
  SentryReplayEvent$ReplayType.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryReplayEvent$ReplayType');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryReplayEvent$ReplayType$NullableType();
  static const type = $SentryReplayEvent$ReplayType$Type();
  static final _id_SESSION = _class.staticFieldId(
    r'SESSION',
    r'Lio/sentry/SentryReplayEvent$ReplayType;',
  );

  /// from: `static public final io.sentry.SentryReplayEvent$ReplayType SESSION`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryReplayEvent$ReplayType get SESSION =>
      _id_SESSION.get(_class, const $SentryReplayEvent$ReplayType$Type());

  static final _id_BUFFER = _class.staticFieldId(
    r'BUFFER',
    r'Lio/sentry/SentryReplayEvent$ReplayType;',
  );

  /// from: `static public final io.sentry.SentryReplayEvent$ReplayType BUFFER`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryReplayEvent$ReplayType get BUFFER =>
      _id_BUFFER.get(_class, const $SentryReplayEvent$ReplayType$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Lio/sentry/SentryReplayEvent$ReplayType;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.SentryReplayEvent$ReplayType[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<SentryReplayEvent$ReplayType?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<SentryReplayEvent$ReplayType?>?>(
            const jni$_.JArrayNullableType<SentryReplayEvent$ReplayType?>(
                $SentryReplayEvent$ReplayType$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Lio/sentry/SentryReplayEvent$ReplayType;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.SentryReplayEvent$ReplayType valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryReplayEvent$ReplayType? valueOf(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<SentryReplayEvent$ReplayType?>(
            const $SentryReplayEvent$ReplayType$NullableType());
  }

  static final _id_serialize = _class.instanceMethodId(
    r'serialize',
    r'(Lio/sentry/ObjectWriter;Lio/sentry/ILogger;)V',
  );

  static final _serialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void serialize(io.sentry.ObjectWriter objectWriter, io.sentry.ILogger iLogger)`
  void serialize(
    jni$_.JObject objectWriter,
    jni$_.JObject iLogger,
  ) {
    final _$objectWriter = objectWriter.reference;
    final _$iLogger = iLogger.reference;
    _serialize(reference.pointer, _id_serialize as jni$_.JMethodIDPtr,
            _$objectWriter.pointer, _$iLogger.pointer)
        .check();
  }
}

final class $SentryReplayEvent$ReplayType$NullableType
    extends jni$_.JObjType<SentryReplayEvent$ReplayType?> {
  @jni$_.internal
  const $SentryReplayEvent$ReplayType$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryReplayEvent$ReplayType;';

  @jni$_.internal
  @core$_.override
  SentryReplayEvent$ReplayType? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryReplayEvent$ReplayType.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayEvent$ReplayType?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryReplayEvent$ReplayType$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryReplayEvent$ReplayType$NullableType) &&
        other is $SentryReplayEvent$ReplayType$NullableType;
  }
}

final class $SentryReplayEvent$ReplayType$Type
    extends jni$_.JObjType<SentryReplayEvent$ReplayType> {
  @jni$_.internal
  const $SentryReplayEvent$ReplayType$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryReplayEvent$ReplayType;';

  @jni$_.internal
  @core$_.override
  SentryReplayEvent$ReplayType fromReference(jni$_.JReference reference) =>
      SentryReplayEvent$ReplayType.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayEvent$ReplayType?> get nullableType =>
      const $SentryReplayEvent$ReplayType$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryReplayEvent$ReplayType$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryReplayEvent$ReplayType$Type) &&
        other is $SentryReplayEvent$ReplayType$Type;
  }
}

/// from: `io.sentry.SentryReplayEvent`
class SentryReplayEvent extends SentryBaseEvent {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryReplayEvent> $type;

  @jni$_.internal
  SentryReplayEvent.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/SentryReplayEvent');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryReplayEvent$NullableType();
  static const type = $SentryReplayEvent$Type();
}

final class $SentryReplayEvent$NullableType
    extends jni$_.JObjType<SentryReplayEvent?> {
  @jni$_.internal
  const $SentryReplayEvent$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryReplayEvent;';

  @jni$_.internal
  @core$_.override
  SentryReplayEvent? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryReplayEvent.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $SentryBaseEvent$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayEvent?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($SentryReplayEvent$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryReplayEvent$NullableType) &&
        other is $SentryReplayEvent$NullableType;
  }
}

final class $SentryReplayEvent$Type extends jni$_.JObjType<SentryReplayEvent> {
  @jni$_.internal
  const $SentryReplayEvent$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryReplayEvent;';

  @jni$_.internal
  @core$_.override
  SentryReplayEvent fromReference(jni$_.JReference reference) =>
      SentryReplayEvent.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $SentryBaseEvent$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayEvent?> get nullableType =>
      const $SentryReplayEvent$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($SentryReplayEvent$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryReplayEvent$Type) &&
        other is $SentryReplayEvent$Type;
  }
}

/// from: `io.sentry.SentryReplayOptions$SentryReplayQuality`
class SentryReplayOptions$SentryReplayQuality extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryReplayOptions$SentryReplayQuality> $type;

  @jni$_.internal
  SentryReplayOptions$SentryReplayQuality.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'io/sentry/SentryReplayOptions$SentryReplayQuality');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $SentryReplayOptions$SentryReplayQuality$NullableType();
  static const type = $SentryReplayOptions$SentryReplayQuality$Type();
  static final _id_LOW = _class.staticFieldId(
    r'LOW',
    r'Lio/sentry/SentryReplayOptions$SentryReplayQuality;',
  );

  /// from: `static public final io.sentry.SentryReplayOptions$SentryReplayQuality LOW`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryReplayOptions$SentryReplayQuality get LOW => _id_LOW.get(
      _class, const $SentryReplayOptions$SentryReplayQuality$Type());

  static final _id_MEDIUM = _class.staticFieldId(
    r'MEDIUM',
    r'Lio/sentry/SentryReplayOptions$SentryReplayQuality;',
  );

  /// from: `static public final io.sentry.SentryReplayOptions$SentryReplayQuality MEDIUM`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryReplayOptions$SentryReplayQuality get MEDIUM => _id_MEDIUM.get(
      _class, const $SentryReplayOptions$SentryReplayQuality$Type());

  static final _id_HIGH = _class.staticFieldId(
    r'HIGH',
    r'Lio/sentry/SentryReplayOptions$SentryReplayQuality;',
  );

  /// from: `static public final io.sentry.SentryReplayOptions$SentryReplayQuality HIGH`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryReplayOptions$SentryReplayQuality get HIGH => _id_HIGH.get(
      _class, const $SentryReplayOptions$SentryReplayQuality$Type());
}

final class $SentryReplayOptions$SentryReplayQuality$NullableType
    extends jni$_.JObjType<SentryReplayOptions$SentryReplayQuality?> {
  @jni$_.internal
  const $SentryReplayOptions$SentryReplayQuality$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/SentryReplayOptions$SentryReplayQuality;';

  @jni$_.internal
  @core$_.override
  SentryReplayOptions$SentryReplayQuality? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryReplayOptions$SentryReplayQuality.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayOptions$SentryReplayQuality?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryReplayOptions$SentryReplayQuality$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryReplayOptions$SentryReplayQuality$NullableType) &&
        other is $SentryReplayOptions$SentryReplayQuality$NullableType;
  }
}

final class $SentryReplayOptions$SentryReplayQuality$Type
    extends jni$_.JObjType<SentryReplayOptions$SentryReplayQuality> {
  @jni$_.internal
  const $SentryReplayOptions$SentryReplayQuality$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/SentryReplayOptions$SentryReplayQuality;';

  @jni$_.internal
  @core$_.override
  SentryReplayOptions$SentryReplayQuality fromReference(
          jni$_.JReference reference) =>
      SentryReplayOptions$SentryReplayQuality.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayOptions$SentryReplayQuality?> get nullableType =>
      const $SentryReplayOptions$SentryReplayQuality$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryReplayOptions$SentryReplayQuality$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryReplayOptions$SentryReplayQuality$Type) &&
        other is $SentryReplayOptions$SentryReplayQuality$Type;
  }
}

/// from: `io.sentry.SentryReplayOptions`
class SentryReplayOptions extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryReplayOptions> $type;

  @jni$_.internal
  SentryReplayOptions.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/SentryReplayOptions');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryReplayOptions$NullableType();
  static const type = $SentryReplayOptions$Type();
  static final _id_setOnErrorSampleRate = _class.instanceMethodId(
    r'setOnErrorSampleRate',
    r'(Ljava/lang/Double;)V',
  );

  static final _setOnErrorSampleRate = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setOnErrorSampleRate(java.lang.Double double)`
  void setOnErrorSampleRate(
    jni$_.JDouble? double,
  ) {
    final _$double = double?.reference ?? jni$_.jNullReference;
    _setOnErrorSampleRate(reference.pointer,
            _id_setOnErrorSampleRate as jni$_.JMethodIDPtr, _$double.pointer)
        .check();
  }

  static final _id_setSessionSampleRate = _class.instanceMethodId(
    r'setSessionSampleRate',
    r'(Ljava/lang/Double;)V',
  );

  static final _setSessionSampleRate = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setSessionSampleRate(java.lang.Double double)`
  void setSessionSampleRate(
    jni$_.JDouble? double,
  ) {
    final _$double = double?.reference ?? jni$_.jNullReference;
    _setSessionSampleRate(reference.pointer,
            _id_setSessionSampleRate as jni$_.JMethodIDPtr, _$double.pointer)
        .check();
  }

  static final _id_setQuality = _class.instanceMethodId(
    r'setQuality',
    r'(Lio/sentry/SentryReplayOptions$SentryReplayQuality;)V',
  );

  static final _setQuality = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setQuality(io.sentry.SentryReplayOptions$SentryReplayQuality sentryReplayQuality)`
  void setQuality(
    SentryReplayOptions$SentryReplayQuality sentryReplayQuality,
  ) {
    final _$sentryReplayQuality = sentryReplayQuality.reference;
    _setQuality(reference.pointer, _id_setQuality as jni$_.JMethodIDPtr,
            _$sentryReplayQuality.pointer)
        .check();
  }

  static final _id_setTrackConfiguration = _class.instanceMethodId(
    r'setTrackConfiguration',
    r'(Z)V',
  );

  static final _setTrackConfiguration = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setTrackConfiguration(boolean z)`
  void setTrackConfiguration(
    bool z,
  ) {
    _setTrackConfiguration(reference.pointer,
            _id_setTrackConfiguration as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_setSdkVersion = _class.instanceMethodId(
    r'setSdkVersion',
    r'(Lio/sentry/protocol/SdkVersion;)V',
  );

  static final _setSdkVersion = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setSdkVersion(io.sentry.protocol.SdkVersion sdkVersion)`
  void setSdkVersion(
    SdkVersion? sdkVersion,
  ) {
    final _$sdkVersion = sdkVersion?.reference ?? jni$_.jNullReference;
    _setSdkVersion(reference.pointer, _id_setSdkVersion as jni$_.JMethodIDPtr,
            _$sdkVersion.pointer)
        .check();
  }
}

final class $SentryReplayOptions$NullableType
    extends jni$_.JObjType<SentryReplayOptions?> {
  @jni$_.internal
  const $SentryReplayOptions$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryReplayOptions;';

  @jni$_.internal
  @core$_.override
  SentryReplayOptions? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryReplayOptions.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayOptions?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryReplayOptions$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryReplayOptions$NullableType) &&
        other is $SentryReplayOptions$NullableType;
  }
}

final class $SentryReplayOptions$Type
    extends jni$_.JObjType<SentryReplayOptions> {
  @jni$_.internal
  const $SentryReplayOptions$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryReplayOptions;';

  @jni$_.internal
  @core$_.override
  SentryReplayOptions fromReference(jni$_.JReference reference) =>
      SentryReplayOptions.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayOptions?> get nullableType =>
      const $SentryReplayOptions$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryReplayOptions$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryReplayOptions$Type) &&
        other is $SentryReplayOptions$Type;
  }
}

/// from: `io.sentry.Hint`
class Hint extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Hint> $type;

  @jni$_.internal
  Hint.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/Hint');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Hint$NullableType();
  static const type = $Hint$Type();
  static final _id_getReplayRecording = _class.instanceMethodId(
    r'getReplayRecording',
    r'()Lio/sentry/ReplayRecording;',
  );

  static final _getReplayRecording = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ReplayRecording getReplayRecording()`
  /// The returned object must be released after use, by calling the [release] method.
  ReplayRecording? getReplayRecording() {
    return _getReplayRecording(
            reference.pointer, _id_getReplayRecording as jni$_.JMethodIDPtr)
        .object<ReplayRecording?>(const $ReplayRecording$NullableType());
  }
}

final class $Hint$NullableType extends jni$_.JObjType<Hint?> {
  @jni$_.internal
  const $Hint$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Hint;';

  @jni$_.internal
  @core$_.override
  Hint? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Hint.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Hint?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Hint$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Hint$NullableType) &&
        other is $Hint$NullableType;
  }
}

final class $Hint$Type extends jni$_.JObjType<Hint> {
  @jni$_.internal
  const $Hint$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Hint;';

  @jni$_.internal
  @core$_.override
  Hint fromReference(jni$_.JReference reference) => Hint.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Hint?> get nullableType => const $Hint$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Hint$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Hint$Type) && other is $Hint$Type;
  }
}

/// from: `io.sentry.ReplayRecording$Deserializer`
class ReplayRecording$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ReplayRecording$Deserializer> $type;

  @jni$_.internal
  ReplayRecording$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/ReplayRecording$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ReplayRecording$Deserializer$NullableType();
  static const type = $ReplayRecording$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory ReplayRecording$Deserializer() {
    return ReplayRecording$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserialize = _class.instanceMethodId(
    r'deserialize',
    r'(Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Lio/sentry/ReplayRecording;',
  );

  static final _deserialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.ReplayRecording deserialize(io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  /// The returned object must be released after use, by calling the [release] method.
  ReplayRecording deserialize(
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserialize(
            reference.pointer,
            _id_deserialize as jni$_.JMethodIDPtr,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .object<ReplayRecording>(const $ReplayRecording$Type());
  }
}

final class $ReplayRecording$Deserializer$NullableType
    extends jni$_.JObjType<ReplayRecording$Deserializer?> {
  @jni$_.internal
  const $ReplayRecording$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/ReplayRecording$Deserializer;';

  @jni$_.internal
  @core$_.override
  ReplayRecording$Deserializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ReplayRecording$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ReplayRecording$Deserializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ReplayRecording$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ReplayRecording$Deserializer$NullableType) &&
        other is $ReplayRecording$Deserializer$NullableType;
  }
}

final class $ReplayRecording$Deserializer$Type
    extends jni$_.JObjType<ReplayRecording$Deserializer> {
  @jni$_.internal
  const $ReplayRecording$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/ReplayRecording$Deserializer;';

  @jni$_.internal
  @core$_.override
  ReplayRecording$Deserializer fromReference(jni$_.JReference reference) =>
      ReplayRecording$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ReplayRecording$Deserializer?> get nullableType =>
      const $ReplayRecording$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ReplayRecording$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ReplayRecording$Deserializer$Type) &&
        other is $ReplayRecording$Deserializer$Type;
  }
}

/// from: `io.sentry.ReplayRecording$JsonKeys`
class ReplayRecording$JsonKeys extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ReplayRecording$JsonKeys> $type;

  @jni$_.internal
  ReplayRecording$JsonKeys.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/ReplayRecording$JsonKeys');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ReplayRecording$JsonKeys$NullableType();
  static const type = $ReplayRecording$JsonKeys$Type();
  static final _id_SEGMENT_ID = _class.staticFieldId(
    r'SEGMENT_ID',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SEGMENT_ID`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SEGMENT_ID =>
      _id_SEGMENT_ID.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory ReplayRecording$JsonKeys() {
    return ReplayRecording$JsonKeys.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $ReplayRecording$JsonKeys$NullableType
    extends jni$_.JObjType<ReplayRecording$JsonKeys?> {
  @jni$_.internal
  const $ReplayRecording$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/ReplayRecording$JsonKeys;';

  @jni$_.internal
  @core$_.override
  ReplayRecording$JsonKeys? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ReplayRecording$JsonKeys.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ReplayRecording$JsonKeys?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ReplayRecording$JsonKeys$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ReplayRecording$JsonKeys$NullableType) &&
        other is $ReplayRecording$JsonKeys$NullableType;
  }
}

final class $ReplayRecording$JsonKeys$Type
    extends jni$_.JObjType<ReplayRecording$JsonKeys> {
  @jni$_.internal
  const $ReplayRecording$JsonKeys$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/ReplayRecording$JsonKeys;';

  @jni$_.internal
  @core$_.override
  ReplayRecording$JsonKeys fromReference(jni$_.JReference reference) =>
      ReplayRecording$JsonKeys.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ReplayRecording$JsonKeys?> get nullableType =>
      const $ReplayRecording$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ReplayRecording$JsonKeys$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ReplayRecording$JsonKeys$Type) &&
        other is $ReplayRecording$JsonKeys$Type;
  }
}

/// from: `io.sentry.ReplayRecording`
class ReplayRecording extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ReplayRecording> $type;

  @jni$_.internal
  ReplayRecording.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/ReplayRecording');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ReplayRecording$NullableType();
  static const type = $ReplayRecording$Type();
  static final _id_getPayload = _class.instanceMethodId(
    r'getPayload',
    r'()Ljava/util/List;',
  );

  static final _getPayload = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<? extends io.sentry.rrweb.RRWebEvent> getPayload()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getPayload() {
    return _getPayload(reference.pointer, _id_getPayload as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }
}

final class $ReplayRecording$NullableType
    extends jni$_.JObjType<ReplayRecording?> {
  @jni$_.internal
  const $ReplayRecording$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/ReplayRecording;';

  @jni$_.internal
  @core$_.override
  ReplayRecording? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : ReplayRecording.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ReplayRecording?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ReplayRecording$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ReplayRecording$NullableType) &&
        other is $ReplayRecording$NullableType;
  }
}

final class $ReplayRecording$Type extends jni$_.JObjType<ReplayRecording> {
  @jni$_.internal
  const $ReplayRecording$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/ReplayRecording;';

  @jni$_.internal
  @core$_.override
  ReplayRecording fromReference(jni$_.JReference reference) =>
      ReplayRecording.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ReplayRecording?> get nullableType =>
      const $ReplayRecording$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ReplayRecording$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ReplayRecording$Type) &&
        other is $ReplayRecording$Type;
  }
}

/// from: `io.sentry.rrweb.RRWebOptionsEvent$Deserializer`
class RRWebOptionsEvent$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<RRWebOptionsEvent$Deserializer> $type;

  @jni$_.internal
  RRWebOptionsEvent$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/rrweb/RRWebOptionsEvent$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $RRWebOptionsEvent$Deserializer$NullableType();
  static const type = $RRWebOptionsEvent$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory RRWebOptionsEvent$Deserializer() {
    return RRWebOptionsEvent$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserialize = _class.instanceMethodId(
    r'deserialize',
    r'(Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Lio/sentry/rrweb/RRWebOptionsEvent;',
  );

  static final _deserialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.rrweb.RRWebOptionsEvent deserialize(io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  /// The returned object must be released after use, by calling the [release] method.
  RRWebOptionsEvent deserialize(
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserialize(
            reference.pointer,
            _id_deserialize as jni$_.JMethodIDPtr,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .object<RRWebOptionsEvent>(const $RRWebOptionsEvent$Type());
  }
}

final class $RRWebOptionsEvent$Deserializer$NullableType
    extends jni$_.JObjType<RRWebOptionsEvent$Deserializer?> {
  @jni$_.internal
  const $RRWebOptionsEvent$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/rrweb/RRWebOptionsEvent$Deserializer;';

  @jni$_.internal
  @core$_.override
  RRWebOptionsEvent$Deserializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : RRWebOptionsEvent$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RRWebOptionsEvent$Deserializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($RRWebOptionsEvent$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($RRWebOptionsEvent$Deserializer$NullableType) &&
        other is $RRWebOptionsEvent$Deserializer$NullableType;
  }
}

final class $RRWebOptionsEvent$Deserializer$Type
    extends jni$_.JObjType<RRWebOptionsEvent$Deserializer> {
  @jni$_.internal
  const $RRWebOptionsEvent$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/rrweb/RRWebOptionsEvent$Deserializer;';

  @jni$_.internal
  @core$_.override
  RRWebOptionsEvent$Deserializer fromReference(jni$_.JReference reference) =>
      RRWebOptionsEvent$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RRWebOptionsEvent$Deserializer?> get nullableType =>
      const $RRWebOptionsEvent$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($RRWebOptionsEvent$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RRWebOptionsEvent$Deserializer$Type) &&
        other is $RRWebOptionsEvent$Deserializer$Type;
  }
}

/// from: `io.sentry.rrweb.RRWebOptionsEvent$JsonKeys`
class RRWebOptionsEvent$JsonKeys extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<RRWebOptionsEvent$JsonKeys> $type;

  @jni$_.internal
  RRWebOptionsEvent$JsonKeys.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/rrweb/RRWebOptionsEvent$JsonKeys');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $RRWebOptionsEvent$JsonKeys$NullableType();
  static const type = $RRWebOptionsEvent$JsonKeys$Type();
  static final _id_DATA = _class.staticFieldId(
    r'DATA',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DATA`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DATA =>
      _id_DATA.get(_class, const jni$_.JStringNullableType());

  static final _id_PAYLOAD = _class.staticFieldId(
    r'PAYLOAD',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PAYLOAD`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get PAYLOAD =>
      _id_PAYLOAD.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory RRWebOptionsEvent$JsonKeys() {
    return RRWebOptionsEvent$JsonKeys.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $RRWebOptionsEvent$JsonKeys$NullableType
    extends jni$_.JObjType<RRWebOptionsEvent$JsonKeys?> {
  @jni$_.internal
  const $RRWebOptionsEvent$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/rrweb/RRWebOptionsEvent$JsonKeys;';

  @jni$_.internal
  @core$_.override
  RRWebOptionsEvent$JsonKeys? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : RRWebOptionsEvent$JsonKeys.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RRWebOptionsEvent$JsonKeys?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($RRWebOptionsEvent$JsonKeys$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RRWebOptionsEvent$JsonKeys$NullableType) &&
        other is $RRWebOptionsEvent$JsonKeys$NullableType;
  }
}

final class $RRWebOptionsEvent$JsonKeys$Type
    extends jni$_.JObjType<RRWebOptionsEvent$JsonKeys> {
  @jni$_.internal
  const $RRWebOptionsEvent$JsonKeys$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/rrweb/RRWebOptionsEvent$JsonKeys;';

  @jni$_.internal
  @core$_.override
  RRWebOptionsEvent$JsonKeys fromReference(jni$_.JReference reference) =>
      RRWebOptionsEvent$JsonKeys.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RRWebOptionsEvent$JsonKeys?> get nullableType =>
      const $RRWebOptionsEvent$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($RRWebOptionsEvent$JsonKeys$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RRWebOptionsEvent$JsonKeys$Type) &&
        other is $RRWebOptionsEvent$JsonKeys$Type;
  }
}

/// from: `io.sentry.rrweb.RRWebOptionsEvent`
class RRWebOptionsEvent extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<RRWebOptionsEvent> $type;

  @jni$_.internal
  RRWebOptionsEvent.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/rrweb/RRWebOptionsEvent');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $RRWebOptionsEvent$NullableType();
  static const type = $RRWebOptionsEvent$Type();
  static final _id_getOptionsPayload = _class.instanceMethodId(
    r'getOptionsPayload',
    r'()Ljava/util/Map;',
  );

  static final _getOptionsPayload = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Map<java.lang.String, java.lang.Object> getOptionsPayload()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JObject?> getOptionsPayload() {
    return _getOptionsPayload(
            reference.pointer, _id_getOptionsPayload as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JString?, jni$_.JObject?>(
                jni$_.JStringNullableType(), jni$_.JObjectNullableType()));
  }
}

final class $RRWebOptionsEvent$NullableType
    extends jni$_.JObjType<RRWebOptionsEvent?> {
  @jni$_.internal
  const $RRWebOptionsEvent$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/rrweb/RRWebOptionsEvent;';

  @jni$_.internal
  @core$_.override
  RRWebOptionsEvent? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : RRWebOptionsEvent.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RRWebOptionsEvent?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($RRWebOptionsEvent$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RRWebOptionsEvent$NullableType) &&
        other is $RRWebOptionsEvent$NullableType;
  }
}

final class $RRWebOptionsEvent$Type extends jni$_.JObjType<RRWebOptionsEvent> {
  @jni$_.internal
  const $RRWebOptionsEvent$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/rrweb/RRWebOptionsEvent;';

  @jni$_.internal
  @core$_.override
  RRWebOptionsEvent fromReference(jni$_.JReference reference) =>
      RRWebOptionsEvent.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RRWebOptionsEvent?> get nullableType =>
      const $RRWebOptionsEvent$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($RRWebOptionsEvent$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RRWebOptionsEvent$Type) &&
        other is $RRWebOptionsEvent$Type;
  }
}

/// from: `io.sentry.SentryLevel$Deserializer`
class SentryLevel$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryLevel$Deserializer> $type;

  @jni$_.internal
  SentryLevel$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryLevel$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryLevel$Deserializer$NullableType();
  static const type = $SentryLevel$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryLevel$Deserializer() {
    return SentryLevel$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserialize = _class.instanceMethodId(
    r'deserialize',
    r'(Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Lio/sentry/SentryLevel;',
  );

  static final _deserialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.SentryLevel deserialize(io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryLevel deserialize(
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserialize(
            reference.pointer,
            _id_deserialize as jni$_.JMethodIDPtr,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .object<SentryLevel>(const $SentryLevel$Type());
  }
}

final class $SentryLevel$Deserializer$NullableType
    extends jni$_.JObjType<SentryLevel$Deserializer?> {
  @jni$_.internal
  const $SentryLevel$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryLevel$Deserializer;';

  @jni$_.internal
  @core$_.override
  SentryLevel$Deserializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryLevel$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryLevel$Deserializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryLevel$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryLevel$Deserializer$NullableType) &&
        other is $SentryLevel$Deserializer$NullableType;
  }
}

final class $SentryLevel$Deserializer$Type
    extends jni$_.JObjType<SentryLevel$Deserializer> {
  @jni$_.internal
  const $SentryLevel$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryLevel$Deserializer;';

  @jni$_.internal
  @core$_.override
  SentryLevel$Deserializer fromReference(jni$_.JReference reference) =>
      SentryLevel$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryLevel$Deserializer?> get nullableType =>
      const $SentryLevel$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryLevel$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryLevel$Deserializer$Type) &&
        other is $SentryLevel$Deserializer$Type;
  }
}

/// from: `io.sentry.SentryLevel`
class SentryLevel extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryLevel> $type;

  @jni$_.internal
  SentryLevel.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/SentryLevel');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryLevel$NullableType();
  static const type = $SentryLevel$Type();
  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Lio/sentry/SentryLevel;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.SentryLevel valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryLevel? valueOf(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<SentryLevel?>(const $SentryLevel$NullableType());
  }
}

final class $SentryLevel$NullableType extends jni$_.JObjType<SentryLevel?> {
  @jni$_.internal
  const $SentryLevel$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryLevel;';

  @jni$_.internal
  @core$_.override
  SentryLevel? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : SentryLevel.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryLevel?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryLevel$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryLevel$NullableType) &&
        other is $SentryLevel$NullableType;
  }
}

final class $SentryLevel$Type extends jni$_.JObjType<SentryLevel> {
  @jni$_.internal
  const $SentryLevel$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryLevel;';

  @jni$_.internal
  @core$_.override
  SentryLevel fromReference(jni$_.JReference reference) =>
      SentryLevel.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryLevel?> get nullableType =>
      const $SentryLevel$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryLevel$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryLevel$Type) &&
        other is $SentryLevel$Type;
  }
}

/// from: `java.net.Proxy$Type`
class Proxy$Type extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Proxy$Type> $type;

  @jni$_.internal
  Proxy$Type.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/Proxy$Type');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Proxy$Type$NullableType();
  static const type = $Proxy$Type$Type();
  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Ljava/net/Proxy$Type;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.net.Proxy$Type valueOf(java.lang.String synthetic)`
  /// The returned object must be released after use, by calling the [release] method.
  static Proxy$Type? valueOf(
    jni$_.JString? synthetic,
  ) {
    final _$synthetic = synthetic?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$synthetic.pointer)
        .object<Proxy$Type?>(const $Proxy$Type$NullableType());
  }
}

final class $Proxy$Type$NullableType extends jni$_.JObjType<Proxy$Type?> {
  @jni$_.internal
  const $Proxy$Type$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/Proxy$Type;';

  @jni$_.internal
  @core$_.override
  Proxy$Type? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Proxy$Type.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Proxy$Type?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Proxy$Type$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Proxy$Type$NullableType) &&
        other is $Proxy$Type$NullableType;
  }
}

final class $Proxy$Type$Type extends jni$_.JObjType<Proxy$Type> {
  @jni$_.internal
  const $Proxy$Type$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/Proxy$Type;';

  @jni$_.internal
  @core$_.override
  Proxy$Type fromReference(jni$_.JReference reference) =>
      Proxy$Type.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Proxy$Type?> get nullableType =>
      const $Proxy$Type$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Proxy$Type$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Proxy$Type$Type) && other is $Proxy$Type$Type;
  }
}

/// from: `java.net.Proxy`
class Proxy extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Proxy> $type;

  @jni$_.internal
  Proxy.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/Proxy');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Proxy$NullableType();
  static const type = $Proxy$Type();
}

final class $Proxy$NullableType extends jni$_.JObjType<Proxy?> {
  @jni$_.internal
  const $Proxy$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/Proxy;';

  @jni$_.internal
  @core$_.override
  Proxy? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Proxy.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Proxy?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Proxy$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Proxy$NullableType) &&
        other is $Proxy$NullableType;
  }
}

final class $Proxy$Type extends jni$_.JObjType<Proxy> {
  @jni$_.internal
  const $Proxy$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/Proxy;';

  @jni$_.internal
  @core$_.override
  Proxy fromReference(jni$_.JReference reference) => Proxy.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Proxy?> get nullableType => const $Proxy$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Proxy$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Proxy$Type) && other is $Proxy$Type;
  }
}

/// from: `android.graphics.Bitmap$CompressFormat`
class Bitmap$CompressFormat extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Bitmap$CompressFormat> $type;

  @jni$_.internal
  Bitmap$CompressFormat.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'android/graphics/Bitmap$CompressFormat');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Bitmap$CompressFormat$NullableType();
  static const type = $Bitmap$CompressFormat$Type();
  static final _id_JPEG = _class.staticFieldId(
    r'JPEG',
    r'Landroid/graphics/Bitmap$CompressFormat;',
  );

  /// from: `static public final android.graphics.Bitmap$CompressFormat JPEG`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat get JPEG =>
      _id_JPEG.get(_class, const $Bitmap$CompressFormat$Type());

  static final _id_PNG = _class.staticFieldId(
    r'PNG',
    r'Landroid/graphics/Bitmap$CompressFormat;',
  );

  /// from: `static public final android.graphics.Bitmap$CompressFormat PNG`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat get PNG =>
      _id_PNG.get(_class, const $Bitmap$CompressFormat$Type());

  static final _id_WEBP = _class.staticFieldId(
    r'WEBP',
    r'Landroid/graphics/Bitmap$CompressFormat;',
  );

  /// from: `static public final android.graphics.Bitmap$CompressFormat WEBP`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat get WEBP =>
      _id_WEBP.get(_class, const $Bitmap$CompressFormat$Type());

  static final _id_WEBP_LOSSY = _class.staticFieldId(
    r'WEBP_LOSSY',
    r'Landroid/graphics/Bitmap$CompressFormat;',
  );

  /// from: `static public final android.graphics.Bitmap$CompressFormat WEBP_LOSSY`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat get WEBP_LOSSY =>
      _id_WEBP_LOSSY.get(_class, const $Bitmap$CompressFormat$Type());

  static final _id_WEBP_LOSSLESS = _class.staticFieldId(
    r'WEBP_LOSSLESS',
    r'Landroid/graphics/Bitmap$CompressFormat;',
  );

  /// from: `static public final android.graphics.Bitmap$CompressFormat WEBP_LOSSLESS`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat get WEBP_LOSSLESS =>
      _id_WEBP_LOSSLESS.get(_class, const $Bitmap$CompressFormat$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Landroid/graphics/Bitmap$CompressFormat;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public android.graphics.Bitmap$CompressFormat[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Bitmap$CompressFormat?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<Bitmap$CompressFormat?>?>(
            const jni$_.JArrayNullableType<Bitmap$CompressFormat?>(
                $Bitmap$CompressFormat$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Landroid/graphics/Bitmap$CompressFormat;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap$CompressFormat valueOf(java.lang.String synthetic)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat? valueOf(
    jni$_.JString? synthetic,
  ) {
    final _$synthetic = synthetic?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$synthetic.pointer)
        .object<Bitmap$CompressFormat?>(
            const $Bitmap$CompressFormat$NullableType());
  }
}

final class $Bitmap$CompressFormat$NullableType
    extends jni$_.JObjType<Bitmap$CompressFormat?> {
  @jni$_.internal
  const $Bitmap$CompressFormat$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap$CompressFormat;';

  @jni$_.internal
  @core$_.override
  Bitmap$CompressFormat? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Bitmap$CompressFormat.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Bitmap$CompressFormat?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$CompressFormat$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$CompressFormat$NullableType) &&
        other is $Bitmap$CompressFormat$NullableType;
  }
}

final class $Bitmap$CompressFormat$Type
    extends jni$_.JObjType<Bitmap$CompressFormat> {
  @jni$_.internal
  const $Bitmap$CompressFormat$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap$CompressFormat;';

  @jni$_.internal
  @core$_.override
  Bitmap$CompressFormat fromReference(jni$_.JReference reference) =>
      Bitmap$CompressFormat.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Bitmap$CompressFormat?> get nullableType =>
      const $Bitmap$CompressFormat$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$CompressFormat$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$CompressFormat$Type) &&
        other is $Bitmap$CompressFormat$Type;
  }
}

/// from: `android.graphics.Bitmap$Config`
class Bitmap$Config extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Bitmap$Config> $type;

  @jni$_.internal
  Bitmap$Config.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/graphics/Bitmap$Config');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Bitmap$Config$NullableType();
  static const type = $Bitmap$Config$Type();
  static final _id_ARGB_8888 = _class.staticFieldId(
    r'ARGB_8888',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config ARGB_8888`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get ARGB_8888 =>
      _id_ARGB_8888.get(_class, const $Bitmap$Config$Type());
}

final class $Bitmap$Config$NullableType extends jni$_.JObjType<Bitmap$Config?> {
  @jni$_.internal
  const $Bitmap$Config$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap$Config;';

  @jni$_.internal
  @core$_.override
  Bitmap$Config? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Bitmap$Config.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Bitmap$Config?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$Config$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$Config$NullableType) &&
        other is $Bitmap$Config$NullableType;
  }
}

final class $Bitmap$Config$Type extends jni$_.JObjType<Bitmap$Config> {
  @jni$_.internal
  const $Bitmap$Config$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap$Config;';

  @jni$_.internal
  @core$_.override
  Bitmap$Config fromReference(jni$_.JReference reference) =>
      Bitmap$Config.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Bitmap$Config?> get nullableType =>
      const $Bitmap$Config$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$Config$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$Config$Type) &&
        other is $Bitmap$Config$Type;
  }
}

/// from: `android.graphics.Bitmap`
class Bitmap extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Bitmap> $type;

  @jni$_.internal
  Bitmap.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/graphics/Bitmap');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Bitmap$NullableType();
  static const type = $Bitmap$Type();
  static final _id_copyPixelsFromBuffer = _class.instanceMethodId(
    r'copyPixelsFromBuffer',
    r'(Ljava/nio/Buffer;)V',
  );

  static final _copyPixelsFromBuffer = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void copyPixelsFromBuffer(java.nio.Buffer buffer)`
  void copyPixelsFromBuffer(
    jni$_.JBuffer? buffer,
  ) {
    final _$buffer = buffer?.reference ?? jni$_.jNullReference;
    _copyPixelsFromBuffer(reference.pointer,
            _id_copyPixelsFromBuffer as jni$_.JMethodIDPtr, _$buffer.pointer)
        .check();
  }

  static final _id_createBitmap = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/graphics/Bitmap;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.graphics.Bitmap bitmap)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap(
    Bitmap? bitmap,
  ) {
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    return _createBitmap(_class.reference.pointer,
            _id_createBitmap as jni$_.JMethodIDPtr, _$bitmap.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$1 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/graphics/Bitmap;IIII)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.graphics.Bitmap bitmap, int i, int i1, int i2, int i3)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$1(
    Bitmap? bitmap,
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    return _createBitmap$1(
            _class.reference.pointer,
            _id_createBitmap$1 as jni$_.JMethodIDPtr,
            _$bitmap.pointer,
            i,
            i1,
            i2,
            i3)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$2 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/graphics/Bitmap;IIIILandroid/graphics/Matrix;Z)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.graphics.Bitmap bitmap, int i, int i1, int i2, int i3, android.graphics.Matrix matrix, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$2(
    Bitmap? bitmap,
    int i,
    int i1,
    int i2,
    int i3,
    jni$_.JObject? matrix,
    bool z,
  ) {
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    final _$matrix = matrix?.reference ?? jni$_.jNullReference;
    return _createBitmap$2(
            _class.reference.pointer,
            _id_createBitmap$2 as jni$_.JMethodIDPtr,
            _$bitmap.pointer,
            i,
            i1,
            i2,
            i3,
            _$matrix.pointer,
            z ? 1 : 0)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$3 = _class.staticMethodId(
    r'createBitmap',
    r'(IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(int i, int i1, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$3(
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$3(_class.reference.pointer,
            _id_createBitmap$3 as jni$_.JMethodIDPtr, i, i1, _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$4 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/util/DisplayMetrics;IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int i, int i1, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$4(
    jni$_.JObject? displayMetrics,
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$4(
            _class.reference.pointer,
            _id_createBitmap$4 as jni$_.JMethodIDPtr,
            _$displayMetrics.pointer,
            i,
            i1,
            _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$5 = _class.staticMethodId(
    r'createBitmap',
    r'(IILandroid/graphics/Bitmap$Config;Z)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$5 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `static public android.graphics.Bitmap createBitmap(int i, int i1, android.graphics.Bitmap$Config config, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$5(
    int i,
    int i1,
    Bitmap$Config? config,
    bool z,
  ) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$5(
            _class.reference.pointer,
            _id_createBitmap$5 as jni$_.JMethodIDPtr,
            i,
            i1,
            _$config.pointer,
            z ? 1 : 0)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$6 = _class.staticMethodId(
    r'createBitmap',
    r'(IILandroid/graphics/Bitmap$Config;ZLandroid/graphics/ColorSpace;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$6 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(int i, int i1, android.graphics.Bitmap$Config config, boolean z, android.graphics.ColorSpace colorSpace)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$6(
    int i,
    int i1,
    Bitmap$Config? config,
    bool z,
    jni$_.JObject? colorSpace,
  ) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    final _$colorSpace = colorSpace?.reference ?? jni$_.jNullReference;
    return _createBitmap$6(
            _class.reference.pointer,
            _id_createBitmap$6 as jni$_.JMethodIDPtr,
            i,
            i1,
            _$config.pointer,
            z ? 1 : 0,
            _$colorSpace.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$7 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/util/DisplayMetrics;IILandroid/graphics/Bitmap$Config;Z)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$7 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int i, int i1, android.graphics.Bitmap$Config config, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$7(
    jni$_.JObject? displayMetrics,
    int i,
    int i1,
    Bitmap$Config? config,
    bool z,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$7(
            _class.reference.pointer,
            _id_createBitmap$7 as jni$_.JMethodIDPtr,
            _$displayMetrics.pointer,
            i,
            i1,
            _$config.pointer,
            z ? 1 : 0)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$8 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/util/DisplayMetrics;IILandroid/graphics/Bitmap$Config;ZLandroid/graphics/ColorSpace;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$8 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int i, int i1, android.graphics.Bitmap$Config config, boolean z, android.graphics.ColorSpace colorSpace)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$8(
    jni$_.JObject? displayMetrics,
    int i,
    int i1,
    Bitmap$Config? config,
    bool z,
    jni$_.JObject? colorSpace,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    final _$colorSpace = colorSpace?.reference ?? jni$_.jNullReference;
    return _createBitmap$8(
            _class.reference.pointer,
            _id_createBitmap$8 as jni$_.JMethodIDPtr,
            _$displayMetrics.pointer,
            i,
            i1,
            _$config.pointer,
            z ? 1 : 0,
            _$colorSpace.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$9 = _class.staticMethodId(
    r'createBitmap',
    r'([IIIIILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$9 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(int[] is, int i, int i1, int i2, int i3, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$9(
    jni$_.JIntArray? is$,
    int i,
    int i1,
    int i2,
    int i3,
    Bitmap$Config? config,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$9(
            _class.reference.pointer,
            _id_createBitmap$9 as jni$_.JMethodIDPtr,
            _$is$.pointer,
            i,
            i1,
            i2,
            i3,
            _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$10 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/util/DisplayMetrics;[IIIIILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$10 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int[] is, int i, int i1, int i2, int i3, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$10(
    jni$_.JObject? displayMetrics,
    jni$_.JIntArray? is$,
    int i,
    int i1,
    int i2,
    int i3,
    Bitmap$Config? config,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$10(
            _class.reference.pointer,
            _id_createBitmap$10 as jni$_.JMethodIDPtr,
            _$displayMetrics.pointer,
            _$is$.pointer,
            i,
            i1,
            i2,
            i3,
            _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$11 = _class.staticMethodId(
    r'createBitmap',
    r'([IIILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$11 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(int[] is, int i, int i1, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$11(
    jni$_.JIntArray? is$,
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$11(
            _class.reference.pointer,
            _id_createBitmap$11 as jni$_.JMethodIDPtr,
            _$is$.pointer,
            i,
            i1,
            _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$12 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/util/DisplayMetrics;[IIILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$12 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int[] is, int i, int i1, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$12(
    jni$_.JObject? displayMetrics,
    jni$_.JIntArray? is$,
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$12(
            _class.reference.pointer,
            _id_createBitmap$12 as jni$_.JMethodIDPtr,
            _$displayMetrics.pointer,
            _$is$.pointer,
            i,
            i1,
            _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$13 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/graphics/Picture;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$13 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.graphics.Picture picture)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$13(
    jni$_.JObject? picture,
  ) {
    final _$picture = picture?.reference ?? jni$_.jNullReference;
    return _createBitmap$13(_class.reference.pointer,
            _id_createBitmap$13 as jni$_.JMethodIDPtr, _$picture.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$14 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/graphics/Picture;IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$14 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.graphics.Picture picture, int i, int i1, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$14(
    jni$_.JObject? picture,
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$picture = picture?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$14(
            _class.reference.pointer,
            _id_createBitmap$14 as jni$_.JMethodIDPtr,
            _$picture.pointer,
            i,
            i1,
            _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_getWidth = _class.instanceMethodId(
    r'getWidth',
    r'()I',
  );

  static final _getWidth = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getWidth()`
  int getWidth() {
    return _getWidth(reference.pointer, _id_getWidth as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getHeight = _class.instanceMethodId(
    r'getHeight',
    r'()I',
  );

  static final _getHeight = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getHeight()`
  int getHeight() {
    return _getHeight(reference.pointer, _id_getHeight as jni$_.JMethodIDPtr)
        .integer;
  }
}

final class $Bitmap$NullableType extends jni$_.JObjType<Bitmap?> {
  @jni$_.internal
  const $Bitmap$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap;';

  @jni$_.internal
  @core$_.override
  Bitmap? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Bitmap.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Bitmap?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$NullableType) &&
        other is $Bitmap$NullableType;
  }
}

final class $Bitmap$Type extends jni$_.JObjType<Bitmap> {
  @jni$_.internal
  const $Bitmap$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap;';

  @jni$_.internal
  @core$_.override
  Bitmap fromReference(jni$_.JReference reference) => Bitmap.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Bitmap?> get nullableType => const $Bitmap$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$Type) && other is $Bitmap$Type;
  }
}
