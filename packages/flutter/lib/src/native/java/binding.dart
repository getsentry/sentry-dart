// AUTO GENERATED BY JNIGEN 0.14.2. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `io.sentry.android.core.SentryAndroid`
class SentryAndroid extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryAndroid> $type;

  @jni$_.internal
  SentryAndroid.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/android/core/SentryAndroid');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryAndroid$NullableType();
  static const type = $SentryAndroid$Type();
  static final _id_init = _class.staticMethodId(
    r'init',
    r'(Landroid/content/Context;)V',
  );

  static final _init = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void init(android.content.Context context)`
  static void init(
    Context context,
  ) {
    final _$context = context.reference;
    _init(_class.reference.pointer, _id_init as jni$_.JMethodIDPtr,
            _$context.pointer)
        .check();
  }

  static final _id_init$1 = _class.staticMethodId(
    r'init',
    r'(Landroid/content/Context;Lio/sentry/ILogger;)V',
  );

  static final _init$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void init(android.content.Context context, io.sentry.ILogger iLogger)`
  static void init$1(
    Context context,
    jni$_.JObject iLogger,
  ) {
    final _$context = context.reference;
    final _$iLogger = iLogger.reference;
    _init$1(_class.reference.pointer, _id_init$1 as jni$_.JMethodIDPtr,
            _$context.pointer, _$iLogger.pointer)
        .check();
  }

  static final _id_init$2 = _class.staticMethodId(
    r'init',
    r'(Landroid/content/Context;Lio/sentry/Sentry$OptionsConfiguration;)V',
  );

  static final _init$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void init(android.content.Context context, io.sentry.Sentry$OptionsConfiguration<io.sentry.android.core.SentryAndroidOptions> optionsConfiguration)`
  static void init$2(
    Context context,
    Sentry$OptionsConfiguration<SentryAndroidOptions?> optionsConfiguration,
  ) {
    final _$context = context.reference;
    final _$optionsConfiguration = optionsConfiguration.reference;
    _init$2(_class.reference.pointer, _id_init$2 as jni$_.JMethodIDPtr,
            _$context.pointer, _$optionsConfiguration.pointer)
        .check();
  }

  static final _id_init$3 = _class.staticMethodId(
    r'init',
    r'(Landroid/content/Context;Lio/sentry/ILogger;Lio/sentry/Sentry$OptionsConfiguration;)V',
  );

  static final _init$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void init(android.content.Context context, io.sentry.ILogger iLogger, io.sentry.Sentry$OptionsConfiguration<io.sentry.android.core.SentryAndroidOptions> optionsConfiguration)`
  static void init$3(
    Context context,
    jni$_.JObject iLogger,
    Sentry$OptionsConfiguration<SentryAndroidOptions?> optionsConfiguration,
  ) {
    final _$context = context.reference;
    final _$iLogger = iLogger.reference;
    final _$optionsConfiguration = optionsConfiguration.reference;
    _init$3(
            _class.reference.pointer,
            _id_init$3 as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$iLogger.pointer,
            _$optionsConfiguration.pointer)
        .check();
  }
}

final class $SentryAndroid$NullableType extends jni$_.JObjType<SentryAndroid?> {
  @jni$_.internal
  const $SentryAndroid$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/core/SentryAndroid;';

  @jni$_.internal
  @core$_.override
  SentryAndroid? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : SentryAndroid.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryAndroid?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryAndroid$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryAndroid$NullableType) &&
        other is $SentryAndroid$NullableType;
  }
}

final class $SentryAndroid$Type extends jni$_.JObjType<SentryAndroid> {
  @jni$_.internal
  const $SentryAndroid$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/core/SentryAndroid;';

  @jni$_.internal
  @core$_.override
  SentryAndroid fromReference(jni$_.JReference reference) =>
      SentryAndroid.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryAndroid?> get nullableType =>
      const $SentryAndroid$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryAndroid$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryAndroid$Type) &&
        other is $SentryAndroid$Type;
  }
}

/// from: `io.sentry.android.core.SentryAndroidOptions$BeforeCaptureCallback`
class SentryAndroidOptions$BeforeCaptureCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryAndroidOptions$BeforeCaptureCallback> $type;

  @jni$_.internal
  SentryAndroidOptions$BeforeCaptureCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'io/sentry/android/core/SentryAndroidOptions$BeforeCaptureCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $SentryAndroidOptions$BeforeCaptureCallback$NullableType();
  static const type = $SentryAndroidOptions$BeforeCaptureCallback$Type();
  static final _id_execute = _class.instanceMethodId(
    r'execute',
    r'(Lio/sentry/SentryEvent;Lio/sentry/Hint;Z)Z',
  );

  static final _execute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `public abstract boolean execute(io.sentry.SentryEvent sentryEvent, io.sentry.Hint hint, boolean z)`
  bool execute(
    SentryEvent sentryEvent,
    Hint hint,
    bool z,
  ) {
    final _$sentryEvent = sentryEvent.reference;
    final _$hint = hint.reference;
    return _execute(reference.pointer, _id_execute as jni$_.JMethodIDPtr,
            _$sentryEvent.pointer, _$hint.pointer, z ? 1 : 0)
        .boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SentryAndroidOptions$BeforeCaptureCallback>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'execute(Lio/sentry/SentryEvent;Lio/sentry/Hint;Z)Z') {
        final $r = _$impls[$p]!.execute(
          $a![0]!.as(const $SentryEvent$Type(), releaseOriginal: true),
          $a![1]!.as(const $Hint$Type(), releaseOriginal: true),
          $a![2]!
              .as(const jni$_.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $SentryAndroidOptions$BeforeCaptureCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.android.core.SentryAndroidOptions$BeforeCaptureCallback',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SentryAndroidOptions$BeforeCaptureCallback.implement(
    $SentryAndroidOptions$BeforeCaptureCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SentryAndroidOptions$BeforeCaptureCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $SentryAndroidOptions$BeforeCaptureCallback {
  factory $SentryAndroidOptions$BeforeCaptureCallback({
    required bool Function(SentryEvent sentryEvent, Hint hint, bool z) execute,
  }) = _$SentryAndroidOptions$BeforeCaptureCallback;

  bool execute(SentryEvent sentryEvent, Hint hint, bool z);
}

final class _$SentryAndroidOptions$BeforeCaptureCallback
    with $SentryAndroidOptions$BeforeCaptureCallback {
  _$SentryAndroidOptions$BeforeCaptureCallback({
    required bool Function(SentryEvent sentryEvent, Hint hint, bool z) execute,
  }) : _execute = execute;

  final bool Function(SentryEvent sentryEvent, Hint hint, bool z) _execute;

  bool execute(SentryEvent sentryEvent, Hint hint, bool z) {
    return _execute(sentryEvent, hint, z);
  }
}

final class $SentryAndroidOptions$BeforeCaptureCallback$NullableType
    extends jni$_.JObjType<SentryAndroidOptions$BeforeCaptureCallback?> {
  @jni$_.internal
  const $SentryAndroidOptions$BeforeCaptureCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/android/core/SentryAndroidOptions$BeforeCaptureCallback;';

  @jni$_.internal
  @core$_.override
  SentryAndroidOptions$BeforeCaptureCallback? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryAndroidOptions$BeforeCaptureCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryAndroidOptions$BeforeCaptureCallback?>
      get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryAndroidOptions$BeforeCaptureCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryAndroidOptions$BeforeCaptureCallback$NullableType) &&
        other is $SentryAndroidOptions$BeforeCaptureCallback$NullableType;
  }
}

final class $SentryAndroidOptions$BeforeCaptureCallback$Type
    extends jni$_.JObjType<SentryAndroidOptions$BeforeCaptureCallback> {
  @jni$_.internal
  const $SentryAndroidOptions$BeforeCaptureCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/android/core/SentryAndroidOptions$BeforeCaptureCallback;';

  @jni$_.internal
  @core$_.override
  SentryAndroidOptions$BeforeCaptureCallback fromReference(
          jni$_.JReference reference) =>
      SentryAndroidOptions$BeforeCaptureCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryAndroidOptions$BeforeCaptureCallback?>
      get nullableType =>
          const $SentryAndroidOptions$BeforeCaptureCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryAndroidOptions$BeforeCaptureCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryAndroidOptions$BeforeCaptureCallback$Type) &&
        other is $SentryAndroidOptions$BeforeCaptureCallback$Type;
  }
}

/// from: `io.sentry.android.core.SentryAndroidOptions`
class SentryAndroidOptions extends SentryOptions {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryAndroidOptions> $type;

  @jni$_.internal
  SentryAndroidOptions.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/android/core/SentryAndroidOptions');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryAndroidOptions$NullableType();
  static const type = $SentryAndroidOptions$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryAndroidOptions() {
    return SentryAndroidOptions.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_isAnrEnabled = _class.instanceMethodId(
    r'isAnrEnabled',
    r'()Z',
  );

  static final _isAnrEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isAnrEnabled()`
  bool isAnrEnabled() {
    return _isAnrEnabled(
            reference.pointer, _id_isAnrEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setAnrEnabled = _class.instanceMethodId(
    r'setAnrEnabled',
    r'(Z)V',
  );

  static final _setAnrEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setAnrEnabled(boolean z)`
  void setAnrEnabled(
    bool z,
  ) {
    _setAnrEnabled(reference.pointer, _id_setAnrEnabled as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_getAnrTimeoutIntervalMillis = _class.instanceMethodId(
    r'getAnrTimeoutIntervalMillis',
    r'()J',
  );

  static final _getAnrTimeoutIntervalMillis =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallLongMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public long getAnrTimeoutIntervalMillis()`
  int getAnrTimeoutIntervalMillis() {
    return _getAnrTimeoutIntervalMillis(reference.pointer,
            _id_getAnrTimeoutIntervalMillis as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_setAnrTimeoutIntervalMillis = _class.instanceMethodId(
    r'setAnrTimeoutIntervalMillis',
    r'(J)V',
  );

  static final _setAnrTimeoutIntervalMillis =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setAnrTimeoutIntervalMillis(long j)`
  void setAnrTimeoutIntervalMillis(
    int j,
  ) {
    _setAnrTimeoutIntervalMillis(reference.pointer,
            _id_setAnrTimeoutIntervalMillis as jni$_.JMethodIDPtr, j)
        .check();
  }

  static final _id_isAnrReportInDebug = _class.instanceMethodId(
    r'isAnrReportInDebug',
    r'()Z',
  );

  static final _isAnrReportInDebug = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isAnrReportInDebug()`
  bool isAnrReportInDebug() {
    return _isAnrReportInDebug(
            reference.pointer, _id_isAnrReportInDebug as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setAnrReportInDebug = _class.instanceMethodId(
    r'setAnrReportInDebug',
    r'(Z)V',
  );

  static final _setAnrReportInDebug = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setAnrReportInDebug(boolean z)`
  void setAnrReportInDebug(
    bool z,
  ) {
    _setAnrReportInDebug(reference.pointer,
            _id_setAnrReportInDebug as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_setTombstoneEnabled = _class.instanceMethodId(
    r'setTombstoneEnabled',
    r'(Z)V',
  );

  static final _setTombstoneEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setTombstoneEnabled(boolean z)`
  void setTombstoneEnabled(
    bool z,
  ) {
    _setTombstoneEnabled(reference.pointer,
            _id_setTombstoneEnabled as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isTombstoneEnabled = _class.instanceMethodId(
    r'isTombstoneEnabled',
    r'()Z',
  );

  static final _isTombstoneEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isTombstoneEnabled()`
  bool isTombstoneEnabled() {
    return _isTombstoneEnabled(
            reference.pointer, _id_isTombstoneEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_isEnableActivityLifecycleBreadcrumbs =
      _class.instanceMethodId(
    r'isEnableActivityLifecycleBreadcrumbs',
    r'()Z',
  );

  static final _isEnableActivityLifecycleBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEnableActivityLifecycleBreadcrumbs()`
  bool isEnableActivityLifecycleBreadcrumbs() {
    return _isEnableActivityLifecycleBreadcrumbs(reference.pointer,
            _id_isEnableActivityLifecycleBreadcrumbs as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableActivityLifecycleBreadcrumbs =
      _class.instanceMethodId(
    r'setEnableActivityLifecycleBreadcrumbs',
    r'(Z)V',
  );

  static final _setEnableActivityLifecycleBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableActivityLifecycleBreadcrumbs(boolean z)`
  void setEnableActivityLifecycleBreadcrumbs(
    bool z,
  ) {
    _setEnableActivityLifecycleBreadcrumbs(
            reference.pointer,
            _id_setEnableActivityLifecycleBreadcrumbs as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_isEnableAppLifecycleBreadcrumbs = _class.instanceMethodId(
    r'isEnableAppLifecycleBreadcrumbs',
    r'()Z',
  );

  static final _isEnableAppLifecycleBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEnableAppLifecycleBreadcrumbs()`
  bool isEnableAppLifecycleBreadcrumbs() {
    return _isEnableAppLifecycleBreadcrumbs(reference.pointer,
            _id_isEnableAppLifecycleBreadcrumbs as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableAppLifecycleBreadcrumbs = _class.instanceMethodId(
    r'setEnableAppLifecycleBreadcrumbs',
    r'(Z)V',
  );

  static final _setEnableAppLifecycleBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableAppLifecycleBreadcrumbs(boolean z)`
  void setEnableAppLifecycleBreadcrumbs(
    bool z,
  ) {
    _setEnableAppLifecycleBreadcrumbs(
            reference.pointer,
            _id_setEnableAppLifecycleBreadcrumbs as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_isEnableSystemEventBreadcrumbs = _class.instanceMethodId(
    r'isEnableSystemEventBreadcrumbs',
    r'()Z',
  );

  static final _isEnableSystemEventBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEnableSystemEventBreadcrumbs()`
  bool isEnableSystemEventBreadcrumbs() {
    return _isEnableSystemEventBreadcrumbs(reference.pointer,
            _id_isEnableSystemEventBreadcrumbs as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableSystemEventBreadcrumbs = _class.instanceMethodId(
    r'setEnableSystemEventBreadcrumbs',
    r'(Z)V',
  );

  static final _setEnableSystemEventBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableSystemEventBreadcrumbs(boolean z)`
  void setEnableSystemEventBreadcrumbs(
    bool z,
  ) {
    _setEnableSystemEventBreadcrumbs(
            reference.pointer,
            _id_setEnableSystemEventBreadcrumbs as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_isEnableAppComponentBreadcrumbs = _class.instanceMethodId(
    r'isEnableAppComponentBreadcrumbs',
    r'()Z',
  );

  static final _isEnableAppComponentBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEnableAppComponentBreadcrumbs()`
  bool isEnableAppComponentBreadcrumbs() {
    return _isEnableAppComponentBreadcrumbs(reference.pointer,
            _id_isEnableAppComponentBreadcrumbs as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableAppComponentBreadcrumbs = _class.instanceMethodId(
    r'setEnableAppComponentBreadcrumbs',
    r'(Z)V',
  );

  static final _setEnableAppComponentBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableAppComponentBreadcrumbs(boolean z)`
  void setEnableAppComponentBreadcrumbs(
    bool z,
  ) {
    _setEnableAppComponentBreadcrumbs(
            reference.pointer,
            _id_setEnableAppComponentBreadcrumbs as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_isEnableNetworkEventBreadcrumbs = _class.instanceMethodId(
    r'isEnableNetworkEventBreadcrumbs',
    r'()Z',
  );

  static final _isEnableNetworkEventBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEnableNetworkEventBreadcrumbs()`
  bool isEnableNetworkEventBreadcrumbs() {
    return _isEnableNetworkEventBreadcrumbs(reference.pointer,
            _id_isEnableNetworkEventBreadcrumbs as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableNetworkEventBreadcrumbs = _class.instanceMethodId(
    r'setEnableNetworkEventBreadcrumbs',
    r'(Z)V',
  );

  static final _setEnableNetworkEventBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableNetworkEventBreadcrumbs(boolean z)`
  void setEnableNetworkEventBreadcrumbs(
    bool z,
  ) {
    _setEnableNetworkEventBreadcrumbs(
            reference.pointer,
            _id_setEnableNetworkEventBreadcrumbs as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_enableAllAutoBreadcrumbs = _class.instanceMethodId(
    r'enableAllAutoBreadcrumbs',
    r'(Z)V',
  );

  static final _enableAllAutoBreadcrumbs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void enableAllAutoBreadcrumbs(boolean z)`
  void enableAllAutoBreadcrumbs(
    bool z,
  ) {
    _enableAllAutoBreadcrumbs(reference.pointer,
            _id_enableAllAutoBreadcrumbs as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getDebugImagesLoader = _class.instanceMethodId(
    r'getDebugImagesLoader',
    r'()Lio/sentry/android/core/IDebugImagesLoader;',
  );

  static final _getDebugImagesLoader = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.android.core.IDebugImagesLoader getDebugImagesLoader()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getDebugImagesLoader() {
    return _getDebugImagesLoader(
            reference.pointer, _id_getDebugImagesLoader as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setDebugImagesLoader = _class.instanceMethodId(
    r'setDebugImagesLoader',
    r'(Lio/sentry/android/core/IDebugImagesLoader;)V',
  );

  static final _setDebugImagesLoader = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDebugImagesLoader(io.sentry.android.core.IDebugImagesLoader iDebugImagesLoader)`
  void setDebugImagesLoader(
    jni$_.JObject iDebugImagesLoader,
  ) {
    final _$iDebugImagesLoader = iDebugImagesLoader.reference;
    _setDebugImagesLoader(
            reference.pointer,
            _id_setDebugImagesLoader as jni$_.JMethodIDPtr,
            _$iDebugImagesLoader.pointer)
        .check();
  }

  static final _id_isEnableAutoActivityLifecycleTracing =
      _class.instanceMethodId(
    r'isEnableAutoActivityLifecycleTracing',
    r'()Z',
  );

  static final _isEnableAutoActivityLifecycleTracing =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEnableAutoActivityLifecycleTracing()`
  bool isEnableAutoActivityLifecycleTracing() {
    return _isEnableAutoActivityLifecycleTracing(reference.pointer,
            _id_isEnableAutoActivityLifecycleTracing as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableAutoActivityLifecycleTracing =
      _class.instanceMethodId(
    r'setEnableAutoActivityLifecycleTracing',
    r'(Z)V',
  );

  static final _setEnableAutoActivityLifecycleTracing =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableAutoActivityLifecycleTracing(boolean z)`
  void setEnableAutoActivityLifecycleTracing(
    bool z,
  ) {
    _setEnableAutoActivityLifecycleTracing(
            reference.pointer,
            _id_setEnableAutoActivityLifecycleTracing as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_isEnableActivityLifecycleTracingAutoFinish =
      _class.instanceMethodId(
    r'isEnableActivityLifecycleTracingAutoFinish',
    r'()Z',
  );

  static final _isEnableActivityLifecycleTracingAutoFinish =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEnableActivityLifecycleTracingAutoFinish()`
  bool isEnableActivityLifecycleTracingAutoFinish() {
    return _isEnableActivityLifecycleTracingAutoFinish(
            reference.pointer,
            _id_isEnableActivityLifecycleTracingAutoFinish
                as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableActivityLifecycleTracingAutoFinish =
      _class.instanceMethodId(
    r'setEnableActivityLifecycleTracingAutoFinish',
    r'(Z)V',
  );

  static final _setEnableActivityLifecycleTracingAutoFinish =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableActivityLifecycleTracingAutoFinish(boolean z)`
  void setEnableActivityLifecycleTracingAutoFinish(
    bool z,
  ) {
    _setEnableActivityLifecycleTracingAutoFinish(
            reference.pointer,
            _id_setEnableActivityLifecycleTracingAutoFinish
                as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_isAttachScreenshot = _class.instanceMethodId(
    r'isAttachScreenshot',
    r'()Z',
  );

  static final _isAttachScreenshot = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isAttachScreenshot()`
  bool isAttachScreenshot() {
    return _isAttachScreenshot(
            reference.pointer, _id_isAttachScreenshot as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setAttachScreenshot = _class.instanceMethodId(
    r'setAttachScreenshot',
    r'(Z)V',
  );

  static final _setAttachScreenshot = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setAttachScreenshot(boolean z)`
  void setAttachScreenshot(
    bool z,
  ) {
    _setAttachScreenshot(reference.pointer,
            _id_setAttachScreenshot as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isAttachViewHierarchy = _class.instanceMethodId(
    r'isAttachViewHierarchy',
    r'()Z',
  );

  static final _isAttachViewHierarchy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isAttachViewHierarchy()`
  bool isAttachViewHierarchy() {
    return _isAttachViewHierarchy(
            reference.pointer, _id_isAttachViewHierarchy as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setAttachViewHierarchy = _class.instanceMethodId(
    r'setAttachViewHierarchy',
    r'(Z)V',
  );

  static final _setAttachViewHierarchy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setAttachViewHierarchy(boolean z)`
  void setAttachViewHierarchy(
    bool z,
  ) {
    _setAttachViewHierarchy(reference.pointer,
            _id_setAttachViewHierarchy as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isCollectAdditionalContext = _class.instanceMethodId(
    r'isCollectAdditionalContext',
    r'()Z',
  );

  static final _isCollectAdditionalContext =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isCollectAdditionalContext()`
  bool isCollectAdditionalContext() {
    return _isCollectAdditionalContext(reference.pointer,
            _id_isCollectAdditionalContext as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setCollectAdditionalContext = _class.instanceMethodId(
    r'setCollectAdditionalContext',
    r'(Z)V',
  );

  static final _setCollectAdditionalContext =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setCollectAdditionalContext(boolean z)`
  void setCollectAdditionalContext(
    bool z,
  ) {
    _setCollectAdditionalContext(reference.pointer,
            _id_setCollectAdditionalContext as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isCollectExternalStorageContext = _class.instanceMethodId(
    r'isCollectExternalStorageContext',
    r'()Z',
  );

  static final _isCollectExternalStorageContext =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isCollectExternalStorageContext()`
  bool isCollectExternalStorageContext() {
    return _isCollectExternalStorageContext(reference.pointer,
            _id_isCollectExternalStorageContext as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setCollectExternalStorageContext = _class.instanceMethodId(
    r'setCollectExternalStorageContext',
    r'(Z)V',
  );

  static final _setCollectExternalStorageContext =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setCollectExternalStorageContext(boolean z)`
  void setCollectExternalStorageContext(
    bool z,
  ) {
    _setCollectExternalStorageContext(
            reference.pointer,
            _id_setCollectExternalStorageContext as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_isEnableFramesTracking = _class.instanceMethodId(
    r'isEnableFramesTracking',
    r'()Z',
  );

  static final _isEnableFramesTracking = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEnableFramesTracking()`
  bool isEnableFramesTracking() {
    return _isEnableFramesTracking(
            reference.pointer, _id_isEnableFramesTracking as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableFramesTracking = _class.instanceMethodId(
    r'setEnableFramesTracking',
    r'(Z)V',
  );

  static final _setEnableFramesTracking = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableFramesTracking(boolean z)`
  void setEnableFramesTracking(
    bool z,
  ) {
    _setEnableFramesTracking(reference.pointer,
            _id_setEnableFramesTracking as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getStartupCrashDurationThresholdMillis =
      _class.instanceMethodId(
    r'getStartupCrashDurationThresholdMillis',
    r'()J',
  );

  static final _getStartupCrashDurationThresholdMillis =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallLongMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public long getStartupCrashDurationThresholdMillis()`
  int getStartupCrashDurationThresholdMillis() {
    return _getStartupCrashDurationThresholdMillis(reference.pointer,
            _id_getStartupCrashDurationThresholdMillis as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_setNativeSdkName = _class.instanceMethodId(
    r'setNativeSdkName',
    r'(Ljava/lang/String;)V',
  );

  static final _setNativeSdkName = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setNativeSdkName(java.lang.String string)`
  void setNativeSdkName(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setNativeSdkName(reference.pointer,
            _id_setNativeSdkName as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_setNativeHandlerStrategy = _class.instanceMethodId(
    r'setNativeHandlerStrategy',
    r'(Lio/sentry/android/core/NdkHandlerStrategy;)V',
  );

  static final _setNativeHandlerStrategy = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setNativeHandlerStrategy(io.sentry.android.core.NdkHandlerStrategy ndkHandlerStrategy)`
  void setNativeHandlerStrategy(
    jni$_.JObject ndkHandlerStrategy,
  ) {
    final _$ndkHandlerStrategy = ndkHandlerStrategy.reference;
    _setNativeHandlerStrategy(
            reference.pointer,
            _id_setNativeHandlerStrategy as jni$_.JMethodIDPtr,
            _$ndkHandlerStrategy.pointer)
        .check();
  }

  static final _id_getNdkHandlerStrategy = _class.instanceMethodId(
    r'getNdkHandlerStrategy',
    r'()I',
  );

  static final _getNdkHandlerStrategy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getNdkHandlerStrategy()`
  int getNdkHandlerStrategy() {
    return _getNdkHandlerStrategy(
            reference.pointer, _id_getNdkHandlerStrategy as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getNativeSdkName = _class.instanceMethodId(
    r'getNativeSdkName',
    r'()Ljava/lang/String;',
  );

  static final _getNativeSdkName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getNativeSdkName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getNativeSdkName() {
    return _getNativeSdkName(
            reference.pointer, _id_getNativeSdkName as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_isEnableRootCheck = _class.instanceMethodId(
    r'isEnableRootCheck',
    r'()Z',
  );

  static final _isEnableRootCheck = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEnableRootCheck()`
  bool isEnableRootCheck() {
    return _isEnableRootCheck(
            reference.pointer, _id_isEnableRootCheck as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableRootCheck = _class.instanceMethodId(
    r'setEnableRootCheck',
    r'(Z)V',
  );

  static final _setEnableRootCheck = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableRootCheck(boolean z)`
  void setEnableRootCheck(
    bool z,
  ) {
    _setEnableRootCheck(reference.pointer,
            _id_setEnableRootCheck as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getBeforeScreenshotCaptureCallback = _class.instanceMethodId(
    r'getBeforeScreenshotCaptureCallback',
    r'()Lio/sentry/android/core/SentryAndroidOptions$BeforeCaptureCallback;',
  );

  static final _getBeforeScreenshotCaptureCallback =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public io.sentry.android.core.SentryAndroidOptions$BeforeCaptureCallback getBeforeScreenshotCaptureCallback()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryAndroidOptions$BeforeCaptureCallback?
      getBeforeScreenshotCaptureCallback() {
    return _getBeforeScreenshotCaptureCallback(reference.pointer,
            _id_getBeforeScreenshotCaptureCallback as jni$_.JMethodIDPtr)
        .object<SentryAndroidOptions$BeforeCaptureCallback?>(
            const $SentryAndroidOptions$BeforeCaptureCallback$NullableType());
  }

  static final _id_setBeforeScreenshotCaptureCallback = _class.instanceMethodId(
    r'setBeforeScreenshotCaptureCallback',
    r'(Lio/sentry/android/core/SentryAndroidOptions$BeforeCaptureCallback;)V',
  );

  static final _setBeforeScreenshotCaptureCallback =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setBeforeScreenshotCaptureCallback(io.sentry.android.core.SentryAndroidOptions$BeforeCaptureCallback beforeCaptureCallback)`
  void setBeforeScreenshotCaptureCallback(
    SentryAndroidOptions$BeforeCaptureCallback beforeCaptureCallback,
  ) {
    final _$beforeCaptureCallback = beforeCaptureCallback.reference;
    _setBeforeScreenshotCaptureCallback(
            reference.pointer,
            _id_setBeforeScreenshotCaptureCallback as jni$_.JMethodIDPtr,
            _$beforeCaptureCallback.pointer)
        .check();
  }

  static final _id_getBeforeViewHierarchyCaptureCallback =
      _class.instanceMethodId(
    r'getBeforeViewHierarchyCaptureCallback',
    r'()Lio/sentry/android/core/SentryAndroidOptions$BeforeCaptureCallback;',
  );

  static final _getBeforeViewHierarchyCaptureCallback =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public io.sentry.android.core.SentryAndroidOptions$BeforeCaptureCallback getBeforeViewHierarchyCaptureCallback()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryAndroidOptions$BeforeCaptureCallback?
      getBeforeViewHierarchyCaptureCallback() {
    return _getBeforeViewHierarchyCaptureCallback(reference.pointer,
            _id_getBeforeViewHierarchyCaptureCallback as jni$_.JMethodIDPtr)
        .object<SentryAndroidOptions$BeforeCaptureCallback?>(
            const $SentryAndroidOptions$BeforeCaptureCallback$NullableType());
  }

  static final _id_setBeforeViewHierarchyCaptureCallback =
      _class.instanceMethodId(
    r'setBeforeViewHierarchyCaptureCallback',
    r'(Lio/sentry/android/core/SentryAndroidOptions$BeforeCaptureCallback;)V',
  );

  static final _setBeforeViewHierarchyCaptureCallback =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setBeforeViewHierarchyCaptureCallback(io.sentry.android.core.SentryAndroidOptions$BeforeCaptureCallback beforeCaptureCallback)`
  void setBeforeViewHierarchyCaptureCallback(
    SentryAndroidOptions$BeforeCaptureCallback beforeCaptureCallback,
  ) {
    final _$beforeCaptureCallback = beforeCaptureCallback.reference;
    _setBeforeViewHierarchyCaptureCallback(
            reference.pointer,
            _id_setBeforeViewHierarchyCaptureCallback as jni$_.JMethodIDPtr,
            _$beforeCaptureCallback.pointer)
        .check();
  }

  static final _id_isEnableNdk = _class.instanceMethodId(
    r'isEnableNdk',
    r'()Z',
  );

  static final _isEnableNdk = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEnableNdk()`
  bool isEnableNdk() {
    return _isEnableNdk(
            reference.pointer, _id_isEnableNdk as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableNdk = _class.instanceMethodId(
    r'setEnableNdk',
    r'(Z)V',
  );

  static final _setEnableNdk = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableNdk(boolean z)`
  void setEnableNdk(
    bool z,
  ) {
    _setEnableNdk(reference.pointer, _id_setEnableNdk as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_isEnableScopeSync = _class.instanceMethodId(
    r'isEnableScopeSync',
    r'()Z',
  );

  static final _isEnableScopeSync = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEnableScopeSync()`
  bool isEnableScopeSync() {
    return _isEnableScopeSync(
            reference.pointer, _id_isEnableScopeSync as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableScopeSync = _class.instanceMethodId(
    r'setEnableScopeSync',
    r'(Z)V',
  );

  static final _setEnableScopeSync = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableScopeSync(boolean z)`
  void setEnableScopeSync(
    bool z,
  ) {
    _setEnableScopeSync(reference.pointer,
            _id_setEnableScopeSync as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isReportHistoricalAnrs = _class.instanceMethodId(
    r'isReportHistoricalAnrs',
    r'()Z',
  );

  static final _isReportHistoricalAnrs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isReportHistoricalAnrs()`
  bool isReportHistoricalAnrs() {
    return _isReportHistoricalAnrs(
            reference.pointer, _id_isReportHistoricalAnrs as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setReportHistoricalAnrs = _class.instanceMethodId(
    r'setReportHistoricalAnrs',
    r'(Z)V',
  );

  static final _setReportHistoricalAnrs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setReportHistoricalAnrs(boolean z)`
  void setReportHistoricalAnrs(
    bool z,
  ) {
    _setReportHistoricalAnrs(reference.pointer,
            _id_setReportHistoricalAnrs as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isReportHistoricalTombstones = _class.instanceMethodId(
    r'isReportHistoricalTombstones',
    r'()Z',
  );

  static final _isReportHistoricalTombstones =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isReportHistoricalTombstones()`
  bool isReportHistoricalTombstones() {
    return _isReportHistoricalTombstones(reference.pointer,
            _id_isReportHistoricalTombstones as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setReportHistoricalTombstones = _class.instanceMethodId(
    r'setReportHistoricalTombstones',
    r'(Z)V',
  );

  static final _setReportHistoricalTombstones =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setReportHistoricalTombstones(boolean z)`
  void setReportHistoricalTombstones(
    bool z,
  ) {
    _setReportHistoricalTombstones(reference.pointer,
            _id_setReportHistoricalTombstones as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isAttachAnrThreadDump = _class.instanceMethodId(
    r'isAttachAnrThreadDump',
    r'()Z',
  );

  static final _isAttachAnrThreadDump = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isAttachAnrThreadDump()`
  bool isAttachAnrThreadDump() {
    return _isAttachAnrThreadDump(
            reference.pointer, _id_isAttachAnrThreadDump as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setAttachAnrThreadDump = _class.instanceMethodId(
    r'setAttachAnrThreadDump',
    r'(Z)V',
  );

  static final _setAttachAnrThreadDump = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setAttachAnrThreadDump(boolean z)`
  void setAttachAnrThreadDump(
    bool z,
  ) {
    _setAttachAnrThreadDump(reference.pointer,
            _id_setAttachAnrThreadDump as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isEnablePerformanceV2 = _class.instanceMethodId(
    r'isEnablePerformanceV2',
    r'()Z',
  );

  static final _isEnablePerformanceV2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEnablePerformanceV2()`
  bool isEnablePerformanceV2() {
    return _isEnablePerformanceV2(
            reference.pointer, _id_isEnablePerformanceV2 as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnablePerformanceV2 = _class.instanceMethodId(
    r'setEnablePerformanceV2',
    r'(Z)V',
  );

  static final _setEnablePerformanceV2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnablePerformanceV2(boolean z)`
  void setEnablePerformanceV2(
    bool z,
  ) {
    _setEnablePerformanceV2(reference.pointer,
            _id_setEnablePerformanceV2 as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getFrameMetricsCollector = _class.instanceMethodId(
    r'getFrameMetricsCollector',
    r'()Lio/sentry/android/core/internal/util/SentryFrameMetricsCollector;',
  );

  static final _getFrameMetricsCollector = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.android.core.internal.util.SentryFrameMetricsCollector getFrameMetricsCollector()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getFrameMetricsCollector() {
    return _getFrameMetricsCollector(reference.pointer,
            _id_getFrameMetricsCollector as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setFrameMetricsCollector = _class.instanceMethodId(
    r'setFrameMetricsCollector',
    r'(Lio/sentry/android/core/internal/util/SentryFrameMetricsCollector;)V',
  );

  static final _setFrameMetricsCollector = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setFrameMetricsCollector(io.sentry.android.core.internal.util.SentryFrameMetricsCollector sentryFrameMetricsCollector)`
  void setFrameMetricsCollector(
    jni$_.JObject? sentryFrameMetricsCollector,
  ) {
    final _$sentryFrameMetricsCollector =
        sentryFrameMetricsCollector?.reference ?? jni$_.jNullReference;
    _setFrameMetricsCollector(
            reference.pointer,
            _id_setFrameMetricsCollector as jni$_.JMethodIDPtr,
            _$sentryFrameMetricsCollector.pointer)
        .check();
  }

  static final _id_isEnableAutoTraceIdGeneration = _class.instanceMethodId(
    r'isEnableAutoTraceIdGeneration',
    r'()Z',
  );

  static final _isEnableAutoTraceIdGeneration =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEnableAutoTraceIdGeneration()`
  bool isEnableAutoTraceIdGeneration() {
    return _isEnableAutoTraceIdGeneration(reference.pointer,
            _id_isEnableAutoTraceIdGeneration as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableAutoTraceIdGeneration = _class.instanceMethodId(
    r'setEnableAutoTraceIdGeneration',
    r'(Z)V',
  );

  static final _setEnableAutoTraceIdGeneration =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableAutoTraceIdGeneration(boolean z)`
  void setEnableAutoTraceIdGeneration(
    bool z,
  ) {
    _setEnableAutoTraceIdGeneration(reference.pointer,
            _id_setEnableAutoTraceIdGeneration as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isEnableSystemEventBreadcrumbsExtras =
      _class.instanceMethodId(
    r'isEnableSystemEventBreadcrumbsExtras',
    r'()Z',
  );

  static final _isEnableSystemEventBreadcrumbsExtras =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEnableSystemEventBreadcrumbsExtras()`
  bool isEnableSystemEventBreadcrumbsExtras() {
    return _isEnableSystemEventBreadcrumbsExtras(reference.pointer,
            _id_isEnableSystemEventBreadcrumbsExtras as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableSystemEventBreadcrumbsExtras =
      _class.instanceMethodId(
    r'setEnableSystemEventBreadcrumbsExtras',
    r'(Z)V',
  );

  static final _setEnableSystemEventBreadcrumbsExtras =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableSystemEventBreadcrumbsExtras(boolean z)`
  void setEnableSystemEventBreadcrumbsExtras(
    bool z,
  ) {
    _setEnableSystemEventBreadcrumbsExtras(
            reference.pointer,
            _id_setEnableSystemEventBreadcrumbsExtras as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }
}

final class $SentryAndroidOptions$NullableType
    extends jni$_.JObjType<SentryAndroidOptions?> {
  @jni$_.internal
  const $SentryAndroidOptions$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/core/SentryAndroidOptions;';

  @jni$_.internal
  @core$_.override
  SentryAndroidOptions? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryAndroidOptions.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $SentryOptions$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryAndroidOptions?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($SentryAndroidOptions$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryAndroidOptions$NullableType) &&
        other is $SentryAndroidOptions$NullableType;
  }
}

final class $SentryAndroidOptions$Type
    extends jni$_.JObjType<SentryAndroidOptions> {
  @jni$_.internal
  const $SentryAndroidOptions$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/core/SentryAndroidOptions;';

  @jni$_.internal
  @core$_.override
  SentryAndroidOptions fromReference(jni$_.JReference reference) =>
      SentryAndroidOptions.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $SentryOptions$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryAndroidOptions?> get nullableType =>
      const $SentryAndroidOptions$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($SentryAndroidOptions$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryAndroidOptions$Type) &&
        other is $SentryAndroidOptions$Type;
  }
}

/// from: `io.sentry.android.core.InternalSentrySdk`
class InternalSentrySdk extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<InternalSentrySdk> $type;

  @jni$_.internal
  InternalSentrySdk.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/android/core/InternalSentrySdk');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $InternalSentrySdk$NullableType();
  static const type = $InternalSentrySdk$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory InternalSentrySdk() {
    return InternalSentrySdk.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_getCurrentScope = _class.staticMethodId(
    r'getCurrentScope',
    r'()Lio/sentry/IScope;',
  );

  static final _getCurrentScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.IScope getCurrentScope()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? getCurrentScope() {
    return _getCurrentScope(
            _class.reference.pointer, _id_getCurrentScope as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_serializeScope = _class.staticMethodId(
    r'serializeScope',
    r'(Landroid/content/Context;Lio/sentry/android/core/SentryAndroidOptions;Lio/sentry/IScope;)Ljava/util/Map;',
  );

  static final _serializeScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.Map<java.lang.String, java.lang.Object> serializeScope(android.content.Context context, io.sentry.android.core.SentryAndroidOptions sentryAndroidOptions, io.sentry.IScope iScope)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JMap<jni$_.JString?, jni$_.JObject?> serializeScope(
    Context context,
    SentryAndroidOptions sentryAndroidOptions,
    jni$_.JObject? iScope,
  ) {
    final _$context = context.reference;
    final _$sentryAndroidOptions = sentryAndroidOptions.reference;
    final _$iScope = iScope?.reference ?? jni$_.jNullReference;
    return _serializeScope(
            _class.reference.pointer,
            _id_serializeScope as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$sentryAndroidOptions.pointer,
            _$iScope.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JString?, jni$_.JObject?>(
                jni$_.JStringNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_captureEnvelope = _class.staticMethodId(
    r'captureEnvelope',
    r'([BZ)Lio/sentry/protocol/SentryId;',
  );

  static final _captureEnvelope = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `static public io.sentry.protocol.SentryId captureEnvelope(byte[] bs, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryId? captureEnvelope(
    jni$_.JByteArray bs,
    bool z,
  ) {
    final _$bs = bs.reference;
    return _captureEnvelope(_class.reference.pointer,
            _id_captureEnvelope as jni$_.JMethodIDPtr, _$bs.pointer, z ? 1 : 0)
        .object<SentryId?>(const $SentryId$NullableType());
  }

  static final _id_getAppStartMeasurement = _class.staticMethodId(
    r'getAppStartMeasurement',
    r'()Ljava/util/Map;',
  );

  static final _getAppStartMeasurement = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.util.Map<java.lang.String, java.lang.Object> getAppStartMeasurement()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JMap<jni$_.JString?, jni$_.JObject?>? getAppStartMeasurement() {
    return _getAppStartMeasurement(_class.reference.pointer,
            _id_getAppStartMeasurement as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JObject?>(
                jni$_.JStringNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_setTrace = _class.staticMethodId(
    r'setTrace',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/Double;Ljava/lang/Double;)V',
  );

  static final _setTrace = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void setTrace(java.lang.String string, java.lang.String string1, java.lang.Double double, java.lang.Double double1)`
  static void setTrace(
    jni$_.JString string,
    jni$_.JString string1,
    jni$_.JDouble? double,
    jni$_.JDouble? double1,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$double1 = double1?.reference ?? jni$_.jNullReference;
    _setTrace(
            _class.reference.pointer,
            _id_setTrace as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$double.pointer,
            _$double1.pointer)
        .check();
  }
}

final class $InternalSentrySdk$NullableType
    extends jni$_.JObjType<InternalSentrySdk?> {
  @jni$_.internal
  const $InternalSentrySdk$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/core/InternalSentrySdk;';

  @jni$_.internal
  @core$_.override
  InternalSentrySdk? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : InternalSentrySdk.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InternalSentrySdk?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InternalSentrySdk$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InternalSentrySdk$NullableType) &&
        other is $InternalSentrySdk$NullableType;
  }
}

final class $InternalSentrySdk$Type extends jni$_.JObjType<InternalSentrySdk> {
  @jni$_.internal
  const $InternalSentrySdk$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/core/InternalSentrySdk;';

  @jni$_.internal
  @core$_.override
  InternalSentrySdk fromReference(jni$_.JReference reference) =>
      InternalSentrySdk.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InternalSentrySdk?> get nullableType =>
      const $InternalSentrySdk$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InternalSentrySdk$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InternalSentrySdk$Type) &&
        other is $InternalSentrySdk$Type;
  }
}

/// from: `io.sentry.android.core.BuildConfig`
class BuildConfig extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<BuildConfig> $type;

  @jni$_.internal
  BuildConfig.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/android/core/BuildConfig');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $BuildConfig$NullableType();
  static const type = $BuildConfig$Type();

  /// from: `static public final boolean DEBUG`
  static const DEBUG = 0;
  static final _id_LIBRARY_PACKAGE_NAME = _class.staticFieldId(
    r'LIBRARY_PACKAGE_NAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LIBRARY_PACKAGE_NAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get LIBRARY_PACKAGE_NAME =>
      _id_LIBRARY_PACKAGE_NAME.get(_class, const jni$_.JStringNullableType());

  static final _id_BUILD_TYPE = _class.staticFieldId(
    r'BUILD_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BUILD_TYPE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BUILD_TYPE =>
      _id_BUILD_TYPE.get(_class, const jni$_.JStringNullableType());

  static final _id_SENTRY_ANDROID_SDK_NAME = _class.staticFieldId(
    r'SENTRY_ANDROID_SDK_NAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SENTRY_ANDROID_SDK_NAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SENTRY_ANDROID_SDK_NAME =>
      _id_SENTRY_ANDROID_SDK_NAME.get(
          _class, const jni$_.JStringNullableType());

  static final _id_VERSION_NAME = _class.staticFieldId(
    r'VERSION_NAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String VERSION_NAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get VERSION_NAME =>
      _id_VERSION_NAME.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory BuildConfig() {
    return BuildConfig.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $BuildConfig$NullableType extends jni$_.JObjType<BuildConfig?> {
  @jni$_.internal
  const $BuildConfig$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/core/BuildConfig;';

  @jni$_.internal
  @core$_.override
  BuildConfig? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : BuildConfig.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<BuildConfig?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($BuildConfig$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($BuildConfig$NullableType) &&
        other is $BuildConfig$NullableType;
  }
}

final class $BuildConfig$Type extends jni$_.JObjType<BuildConfig> {
  @jni$_.internal
  const $BuildConfig$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/core/BuildConfig;';

  @jni$_.internal
  @core$_.override
  BuildConfig fromReference(jni$_.JReference reference) =>
      BuildConfig.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<BuildConfig?> get nullableType =>
      const $BuildConfig$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($BuildConfig$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($BuildConfig$Type) &&
        other is $BuildConfig$Type;
  }
}

/// from: `io.sentry.android.replay.ReplayIntegration`
class ReplayIntegration extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ReplayIntegration> $type;

  @jni$_.internal
  ReplayIntegration.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/android/replay/ReplayIntegration');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ReplayIntegration$NullableType();
  static const type = $ReplayIntegration$Type();
  static final _id_new$ = _class.constructorId(
    r'(Landroid/content/Context;Lio/sentry/transport/ICurrentDateProvider;Lkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(android.content.Context context, io.sentry.transport.ICurrentDateProvider iCurrentDateProvider, kotlin.jvm.functions.Function0<? extends io.sentry.android.replay.Recorder> function0, kotlin.jvm.functions.Function1<? super io.sentry.protocol.SentryId, io.sentry.android.replay.ReplayCache> function1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ReplayIntegration(
    Context context,
    jni$_.JObject iCurrentDateProvider,
    jni$_.JObject? function0,
    jni$_.JObject? function1,
  ) {
    final _$context = context.reference;
    final _$iCurrentDateProvider = iCurrentDateProvider.reference;
    final _$function0 = function0?.reference ?? jni$_.jNullReference;
    final _$function1 = function1?.reference ?? jni$_.jNullReference;
    return ReplayIntegration.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$iCurrentDateProvider.pointer,
            _$function0.pointer,
            _$function1.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Landroid/content/Context;Lio/sentry/transport/ICurrentDateProvider;Lkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(android.content.Context context, io.sentry.transport.ICurrentDateProvider iCurrentDateProvider, kotlin.jvm.functions.Function0 function0, kotlin.jvm.functions.Function1 function1, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ReplayIntegration.new$1(
    Context? context,
    jni$_.JObject? iCurrentDateProvider,
    jni$_.JObject? function0,
    jni$_.JObject? function1,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$context = context?.reference ?? jni$_.jNullReference;
    final _$iCurrentDateProvider =
        iCurrentDateProvider?.reference ?? jni$_.jNullReference;
    final _$function0 = function0?.reference ?? jni$_.jNullReference;
    final _$function1 = function1?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return ReplayIntegration.fromReference(_new$1(
            _class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$iCurrentDateProvider.pointer,
            _$function0.pointer,
            _$function1.pointer,
            i,
            _$defaultConstructorMarker.pointer)
        .reference);
  }

  static final _id_new$2 = _class.constructorId(
    r'(Landroid/content/Context;Lio/sentry/transport/ICurrentDateProvider;)V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(android.content.Context context, io.sentry.transport.ICurrentDateProvider iCurrentDateProvider)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ReplayIntegration.new$2(
    Context context,
    jni$_.JObject iCurrentDateProvider,
  ) {
    final _$context = context.reference;
    final _$iCurrentDateProvider = iCurrentDateProvider.reference;
    return ReplayIntegration.fromReference(_new$2(
            _class.reference.pointer,
            _id_new$2 as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$iCurrentDateProvider.pointer)
        .reference);
  }

  static final _id_new$3 = _class.constructorId(
    r'(Landroid/content/Context;Lio/sentry/transport/ICurrentDateProvider;Lkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;Lio/sentry/android/replay/util/MainLooperHandler;Lkotlin/jvm/functions/Function0;)V',
  );

  static final _new$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(android.content.Context context, io.sentry.transport.ICurrentDateProvider iCurrentDateProvider, kotlin.jvm.functions.Function0<? extends io.sentry.android.replay.Recorder> function0, kotlin.jvm.functions.Function1<? super io.sentry.protocol.SentryId, io.sentry.android.replay.ReplayCache> function1, kotlin.jvm.functions.Function1<? super java.lang.Boolean, ? extends io.sentry.android.replay.capture.CaptureStrategy> function11, io.sentry.android.replay.util.MainLooperHandler mainLooperHandler, kotlin.jvm.functions.Function0<io.sentry.android.replay.gestures.GestureRecorder> function01)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ReplayIntegration.new$3(
    Context context,
    jni$_.JObject iCurrentDateProvider,
    jni$_.JObject? function0,
    jni$_.JObject? function1,
    jni$_.JObject? function11,
    jni$_.JObject? mainLooperHandler,
    jni$_.JObject? function01,
  ) {
    final _$context = context.reference;
    final _$iCurrentDateProvider = iCurrentDateProvider.reference;
    final _$function0 = function0?.reference ?? jni$_.jNullReference;
    final _$function1 = function1?.reference ?? jni$_.jNullReference;
    final _$function11 = function11?.reference ?? jni$_.jNullReference;
    final _$mainLooperHandler =
        mainLooperHandler?.reference ?? jni$_.jNullReference;
    final _$function01 = function01?.reference ?? jni$_.jNullReference;
    return ReplayIntegration.fromReference(_new$3(
            _class.reference.pointer,
            _id_new$3 as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$iCurrentDateProvider.pointer,
            _$function0.pointer,
            _$function1.pointer,
            _$function11.pointer,
            _$mainLooperHandler.pointer,
            _$function01.pointer)
        .reference);
  }

  static final _id_new$4 = _class.constructorId(
    r'(Landroid/content/Context;Lio/sentry/transport/ICurrentDateProvider;Lkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;Lio/sentry/android/replay/util/MainLooperHandler;Lkotlin/jvm/functions/Function0;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(android.content.Context context, io.sentry.transport.ICurrentDateProvider iCurrentDateProvider, kotlin.jvm.functions.Function0 function0, kotlin.jvm.functions.Function1 function1, kotlin.jvm.functions.Function1 function11, io.sentry.android.replay.util.MainLooperHandler mainLooperHandler, kotlin.jvm.functions.Function0 function01, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ReplayIntegration.new$4(
    Context? context,
    jni$_.JObject? iCurrentDateProvider,
    jni$_.JObject? function0,
    jni$_.JObject? function1,
    jni$_.JObject? function11,
    jni$_.JObject? mainLooperHandler,
    jni$_.JObject? function01,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$context = context?.reference ?? jni$_.jNullReference;
    final _$iCurrentDateProvider =
        iCurrentDateProvider?.reference ?? jni$_.jNullReference;
    final _$function0 = function0?.reference ?? jni$_.jNullReference;
    final _$function1 = function1?.reference ?? jni$_.jNullReference;
    final _$function11 = function11?.reference ?? jni$_.jNullReference;
    final _$mainLooperHandler =
        mainLooperHandler?.reference ?? jni$_.jNullReference;
    final _$function01 = function01?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return ReplayIntegration.fromReference(_new$4(
            _class.reference.pointer,
            _id_new$4 as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$iCurrentDateProvider.pointer,
            _$function0.pointer,
            _$function1.pointer,
            _$function11.pointer,
            _$mainLooperHandler.pointer,
            _$function01.pointer,
            i,
            _$defaultConstructorMarker.pointer)
        .reference);
  }

  static final _id_getReplayCacheDir = _class.instanceMethodId(
    r'getReplayCacheDir',
    r'()Ljava/io/File;',
  );

  static final _getReplayCacheDir = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.io.File getReplayCacheDir()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getReplayCacheDir() {
    return _getReplayCacheDir(
            reference.pointer, _id_getReplayCacheDir as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_register = _class.instanceMethodId(
    r'register',
    r'(Lio/sentry/IScopes;Lio/sentry/SentryOptions;)V',
  );

  static final _register = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void register(io.sentry.IScopes iScopes, io.sentry.SentryOptions sentryOptions)`
  void register(
    jni$_.JObject iScopes,
    SentryOptions sentryOptions,
  ) {
    final _$iScopes = iScopes.reference;
    final _$sentryOptions = sentryOptions.reference;
    _register(reference.pointer, _id_register as jni$_.JMethodIDPtr,
            _$iScopes.pointer, _$sentryOptions.pointer)
        .check();
  }

  static final _id_isRecording = _class.instanceMethodId(
    r'isRecording',
    r'()Z',
  );

  static final _isRecording = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isRecording()`
  bool isRecording() {
    return _isRecording(
            reference.pointer, _id_isRecording as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_start = _class.instanceMethodId(
    r'start',
    r'()V',
  );

  static final _start = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void start()`
  void start() {
    _start(reference.pointer, _id_start as jni$_.JMethodIDPtr).check();
  }

  static final _id_resume = _class.instanceMethodId(
    r'resume',
    r'()V',
  );

  static final _resume = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void resume()`
  void resume() {
    _resume(reference.pointer, _id_resume as jni$_.JMethodIDPtr).check();
  }

  static final _id_captureReplay = _class.instanceMethodId(
    r'captureReplay',
    r'(Ljava/lang/Boolean;)V',
  );

  static final _captureReplay = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void captureReplay(java.lang.Boolean boolean)`
  void captureReplay(
    jni$_.JBoolean? boolean,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    _captureReplay(reference.pointer, _id_captureReplay as jni$_.JMethodIDPtr,
            _$boolean.pointer)
        .check();
  }

  static final _id_getReplayId = _class.instanceMethodId(
    r'getReplayId',
    r'()Lio/sentry/protocol/SentryId;',
  );

  static final _getReplayId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.SentryId getReplayId()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryId getReplayId() {
    return _getReplayId(
            reference.pointer, _id_getReplayId as jni$_.JMethodIDPtr)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_setBreadcrumbConverter = _class.instanceMethodId(
    r'setBreadcrumbConverter',
    r'(Lio/sentry/ReplayBreadcrumbConverter;)V',
  );

  static final _setBreadcrumbConverter = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setBreadcrumbConverter(io.sentry.ReplayBreadcrumbConverter replayBreadcrumbConverter)`
  void setBreadcrumbConverter(
    jni$_.JObject replayBreadcrumbConverter,
  ) {
    final _$replayBreadcrumbConverter = replayBreadcrumbConverter.reference;
    _setBreadcrumbConverter(
            reference.pointer,
            _id_setBreadcrumbConverter as jni$_.JMethodIDPtr,
            _$replayBreadcrumbConverter.pointer)
        .check();
  }

  static final _id_getBreadcrumbConverter = _class.instanceMethodId(
    r'getBreadcrumbConverter',
    r'()Lio/sentry/ReplayBreadcrumbConverter;',
  );

  static final _getBreadcrumbConverter = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ReplayBreadcrumbConverter getBreadcrumbConverter()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getBreadcrumbConverter() {
    return _getBreadcrumbConverter(
            reference.pointer, _id_getBreadcrumbConverter as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_pause = _class.instanceMethodId(
    r'pause',
    r'()V',
  );

  static final _pause = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void pause()`
  void pause() {
    _pause(reference.pointer, _id_pause as jni$_.JMethodIDPtr).check();
  }

  static final _id_enableDebugMaskingOverlay = _class.instanceMethodId(
    r'enableDebugMaskingOverlay',
    r'()V',
  );

  static final _enableDebugMaskingOverlay = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void enableDebugMaskingOverlay()`
  void enableDebugMaskingOverlay() {
    _enableDebugMaskingOverlay(reference.pointer,
            _id_enableDebugMaskingOverlay as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_disableDebugMaskingOverlay = _class.instanceMethodId(
    r'disableDebugMaskingOverlay',
    r'()V',
  );

  static final _disableDebugMaskingOverlay =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public void disableDebugMaskingOverlay()`
  void disableDebugMaskingOverlay() {
    _disableDebugMaskingOverlay(reference.pointer,
            _id_disableDebugMaskingOverlay as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_isDebugMaskingOverlayEnabled = _class.instanceMethodId(
    r'isDebugMaskingOverlayEnabled',
    r'()Z',
  );

  static final _isDebugMaskingOverlayEnabled =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isDebugMaskingOverlayEnabled()`
  bool isDebugMaskingOverlayEnabled() {
    return _isDebugMaskingOverlayEnabled(reference.pointer,
            _id_isDebugMaskingOverlayEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_stop = _class.instanceMethodId(
    r'stop',
    r'()V',
  );

  static final _stop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void stop()`
  void stop() {
    _stop(reference.pointer, _id_stop as jni$_.JMethodIDPtr).check();
  }

  static final _id_onScreenshotRecorded = _class.instanceMethodId(
    r'onScreenshotRecorded',
    r'(Landroid/graphics/Bitmap;)V',
  );

  static final _onScreenshotRecorded = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onScreenshotRecorded(android.graphics.Bitmap bitmap)`
  void onScreenshotRecorded(
    Bitmap bitmap,
  ) {
    final _$bitmap = bitmap.reference;
    _onScreenshotRecorded(reference.pointer,
            _id_onScreenshotRecorded as jni$_.JMethodIDPtr, _$bitmap.pointer)
        .check();
  }

  static final _id_onScreenshotRecorded$1 = _class.instanceMethodId(
    r'onScreenshotRecorded',
    r'(Ljava/io/File;J)V',
  );

  static final _onScreenshotRecorded$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public void onScreenshotRecorded(java.io.File file, long j)`
  void onScreenshotRecorded$1(
    jni$_.JObject file,
    int j,
  ) {
    final _$file = file.reference;
    _onScreenshotRecorded$1(reference.pointer,
            _id_onScreenshotRecorded$1 as jni$_.JMethodIDPtr, _$file.pointer, j)
        .check();
  }

  static final _id_close = _class.instanceMethodId(
    r'close',
    r'()V',
  );

  static final _close = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_onConnectionStatusChanged = _class.instanceMethodId(
    r'onConnectionStatusChanged',
    r'(Lio/sentry/IConnectionStatusProvider$ConnectionStatus;)V',
  );

  static final _onConnectionStatusChanged = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onConnectionStatusChanged(io.sentry.IConnectionStatusProvider$ConnectionStatus connectionStatus)`
  void onConnectionStatusChanged(
    jni$_.JObject connectionStatus,
  ) {
    final _$connectionStatus = connectionStatus.reference;
    _onConnectionStatusChanged(
            reference.pointer,
            _id_onConnectionStatusChanged as jni$_.JMethodIDPtr,
            _$connectionStatus.pointer)
        .check();
  }

  static final _id_onRateLimitChanged = _class.instanceMethodId(
    r'onRateLimitChanged',
    r'(Lio/sentry/transport/RateLimiter;)V',
  );

  static final _onRateLimitChanged = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onRateLimitChanged(io.sentry.transport.RateLimiter rateLimiter)`
  void onRateLimitChanged(
    jni$_.JObject rateLimiter,
  ) {
    final _$rateLimiter = rateLimiter.reference;
    _onRateLimitChanged(reference.pointer,
            _id_onRateLimitChanged as jni$_.JMethodIDPtr, _$rateLimiter.pointer)
        .check();
  }

  static final _id_onTouchEvent = _class.instanceMethodId(
    r'onTouchEvent',
    r'(Landroid/view/MotionEvent;)V',
  );

  static final _onTouchEvent = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onTouchEvent(android.view.MotionEvent motionEvent)`
  void onTouchEvent(
    jni$_.JObject motionEvent,
  ) {
    final _$motionEvent = motionEvent.reference;
    _onTouchEvent(reference.pointer, _id_onTouchEvent as jni$_.JMethodIDPtr,
            _$motionEvent.pointer)
        .check();
  }

  static final _id_onWindowSizeChanged = _class.instanceMethodId(
    r'onWindowSizeChanged',
    r'(II)V',
  );

  static final _onWindowSizeChanged = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int)>();

  /// from: `public void onWindowSizeChanged(int i, int i1)`
  void onWindowSizeChanged(
    int i,
    int i1,
  ) {
    _onWindowSizeChanged(reference.pointer,
            _id_onWindowSizeChanged as jni$_.JMethodIDPtr, i, i1)
        .check();
  }

  static final _id_onConfigurationChanged = _class.instanceMethodId(
    r'onConfigurationChanged',
    r'(Lio/sentry/android/replay/ScreenshotRecorderConfig;)V',
  );

  static final _onConfigurationChanged = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void onConfigurationChanged(io.sentry.android.replay.ScreenshotRecorderConfig screenshotRecorderConfig)`
  void onConfigurationChanged(
    ScreenshotRecorderConfig screenshotRecorderConfig,
  ) {
    final _$screenshotRecorderConfig = screenshotRecorderConfig.reference;
    _onConfigurationChanged(
            reference.pointer,
            _id_onConfigurationChanged as jni$_.JMethodIDPtr,
            _$screenshotRecorderConfig.pointer)
        .check();
  }
}

final class $ReplayIntegration$NullableType
    extends jni$_.JObjType<ReplayIntegration?> {
  @jni$_.internal
  const $ReplayIntegration$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/replay/ReplayIntegration;';

  @jni$_.internal
  @core$_.override
  ReplayIntegration? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ReplayIntegration.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ReplayIntegration?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ReplayIntegration$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ReplayIntegration$NullableType) &&
        other is $ReplayIntegration$NullableType;
  }
}

final class $ReplayIntegration$Type extends jni$_.JObjType<ReplayIntegration> {
  @jni$_.internal
  const $ReplayIntegration$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/replay/ReplayIntegration;';

  @jni$_.internal
  @core$_.override
  ReplayIntegration fromReference(jni$_.JReference reference) =>
      ReplayIntegration.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ReplayIntegration?> get nullableType =>
      const $ReplayIntegration$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ReplayIntegration$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ReplayIntegration$Type) &&
        other is $ReplayIntegration$Type;
  }
}

/// from: `io.sentry.android.replay.ScreenshotRecorderConfig$Companion`
class ScreenshotRecorderConfig$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ScreenshotRecorderConfig$Companion> $type;

  @jni$_.internal
  ScreenshotRecorderConfig$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'io/sentry/android/replay/ScreenshotRecorderConfig$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $ScreenshotRecorderConfig$Companion$NullableType();
  static const type = $ScreenshotRecorderConfig$Companion$Type();
  static final _id_fromSize = _class.instanceMethodId(
    r'fromSize',
    r'(Landroid/content/Context;Lio/sentry/SentryReplayOptions;II)Lio/sentry/android/replay/ScreenshotRecorderConfig;',
  );

  static final _fromSize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int)>();

  /// from: `public final io.sentry.android.replay.ScreenshotRecorderConfig fromSize(android.content.Context context, io.sentry.SentryReplayOptions sentryReplayOptions, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  ScreenshotRecorderConfig fromSize(
    Context context,
    SentryReplayOptions sentryReplayOptions,
    int i,
    int i1,
  ) {
    final _$context = context.reference;
    final _$sentryReplayOptions = sentryReplayOptions.reference;
    return _fromSize(reference.pointer, _id_fromSize as jni$_.JMethodIDPtr,
            _$context.pointer, _$sentryReplayOptions.pointer, i, i1)
        .object<ScreenshotRecorderConfig>(
            const $ScreenshotRecorderConfig$Type());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ScreenshotRecorderConfig$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return ScreenshotRecorderConfig$Companion.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $ScreenshotRecorderConfig$Companion$NullableType
    extends jni$_.JObjType<ScreenshotRecorderConfig$Companion?> {
  @jni$_.internal
  const $ScreenshotRecorderConfig$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/android/replay/ScreenshotRecorderConfig$Companion;';

  @jni$_.internal
  @core$_.override
  ScreenshotRecorderConfig$Companion? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ScreenshotRecorderConfig$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ScreenshotRecorderConfig$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($ScreenshotRecorderConfig$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ScreenshotRecorderConfig$Companion$NullableType) &&
        other is $ScreenshotRecorderConfig$Companion$NullableType;
  }
}

final class $ScreenshotRecorderConfig$Companion$Type
    extends jni$_.JObjType<ScreenshotRecorderConfig$Companion> {
  @jni$_.internal
  const $ScreenshotRecorderConfig$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/android/replay/ScreenshotRecorderConfig$Companion;';

  @jni$_.internal
  @core$_.override
  ScreenshotRecorderConfig$Companion fromReference(
          jni$_.JReference reference) =>
      ScreenshotRecorderConfig$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ScreenshotRecorderConfig$Companion?> get nullableType =>
      const $ScreenshotRecorderConfig$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ScreenshotRecorderConfig$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ScreenshotRecorderConfig$Companion$Type) &&
        other is $ScreenshotRecorderConfig$Companion$Type;
  }
}

/// from: `io.sentry.android.replay.ScreenshotRecorderConfig`
class ScreenshotRecorderConfig extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ScreenshotRecorderConfig> $type;

  @jni$_.internal
  ScreenshotRecorderConfig.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'io/sentry/android/replay/ScreenshotRecorderConfig');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ScreenshotRecorderConfig$NullableType();
  static const type = $ScreenshotRecorderConfig$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Lio/sentry/android/replay/ScreenshotRecorderConfig$Companion;',
  );

  /// from: `static public final io.sentry.android.replay.ScreenshotRecorderConfig$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static ScreenshotRecorderConfig$Companion get Companion => _id_Companion.get(
      _class, const $ScreenshotRecorderConfig$Companion$Type());

  static final _id_new$ = _class.constructorId(
    r'(IIFFII)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Double,
                        jni$_.Double,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, double, double, int, int)>();

  /// from: `public void <init>(int i, int i1, float f, float f1, int i2, int i3)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ScreenshotRecorderConfig(
    int i,
    int i1,
    double f,
    double f1,
    int i2,
    int i3,
  ) {
    return ScreenshotRecorderConfig.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            i,
            i1,
            f,
            f1,
            i2,
            i3)
        .reference);
  }

  static final _id_getRecordingWidth = _class.instanceMethodId(
    r'getRecordingWidth',
    r'()I',
  );

  static final _getRecordingWidth = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int getRecordingWidth()`
  int getRecordingWidth() {
    return _getRecordingWidth(
            reference.pointer, _id_getRecordingWidth as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getRecordingHeight = _class.instanceMethodId(
    r'getRecordingHeight',
    r'()I',
  );

  static final _getRecordingHeight = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int getRecordingHeight()`
  int getRecordingHeight() {
    return _getRecordingHeight(
            reference.pointer, _id_getRecordingHeight as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getScaleFactorX = _class.instanceMethodId(
    r'getScaleFactorX',
    r'()F',
  );

  static final _getScaleFactorX = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final float getScaleFactorX()`
  double getScaleFactorX() {
    return _getScaleFactorX(
            reference.pointer, _id_getScaleFactorX as jni$_.JMethodIDPtr)
        .float;
  }

  static final _id_getScaleFactorY = _class.instanceMethodId(
    r'getScaleFactorY',
    r'()F',
  );

  static final _getScaleFactorY = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final float getScaleFactorY()`
  double getScaleFactorY() {
    return _getScaleFactorY(
            reference.pointer, _id_getScaleFactorY as jni$_.JMethodIDPtr)
        .float;
  }

  static final _id_getFrameRate = _class.instanceMethodId(
    r'getFrameRate',
    r'()I',
  );

  static final _getFrameRate = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int getFrameRate()`
  int getFrameRate() {
    return _getFrameRate(
            reference.pointer, _id_getFrameRate as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getBitRate = _class.instanceMethodId(
    r'getBitRate',
    r'()I',
  );

  static final _getBitRate = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int getBitRate()`
  int getBitRate() {
    return _getBitRate(reference.pointer, _id_getBitRate as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_new$1 = _class.constructorId(
    r'(FF)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Double, jni$_.Double)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double, double)>();

  /// from: `public void <init>(float f, float f1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ScreenshotRecorderConfig.new$1(
    double f,
    double f1,
  ) {
    return ScreenshotRecorderConfig.fromReference(
        _new$1(_class.reference.pointer, _id_new$1 as jni$_.JMethodIDPtr, f, f1)
            .reference);
  }

  static final _id_component1 = _class.instanceMethodId(
    r'component1',
    r'()I',
  );

  static final _component1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int component1()`
  int component1() {
    return _component1(reference.pointer, _id_component1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_component2 = _class.instanceMethodId(
    r'component2',
    r'()I',
  );

  static final _component2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int component2()`
  int component2() {
    return _component2(reference.pointer, _id_component2 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_component3 = _class.instanceMethodId(
    r'component3',
    r'()F',
  );

  static final _component3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final float component3()`
  double component3() {
    return _component3(reference.pointer, _id_component3 as jni$_.JMethodIDPtr)
        .float;
  }

  static final _id_component4 = _class.instanceMethodId(
    r'component4',
    r'()F',
  );

  static final _component4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final float component4()`
  double component4() {
    return _component4(reference.pointer, _id_component4 as jni$_.JMethodIDPtr)
        .float;
  }

  static final _id_component5 = _class.instanceMethodId(
    r'component5',
    r'()I',
  );

  static final _component5 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int component5()`
  int component5() {
    return _component5(reference.pointer, _id_component5 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_component6 = _class.instanceMethodId(
    r'component6',
    r'()I',
  );

  static final _component6 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int component6()`
  int component6() {
    return _component6(reference.pointer, _id_component6 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(IIFFII)Lio/sentry/android/replay/ScreenshotRecorderConfig;',
  );

  static final _copy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Double,
                        jni$_.Double,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, double, double, int, int)>();

  /// from: `public final io.sentry.android.replay.ScreenshotRecorderConfig copy(int i, int i1, float f, float f1, int i2, int i3)`
  /// The returned object must be released after use, by calling the [release] method.
  ScreenshotRecorderConfig copy(
    int i,
    int i1,
    double f,
    double f1,
    int i2,
    int i3,
  ) {
    return _copy(reference.pointer, _id_copy as jni$_.JMethodIDPtr, i, i1, f,
            f1, i2, i3)
        .object<ScreenshotRecorderConfig>(
            const $ScreenshotRecorderConfig$Type());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }
}

final class $ScreenshotRecorderConfig$NullableType
    extends jni$_.JObjType<ScreenshotRecorderConfig?> {
  @jni$_.internal
  const $ScreenshotRecorderConfig$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/android/replay/ScreenshotRecorderConfig;';

  @jni$_.internal
  @core$_.override
  ScreenshotRecorderConfig? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ScreenshotRecorderConfig.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ScreenshotRecorderConfig?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ScreenshotRecorderConfig$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ScreenshotRecorderConfig$NullableType) &&
        other is $ScreenshotRecorderConfig$NullableType;
  }
}

final class $ScreenshotRecorderConfig$Type
    extends jni$_.JObjType<ScreenshotRecorderConfig> {
  @jni$_.internal
  const $ScreenshotRecorderConfig$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/android/replay/ScreenshotRecorderConfig;';

  @jni$_.internal
  @core$_.override
  ScreenshotRecorderConfig fromReference(jni$_.JReference reference) =>
      ScreenshotRecorderConfig.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ScreenshotRecorderConfig?> get nullableType =>
      const $ScreenshotRecorderConfig$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ScreenshotRecorderConfig$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ScreenshotRecorderConfig$Type) &&
        other is $ScreenshotRecorderConfig$Type;
  }
}

/// from: `io.sentry.flutter.SentryFlutterPlugin$Companion`
class SentryFlutterPlugin$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryFlutterPlugin$Companion> $type;

  @jni$_.internal
  SentryFlutterPlugin$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/flutter/SentryFlutterPlugin$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryFlutterPlugin$Companion$NullableType();
  static const type = $SentryFlutterPlugin$Companion$Type();
  static final _id_tearDownReplayIntegration = _class.instanceMethodId(
    r'tearDownReplayIntegration',
    r'()V',
  );

  static final _tearDownReplayIntegration = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final void tearDownReplayIntegration()`
  void tearDownReplayIntegration() {
    _tearDownReplayIntegration(reference.pointer,
            _id_tearDownReplayIntegration as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_privateSentryGetReplayIntegration = _class.instanceMethodId(
    r'privateSentryGetReplayIntegration',
    r'()Lio/sentry/android/replay/ReplayIntegration;',
  );

  static final _privateSentryGetReplayIntegration =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public final io.sentry.android.replay.ReplayIntegration privateSentryGetReplayIntegration()`
  /// The returned object must be released after use, by calling the [release] method.
  ReplayIntegration? privateSentryGetReplayIntegration() {
    return _privateSentryGetReplayIntegration(reference.pointer,
            _id_privateSentryGetReplayIntegration as jni$_.JMethodIDPtr)
        .object<ReplayIntegration?>(const $ReplayIntegration$NullableType());
  }

  static final _id_setupReplay = _class.instanceMethodId(
    r'setupReplay',
    r'(Lio/sentry/android/core/SentryAndroidOptions;Lio/sentry/flutter/ReplayRecorderCallbacks;)V',
  );

  static final _setupReplay = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setupReplay(io.sentry.android.core.SentryAndroidOptions sentryAndroidOptions, io.sentry.flutter.ReplayRecorderCallbacks replayRecorderCallbacks)`
  void setupReplay(
    SentryAndroidOptions sentryAndroidOptions,
    ReplayRecorderCallbacks? replayRecorderCallbacks,
  ) {
    final _$sentryAndroidOptions = sentryAndroidOptions.reference;
    final _$replayRecorderCallbacks =
        replayRecorderCallbacks?.reference ?? jni$_.jNullReference;
    _setupReplay(reference.pointer, _id_setupReplay as jni$_.JMethodIDPtr,
            _$sentryAndroidOptions.pointer, _$replayRecorderCallbacks.pointer)
        .check();
  }

  static final _id_crash = _class.instanceMethodId(
    r'crash',
    r'()V',
  );

  static final _crash = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final void crash()`
  void crash() {
    _crash(reference.pointer, _id_crash as jni$_.JMethodIDPtr).check();
  }

  static final _id_getDisplayRefreshRate = _class.instanceMethodId(
    r'getDisplayRefreshRate',
    r'()Ljava/lang/Integer;',
  );

  static final _getDisplayRefreshRate = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Integer getDisplayRefreshRate()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JInteger? getDisplayRefreshRate() {
    return _getDisplayRefreshRate(
            reference.pointer, _id_getDisplayRefreshRate as jni$_.JMethodIDPtr)
        .object<jni$_.JInteger?>(const jni$_.JIntegerNullableType());
  }

  static final _id_fetchNativeAppStartAsBytes = _class.instanceMethodId(
    r'fetchNativeAppStartAsBytes',
    r'()[B',
  );

  static final _fetchNativeAppStartAsBytes =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public final byte[] fetchNativeAppStartAsBytes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? fetchNativeAppStartAsBytes() {
    return _fetchNativeAppStartAsBytes(reference.pointer,
            _id_fetchNativeAppStartAsBytes as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_getApplicationContext = _class.instanceMethodId(
    r'getApplicationContext',
    r'()Landroid/content/Context;',
  );

  static final _getApplicationContext = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final android.content.Context getApplicationContext()`
  /// The returned object must be released after use, by calling the [release] method.
  Context? getApplicationContext() {
    return _getApplicationContext(
            reference.pointer, _id_getApplicationContext as jni$_.JMethodIDPtr)
        .object<Context?>(const $Context$NullableType());
  }

  static final _id_loadContextsAsBytes = _class.instanceMethodId(
    r'loadContextsAsBytes',
    r'()[B',
  );

  static final _loadContextsAsBytes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final byte[] loadContextsAsBytes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? loadContextsAsBytes() {
    return _loadContextsAsBytes(
            reference.pointer, _id_loadContextsAsBytes as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_loadDebugImagesAsBytes = _class.instanceMethodId(
    r'loadDebugImagesAsBytes',
    r'(Ljava/util/Set;)[B',
  );

  static final _loadDebugImagesAsBytes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final byte[] loadDebugImagesAsBytes(java.util.Set<java.lang.String> set)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? loadDebugImagesAsBytes(
    jni$_.JSet<jni$_.JString> set,
  ) {
    final _$set = set.reference;
    return _loadDebugImagesAsBytes(reference.pointer,
            _id_loadDebugImagesAsBytes as jni$_.JMethodIDPtr, _$set.pointer)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryFlutterPlugin$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return SentryFlutterPlugin$Companion.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $SentryFlutterPlugin$Companion$NullableType
    extends jni$_.JObjType<SentryFlutterPlugin$Companion?> {
  @jni$_.internal
  const $SentryFlutterPlugin$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/flutter/SentryFlutterPlugin$Companion;';

  @jni$_.internal
  @core$_.override
  SentryFlutterPlugin$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryFlutterPlugin$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryFlutterPlugin$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryFlutterPlugin$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryFlutterPlugin$Companion$NullableType) &&
        other is $SentryFlutterPlugin$Companion$NullableType;
  }
}

final class $SentryFlutterPlugin$Companion$Type
    extends jni$_.JObjType<SentryFlutterPlugin$Companion> {
  @jni$_.internal
  const $SentryFlutterPlugin$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/flutter/SentryFlutterPlugin$Companion;';

  @jni$_.internal
  @core$_.override
  SentryFlutterPlugin$Companion fromReference(jni$_.JReference reference) =>
      SentryFlutterPlugin$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryFlutterPlugin$Companion?> get nullableType =>
      const $SentryFlutterPlugin$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryFlutterPlugin$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryFlutterPlugin$Companion$Type) &&
        other is $SentryFlutterPlugin$Companion$Type;
  }
}

/// from: `io.sentry.flutter.SentryFlutterPlugin`
class SentryFlutterPlugin extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryFlutterPlugin> $type;

  @jni$_.internal
  SentryFlutterPlugin.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/flutter/SentryFlutterPlugin');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryFlutterPlugin$NullableType();
  static const type = $SentryFlutterPlugin$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Lio/sentry/flutter/SentryFlutterPlugin$Companion;',
  );

  /// from: `static public final io.sentry.flutter.SentryFlutterPlugin$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryFlutterPlugin$Companion get Companion =>
      _id_Companion.get(_class, const $SentryFlutterPlugin$Companion$Type());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryFlutterPlugin() {
    return SentryFlutterPlugin.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_onAttachedToEngine = _class.instanceMethodId(
    r'onAttachedToEngine',
    r'(Lio/flutter/embedding/engine/plugins/FlutterPlugin$FlutterPluginBinding;)V',
  );

  static final _onAttachedToEngine = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onAttachedToEngine(io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding flutterPluginBinding)`
  void onAttachedToEngine(
    jni$_.JObject flutterPluginBinding,
  ) {
    final _$flutterPluginBinding = flutterPluginBinding.reference;
    _onAttachedToEngine(
            reference.pointer,
            _id_onAttachedToEngine as jni$_.JMethodIDPtr,
            _$flutterPluginBinding.pointer)
        .check();
  }

  static final _id_onMethodCall = _class.instanceMethodId(
    r'onMethodCall',
    r'(Lio/flutter/plugin/common/MethodCall;Lio/flutter/plugin/common/MethodChannel$Result;)V',
  );

  static final _onMethodCall = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onMethodCall(io.flutter.plugin.common.MethodCall methodCall, io.flutter.plugin.common.MethodChannel$Result result)`
  void onMethodCall(
    jni$_.JObject methodCall,
    jni$_.JObject result,
  ) {
    final _$methodCall = methodCall.reference;
    final _$result = result.reference;
    _onMethodCall(reference.pointer, _id_onMethodCall as jni$_.JMethodIDPtr,
            _$methodCall.pointer, _$result.pointer)
        .check();
  }

  static final _id_onDetachedFromEngine = _class.instanceMethodId(
    r'onDetachedFromEngine',
    r'(Lio/flutter/embedding/engine/plugins/FlutterPlugin$FlutterPluginBinding;)V',
  );

  static final _onDetachedFromEngine = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onDetachedFromEngine(io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding flutterPluginBinding)`
  void onDetachedFromEngine(
    jni$_.JObject flutterPluginBinding,
  ) {
    final _$flutterPluginBinding = flutterPluginBinding.reference;
    _onDetachedFromEngine(
            reference.pointer,
            _id_onDetachedFromEngine as jni$_.JMethodIDPtr,
            _$flutterPluginBinding.pointer)
        .check();
  }

  static final _id_onAttachedToActivity = _class.instanceMethodId(
    r'onAttachedToActivity',
    r'(Lio/flutter/embedding/engine/plugins/activity/ActivityPluginBinding;)V',
  );

  static final _onAttachedToActivity = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onAttachedToActivity(io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding activityPluginBinding)`
  void onAttachedToActivity(
    jni$_.JObject activityPluginBinding,
  ) {
    final _$activityPluginBinding = activityPluginBinding.reference;
    _onAttachedToActivity(
            reference.pointer,
            _id_onAttachedToActivity as jni$_.JMethodIDPtr,
            _$activityPluginBinding.pointer)
        .check();
  }

  static final _id_onDetachedFromActivity = _class.instanceMethodId(
    r'onDetachedFromActivity',
    r'()V',
  );

  static final _onDetachedFromActivity = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void onDetachedFromActivity()`
  void onDetachedFromActivity() {
    _onDetachedFromActivity(
            reference.pointer, _id_onDetachedFromActivity as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_onReattachedToActivityForConfigChanges =
      _class.instanceMethodId(
    r'onReattachedToActivityForConfigChanges',
    r'(Lio/flutter/embedding/engine/plugins/activity/ActivityPluginBinding;)V',
  );

  static final _onReattachedToActivityForConfigChanges =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onReattachedToActivityForConfigChanges(io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding activityPluginBinding)`
  void onReattachedToActivityForConfigChanges(
    jni$_.JObject activityPluginBinding,
  ) {
    final _$activityPluginBinding = activityPluginBinding.reference;
    _onReattachedToActivityForConfigChanges(
            reference.pointer,
            _id_onReattachedToActivityForConfigChanges as jni$_.JMethodIDPtr,
            _$activityPluginBinding.pointer)
        .check();
  }

  static final _id_onDetachedFromActivityForConfigChanges =
      _class.instanceMethodId(
    r'onDetachedFromActivityForConfigChanges',
    r'()V',
  );

  static final _onDetachedFromActivityForConfigChanges =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public void onDetachedFromActivityForConfigChanges()`
  void onDetachedFromActivityForConfigChanges() {
    _onDetachedFromActivityForConfigChanges(reference.pointer,
            _id_onDetachedFromActivityForConfigChanges as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_privateSentryGetReplayIntegration = _class.staticMethodId(
    r'privateSentryGetReplayIntegration',
    r'()Lio/sentry/android/replay/ReplayIntegration;',
  );

  static final _privateSentryGetReplayIntegration =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `static public final io.sentry.android.replay.ReplayIntegration privateSentryGetReplayIntegration()`
  /// The returned object must be released after use, by calling the [release] method.
  static ReplayIntegration? privateSentryGetReplayIntegration() {
    return _privateSentryGetReplayIntegration(_class.reference.pointer,
            _id_privateSentryGetReplayIntegration as jni$_.JMethodIDPtr)
        .object<ReplayIntegration?>(const $ReplayIntegration$NullableType());
  }

  static final _id_setupReplay = _class.staticMethodId(
    r'setupReplay',
    r'(Lio/sentry/android/core/SentryAndroidOptions;Lio/sentry/flutter/ReplayRecorderCallbacks;)V',
  );

  static final _setupReplay = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public final void setupReplay(io.sentry.android.core.SentryAndroidOptions sentryAndroidOptions, io.sentry.flutter.ReplayRecorderCallbacks replayRecorderCallbacks)`
  static void setupReplay(
    SentryAndroidOptions sentryAndroidOptions,
    ReplayRecorderCallbacks? replayRecorderCallbacks,
  ) {
    final _$sentryAndroidOptions = sentryAndroidOptions.reference;
    final _$replayRecorderCallbacks =
        replayRecorderCallbacks?.reference ?? jni$_.jNullReference;
    _setupReplay(
            _class.reference.pointer,
            _id_setupReplay as jni$_.JMethodIDPtr,
            _$sentryAndroidOptions.pointer,
            _$replayRecorderCallbacks.pointer)
        .check();
  }

  static final _id_crash = _class.staticMethodId(
    r'crash',
    r'()V',
  );

  static final _crash = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public final void crash()`
  static void crash() {
    _crash(_class.reference.pointer, _id_crash as jni$_.JMethodIDPtr).check();
  }

  static final _id_getDisplayRefreshRate = _class.staticMethodId(
    r'getDisplayRefreshRate',
    r'()Ljava/lang/Integer;',
  );

  static final _getDisplayRefreshRate = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public final java.lang.Integer getDisplayRefreshRate()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JInteger? getDisplayRefreshRate() {
    return _getDisplayRefreshRate(_class.reference.pointer,
            _id_getDisplayRefreshRate as jni$_.JMethodIDPtr)
        .object<jni$_.JInteger?>(const jni$_.JIntegerNullableType());
  }

  static final _id_fetchNativeAppStartAsBytes = _class.staticMethodId(
    r'fetchNativeAppStartAsBytes',
    r'()[B',
  );

  static final _fetchNativeAppStartAsBytes =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `static public final byte[] fetchNativeAppStartAsBytes()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JByteArray? fetchNativeAppStartAsBytes() {
    return _fetchNativeAppStartAsBytes(_class.reference.pointer,
            _id_fetchNativeAppStartAsBytes as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_getApplicationContext = _class.staticMethodId(
    r'getApplicationContext',
    r'()Landroid/content/Context;',
  );

  static final _getApplicationContext = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public final android.content.Context getApplicationContext()`
  /// The returned object must be released after use, by calling the [release] method.
  static Context? getApplicationContext() {
    return _getApplicationContext(_class.reference.pointer,
            _id_getApplicationContext as jni$_.JMethodIDPtr)
        .object<Context?>(const $Context$NullableType());
  }

  static final _id_loadContextsAsBytes = _class.staticMethodId(
    r'loadContextsAsBytes',
    r'()[B',
  );

  static final _loadContextsAsBytes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public final byte[] loadContextsAsBytes()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JByteArray? loadContextsAsBytes() {
    return _loadContextsAsBytes(_class.reference.pointer,
            _id_loadContextsAsBytes as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_loadDebugImagesAsBytes = _class.staticMethodId(
    r'loadDebugImagesAsBytes',
    r'(Ljava/util/Set;)[B',
  );

  static final _loadDebugImagesAsBytes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public final byte[] loadDebugImagesAsBytes(java.util.Set<java.lang.String> set)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JByteArray? loadDebugImagesAsBytes(
    jni$_.JSet<jni$_.JString?> set,
  ) {
    final _$set = set.reference;
    return _loadDebugImagesAsBytes(_class.reference.pointer,
            _id_loadDebugImagesAsBytes as jni$_.JMethodIDPtr, _$set.pointer)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }
}

final class $SentryFlutterPlugin$NullableType
    extends jni$_.JObjType<SentryFlutterPlugin?> {
  @jni$_.internal
  const $SentryFlutterPlugin$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/flutter/SentryFlutterPlugin;';

  @jni$_.internal
  @core$_.override
  SentryFlutterPlugin? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryFlutterPlugin.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryFlutterPlugin?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryFlutterPlugin$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryFlutterPlugin$NullableType) &&
        other is $SentryFlutterPlugin$NullableType;
  }
}

final class $SentryFlutterPlugin$Type
    extends jni$_.JObjType<SentryFlutterPlugin> {
  @jni$_.internal
  const $SentryFlutterPlugin$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/flutter/SentryFlutterPlugin;';

  @jni$_.internal
  @core$_.override
  SentryFlutterPlugin fromReference(jni$_.JReference reference) =>
      SentryFlutterPlugin.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryFlutterPlugin?> get nullableType =>
      const $SentryFlutterPlugin$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryFlutterPlugin$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryFlutterPlugin$Type) &&
        other is $SentryFlutterPlugin$Type;
  }
}

/// from: `io.sentry.flutter.ReplayRecorderCallbacks`
class ReplayRecorderCallbacks extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ReplayRecorderCallbacks> $type;

  @jni$_.internal
  ReplayRecorderCallbacks.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/flutter/ReplayRecorderCallbacks');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ReplayRecorderCallbacks$NullableType();
  static const type = $ReplayRecorderCallbacks$Type();
  static final _id_replayStarted = _class.instanceMethodId(
    r'replayStarted',
    r'(Ljava/lang/String;Z)V',
  );

  static final _replayStarted = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public abstract void replayStarted(java.lang.String string, boolean z)`
  void replayStarted(
    jni$_.JString string,
    bool z,
  ) {
    final _$string = string.reference;
    _replayStarted(reference.pointer, _id_replayStarted as jni$_.JMethodIDPtr,
            _$string.pointer, z ? 1 : 0)
        .check();
  }

  static final _id_replayResumed = _class.instanceMethodId(
    r'replayResumed',
    r'()V',
  );

  static final _replayResumed = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void replayResumed()`
  void replayResumed() {
    _replayResumed(reference.pointer, _id_replayResumed as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_replayPaused = _class.instanceMethodId(
    r'replayPaused',
    r'()V',
  );

  static final _replayPaused = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void replayPaused()`
  void replayPaused() {
    _replayPaused(reference.pointer, _id_replayPaused as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_replayStopped = _class.instanceMethodId(
    r'replayStopped',
    r'()V',
  );

  static final _replayStopped = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void replayStopped()`
  void replayStopped() {
    _replayStopped(reference.pointer, _id_replayStopped as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_replayReset = _class.instanceMethodId(
    r'replayReset',
    r'()V',
  );

  static final _replayReset = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void replayReset()`
  void replayReset() {
    _replayReset(reference.pointer, _id_replayReset as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_replayConfigChanged = _class.instanceMethodId(
    r'replayConfigChanged',
    r'(III)V',
  );

  static final _replayConfigChanged = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int, int)>();

  /// from: `public abstract void replayConfigChanged(int i, int i1, int i2)`
  void replayConfigChanged(
    int i,
    int i1,
    int i2,
  ) {
    _replayConfigChanged(reference.pointer,
            _id_replayConfigChanged as jni$_.JMethodIDPtr, i, i1, i2)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ReplayRecorderCallbacks> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'replayStarted(Ljava/lang/String;Z)V') {
        _$impls[$p]!.replayStarted(
          $a![0]!.as(const jni$_.JStringType(), releaseOriginal: true),
          $a![1]!
              .as(const jni$_.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'replayResumed()V') {
        _$impls[$p]!.replayResumed();
        return jni$_.nullptr;
      }
      if ($d == r'replayPaused()V') {
        _$impls[$p]!.replayPaused();
        return jni$_.nullptr;
      }
      if ($d == r'replayStopped()V') {
        _$impls[$p]!.replayStopped();
        return jni$_.nullptr;
      }
      if ($d == r'replayReset()V') {
        _$impls[$p]!.replayReset();
        return jni$_.nullptr;
      }
      if ($d == r'replayConfigChanged(III)V') {
        _$impls[$p]!.replayConfigChanged(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![1]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![2]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $ReplayRecorderCallbacks $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.flutter.ReplayRecorderCallbacks',
      $p,
      _$invokePointer,
      [
        if ($impl.replayStarted$async) r'replayStarted(Ljava/lang/String;Z)V',
        if ($impl.replayResumed$async) r'replayResumed()V',
        if ($impl.replayPaused$async) r'replayPaused()V',
        if ($impl.replayStopped$async) r'replayStopped()V',
        if ($impl.replayReset$async) r'replayReset()V',
        if ($impl.replayConfigChanged$async) r'replayConfigChanged(III)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ReplayRecorderCallbacks.implement(
    $ReplayRecorderCallbacks $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ReplayRecorderCallbacks.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $ReplayRecorderCallbacks {
  factory $ReplayRecorderCallbacks({
    required void Function(jni$_.JString string, bool z) replayStarted,
    bool replayStarted$async,
    required void Function() replayResumed,
    bool replayResumed$async,
    required void Function() replayPaused,
    bool replayPaused$async,
    required void Function() replayStopped,
    bool replayStopped$async,
    required void Function() replayReset,
    bool replayReset$async,
    required void Function(int i, int i1, int i2) replayConfigChanged,
    bool replayConfigChanged$async,
  }) = _$ReplayRecorderCallbacks;

  void replayStarted(jni$_.JString string, bool z);
  bool get replayStarted$async => false;
  void replayResumed();
  bool get replayResumed$async => false;
  void replayPaused();
  bool get replayPaused$async => false;
  void replayStopped();
  bool get replayStopped$async => false;
  void replayReset();
  bool get replayReset$async => false;
  void replayConfigChanged(int i, int i1, int i2);
  bool get replayConfigChanged$async => false;
}

final class _$ReplayRecorderCallbacks with $ReplayRecorderCallbacks {
  _$ReplayRecorderCallbacks({
    required void Function(jni$_.JString string, bool z) replayStarted,
    this.replayStarted$async = false,
    required void Function() replayResumed,
    this.replayResumed$async = false,
    required void Function() replayPaused,
    this.replayPaused$async = false,
    required void Function() replayStopped,
    this.replayStopped$async = false,
    required void Function() replayReset,
    this.replayReset$async = false,
    required void Function(int i, int i1, int i2) replayConfigChanged,
    this.replayConfigChanged$async = false,
  })  : _replayStarted = replayStarted,
        _replayResumed = replayResumed,
        _replayPaused = replayPaused,
        _replayStopped = replayStopped,
        _replayReset = replayReset,
        _replayConfigChanged = replayConfigChanged;

  final void Function(jni$_.JString string, bool z) _replayStarted;
  final bool replayStarted$async;
  final void Function() _replayResumed;
  final bool replayResumed$async;
  final void Function() _replayPaused;
  final bool replayPaused$async;
  final void Function() _replayStopped;
  final bool replayStopped$async;
  final void Function() _replayReset;
  final bool replayReset$async;
  final void Function(int i, int i1, int i2) _replayConfigChanged;
  final bool replayConfigChanged$async;

  void replayStarted(jni$_.JString string, bool z) {
    return _replayStarted(string, z);
  }

  void replayResumed() {
    return _replayResumed();
  }

  void replayPaused() {
    return _replayPaused();
  }

  void replayStopped() {
    return _replayStopped();
  }

  void replayReset() {
    return _replayReset();
  }

  void replayConfigChanged(int i, int i1, int i2) {
    return _replayConfigChanged(i, i1, i2);
  }
}

final class $ReplayRecorderCallbacks$NullableType
    extends jni$_.JObjType<ReplayRecorderCallbacks?> {
  @jni$_.internal
  const $ReplayRecorderCallbacks$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/flutter/ReplayRecorderCallbacks;';

  @jni$_.internal
  @core$_.override
  ReplayRecorderCallbacks? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ReplayRecorderCallbacks.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ReplayRecorderCallbacks?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ReplayRecorderCallbacks$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ReplayRecorderCallbacks$NullableType) &&
        other is $ReplayRecorderCallbacks$NullableType;
  }
}

final class $ReplayRecorderCallbacks$Type
    extends jni$_.JObjType<ReplayRecorderCallbacks> {
  @jni$_.internal
  const $ReplayRecorderCallbacks$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/flutter/ReplayRecorderCallbacks;';

  @jni$_.internal
  @core$_.override
  ReplayRecorderCallbacks fromReference(jni$_.JReference reference) =>
      ReplayRecorderCallbacks.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ReplayRecorderCallbacks?> get nullableType =>
      const $ReplayRecorderCallbacks$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ReplayRecorderCallbacks$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ReplayRecorderCallbacks$Type) &&
        other is $ReplayRecorderCallbacks$Type;
  }
}

/// from: `io.sentry.Sentry$OptionsConfiguration`
class Sentry$OptionsConfiguration<$T extends jni$_.JObject?>
    extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Sentry$OptionsConfiguration<$T>> $type;

  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  Sentry$OptionsConfiguration.fromReference(
    this.T,
    jni$_.JReference reference,
  )   : $type = type<$T>(T),
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/Sentry$OptionsConfiguration');

  /// The type which includes information such as the signature of this class.
  static $Sentry$OptionsConfiguration$NullableType<$T>
      nullableType<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) {
    return $Sentry$OptionsConfiguration$NullableType<$T>(
      T,
    );
  }

  static $Sentry$OptionsConfiguration$Type<$T> type<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) {
    return $Sentry$OptionsConfiguration$Type<$T>(
      T,
    );
  }

  static final _id_configure = _class.instanceMethodId(
    r'configure',
    r'(Lio/sentry/SentryOptions;)V',
  );

  static final _configure = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void configure(T sentryOptions)`
  void configure(
    $T sentryOptions,
  ) {
    final _$sentryOptions = sentryOptions?.reference ?? jni$_.jNullReference;
    _configure(reference.pointer, _id_configure as jni$_.JMethodIDPtr,
            _$sentryOptions.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Sentry$OptionsConfiguration> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'configure(Lio/sentry/SentryOptions;)V') {
        _$impls[$p]!.configure(
          $a![0]?.as(_$impls[$p]!.T, releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn<$T extends jni$_.JObject?>(
    jni$_.JImplementer implementer,
    $Sentry$OptionsConfiguration<$T> $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.Sentry$OptionsConfiguration',
      $p,
      _$invokePointer,
      [
        if ($impl.configure$async) r'configure(Lio/sentry/SentryOptions;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Sentry$OptionsConfiguration.implement(
    $Sentry$OptionsConfiguration<$T> $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Sentry$OptionsConfiguration<$T>.fromReference(
      $impl.T,
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Sentry$OptionsConfiguration<
    $T extends jni$_.JObject?> {
  factory $Sentry$OptionsConfiguration({
    required jni$_.JObjType<$T> T,
    required void Function($T sentryOptions) configure,
    bool configure$async,
  }) = _$Sentry$OptionsConfiguration<$T>;

  jni$_.JObjType<$T> get T;

  void configure($T sentryOptions);
  bool get configure$async => false;
}

final class _$Sentry$OptionsConfiguration<$T extends jni$_.JObject?>
    with $Sentry$OptionsConfiguration<$T> {
  _$Sentry$OptionsConfiguration({
    required this.T,
    required void Function($T sentryOptions) configure,
    this.configure$async = false,
  }) : _configure = configure;

  @core$_.override
  final jni$_.JObjType<$T> T;

  final void Function($T sentryOptions) _configure;
  final bool configure$async;

  void configure($T sentryOptions) {
    return _configure(sentryOptions);
  }
}

final class $Sentry$OptionsConfiguration$NullableType<$T extends jni$_.JObject?>
    extends jni$_.JObjType<Sentry$OptionsConfiguration<$T>?> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $Sentry$OptionsConfiguration$NullableType(
    this.T,
  );

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Sentry$OptionsConfiguration;';

  @jni$_.internal
  @core$_.override
  Sentry$OptionsConfiguration<$T>? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Sentry$OptionsConfiguration<$T>.fromReference(
              T,
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Sentry$OptionsConfiguration<$T>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($Sentry$OptionsConfiguration$NullableType, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($Sentry$OptionsConfiguration$NullableType<$T>) &&
        other is $Sentry$OptionsConfiguration$NullableType<$T> &&
        T == other.T;
  }
}

final class $Sentry$OptionsConfiguration$Type<$T extends jni$_.JObject?>
    extends jni$_.JObjType<Sentry$OptionsConfiguration<$T>> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $Sentry$OptionsConfiguration$Type(
    this.T,
  );

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Sentry$OptionsConfiguration;';

  @jni$_.internal
  @core$_.override
  Sentry$OptionsConfiguration<$T> fromReference(jni$_.JReference reference) =>
      Sentry$OptionsConfiguration<$T>.fromReference(
        T,
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Sentry$OptionsConfiguration<$T>?> get nullableType =>
      $Sentry$OptionsConfiguration$NullableType<$T>(T);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($Sentry$OptionsConfiguration$Type, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Sentry$OptionsConfiguration$Type<$T>) &&
        other is $Sentry$OptionsConfiguration$Type<$T> &&
        T == other.T;
  }
}

/// from: `io.sentry.Sentry`
class Sentry extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Sentry> $type;

  @jni$_.internal
  Sentry.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/Sentry');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Sentry$NullableType();
  static const type = $Sentry$Type();
  static final _id_APP_START_PROFILING_CONFIG_FILE_NAME = _class.staticFieldId(
    r'APP_START_PROFILING_CONFIG_FILE_NAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String APP_START_PROFILING_CONFIG_FILE_NAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString get APP_START_PROFILING_CONFIG_FILE_NAME =>
      _id_APP_START_PROFILING_CONFIG_FILE_NAME.get(
          _class, const jni$_.JStringType());

  static final _id_getCurrentHub = _class.staticMethodId(
    r'getCurrentHub',
    r'()Lio/sentry/IHub;',
  );

  static final _getCurrentHub = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.IHub getCurrentHub()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getCurrentHub() {
    return _getCurrentHub(
            _class.reference.pointer, _id_getCurrentHub as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getCurrentScopes = _class.staticMethodId(
    r'getCurrentScopes',
    r'()Lio/sentry/IScopes;',
  );

  static final _getCurrentScopes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.IScopes getCurrentScopes()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getCurrentScopes() {
    return _getCurrentScopes(_class.reference.pointer,
            _id_getCurrentScopes as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getCurrentScopes$1 = _class.staticMethodId(
    r'getCurrentScopes',
    r'(Z)Lio/sentry/IScopes;',
  );

  static final _getCurrentScopes$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public io.sentry.IScopes getCurrentScopes(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getCurrentScopes$1(
    bool z,
  ) {
    return _getCurrentScopes$1(_class.reference.pointer,
            _id_getCurrentScopes$1 as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_forkedRootScopes = _class.staticMethodId(
    r'forkedRootScopes',
    r'(Ljava/lang/String;)Lio/sentry/IScopes;',
  );

  static final _forkedRootScopes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.IScopes forkedRootScopes(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject forkedRootScopes(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _forkedRootScopes(_class.reference.pointer,
            _id_forkedRootScopes as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_forkedScopes = _class.staticMethodId(
    r'forkedScopes',
    r'(Ljava/lang/String;)Lio/sentry/IScopes;',
  );

  static final _forkedScopes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.IScopes forkedScopes(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject forkedScopes(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _forkedScopes(_class.reference.pointer,
            _id_forkedScopes as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_forkedCurrentScope = _class.staticMethodId(
    r'forkedCurrentScope',
    r'(Ljava/lang/String;)Lio/sentry/IScopes;',
  );

  static final _forkedCurrentScope = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.IScopes forkedCurrentScope(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject forkedCurrentScope(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _forkedCurrentScope(_class.reference.pointer,
            _id_forkedCurrentScope as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setCurrentHub = _class.staticMethodId(
    r'setCurrentHub',
    r'(Lio/sentry/IHub;)Lio/sentry/ISentryLifecycleToken;',
  );

  static final _setCurrentHub = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.ISentryLifecycleToken setCurrentHub(io.sentry.IHub iHub)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject setCurrentHub(
    jni$_.JObject iHub,
  ) {
    final _$iHub = iHub.reference;
    return _setCurrentHub(_class.reference.pointer,
            _id_setCurrentHub as jni$_.JMethodIDPtr, _$iHub.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setCurrentScopes = _class.staticMethodId(
    r'setCurrentScopes',
    r'(Lio/sentry/IScopes;)Lio/sentry/ISentryLifecycleToken;',
  );

  static final _setCurrentScopes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.ISentryLifecycleToken setCurrentScopes(io.sentry.IScopes iScopes)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject setCurrentScopes(
    jni$_.JObject iScopes,
  ) {
    final _$iScopes = iScopes.reference;
    return _setCurrentScopes(_class.reference.pointer,
            _id_setCurrentScopes as jni$_.JMethodIDPtr, _$iScopes.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getGlobalScope = _class.staticMethodId(
    r'getGlobalScope',
    r'()Lio/sentry/IScope;',
  );

  static final _getGlobalScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.IScope getGlobalScope()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getGlobalScope() {
    return _getGlobalScope(
            _class.reference.pointer, _id_getGlobalScope as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_isEnabled = _class.staticMethodId(
    r'isEnabled',
    r'()Z',
  );

  static final _isEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public boolean isEnabled()`
  static bool isEnabled() {
    return _isEnabled(
            _class.reference.pointer, _id_isEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_init = _class.staticMethodId(
    r'init',
    r'()V',
  );

  static final _init = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public void init()`
  static void init() {
    _init(_class.reference.pointer, _id_init as jni$_.JMethodIDPtr).check();
  }

  static final _id_init$1 = _class.staticMethodId(
    r'init',
    r'(Ljava/lang/String;)V',
  );

  static final _init$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void init(java.lang.String string)`
  static void init$1(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _init$1(_class.reference.pointer, _id_init$1 as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_init$2 = _class.staticMethodId(
    r'init',
    r'(Lio/sentry/OptionsContainer;Lio/sentry/Sentry$OptionsConfiguration;)V',
  );

  static final _init$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void init(io.sentry.OptionsContainer<T> optionsContainer, io.sentry.Sentry$OptionsConfiguration<T> optionsConfiguration)`
  static void init$2<$T extends jni$_.JObject?>(
    jni$_.JObject optionsContainer,
    Sentry$OptionsConfiguration<$T?> optionsConfiguration, {
    jni$_.JObjType<$T>? T,
  }) {
    T ??= jni$_.lowestCommonSuperType([
      (optionsConfiguration.$type
              as $Sentry$OptionsConfiguration$Type<core$_.dynamic>)
          .T,
    ]) as jni$_.JObjType<$T>;
    final _$optionsContainer = optionsContainer.reference;
    final _$optionsConfiguration = optionsConfiguration.reference;
    _init$2(_class.reference.pointer, _id_init$2 as jni$_.JMethodIDPtr,
            _$optionsContainer.pointer, _$optionsConfiguration.pointer)
        .check();
  }

  static final _id_init$3 = _class.staticMethodId(
    r'init',
    r'(Lio/sentry/OptionsContainer;Lio/sentry/Sentry$OptionsConfiguration;Z)V',
  );

  static final _init$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `static public void init(io.sentry.OptionsContainer<T> optionsContainer, io.sentry.Sentry$OptionsConfiguration<T> optionsConfiguration, boolean z)`
  static void init$3<$T extends jni$_.JObject?>(
    jni$_.JObject optionsContainer,
    Sentry$OptionsConfiguration<$T?> optionsConfiguration,
    bool z, {
    jni$_.JObjType<$T>? T,
  }) {
    T ??= jni$_.lowestCommonSuperType([
      (optionsConfiguration.$type
              as $Sentry$OptionsConfiguration$Type<core$_.dynamic>)
          .T,
    ]) as jni$_.JObjType<$T>;
    final _$optionsContainer = optionsContainer.reference;
    final _$optionsConfiguration = optionsConfiguration.reference;
    _init$3(
            _class.reference.pointer,
            _id_init$3 as jni$_.JMethodIDPtr,
            _$optionsContainer.pointer,
            _$optionsConfiguration.pointer,
            z ? 1 : 0)
        .check();
  }

  static final _id_init$4 = _class.staticMethodId(
    r'init',
    r'(Lio/sentry/Sentry$OptionsConfiguration;)V',
  );

  static final _init$4 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void init(io.sentry.Sentry$OptionsConfiguration<io.sentry.SentryOptions> optionsConfiguration)`
  static void init$4(
    Sentry$OptionsConfiguration<SentryOptions?> optionsConfiguration,
  ) {
    final _$optionsConfiguration = optionsConfiguration.reference;
    _init$4(_class.reference.pointer, _id_init$4 as jni$_.JMethodIDPtr,
            _$optionsConfiguration.pointer)
        .check();
  }

  static final _id_init$5 = _class.staticMethodId(
    r'init',
    r'(Lio/sentry/Sentry$OptionsConfiguration;Z)V',
  );

  static final _init$5 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `static public void init(io.sentry.Sentry$OptionsConfiguration<io.sentry.SentryOptions> optionsConfiguration, boolean z)`
  static void init$5(
    Sentry$OptionsConfiguration<SentryOptions?> optionsConfiguration,
    bool z,
  ) {
    final _$optionsConfiguration = optionsConfiguration.reference;
    _init$5(_class.reference.pointer, _id_init$5 as jni$_.JMethodIDPtr,
            _$optionsConfiguration.pointer, z ? 1 : 0)
        .check();
  }

  static final _id_init$6 = _class.staticMethodId(
    r'init',
    r'(Lio/sentry/SentryOptions;)V',
  );

  static final _init$6 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void init(io.sentry.SentryOptions sentryOptions)`
  static void init$6(
    SentryOptions sentryOptions,
  ) {
    final _$sentryOptions = sentryOptions.reference;
    _init$6(_class.reference.pointer, _id_init$6 as jni$_.JMethodIDPtr,
            _$sentryOptions.pointer)
        .check();
  }

  static final _id_close = _class.staticMethodId(
    r'close',
    r'()V',
  );

  static final _close = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public void close()`
  static void close() {
    _close(_class.reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_captureEvent = _class.staticMethodId(
    r'captureEvent',
    r'(Lio/sentry/SentryEvent;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureEvent = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureEvent(io.sentry.SentryEvent sentryEvent)`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryId captureEvent(
    SentryEvent sentryEvent,
  ) {
    final _$sentryEvent = sentryEvent.reference;
    return _captureEvent(_class.reference.pointer,
            _id_captureEvent as jni$_.JMethodIDPtr, _$sentryEvent.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_captureEvent$1 = _class.staticMethodId(
    r'captureEvent',
    r'(Lio/sentry/SentryEvent;Lio/sentry/ScopeCallback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureEvent$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureEvent(io.sentry.SentryEvent sentryEvent, io.sentry.ScopeCallback scopeCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryId captureEvent$1(
    SentryEvent sentryEvent,
    ScopeCallback scopeCallback,
  ) {
    final _$sentryEvent = sentryEvent.reference;
    final _$scopeCallback = scopeCallback.reference;
    return _captureEvent$1(
            _class.reference.pointer,
            _id_captureEvent$1 as jni$_.JMethodIDPtr,
            _$sentryEvent.pointer,
            _$scopeCallback.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_captureEvent$2 = _class.staticMethodId(
    r'captureEvent',
    r'(Lio/sentry/SentryEvent;Lio/sentry/Hint;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureEvent$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureEvent(io.sentry.SentryEvent sentryEvent, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryId captureEvent$2(
    SentryEvent sentryEvent,
    Hint? hint,
  ) {
    final _$sentryEvent = sentryEvent.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    return _captureEvent$2(
            _class.reference.pointer,
            _id_captureEvent$2 as jni$_.JMethodIDPtr,
            _$sentryEvent.pointer,
            _$hint.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_captureEvent$3 = _class.staticMethodId(
    r'captureEvent',
    r'(Lio/sentry/SentryEvent;Lio/sentry/Hint;Lio/sentry/ScopeCallback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureEvent$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureEvent(io.sentry.SentryEvent sentryEvent, io.sentry.Hint hint, io.sentry.ScopeCallback scopeCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryId captureEvent$3(
    SentryEvent sentryEvent,
    Hint? hint,
    ScopeCallback scopeCallback,
  ) {
    final _$sentryEvent = sentryEvent.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    final _$scopeCallback = scopeCallback.reference;
    return _captureEvent$3(
            _class.reference.pointer,
            _id_captureEvent$3 as jni$_.JMethodIDPtr,
            _$sentryEvent.pointer,
            _$hint.pointer,
            _$scopeCallback.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_captureMessage = _class.staticMethodId(
    r'captureMessage',
    r'(Ljava/lang/String;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureMessage = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureMessage(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryId captureMessage(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _captureMessage(_class.reference.pointer,
            _id_captureMessage as jni$_.JMethodIDPtr, _$string.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_captureMessage$1 = _class.staticMethodId(
    r'captureMessage',
    r'(Ljava/lang/String;Lio/sentry/ScopeCallback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureMessage$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureMessage(java.lang.String string, io.sentry.ScopeCallback scopeCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryId captureMessage$1(
    jni$_.JString string,
    ScopeCallback scopeCallback,
  ) {
    final _$string = string.reference;
    final _$scopeCallback = scopeCallback.reference;
    return _captureMessage$1(
            _class.reference.pointer,
            _id_captureMessage$1 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$scopeCallback.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_captureMessage$2 = _class.staticMethodId(
    r'captureMessage',
    r'(Ljava/lang/String;Lio/sentry/SentryLevel;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureMessage$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureMessage(java.lang.String string, io.sentry.SentryLevel sentryLevel)`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryId captureMessage$2(
    jni$_.JString string,
    SentryLevel sentryLevel,
  ) {
    final _$string = string.reference;
    final _$sentryLevel = sentryLevel.reference;
    return _captureMessage$2(
            _class.reference.pointer,
            _id_captureMessage$2 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$sentryLevel.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_captureMessage$3 = _class.staticMethodId(
    r'captureMessage',
    r'(Ljava/lang/String;Lio/sentry/SentryLevel;Lio/sentry/ScopeCallback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureMessage$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureMessage(java.lang.String string, io.sentry.SentryLevel sentryLevel, io.sentry.ScopeCallback scopeCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryId captureMessage$3(
    jni$_.JString string,
    SentryLevel sentryLevel,
    ScopeCallback scopeCallback,
  ) {
    final _$string = string.reference;
    final _$sentryLevel = sentryLevel.reference;
    final _$scopeCallback = scopeCallback.reference;
    return _captureMessage$3(
            _class.reference.pointer,
            _id_captureMessage$3 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$sentryLevel.pointer,
            _$scopeCallback.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_captureFeedback = _class.staticMethodId(
    r'captureFeedback',
    r'(Lio/sentry/protocol/Feedback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureFeedback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureFeedback(io.sentry.protocol.Feedback feedback)`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryId captureFeedback(
    jni$_.JObject feedback,
  ) {
    final _$feedback = feedback.reference;
    return _captureFeedback(_class.reference.pointer,
            _id_captureFeedback as jni$_.JMethodIDPtr, _$feedback.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_captureFeedback$1 = _class.staticMethodId(
    r'captureFeedback',
    r'(Lio/sentry/protocol/Feedback;Lio/sentry/Hint;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureFeedback$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureFeedback(io.sentry.protocol.Feedback feedback, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryId captureFeedback$1(
    jni$_.JObject feedback,
    Hint? hint,
  ) {
    final _$feedback = feedback.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    return _captureFeedback$1(
            _class.reference.pointer,
            _id_captureFeedback$1 as jni$_.JMethodIDPtr,
            _$feedback.pointer,
            _$hint.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_captureFeedback$2 = _class.staticMethodId(
    r'captureFeedback',
    r'(Lio/sentry/protocol/Feedback;Lio/sentry/Hint;Lio/sentry/ScopeCallback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureFeedback$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureFeedback(io.sentry.protocol.Feedback feedback, io.sentry.Hint hint, io.sentry.ScopeCallback scopeCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryId captureFeedback$2(
    jni$_.JObject feedback,
    Hint? hint,
    ScopeCallback? scopeCallback,
  ) {
    final _$feedback = feedback.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    final _$scopeCallback = scopeCallback?.reference ?? jni$_.jNullReference;
    return _captureFeedback$2(
            _class.reference.pointer,
            _id_captureFeedback$2 as jni$_.JMethodIDPtr,
            _$feedback.pointer,
            _$hint.pointer,
            _$scopeCallback.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_captureException = _class.staticMethodId(
    r'captureException',
    r'(Ljava/lang/Throwable;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureException = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureException(java.lang.Throwable throwable)`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryId captureException(
    jni$_.JObject throwable,
  ) {
    final _$throwable = throwable.reference;
    return _captureException(_class.reference.pointer,
            _id_captureException as jni$_.JMethodIDPtr, _$throwable.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_captureException$1 = _class.staticMethodId(
    r'captureException',
    r'(Ljava/lang/Throwable;Lio/sentry/ScopeCallback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureException$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureException(java.lang.Throwable throwable, io.sentry.ScopeCallback scopeCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryId captureException$1(
    jni$_.JObject throwable,
    ScopeCallback scopeCallback,
  ) {
    final _$throwable = throwable.reference;
    final _$scopeCallback = scopeCallback.reference;
    return _captureException$1(
            _class.reference.pointer,
            _id_captureException$1 as jni$_.JMethodIDPtr,
            _$throwable.pointer,
            _$scopeCallback.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_captureException$2 = _class.staticMethodId(
    r'captureException',
    r'(Ljava/lang/Throwable;Lio/sentry/Hint;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureException$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureException(java.lang.Throwable throwable, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryId captureException$2(
    jni$_.JObject throwable,
    Hint? hint,
  ) {
    final _$throwable = throwable.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    return _captureException$2(
            _class.reference.pointer,
            _id_captureException$2 as jni$_.JMethodIDPtr,
            _$throwable.pointer,
            _$hint.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_captureException$3 = _class.staticMethodId(
    r'captureException',
    r'(Ljava/lang/Throwable;Lio/sentry/Hint;Lio/sentry/ScopeCallback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureException$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureException(java.lang.Throwable throwable, io.sentry.Hint hint, io.sentry.ScopeCallback scopeCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryId captureException$3(
    jni$_.JObject throwable,
    Hint? hint,
    ScopeCallback scopeCallback,
  ) {
    final _$throwable = throwable.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    final _$scopeCallback = scopeCallback.reference;
    return _captureException$3(
            _class.reference.pointer,
            _id_captureException$3 as jni$_.JMethodIDPtr,
            _$throwable.pointer,
            _$hint.pointer,
            _$scopeCallback.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_captureUserFeedback = _class.staticMethodId(
    r'captureUserFeedback',
    r'(Lio/sentry/UserFeedback;)V',
  );

  static final _captureUserFeedback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void captureUserFeedback(io.sentry.UserFeedback userFeedback)`
  static void captureUserFeedback(
    jni$_.JObject userFeedback,
  ) {
    final _$userFeedback = userFeedback.reference;
    _captureUserFeedback(
            _class.reference.pointer,
            _id_captureUserFeedback as jni$_.JMethodIDPtr,
            _$userFeedback.pointer)
        .check();
  }

  static final _id_addBreadcrumb = _class.staticMethodId(
    r'addBreadcrumb',
    r'(Lio/sentry/Breadcrumb;Lio/sentry/Hint;)V',
  );

  static final _addBreadcrumb = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void addBreadcrumb(io.sentry.Breadcrumb breadcrumb, io.sentry.Hint hint)`
  static void addBreadcrumb(
    Breadcrumb breadcrumb,
    Hint? hint,
  ) {
    final _$breadcrumb = breadcrumb.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    _addBreadcrumb(
            _class.reference.pointer,
            _id_addBreadcrumb as jni$_.JMethodIDPtr,
            _$breadcrumb.pointer,
            _$hint.pointer)
        .check();
  }

  static final _id_addBreadcrumb$1 = _class.staticMethodId(
    r'addBreadcrumb',
    r'(Lio/sentry/Breadcrumb;)V',
  );

  static final _addBreadcrumb$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void addBreadcrumb(io.sentry.Breadcrumb breadcrumb)`
  static void addBreadcrumb$1(
    Breadcrumb breadcrumb,
  ) {
    final _$breadcrumb = breadcrumb.reference;
    _addBreadcrumb$1(_class.reference.pointer,
            _id_addBreadcrumb$1 as jni$_.JMethodIDPtr, _$breadcrumb.pointer)
        .check();
  }

  static final _id_addBreadcrumb$2 = _class.staticMethodId(
    r'addBreadcrumb',
    r'(Ljava/lang/String;)V',
  );

  static final _addBreadcrumb$2 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void addBreadcrumb(java.lang.String string)`
  static void addBreadcrumb$2(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _addBreadcrumb$2(_class.reference.pointer,
            _id_addBreadcrumb$2 as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_addBreadcrumb$3 = _class.staticMethodId(
    r'addBreadcrumb',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _addBreadcrumb$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void addBreadcrumb(java.lang.String string, java.lang.String string1)`
  static void addBreadcrumb$3(
    jni$_.JString string,
    jni$_.JString string1,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    _addBreadcrumb$3(
            _class.reference.pointer,
            _id_addBreadcrumb$3 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer)
        .check();
  }

  static final _id_setLevel = _class.staticMethodId(
    r'setLevel',
    r'(Lio/sentry/SentryLevel;)V',
  );

  static final _setLevel = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void setLevel(io.sentry.SentryLevel sentryLevel)`
  static void setLevel(
    SentryLevel? sentryLevel,
  ) {
    final _$sentryLevel = sentryLevel?.reference ?? jni$_.jNullReference;
    _setLevel(_class.reference.pointer, _id_setLevel as jni$_.JMethodIDPtr,
            _$sentryLevel.pointer)
        .check();
  }

  static final _id_setTransaction = _class.staticMethodId(
    r'setTransaction',
    r'(Ljava/lang/String;)V',
  );

  static final _setTransaction = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void setTransaction(java.lang.String string)`
  static void setTransaction(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setTransaction(_class.reference.pointer,
            _id_setTransaction as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_setUser = _class.staticMethodId(
    r'setUser',
    r'(Lio/sentry/protocol/User;)V',
  );

  static final _setUser = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void setUser(io.sentry.protocol.User user)`
  static void setUser(
    User? user,
  ) {
    final _$user = user?.reference ?? jni$_.jNullReference;
    _setUser(_class.reference.pointer, _id_setUser as jni$_.JMethodIDPtr,
            _$user.pointer)
        .check();
  }

  static final _id_setFingerprint = _class.staticMethodId(
    r'setFingerprint',
    r'(Ljava/util/List;)V',
  );

  static final _setFingerprint = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void setFingerprint(java.util.List<java.lang.String> list)`
  static void setFingerprint(
    jni$_.JList<jni$_.JString?> list,
  ) {
    final _$list = list.reference;
    _setFingerprint(_class.reference.pointer,
            _id_setFingerprint as jni$_.JMethodIDPtr, _$list.pointer)
        .check();
  }

  static final _id_clearBreadcrumbs = _class.staticMethodId(
    r'clearBreadcrumbs',
    r'()V',
  );

  static final _clearBreadcrumbs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public void clearBreadcrumbs()`
  static void clearBreadcrumbs() {
    _clearBreadcrumbs(_class.reference.pointer,
            _id_clearBreadcrumbs as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_setTag = _class.staticMethodId(
    r'setTag',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setTag = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void setTag(java.lang.String string, java.lang.String string1)`
  static void setTag(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setTag(_class.reference.pointer, _id_setTag as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  static final _id_removeTag = _class.staticMethodId(
    r'removeTag',
    r'(Ljava/lang/String;)V',
  );

  static final _removeTag = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void removeTag(java.lang.String string)`
  static void removeTag(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _removeTag(_class.reference.pointer, _id_removeTag as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_setExtra = _class.staticMethodId(
    r'setExtra',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setExtra = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void setExtra(java.lang.String string, java.lang.String string1)`
  static void setExtra(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setExtra(_class.reference.pointer, _id_setExtra as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  static final _id_removeExtra = _class.staticMethodId(
    r'removeExtra',
    r'(Ljava/lang/String;)V',
  );

  static final _removeExtra = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void removeExtra(java.lang.String string)`
  static void removeExtra(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _removeExtra(_class.reference.pointer,
            _id_removeExtra as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_getLastEventId = _class.staticMethodId(
    r'getLastEventId',
    r'()Lio/sentry/protocol/SentryId;',
  );

  static final _getLastEventId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.protocol.SentryId getLastEventId()`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryId getLastEventId() {
    return _getLastEventId(
            _class.reference.pointer, _id_getLastEventId as jni$_.JMethodIDPtr)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_pushScope = _class.staticMethodId(
    r'pushScope',
    r'()Lio/sentry/ISentryLifecycleToken;',
  );

  static final _pushScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.ISentryLifecycleToken pushScope()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject pushScope() {
    return _pushScope(
            _class.reference.pointer, _id_pushScope as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_pushIsolationScope = _class.staticMethodId(
    r'pushIsolationScope',
    r'()Lio/sentry/ISentryLifecycleToken;',
  );

  static final _pushIsolationScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.ISentryLifecycleToken pushIsolationScope()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject pushIsolationScope() {
    return _pushIsolationScope(_class.reference.pointer,
            _id_pushIsolationScope as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_popScope = _class.staticMethodId(
    r'popScope',
    r'()V',
  );

  static final _popScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public void popScope()`
  static void popScope() {
    _popScope(_class.reference.pointer, _id_popScope as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_withScope = _class.staticMethodId(
    r'withScope',
    r'(Lio/sentry/ScopeCallback;)V',
  );

  static final _withScope = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void withScope(io.sentry.ScopeCallback scopeCallback)`
  static void withScope(
    ScopeCallback scopeCallback,
  ) {
    final _$scopeCallback = scopeCallback.reference;
    _withScope(_class.reference.pointer, _id_withScope as jni$_.JMethodIDPtr,
            _$scopeCallback.pointer)
        .check();
  }

  static final _id_withIsolationScope = _class.staticMethodId(
    r'withIsolationScope',
    r'(Lio/sentry/ScopeCallback;)V',
  );

  static final _withIsolationScope = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void withIsolationScope(io.sentry.ScopeCallback scopeCallback)`
  static void withIsolationScope(
    ScopeCallback scopeCallback,
  ) {
    final _$scopeCallback = scopeCallback.reference;
    _withIsolationScope(
            _class.reference.pointer,
            _id_withIsolationScope as jni$_.JMethodIDPtr,
            _$scopeCallback.pointer)
        .check();
  }

  static final _id_configureScope = _class.staticMethodId(
    r'configureScope',
    r'(Lio/sentry/ScopeCallback;)V',
  );

  static final _configureScope = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void configureScope(io.sentry.ScopeCallback scopeCallback)`
  static void configureScope(
    ScopeCallback scopeCallback,
  ) {
    final _$scopeCallback = scopeCallback.reference;
    _configureScope(_class.reference.pointer,
            _id_configureScope as jni$_.JMethodIDPtr, _$scopeCallback.pointer)
        .check();
  }

  static final _id_configureScope$1 = _class.staticMethodId(
    r'configureScope',
    r'(Lio/sentry/ScopeType;Lio/sentry/ScopeCallback;)V',
  );

  static final _configureScope$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void configureScope(io.sentry.ScopeType scopeType, io.sentry.ScopeCallback scopeCallback)`
  static void configureScope$1(
    jni$_.JObject? scopeType,
    ScopeCallback scopeCallback,
  ) {
    final _$scopeType = scopeType?.reference ?? jni$_.jNullReference;
    final _$scopeCallback = scopeCallback.reference;
    _configureScope$1(
            _class.reference.pointer,
            _id_configureScope$1 as jni$_.JMethodIDPtr,
            _$scopeType.pointer,
            _$scopeCallback.pointer)
        .check();
  }

  static final _id_bindClient = _class.staticMethodId(
    r'bindClient',
    r'(Lio/sentry/ISentryClient;)V',
  );

  static final _bindClient = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void bindClient(io.sentry.ISentryClient iSentryClient)`
  static void bindClient(
    jni$_.JObject iSentryClient,
  ) {
    final _$iSentryClient = iSentryClient.reference;
    _bindClient(_class.reference.pointer, _id_bindClient as jni$_.JMethodIDPtr,
            _$iSentryClient.pointer)
        .check();
  }

  static final _id_isHealthy = _class.staticMethodId(
    r'isHealthy',
    r'()Z',
  );

  static final _isHealthy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public boolean isHealthy()`
  static bool isHealthy() {
    return _isHealthy(
            _class.reference.pointer, _id_isHealthy as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_flush = _class.staticMethodId(
    r'flush',
    r'(J)V',
  );

  static final _flush = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public void flush(long j)`
  static void flush(
    int j,
  ) {
    _flush(_class.reference.pointer, _id_flush as jni$_.JMethodIDPtr, j)
        .check();
  }

  static final _id_startSession = _class.staticMethodId(
    r'startSession',
    r'()V',
  );

  static final _startSession = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public void startSession()`
  static void startSession() {
    _startSession(
            _class.reference.pointer, _id_startSession as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_endSession = _class.staticMethodId(
    r'endSession',
    r'()V',
  );

  static final _endSession = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public void endSession()`
  static void endSession() {
    _endSession(_class.reference.pointer, _id_endSession as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_startTransaction = _class.staticMethodId(
    r'startTransaction',
    r'(Ljava/lang/String;Ljava/lang/String;)Lio/sentry/ITransaction;',
  );

  static final _startTransaction = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.ITransaction startTransaction(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject startTransaction(
    jni$_.JString string,
    jni$_.JString string1,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    return _startTransaction(
            _class.reference.pointer,
            _id_startTransaction as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_startTransaction$1 = _class.staticMethodId(
    r'startTransaction',
    r'(Ljava/lang/String;Ljava/lang/String;Lio/sentry/TransactionOptions;)Lio/sentry/ITransaction;',
  );

  static final _startTransaction$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.ITransaction startTransaction(java.lang.String string, java.lang.String string1, io.sentry.TransactionOptions transactionOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject startTransaction$1(
    jni$_.JString string,
    jni$_.JString string1,
    jni$_.JObject transactionOptions,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    final _$transactionOptions = transactionOptions.reference;
    return _startTransaction$1(
            _class.reference.pointer,
            _id_startTransaction$1 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$transactionOptions.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_startTransaction$2 = _class.staticMethodId(
    r'startTransaction',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lio/sentry/TransactionOptions;)Lio/sentry/ITransaction;',
  );

  static final _startTransaction$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.ITransaction startTransaction(java.lang.String string, java.lang.String string1, java.lang.String string2, io.sentry.TransactionOptions transactionOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject startTransaction$2(
    jni$_.JString string,
    jni$_.JString string1,
    jni$_.JString? string2,
    jni$_.JObject transactionOptions,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    final _$transactionOptions = transactionOptions.reference;
    return _startTransaction$2(
            _class.reference.pointer,
            _id_startTransaction$2 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$string2.pointer,
            _$transactionOptions.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_startTransaction$3 = _class.staticMethodId(
    r'startTransaction',
    r'(Lio/sentry/TransactionContext;)Lio/sentry/ITransaction;',
  );

  static final _startTransaction$3 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.ITransaction startTransaction(io.sentry.TransactionContext transactionContext)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject startTransaction$3(
    jni$_.JObject transactionContext,
  ) {
    final _$transactionContext = transactionContext.reference;
    return _startTransaction$3(
            _class.reference.pointer,
            _id_startTransaction$3 as jni$_.JMethodIDPtr,
            _$transactionContext.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_startTransaction$4 = _class.staticMethodId(
    r'startTransaction',
    r'(Lio/sentry/TransactionContext;Lio/sentry/TransactionOptions;)Lio/sentry/ITransaction;',
  );

  static final _startTransaction$4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.ITransaction startTransaction(io.sentry.TransactionContext transactionContext, io.sentry.TransactionOptions transactionOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject startTransaction$4(
    jni$_.JObject transactionContext,
    jni$_.JObject transactionOptions,
  ) {
    final _$transactionContext = transactionContext.reference;
    final _$transactionOptions = transactionOptions.reference;
    return _startTransaction$4(
            _class.reference.pointer,
            _id_startTransaction$4 as jni$_.JMethodIDPtr,
            _$transactionContext.pointer,
            _$transactionOptions.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_startProfiler = _class.staticMethodId(
    r'startProfiler',
    r'()V',
  );

  static final _startProfiler = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public void startProfiler()`
  static void startProfiler() {
    _startProfiler(
            _class.reference.pointer, _id_startProfiler as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_stopProfiler = _class.staticMethodId(
    r'stopProfiler',
    r'()V',
  );

  static final _stopProfiler = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public void stopProfiler()`
  static void stopProfiler() {
    _stopProfiler(
            _class.reference.pointer, _id_stopProfiler as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_getSpan = _class.staticMethodId(
    r'getSpan',
    r'()Lio/sentry/ISpan;',
  );

  static final _getSpan = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.ISpan getSpan()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? getSpan() {
    return _getSpan(_class.reference.pointer, _id_getSpan as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_isCrashedLastRun = _class.staticMethodId(
    r'isCrashedLastRun',
    r'()Ljava/lang/Boolean;',
  );

  static final _isCrashedLastRun = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.lang.Boolean isCrashedLastRun()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JBoolean? isCrashedLastRun() {
    return _isCrashedLastRun(_class.reference.pointer,
            _id_isCrashedLastRun as jni$_.JMethodIDPtr)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_reportFullyDisplayed = _class.staticMethodId(
    r'reportFullyDisplayed',
    r'()V',
  );

  static final _reportFullyDisplayed = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public void reportFullyDisplayed()`
  static void reportFullyDisplayed() {
    _reportFullyDisplayed(_class.reference.pointer,
            _id_reportFullyDisplayed as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_continueTrace = _class.staticMethodId(
    r'continueTrace',
    r'(Ljava/lang/String;Ljava/util/List;)Lio/sentry/TransactionContext;',
  );

  static final _continueTrace = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.TransactionContext continueTrace(java.lang.String string, java.util.List<java.lang.String> list)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? continueTrace(
    jni$_.JString? string,
    jni$_.JList<jni$_.JString?>? list,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _continueTrace(
            _class.reference.pointer,
            _id_continueTrace as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$list.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getTraceparent = _class.staticMethodId(
    r'getTraceparent',
    r'()Lio/sentry/SentryTraceHeader;',
  );

  static final _getTraceparent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.SentryTraceHeader getTraceparent()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? getTraceparent() {
    return _getTraceparent(
            _class.reference.pointer, _id_getTraceparent as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getBaggage = _class.staticMethodId(
    r'getBaggage',
    r'()Lio/sentry/BaggageHeader;',
  );

  static final _getBaggage = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.BaggageHeader getBaggage()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? getBaggage() {
    return _getBaggage(
            _class.reference.pointer, _id_getBaggage as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_captureCheckIn = _class.staticMethodId(
    r'captureCheckIn',
    r'(Lio/sentry/CheckIn;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureCheckIn = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureCheckIn(io.sentry.CheckIn checkIn)`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryId captureCheckIn(
    jni$_.JObject checkIn,
  ) {
    final _$checkIn = checkIn.reference;
    return _captureCheckIn(_class.reference.pointer,
            _id_captureCheckIn as jni$_.JMethodIDPtr, _$checkIn.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_logger = _class.staticMethodId(
    r'logger',
    r'()Lio/sentry/logger/ILoggerApi;',
  );

  static final _logger = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.logger.ILoggerApi logger()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject logger() {
    return _logger(_class.reference.pointer, _id_logger as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_replay = _class.staticMethodId(
    r'replay',
    r'()Lio/sentry/IReplayApi;',
  );

  static final _replay = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.IReplayApi replay()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject replay() {
    return _replay(_class.reference.pointer, _id_replay as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_distribution = _class.staticMethodId(
    r'distribution',
    r'()Lio/sentry/IDistributionApi;',
  );

  static final _distribution = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.IDistributionApi distribution()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject distribution() {
    return _distribution(
            _class.reference.pointer, _id_distribution as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_metrics = _class.staticMethodId(
    r'metrics',
    r'()Lio/sentry/metrics/IMetricsApi;',
  );

  static final _metrics = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.metrics.IMetricsApi metrics()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject metrics() {
    return _metrics(_class.reference.pointer, _id_metrics as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_showUserFeedbackDialog = _class.staticMethodId(
    r'showUserFeedbackDialog',
    r'()V',
  );

  static final _showUserFeedbackDialog = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public void showUserFeedbackDialog()`
  static void showUserFeedbackDialog() {
    _showUserFeedbackDialog(_class.reference.pointer,
            _id_showUserFeedbackDialog as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_showUserFeedbackDialog$1 = _class.staticMethodId(
    r'showUserFeedbackDialog',
    r'(Lio/sentry/SentryFeedbackOptions$OptionsConfigurator;)V',
  );

  static final _showUserFeedbackDialog$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void showUserFeedbackDialog(io.sentry.SentryFeedbackOptions$OptionsConfigurator optionsConfigurator)`
  static void showUserFeedbackDialog$1(
    jni$_.JObject? optionsConfigurator,
  ) {
    final _$optionsConfigurator =
        optionsConfigurator?.reference ?? jni$_.jNullReference;
    _showUserFeedbackDialog$1(
            _class.reference.pointer,
            _id_showUserFeedbackDialog$1 as jni$_.JMethodIDPtr,
            _$optionsConfigurator.pointer)
        .check();
  }

  static final _id_showUserFeedbackDialog$2 = _class.staticMethodId(
    r'showUserFeedbackDialog',
    r'(Lio/sentry/protocol/SentryId;Lio/sentry/SentryFeedbackOptions$OptionsConfigurator;)V',
  );

  static final _showUserFeedbackDialog$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void showUserFeedbackDialog(io.sentry.protocol.SentryId sentryId, io.sentry.SentryFeedbackOptions$OptionsConfigurator optionsConfigurator)`
  static void showUserFeedbackDialog$2(
    SentryId? sentryId,
    jni$_.JObject? optionsConfigurator,
  ) {
    final _$sentryId = sentryId?.reference ?? jni$_.jNullReference;
    final _$optionsConfigurator =
        optionsConfigurator?.reference ?? jni$_.jNullReference;
    _showUserFeedbackDialog$2(
            _class.reference.pointer,
            _id_showUserFeedbackDialog$2 as jni$_.JMethodIDPtr,
            _$sentryId.pointer,
            _$optionsConfigurator.pointer)
        .check();
  }

  static final _id_addFeatureFlag = _class.staticMethodId(
    r'addFeatureFlag',
    r'(Ljava/lang/String;Ljava/lang/Boolean;)V',
  );

  static final _addFeatureFlag = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void addFeatureFlag(java.lang.String string, java.lang.Boolean boolean)`
  static void addFeatureFlag(
    jni$_.JString? string,
    jni$_.JBoolean? boolean,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    _addFeatureFlag(
            _class.reference.pointer,
            _id_addFeatureFlag as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$boolean.pointer)
        .check();
  }
}

final class $Sentry$NullableType extends jni$_.JObjType<Sentry?> {
  @jni$_.internal
  const $Sentry$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Sentry;';

  @jni$_.internal
  @core$_.override
  Sentry? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Sentry.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Sentry?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Sentry$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Sentry$NullableType) &&
        other is $Sentry$NullableType;
  }
}

final class $Sentry$Type extends jni$_.JObjType<Sentry> {
  @jni$_.internal
  const $Sentry$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Sentry;';

  @jni$_.internal
  @core$_.override
  Sentry fromReference(jni$_.JReference reference) => Sentry.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Sentry?> get nullableType => const $Sentry$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Sentry$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Sentry$Type) && other is $Sentry$Type;
  }
}

/// from: `io.sentry.SentryOptions$BeforeBreadcrumbCallback`
class SentryOptions$BeforeBreadcrumbCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$BeforeBreadcrumbCallback> $type;

  @jni$_.internal
  SentryOptions$BeforeBreadcrumbCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryOptions$BeforeBreadcrumbCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $SentryOptions$BeforeBreadcrumbCallback$NullableType();
  static const type = $SentryOptions$BeforeBreadcrumbCallback$Type();
  static final _id_execute = _class.instanceMethodId(
    r'execute',
    r'(Lio/sentry/Breadcrumb;Lio/sentry/Hint;)Lio/sentry/Breadcrumb;',
  );

  static final _execute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract io.sentry.Breadcrumb execute(io.sentry.Breadcrumb breadcrumb, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  Breadcrumb? execute(
    Breadcrumb breadcrumb,
    Hint hint,
  ) {
    final _$breadcrumb = breadcrumb.reference;
    final _$hint = hint.reference;
    return _execute(reference.pointer, _id_execute as jni$_.JMethodIDPtr,
            _$breadcrumb.pointer, _$hint.pointer)
        .object<Breadcrumb?>(const $Breadcrumb$NullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SentryOptions$BeforeBreadcrumbCallback>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'execute(Lio/sentry/Breadcrumb;Lio/sentry/Hint;)Lio/sentry/Breadcrumb;') {
        final $r = _$impls[$p]!.execute(
          $a![0]!.as(const $Breadcrumb$Type(), releaseOriginal: true),
          $a![1]!.as(const $Hint$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $SentryOptions$BeforeBreadcrumbCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.SentryOptions$BeforeBreadcrumbCallback',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SentryOptions$BeforeBreadcrumbCallback.implement(
    $SentryOptions$BeforeBreadcrumbCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SentryOptions$BeforeBreadcrumbCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $SentryOptions$BeforeBreadcrumbCallback {
  factory $SentryOptions$BeforeBreadcrumbCallback({
    required Breadcrumb? Function(Breadcrumb breadcrumb, Hint hint) execute,
  }) = _$SentryOptions$BeforeBreadcrumbCallback;

  Breadcrumb? execute(Breadcrumb breadcrumb, Hint hint);
}

final class _$SentryOptions$BeforeBreadcrumbCallback
    with $SentryOptions$BeforeBreadcrumbCallback {
  _$SentryOptions$BeforeBreadcrumbCallback({
    required Breadcrumb? Function(Breadcrumb breadcrumb, Hint hint) execute,
  }) : _execute = execute;

  final Breadcrumb? Function(Breadcrumb breadcrumb, Hint hint) _execute;

  Breadcrumb? execute(Breadcrumb breadcrumb, Hint hint) {
    return _execute(breadcrumb, hint);
  }
}

final class $SentryOptions$BeforeBreadcrumbCallback$NullableType
    extends jni$_.JObjType<SentryOptions$BeforeBreadcrumbCallback?> {
  @jni$_.internal
  const $SentryOptions$BeforeBreadcrumbCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$BeforeBreadcrumbCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$BeforeBreadcrumbCallback? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$BeforeBreadcrumbCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$BeforeBreadcrumbCallback?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryOptions$BeforeBreadcrumbCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$BeforeBreadcrumbCallback$NullableType) &&
        other is $SentryOptions$BeforeBreadcrumbCallback$NullableType;
  }
}

final class $SentryOptions$BeforeBreadcrumbCallback$Type
    extends jni$_.JObjType<SentryOptions$BeforeBreadcrumbCallback> {
  @jni$_.internal
  const $SentryOptions$BeforeBreadcrumbCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$BeforeBreadcrumbCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$BeforeBreadcrumbCallback fromReference(
          jni$_.JReference reference) =>
      SentryOptions$BeforeBreadcrumbCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$BeforeBreadcrumbCallback?> get nullableType =>
      const $SentryOptions$BeforeBreadcrumbCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$BeforeBreadcrumbCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$BeforeBreadcrumbCallback$Type) &&
        other is $SentryOptions$BeforeBreadcrumbCallback$Type;
  }
}

/// from: `io.sentry.SentryOptions$BeforeEnvelopeCallback`
class SentryOptions$BeforeEnvelopeCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$BeforeEnvelopeCallback> $type;

  @jni$_.internal
  SentryOptions$BeforeEnvelopeCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryOptions$BeforeEnvelopeCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $SentryOptions$BeforeEnvelopeCallback$NullableType();
  static const type = $SentryOptions$BeforeEnvelopeCallback$Type();
  static final _id_execute = _class.instanceMethodId(
    r'execute',
    r'(Lio/sentry/SentryEnvelope;Lio/sentry/Hint;)V',
  );

  static final _execute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void execute(io.sentry.SentryEnvelope sentryEnvelope, io.sentry.Hint hint)`
  void execute(
    jni$_.JObject sentryEnvelope,
    Hint? hint,
  ) {
    final _$sentryEnvelope = sentryEnvelope.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    _execute(reference.pointer, _id_execute as jni$_.JMethodIDPtr,
            _$sentryEnvelope.pointer, _$hint.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SentryOptions$BeforeEnvelopeCallback> _$impls =
      {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'execute(Lio/sentry/SentryEnvelope;Lio/sentry/Hint;)V') {
        _$impls[$p]!.execute(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![1]?.as(const $Hint$Type(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $SentryOptions$BeforeEnvelopeCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.SentryOptions$BeforeEnvelopeCallback',
      $p,
      _$invokePointer,
      [
        if ($impl.execute$async)
          r'execute(Lio/sentry/SentryEnvelope;Lio/sentry/Hint;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SentryOptions$BeforeEnvelopeCallback.implement(
    $SentryOptions$BeforeEnvelopeCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SentryOptions$BeforeEnvelopeCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $SentryOptions$BeforeEnvelopeCallback {
  factory $SentryOptions$BeforeEnvelopeCallback({
    required void Function(jni$_.JObject sentryEnvelope, Hint? hint) execute,
    bool execute$async,
  }) = _$SentryOptions$BeforeEnvelopeCallback;

  void execute(jni$_.JObject sentryEnvelope, Hint? hint);
  bool get execute$async => false;
}

final class _$SentryOptions$BeforeEnvelopeCallback
    with $SentryOptions$BeforeEnvelopeCallback {
  _$SentryOptions$BeforeEnvelopeCallback({
    required void Function(jni$_.JObject sentryEnvelope, Hint? hint) execute,
    this.execute$async = false,
  }) : _execute = execute;

  final void Function(jni$_.JObject sentryEnvelope, Hint? hint) _execute;
  final bool execute$async;

  void execute(jni$_.JObject sentryEnvelope, Hint? hint) {
    return _execute(sentryEnvelope, hint);
  }
}

final class $SentryOptions$BeforeEnvelopeCallback$NullableType
    extends jni$_.JObjType<SentryOptions$BeforeEnvelopeCallback?> {
  @jni$_.internal
  const $SentryOptions$BeforeEnvelopeCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$BeforeEnvelopeCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$BeforeEnvelopeCallback? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$BeforeEnvelopeCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$BeforeEnvelopeCallback?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryOptions$BeforeEnvelopeCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$BeforeEnvelopeCallback$NullableType) &&
        other is $SentryOptions$BeforeEnvelopeCallback$NullableType;
  }
}

final class $SentryOptions$BeforeEnvelopeCallback$Type
    extends jni$_.JObjType<SentryOptions$BeforeEnvelopeCallback> {
  @jni$_.internal
  const $SentryOptions$BeforeEnvelopeCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$BeforeEnvelopeCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$BeforeEnvelopeCallback fromReference(
          jni$_.JReference reference) =>
      SentryOptions$BeforeEnvelopeCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$BeforeEnvelopeCallback?> get nullableType =>
      const $SentryOptions$BeforeEnvelopeCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$BeforeEnvelopeCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$BeforeEnvelopeCallback$Type) &&
        other is $SentryOptions$BeforeEnvelopeCallback$Type;
  }
}

/// from: `io.sentry.SentryOptions$BeforeSendCallback`
class SentryOptions$BeforeSendCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$BeforeSendCallback> $type;

  @jni$_.internal
  SentryOptions$BeforeSendCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryOptions$BeforeSendCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryOptions$BeforeSendCallback$NullableType();
  static const type = $SentryOptions$BeforeSendCallback$Type();
  static final _id_execute = _class.instanceMethodId(
    r'execute',
    r'(Lio/sentry/SentryEvent;Lio/sentry/Hint;)Lio/sentry/SentryEvent;',
  );

  static final _execute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract io.sentry.SentryEvent execute(io.sentry.SentryEvent sentryEvent, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryEvent? execute(
    SentryEvent sentryEvent,
    Hint hint,
  ) {
    final _$sentryEvent = sentryEvent.reference;
    final _$hint = hint.reference;
    return _execute(reference.pointer, _id_execute as jni$_.JMethodIDPtr,
            _$sentryEvent.pointer, _$hint.pointer)
        .object<SentryEvent?>(const $SentryEvent$NullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SentryOptions$BeforeSendCallback> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'execute(Lio/sentry/SentryEvent;Lio/sentry/Hint;)Lio/sentry/SentryEvent;') {
        final $r = _$impls[$p]!.execute(
          $a![0]!.as(const $SentryEvent$Type(), releaseOriginal: true),
          $a![1]!.as(const $Hint$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $SentryOptions$BeforeSendCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.SentryOptions$BeforeSendCallback',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SentryOptions$BeforeSendCallback.implement(
    $SentryOptions$BeforeSendCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SentryOptions$BeforeSendCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $SentryOptions$BeforeSendCallback {
  factory $SentryOptions$BeforeSendCallback({
    required SentryEvent? Function(SentryEvent sentryEvent, Hint hint) execute,
  }) = _$SentryOptions$BeforeSendCallback;

  SentryEvent? execute(SentryEvent sentryEvent, Hint hint);
}

final class _$SentryOptions$BeforeSendCallback
    with $SentryOptions$BeforeSendCallback {
  _$SentryOptions$BeforeSendCallback({
    required SentryEvent? Function(SentryEvent sentryEvent, Hint hint) execute,
  }) : _execute = execute;

  final SentryEvent? Function(SentryEvent sentryEvent, Hint hint) _execute;

  SentryEvent? execute(SentryEvent sentryEvent, Hint hint) {
    return _execute(sentryEvent, hint);
  }
}

final class $SentryOptions$BeforeSendCallback$NullableType
    extends jni$_.JObjType<SentryOptions$BeforeSendCallback?> {
  @jni$_.internal
  const $SentryOptions$BeforeSendCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$BeforeSendCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$BeforeSendCallback? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$BeforeSendCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$BeforeSendCallback?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$BeforeSendCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$BeforeSendCallback$NullableType) &&
        other is $SentryOptions$BeforeSendCallback$NullableType;
  }
}

final class $SentryOptions$BeforeSendCallback$Type
    extends jni$_.JObjType<SentryOptions$BeforeSendCallback> {
  @jni$_.internal
  const $SentryOptions$BeforeSendCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$BeforeSendCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$BeforeSendCallback fromReference(jni$_.JReference reference) =>
      SentryOptions$BeforeSendCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$BeforeSendCallback?> get nullableType =>
      const $SentryOptions$BeforeSendCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$BeforeSendCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$BeforeSendCallback$Type) &&
        other is $SentryOptions$BeforeSendCallback$Type;
  }
}

/// from: `io.sentry.SentryOptions$BeforeSendReplayCallback`
class SentryOptions$BeforeSendReplayCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$BeforeSendReplayCallback> $type;

  @jni$_.internal
  SentryOptions$BeforeSendReplayCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryOptions$BeforeSendReplayCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $SentryOptions$BeforeSendReplayCallback$NullableType();
  static const type = $SentryOptions$BeforeSendReplayCallback$Type();
  static final _id_execute = _class.instanceMethodId(
    r'execute',
    r'(Lio/sentry/SentryReplayEvent;Lio/sentry/Hint;)Lio/sentry/SentryReplayEvent;',
  );

  static final _execute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract io.sentry.SentryReplayEvent execute(io.sentry.SentryReplayEvent sentryReplayEvent, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryReplayEvent? execute(
    SentryReplayEvent sentryReplayEvent,
    Hint hint,
  ) {
    final _$sentryReplayEvent = sentryReplayEvent.reference;
    final _$hint = hint.reference;
    return _execute(reference.pointer, _id_execute as jni$_.JMethodIDPtr,
            _$sentryReplayEvent.pointer, _$hint.pointer)
        .object<SentryReplayEvent?>(const $SentryReplayEvent$NullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SentryOptions$BeforeSendReplayCallback>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'execute(Lio/sentry/SentryReplayEvent;Lio/sentry/Hint;)Lio/sentry/SentryReplayEvent;') {
        final $r = _$impls[$p]!.execute(
          $a![0]!.as(const $SentryReplayEvent$Type(), releaseOriginal: true),
          $a![1]!.as(const $Hint$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $SentryOptions$BeforeSendReplayCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.SentryOptions$BeforeSendReplayCallback',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SentryOptions$BeforeSendReplayCallback.implement(
    $SentryOptions$BeforeSendReplayCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SentryOptions$BeforeSendReplayCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $SentryOptions$BeforeSendReplayCallback {
  factory $SentryOptions$BeforeSendReplayCallback({
    required SentryReplayEvent? Function(
            SentryReplayEvent sentryReplayEvent, Hint hint)
        execute,
  }) = _$SentryOptions$BeforeSendReplayCallback;

  SentryReplayEvent? execute(SentryReplayEvent sentryReplayEvent, Hint hint);
}

final class _$SentryOptions$BeforeSendReplayCallback
    with $SentryOptions$BeforeSendReplayCallback {
  _$SentryOptions$BeforeSendReplayCallback({
    required SentryReplayEvent? Function(
            SentryReplayEvent sentryReplayEvent, Hint hint)
        execute,
  }) : _execute = execute;

  final SentryReplayEvent? Function(
      SentryReplayEvent sentryReplayEvent, Hint hint) _execute;

  SentryReplayEvent? execute(SentryReplayEvent sentryReplayEvent, Hint hint) {
    return _execute(sentryReplayEvent, hint);
  }
}

final class $SentryOptions$BeforeSendReplayCallback$NullableType
    extends jni$_.JObjType<SentryOptions$BeforeSendReplayCallback?> {
  @jni$_.internal
  const $SentryOptions$BeforeSendReplayCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$BeforeSendReplayCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$BeforeSendReplayCallback? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$BeforeSendReplayCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$BeforeSendReplayCallback?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryOptions$BeforeSendReplayCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$BeforeSendReplayCallback$NullableType) &&
        other is $SentryOptions$BeforeSendReplayCallback$NullableType;
  }
}

final class $SentryOptions$BeforeSendReplayCallback$Type
    extends jni$_.JObjType<SentryOptions$BeforeSendReplayCallback> {
  @jni$_.internal
  const $SentryOptions$BeforeSendReplayCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$BeforeSendReplayCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$BeforeSendReplayCallback fromReference(
          jni$_.JReference reference) =>
      SentryOptions$BeforeSendReplayCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$BeforeSendReplayCallback?> get nullableType =>
      const $SentryOptions$BeforeSendReplayCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$BeforeSendReplayCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$BeforeSendReplayCallback$Type) &&
        other is $SentryOptions$BeforeSendReplayCallback$Type;
  }
}

/// from: `io.sentry.SentryOptions$BeforeSendTransactionCallback`
class SentryOptions$BeforeSendTransactionCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$BeforeSendTransactionCallback> $type;

  @jni$_.internal
  SentryOptions$BeforeSendTransactionCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'io/sentry/SentryOptions$BeforeSendTransactionCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $SentryOptions$BeforeSendTransactionCallback$NullableType();
  static const type = $SentryOptions$BeforeSendTransactionCallback$Type();
  static final _id_execute = _class.instanceMethodId(
    r'execute',
    r'(Lio/sentry/protocol/SentryTransaction;Lio/sentry/Hint;)Lio/sentry/protocol/SentryTransaction;',
  );

  static final _execute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract io.sentry.protocol.SentryTransaction execute(io.sentry.protocol.SentryTransaction sentryTransaction, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? execute(
    jni$_.JObject sentryTransaction,
    Hint hint,
  ) {
    final _$sentryTransaction = sentryTransaction.reference;
    final _$hint = hint.reference;
    return _execute(reference.pointer, _id_execute as jni$_.JMethodIDPtr,
            _$sentryTransaction.pointer, _$hint.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SentryOptions$BeforeSendTransactionCallback>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'execute(Lio/sentry/protocol/SentryTransaction;Lio/sentry/Hint;)Lio/sentry/protocol/SentryTransaction;') {
        final $r = _$impls[$p]!.execute(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![1]!.as(const $Hint$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $SentryOptions$BeforeSendTransactionCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.SentryOptions$BeforeSendTransactionCallback',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SentryOptions$BeforeSendTransactionCallback.implement(
    $SentryOptions$BeforeSendTransactionCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SentryOptions$BeforeSendTransactionCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $SentryOptions$BeforeSendTransactionCallback {
  factory $SentryOptions$BeforeSendTransactionCallback({
    required jni$_.JObject? Function(jni$_.JObject sentryTransaction, Hint hint)
        execute,
  }) = _$SentryOptions$BeforeSendTransactionCallback;

  jni$_.JObject? execute(jni$_.JObject sentryTransaction, Hint hint);
}

final class _$SentryOptions$BeforeSendTransactionCallback
    with $SentryOptions$BeforeSendTransactionCallback {
  _$SentryOptions$BeforeSendTransactionCallback({
    required jni$_.JObject? Function(jni$_.JObject sentryTransaction, Hint hint)
        execute,
  }) : _execute = execute;

  final jni$_.JObject? Function(jni$_.JObject sentryTransaction, Hint hint)
      _execute;

  jni$_.JObject? execute(jni$_.JObject sentryTransaction, Hint hint) {
    return _execute(sentryTransaction, hint);
  }
}

final class $SentryOptions$BeforeSendTransactionCallback$NullableType
    extends jni$_.JObjType<SentryOptions$BeforeSendTransactionCallback?> {
  @jni$_.internal
  const $SentryOptions$BeforeSendTransactionCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/SentryOptions$BeforeSendTransactionCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$BeforeSendTransactionCallback? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$BeforeSendTransactionCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$BeforeSendTransactionCallback?>
      get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryOptions$BeforeSendTransactionCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$BeforeSendTransactionCallback$NullableType) &&
        other is $SentryOptions$BeforeSendTransactionCallback$NullableType;
  }
}

final class $SentryOptions$BeforeSendTransactionCallback$Type
    extends jni$_.JObjType<SentryOptions$BeforeSendTransactionCallback> {
  @jni$_.internal
  const $SentryOptions$BeforeSendTransactionCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/SentryOptions$BeforeSendTransactionCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$BeforeSendTransactionCallback fromReference(
          jni$_.JReference reference) =>
      SentryOptions$BeforeSendTransactionCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$BeforeSendTransactionCallback?>
      get nullableType =>
          const $SentryOptions$BeforeSendTransactionCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryOptions$BeforeSendTransactionCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$BeforeSendTransactionCallback$Type) &&
        other is $SentryOptions$BeforeSendTransactionCallback$Type;
  }
}

/// from: `io.sentry.SentryOptions$Cron`
class SentryOptions$Cron extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$Cron> $type;

  @jni$_.internal
  SentryOptions$Cron.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/SentryOptions$Cron');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryOptions$Cron$NullableType();
  static const type = $SentryOptions$Cron$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryOptions$Cron() {
    return SentryOptions$Cron.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_getDefaultCheckinMargin = _class.instanceMethodId(
    r'getDefaultCheckinMargin',
    r'()Ljava/lang/Long;',
  );

  static final _getDefaultCheckinMargin = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Long getDefaultCheckinMargin()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getDefaultCheckinMargin() {
    return _getDefaultCheckinMargin(reference.pointer,
            _id_getDefaultCheckinMargin as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_setDefaultCheckinMargin = _class.instanceMethodId(
    r'setDefaultCheckinMargin',
    r'(Ljava/lang/Long;)V',
  );

  static final _setDefaultCheckinMargin = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDefaultCheckinMargin(java.lang.Long long)`
  void setDefaultCheckinMargin(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    _setDefaultCheckinMargin(reference.pointer,
            _id_setDefaultCheckinMargin as jni$_.JMethodIDPtr, _$long.pointer)
        .check();
  }

  static final _id_getDefaultMaxRuntime = _class.instanceMethodId(
    r'getDefaultMaxRuntime',
    r'()Ljava/lang/Long;',
  );

  static final _getDefaultMaxRuntime = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Long getDefaultMaxRuntime()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getDefaultMaxRuntime() {
    return _getDefaultMaxRuntime(
            reference.pointer, _id_getDefaultMaxRuntime as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_setDefaultMaxRuntime = _class.instanceMethodId(
    r'setDefaultMaxRuntime',
    r'(Ljava/lang/Long;)V',
  );

  static final _setDefaultMaxRuntime = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDefaultMaxRuntime(java.lang.Long long)`
  void setDefaultMaxRuntime(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    _setDefaultMaxRuntime(reference.pointer,
            _id_setDefaultMaxRuntime as jni$_.JMethodIDPtr, _$long.pointer)
        .check();
  }

  static final _id_getDefaultTimezone = _class.instanceMethodId(
    r'getDefaultTimezone',
    r'()Ljava/lang/String;',
  );

  static final _getDefaultTimezone = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getDefaultTimezone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDefaultTimezone() {
    return _getDefaultTimezone(
            reference.pointer, _id_getDefaultTimezone as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setDefaultTimezone = _class.instanceMethodId(
    r'setDefaultTimezone',
    r'(Ljava/lang/String;)V',
  );

  static final _setDefaultTimezone = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDefaultTimezone(java.lang.String string)`
  void setDefaultTimezone(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setDefaultTimezone(reference.pointer,
            _id_setDefaultTimezone as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_getDefaultFailureIssueThreshold = _class.instanceMethodId(
    r'getDefaultFailureIssueThreshold',
    r'()Ljava/lang/Long;',
  );

  static final _getDefaultFailureIssueThreshold =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public java.lang.Long getDefaultFailureIssueThreshold()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getDefaultFailureIssueThreshold() {
    return _getDefaultFailureIssueThreshold(reference.pointer,
            _id_getDefaultFailureIssueThreshold as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_setDefaultFailureIssueThreshold = _class.instanceMethodId(
    r'setDefaultFailureIssueThreshold',
    r'(Ljava/lang/Long;)V',
  );

  static final _setDefaultFailureIssueThreshold =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDefaultFailureIssueThreshold(java.lang.Long long)`
  void setDefaultFailureIssueThreshold(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    _setDefaultFailureIssueThreshold(
            reference.pointer,
            _id_setDefaultFailureIssueThreshold as jni$_.JMethodIDPtr,
            _$long.pointer)
        .check();
  }

  static final _id_getDefaultRecoveryThreshold = _class.instanceMethodId(
    r'getDefaultRecoveryThreshold',
    r'()Ljava/lang/Long;',
  );

  static final _getDefaultRecoveryThreshold =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public java.lang.Long getDefaultRecoveryThreshold()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getDefaultRecoveryThreshold() {
    return _getDefaultRecoveryThreshold(reference.pointer,
            _id_getDefaultRecoveryThreshold as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_setDefaultRecoveryThreshold = _class.instanceMethodId(
    r'setDefaultRecoveryThreshold',
    r'(Ljava/lang/Long;)V',
  );

  static final _setDefaultRecoveryThreshold =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDefaultRecoveryThreshold(java.lang.Long long)`
  void setDefaultRecoveryThreshold(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    _setDefaultRecoveryThreshold(
            reference.pointer,
            _id_setDefaultRecoveryThreshold as jni$_.JMethodIDPtr,
            _$long.pointer)
        .check();
  }
}

final class $SentryOptions$Cron$NullableType
    extends jni$_.JObjType<SentryOptions$Cron?> {
  @jni$_.internal
  const $SentryOptions$Cron$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$Cron;';

  @jni$_.internal
  @core$_.override
  SentryOptions$Cron? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$Cron.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$Cron?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$Cron$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$Cron$NullableType) &&
        other is $SentryOptions$Cron$NullableType;
  }
}

final class $SentryOptions$Cron$Type
    extends jni$_.JObjType<SentryOptions$Cron> {
  @jni$_.internal
  const $SentryOptions$Cron$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$Cron;';

  @jni$_.internal
  @core$_.override
  SentryOptions$Cron fromReference(jni$_.JReference reference) =>
      SentryOptions$Cron.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$Cron?> get nullableType =>
      const $SentryOptions$Cron$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$Cron$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$Cron$Type) &&
        other is $SentryOptions$Cron$Type;
  }
}

/// from: `io.sentry.SentryOptions$DistributionOptions`
class SentryOptions$DistributionOptions extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$DistributionOptions> $type;

  @jni$_.internal
  SentryOptions$DistributionOptions.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryOptions$DistributionOptions');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryOptions$DistributionOptions$NullableType();
  static const type = $SentryOptions$DistributionOptions$Type();
  static final _id_orgAuthToken = _class.instanceFieldId(
    r'orgAuthToken',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String orgAuthToken`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? get orgAuthToken =>
      _id_orgAuthToken.get(this, const jni$_.JStringNullableType());

  /// from: `public java.lang.String orgAuthToken`
  /// The returned object must be released after use, by calling the [release] method.
  set orgAuthToken(jni$_.JString? value) =>
      _id_orgAuthToken.set(this, const jni$_.JStringNullableType(), value);

  static final _id_orgSlug = _class.instanceFieldId(
    r'orgSlug',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String orgSlug`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? get orgSlug =>
      _id_orgSlug.get(this, const jni$_.JStringNullableType());

  /// from: `public java.lang.String orgSlug`
  /// The returned object must be released after use, by calling the [release] method.
  set orgSlug(jni$_.JString? value) =>
      _id_orgSlug.set(this, const jni$_.JStringNullableType(), value);

  static final _id_projectSlug = _class.instanceFieldId(
    r'projectSlug',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String projectSlug`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? get projectSlug =>
      _id_projectSlug.get(this, const jni$_.JStringNullableType());

  /// from: `public java.lang.String projectSlug`
  /// The returned object must be released after use, by calling the [release] method.
  set projectSlug(jni$_.JString? value) =>
      _id_projectSlug.set(this, const jni$_.JStringNullableType(), value);

  static final _id_sentryBaseUrl = _class.instanceFieldId(
    r'sentryBaseUrl',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String sentryBaseUrl`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? get sentryBaseUrl =>
      _id_sentryBaseUrl.get(this, const jni$_.JStringNullableType());

  /// from: `public java.lang.String sentryBaseUrl`
  /// The returned object must be released after use, by calling the [release] method.
  set sentryBaseUrl(jni$_.JString? value) =>
      _id_sentryBaseUrl.set(this, const jni$_.JStringNullableType(), value);

  static final _id_buildConfiguration = _class.instanceFieldId(
    r'buildConfiguration',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String buildConfiguration`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? get buildConfiguration =>
      _id_buildConfiguration.get(this, const jni$_.JStringNullableType());

  /// from: `public java.lang.String buildConfiguration`
  /// The returned object must be released after use, by calling the [release] method.
  set buildConfiguration(jni$_.JString? value) => _id_buildConfiguration.set(
      this, const jni$_.JStringNullableType(), value);

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryOptions$DistributionOptions() {
    return SentryOptions$DistributionOptions.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $SentryOptions$DistributionOptions$NullableType
    extends jni$_.JObjType<SentryOptions$DistributionOptions?> {
  @jni$_.internal
  const $SentryOptions$DistributionOptions$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$DistributionOptions;';

  @jni$_.internal
  @core$_.override
  SentryOptions$DistributionOptions? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$DistributionOptions.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$DistributionOptions?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryOptions$DistributionOptions$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$DistributionOptions$NullableType) &&
        other is $SentryOptions$DistributionOptions$NullableType;
  }
}

final class $SentryOptions$DistributionOptions$Type
    extends jni$_.JObjType<SentryOptions$DistributionOptions> {
  @jni$_.internal
  const $SentryOptions$DistributionOptions$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$DistributionOptions;';

  @jni$_.internal
  @core$_.override
  SentryOptions$DistributionOptions fromReference(jni$_.JReference reference) =>
      SentryOptions$DistributionOptions.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$DistributionOptions?> get nullableType =>
      const $SentryOptions$DistributionOptions$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$DistributionOptions$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$DistributionOptions$Type) &&
        other is $SentryOptions$DistributionOptions$Type;
  }
}

/// from: `io.sentry.SentryOptions$Logs$BeforeSendLogCallback`
class SentryOptions$Logs$BeforeSendLogCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$Logs$BeforeSendLogCallback> $type;

  @jni$_.internal
  SentryOptions$Logs$BeforeSendLogCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'io/sentry/SentryOptions$Logs$BeforeSendLogCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $SentryOptions$Logs$BeforeSendLogCallback$NullableType();
  static const type = $SentryOptions$Logs$BeforeSendLogCallback$Type();
  static final _id_execute = _class.instanceMethodId(
    r'execute',
    r'(Lio/sentry/SentryLogEvent;)Lio/sentry/SentryLogEvent;',
  );

  static final _execute = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract io.sentry.SentryLogEvent execute(io.sentry.SentryLogEvent sentryLogEvent)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? execute(
    jni$_.JObject sentryLogEvent,
  ) {
    final _$sentryLogEvent = sentryLogEvent.reference;
    return _execute(reference.pointer, _id_execute as jni$_.JMethodIDPtr,
            _$sentryLogEvent.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SentryOptions$Logs$BeforeSendLogCallback>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'execute(Lio/sentry/SentryLogEvent;)Lio/sentry/SentryLogEvent;') {
        final $r = _$impls[$p]!.execute(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $SentryOptions$Logs$BeforeSendLogCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.SentryOptions$Logs$BeforeSendLogCallback',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SentryOptions$Logs$BeforeSendLogCallback.implement(
    $SentryOptions$Logs$BeforeSendLogCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SentryOptions$Logs$BeforeSendLogCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $SentryOptions$Logs$BeforeSendLogCallback {
  factory $SentryOptions$Logs$BeforeSendLogCallback({
    required jni$_.JObject? Function(jni$_.JObject sentryLogEvent) execute,
  }) = _$SentryOptions$Logs$BeforeSendLogCallback;

  jni$_.JObject? execute(jni$_.JObject sentryLogEvent);
}

final class _$SentryOptions$Logs$BeforeSendLogCallback
    with $SentryOptions$Logs$BeforeSendLogCallback {
  _$SentryOptions$Logs$BeforeSendLogCallback({
    required jni$_.JObject? Function(jni$_.JObject sentryLogEvent) execute,
  }) : _execute = execute;

  final jni$_.JObject? Function(jni$_.JObject sentryLogEvent) _execute;

  jni$_.JObject? execute(jni$_.JObject sentryLogEvent) {
    return _execute(sentryLogEvent);
  }
}

final class $SentryOptions$Logs$BeforeSendLogCallback$NullableType
    extends jni$_.JObjType<SentryOptions$Logs$BeforeSendLogCallback?> {
  @jni$_.internal
  const $SentryOptions$Logs$BeforeSendLogCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/SentryOptions$Logs$BeforeSendLogCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$Logs$BeforeSendLogCallback? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$Logs$BeforeSendLogCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$Logs$BeforeSendLogCallback?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryOptions$Logs$BeforeSendLogCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$Logs$BeforeSendLogCallback$NullableType) &&
        other is $SentryOptions$Logs$BeforeSendLogCallback$NullableType;
  }
}

final class $SentryOptions$Logs$BeforeSendLogCallback$Type
    extends jni$_.JObjType<SentryOptions$Logs$BeforeSendLogCallback> {
  @jni$_.internal
  const $SentryOptions$Logs$BeforeSendLogCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/SentryOptions$Logs$BeforeSendLogCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$Logs$BeforeSendLogCallback fromReference(
          jni$_.JReference reference) =>
      SentryOptions$Logs$BeforeSendLogCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$Logs$BeforeSendLogCallback?> get nullableType =>
      const $SentryOptions$Logs$BeforeSendLogCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$Logs$BeforeSendLogCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$Logs$BeforeSendLogCallback$Type) &&
        other is $SentryOptions$Logs$BeforeSendLogCallback$Type;
  }
}

/// from: `io.sentry.SentryOptions$Logs`
class SentryOptions$Logs extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$Logs> $type;

  @jni$_.internal
  SentryOptions$Logs.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/SentryOptions$Logs');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryOptions$Logs$NullableType();
  static const type = $SentryOptions$Logs$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryOptions$Logs() {
    return SentryOptions$Logs.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_isEnabled = _class.instanceMethodId(
    r'isEnabled',
    r'()Z',
  );

  static final _isEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEnabled()`
  bool isEnabled() {
    return _isEnabled(reference.pointer, _id_isEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnabled = _class.instanceMethodId(
    r'setEnabled',
    r'(Z)V',
  );

  static final _setEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnabled(boolean z)`
  void setEnabled(
    bool z,
  ) {
    _setEnabled(
            reference.pointer, _id_setEnabled as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getBeforeSend = _class.instanceMethodId(
    r'getBeforeSend',
    r'()Lio/sentry/SentryOptions$Logs$BeforeSendLogCallback;',
  );

  static final _getBeforeSend = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryOptions$Logs$BeforeSendLogCallback getBeforeSend()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryOptions$Logs$BeforeSendLogCallback? getBeforeSend() {
    return _getBeforeSend(
            reference.pointer, _id_getBeforeSend as jni$_.JMethodIDPtr)
        .object<SentryOptions$Logs$BeforeSendLogCallback?>(
            const $SentryOptions$Logs$BeforeSendLogCallback$NullableType());
  }

  static final _id_setBeforeSend = _class.instanceMethodId(
    r'setBeforeSend',
    r'(Lio/sentry/SentryOptions$Logs$BeforeSendLogCallback;)V',
  );

  static final _setBeforeSend = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setBeforeSend(io.sentry.SentryOptions$Logs$BeforeSendLogCallback beforeSendLogCallback)`
  void setBeforeSend(
    SentryOptions$Logs$BeforeSendLogCallback? beforeSendLogCallback,
  ) {
    final _$beforeSendLogCallback =
        beforeSendLogCallback?.reference ?? jni$_.jNullReference;
    _setBeforeSend(reference.pointer, _id_setBeforeSend as jni$_.JMethodIDPtr,
            _$beforeSendLogCallback.pointer)
        .check();
  }

  static final _id_getLoggerBatchProcessorFactory = _class.instanceMethodId(
    r'getLoggerBatchProcessorFactory',
    r'()Lio/sentry/logger/ILoggerBatchProcessorFactory;',
  );

  static final _getLoggerBatchProcessorFactory =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public io.sentry.logger.ILoggerBatchProcessorFactory getLoggerBatchProcessorFactory()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getLoggerBatchProcessorFactory() {
    return _getLoggerBatchProcessorFactory(reference.pointer,
            _id_getLoggerBatchProcessorFactory as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setLoggerBatchProcessorFactory = _class.instanceMethodId(
    r'setLoggerBatchProcessorFactory',
    r'(Lio/sentry/logger/ILoggerBatchProcessorFactory;)V',
  );

  static final _setLoggerBatchProcessorFactory =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setLoggerBatchProcessorFactory(io.sentry.logger.ILoggerBatchProcessorFactory iLoggerBatchProcessorFactory)`
  void setLoggerBatchProcessorFactory(
    jni$_.JObject iLoggerBatchProcessorFactory,
  ) {
    final _$iLoggerBatchProcessorFactory =
        iLoggerBatchProcessorFactory.reference;
    _setLoggerBatchProcessorFactory(
            reference.pointer,
            _id_setLoggerBatchProcessorFactory as jni$_.JMethodIDPtr,
            _$iLoggerBatchProcessorFactory.pointer)
        .check();
  }
}

final class $SentryOptions$Logs$NullableType
    extends jni$_.JObjType<SentryOptions$Logs?> {
  @jni$_.internal
  const $SentryOptions$Logs$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$Logs;';

  @jni$_.internal
  @core$_.override
  SentryOptions$Logs? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$Logs.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$Logs?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$Logs$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$Logs$NullableType) &&
        other is $SentryOptions$Logs$NullableType;
  }
}

final class $SentryOptions$Logs$Type
    extends jni$_.JObjType<SentryOptions$Logs> {
  @jni$_.internal
  const $SentryOptions$Logs$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$Logs;';

  @jni$_.internal
  @core$_.override
  SentryOptions$Logs fromReference(jni$_.JReference reference) =>
      SentryOptions$Logs.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$Logs?> get nullableType =>
      const $SentryOptions$Logs$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$Logs$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$Logs$Type) &&
        other is $SentryOptions$Logs$Type;
  }
}

/// from: `io.sentry.SentryOptions$Metrics$BeforeSendMetricCallback`
class SentryOptions$Metrics$BeforeSendMetricCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$Metrics$BeforeSendMetricCallback> $type;

  @jni$_.internal
  SentryOptions$Metrics$BeforeSendMetricCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'io/sentry/SentryOptions$Metrics$BeforeSendMetricCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $SentryOptions$Metrics$BeforeSendMetricCallback$NullableType();
  static const type = $SentryOptions$Metrics$BeforeSendMetricCallback$Type();
  static final _id_execute = _class.instanceMethodId(
    r'execute',
    r'(Lio/sentry/SentryMetricsEvent;Lio/sentry/Hint;)Lio/sentry/SentryMetricsEvent;',
  );

  static final _execute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract io.sentry.SentryMetricsEvent execute(io.sentry.SentryMetricsEvent sentryMetricsEvent, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? execute(
    jni$_.JObject sentryMetricsEvent,
    Hint hint,
  ) {
    final _$sentryMetricsEvent = sentryMetricsEvent.reference;
    final _$hint = hint.reference;
    return _execute(reference.pointer, _id_execute as jni$_.JMethodIDPtr,
            _$sentryMetricsEvent.pointer, _$hint.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SentryOptions$Metrics$BeforeSendMetricCallback>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'execute(Lio/sentry/SentryMetricsEvent;Lio/sentry/Hint;)Lio/sentry/SentryMetricsEvent;') {
        final $r = _$impls[$p]!.execute(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![1]!.as(const $Hint$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $SentryOptions$Metrics$BeforeSendMetricCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.SentryOptions$Metrics$BeforeSendMetricCallback',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SentryOptions$Metrics$BeforeSendMetricCallback.implement(
    $SentryOptions$Metrics$BeforeSendMetricCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SentryOptions$Metrics$BeforeSendMetricCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $SentryOptions$Metrics$BeforeSendMetricCallback {
  factory $SentryOptions$Metrics$BeforeSendMetricCallback({
    required jni$_.JObject? Function(
            jni$_.JObject sentryMetricsEvent, Hint hint)
        execute,
  }) = _$SentryOptions$Metrics$BeforeSendMetricCallback;

  jni$_.JObject? execute(jni$_.JObject sentryMetricsEvent, Hint hint);
}

final class _$SentryOptions$Metrics$BeforeSendMetricCallback
    with $SentryOptions$Metrics$BeforeSendMetricCallback {
  _$SentryOptions$Metrics$BeforeSendMetricCallback({
    required jni$_.JObject? Function(
            jni$_.JObject sentryMetricsEvent, Hint hint)
        execute,
  }) : _execute = execute;

  final jni$_.JObject? Function(jni$_.JObject sentryMetricsEvent, Hint hint)
      _execute;

  jni$_.JObject? execute(jni$_.JObject sentryMetricsEvent, Hint hint) {
    return _execute(sentryMetricsEvent, hint);
  }
}

final class $SentryOptions$Metrics$BeforeSendMetricCallback$NullableType
    extends jni$_.JObjType<SentryOptions$Metrics$BeforeSendMetricCallback?> {
  @jni$_.internal
  const $SentryOptions$Metrics$BeforeSendMetricCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/SentryOptions$Metrics$BeforeSendMetricCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$Metrics$BeforeSendMetricCallback? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$Metrics$BeforeSendMetricCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$Metrics$BeforeSendMetricCallback?>
      get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryOptions$Metrics$BeforeSendMetricCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$Metrics$BeforeSendMetricCallback$NullableType) &&
        other is $SentryOptions$Metrics$BeforeSendMetricCallback$NullableType;
  }
}

final class $SentryOptions$Metrics$BeforeSendMetricCallback$Type
    extends jni$_.JObjType<SentryOptions$Metrics$BeforeSendMetricCallback> {
  @jni$_.internal
  const $SentryOptions$Metrics$BeforeSendMetricCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/SentryOptions$Metrics$BeforeSendMetricCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$Metrics$BeforeSendMetricCallback fromReference(
          jni$_.JReference reference) =>
      SentryOptions$Metrics$BeforeSendMetricCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$Metrics$BeforeSendMetricCallback?>
      get nullableType =>
          const $SentryOptions$Metrics$BeforeSendMetricCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryOptions$Metrics$BeforeSendMetricCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$Metrics$BeforeSendMetricCallback$Type) &&
        other is $SentryOptions$Metrics$BeforeSendMetricCallback$Type;
  }
}

/// from: `io.sentry.SentryOptions$Metrics`
class SentryOptions$Metrics extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$Metrics> $type;

  @jni$_.internal
  SentryOptions$Metrics.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryOptions$Metrics');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryOptions$Metrics$NullableType();
  static const type = $SentryOptions$Metrics$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryOptions$Metrics() {
    return SentryOptions$Metrics.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_isEnabled = _class.instanceMethodId(
    r'isEnabled',
    r'()Z',
  );

  static final _isEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEnabled()`
  bool isEnabled() {
    return _isEnabled(reference.pointer, _id_isEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnabled = _class.instanceMethodId(
    r'setEnabled',
    r'(Z)V',
  );

  static final _setEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnabled(boolean z)`
  void setEnabled(
    bool z,
  ) {
    _setEnabled(
            reference.pointer, _id_setEnabled as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getBeforeSend = _class.instanceMethodId(
    r'getBeforeSend',
    r'()Lio/sentry/SentryOptions$Metrics$BeforeSendMetricCallback;',
  );

  static final _getBeforeSend = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryOptions$Metrics$BeforeSendMetricCallback getBeforeSend()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryOptions$Metrics$BeforeSendMetricCallback? getBeforeSend() {
    return _getBeforeSend(
            reference.pointer, _id_getBeforeSend as jni$_.JMethodIDPtr)
        .object<SentryOptions$Metrics$BeforeSendMetricCallback?>(
            const $SentryOptions$Metrics$BeforeSendMetricCallback$NullableType());
  }

  static final _id_setBeforeSend = _class.instanceMethodId(
    r'setBeforeSend',
    r'(Lio/sentry/SentryOptions$Metrics$BeforeSendMetricCallback;)V',
  );

  static final _setBeforeSend = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setBeforeSend(io.sentry.SentryOptions$Metrics$BeforeSendMetricCallback beforeSendMetricCallback)`
  void setBeforeSend(
    SentryOptions$Metrics$BeforeSendMetricCallback? beforeSendMetricCallback,
  ) {
    final _$beforeSendMetricCallback =
        beforeSendMetricCallback?.reference ?? jni$_.jNullReference;
    _setBeforeSend(reference.pointer, _id_setBeforeSend as jni$_.JMethodIDPtr,
            _$beforeSendMetricCallback.pointer)
        .check();
  }

  static final _id_getMetricsBatchProcessorFactory = _class.instanceMethodId(
    r'getMetricsBatchProcessorFactory',
    r'()Lio/sentry/metrics/IMetricsBatchProcessorFactory;',
  );

  static final _getMetricsBatchProcessorFactory =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public io.sentry.metrics.IMetricsBatchProcessorFactory getMetricsBatchProcessorFactory()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getMetricsBatchProcessorFactory() {
    return _getMetricsBatchProcessorFactory(reference.pointer,
            _id_getMetricsBatchProcessorFactory as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setMetricsBatchProcessorFactory = _class.instanceMethodId(
    r'setMetricsBatchProcessorFactory',
    r'(Lio/sentry/metrics/IMetricsBatchProcessorFactory;)V',
  );

  static final _setMetricsBatchProcessorFactory =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setMetricsBatchProcessorFactory(io.sentry.metrics.IMetricsBatchProcessorFactory iMetricsBatchProcessorFactory)`
  void setMetricsBatchProcessorFactory(
    jni$_.JObject iMetricsBatchProcessorFactory,
  ) {
    final _$iMetricsBatchProcessorFactory =
        iMetricsBatchProcessorFactory.reference;
    _setMetricsBatchProcessorFactory(
            reference.pointer,
            _id_setMetricsBatchProcessorFactory as jni$_.JMethodIDPtr,
            _$iMetricsBatchProcessorFactory.pointer)
        .check();
  }
}

final class $SentryOptions$Metrics$NullableType
    extends jni$_.JObjType<SentryOptions$Metrics?> {
  @jni$_.internal
  const $SentryOptions$Metrics$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$Metrics;';

  @jni$_.internal
  @core$_.override
  SentryOptions$Metrics? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$Metrics.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$Metrics?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$Metrics$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$Metrics$NullableType) &&
        other is $SentryOptions$Metrics$NullableType;
  }
}

final class $SentryOptions$Metrics$Type
    extends jni$_.JObjType<SentryOptions$Metrics> {
  @jni$_.internal
  const $SentryOptions$Metrics$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$Metrics;';

  @jni$_.internal
  @core$_.override
  SentryOptions$Metrics fromReference(jni$_.JReference reference) =>
      SentryOptions$Metrics.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$Metrics?> get nullableType =>
      const $SentryOptions$Metrics$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$Metrics$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$Metrics$Type) &&
        other is $SentryOptions$Metrics$Type;
  }
}

/// from: `io.sentry.SentryOptions$OnDiscardCallback`
class SentryOptions$OnDiscardCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$OnDiscardCallback> $type;

  @jni$_.internal
  SentryOptions$OnDiscardCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryOptions$OnDiscardCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryOptions$OnDiscardCallback$NullableType();
  static const type = $SentryOptions$OnDiscardCallback$Type();
  static final _id_execute = _class.instanceMethodId(
    r'execute',
    r'(Lio/sentry/clientreport/DiscardReason;Lio/sentry/DataCategory;Ljava/lang/Long;)V',
  );

  static final _execute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void execute(io.sentry.clientreport.DiscardReason discardReason, io.sentry.DataCategory dataCategory, java.lang.Long long)`
  void execute(
    jni$_.JObject discardReason,
    jni$_.JObject dataCategory,
    jni$_.JLong long,
  ) {
    final _$discardReason = discardReason.reference;
    final _$dataCategory = dataCategory.reference;
    final _$long = long.reference;
    _execute(reference.pointer, _id_execute as jni$_.JMethodIDPtr,
            _$discardReason.pointer, _$dataCategory.pointer, _$long.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SentryOptions$OnDiscardCallback> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'execute(Lio/sentry/clientreport/DiscardReason;Lio/sentry/DataCategory;Ljava/lang/Long;)V') {
        _$impls[$p]!.execute(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![1]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![2]!.as(const jni$_.JLongType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $SentryOptions$OnDiscardCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.SentryOptions$OnDiscardCallback',
      $p,
      _$invokePointer,
      [
        if ($impl.execute$async)
          r'execute(Lio/sentry/clientreport/DiscardReason;Lio/sentry/DataCategory;Ljava/lang/Long;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SentryOptions$OnDiscardCallback.implement(
    $SentryOptions$OnDiscardCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SentryOptions$OnDiscardCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $SentryOptions$OnDiscardCallback {
  factory $SentryOptions$OnDiscardCallback({
    required void Function(jni$_.JObject discardReason,
            jni$_.JObject dataCategory, jni$_.JLong long)
        execute,
    bool execute$async,
  }) = _$SentryOptions$OnDiscardCallback;

  void execute(jni$_.JObject discardReason, jni$_.JObject dataCategory,
      jni$_.JLong long);
  bool get execute$async => false;
}

final class _$SentryOptions$OnDiscardCallback
    with $SentryOptions$OnDiscardCallback {
  _$SentryOptions$OnDiscardCallback({
    required void Function(jni$_.JObject discardReason,
            jni$_.JObject dataCategory, jni$_.JLong long)
        execute,
    this.execute$async = false,
  }) : _execute = execute;

  final void Function(jni$_.JObject discardReason, jni$_.JObject dataCategory,
      jni$_.JLong long) _execute;
  final bool execute$async;

  void execute(jni$_.JObject discardReason, jni$_.JObject dataCategory,
      jni$_.JLong long) {
    return _execute(discardReason, dataCategory, long);
  }
}

final class $SentryOptions$OnDiscardCallback$NullableType
    extends jni$_.JObjType<SentryOptions$OnDiscardCallback?> {
  @jni$_.internal
  const $SentryOptions$OnDiscardCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$OnDiscardCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$OnDiscardCallback? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$OnDiscardCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$OnDiscardCallback?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$OnDiscardCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$OnDiscardCallback$NullableType) &&
        other is $SentryOptions$OnDiscardCallback$NullableType;
  }
}

final class $SentryOptions$OnDiscardCallback$Type
    extends jni$_.JObjType<SentryOptions$OnDiscardCallback> {
  @jni$_.internal
  const $SentryOptions$OnDiscardCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$OnDiscardCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$OnDiscardCallback fromReference(jni$_.JReference reference) =>
      SentryOptions$OnDiscardCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$OnDiscardCallback?> get nullableType =>
      const $SentryOptions$OnDiscardCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$OnDiscardCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$OnDiscardCallback$Type) &&
        other is $SentryOptions$OnDiscardCallback$Type;
  }
}

/// from: `io.sentry.SentryOptions$OnOversizedEventCallback`
class SentryOptions$OnOversizedEventCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$OnOversizedEventCallback> $type;

  @jni$_.internal
  SentryOptions$OnOversizedEventCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryOptions$OnOversizedEventCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $SentryOptions$OnOversizedEventCallback$NullableType();
  static const type = $SentryOptions$OnOversizedEventCallback$Type();
  static final _id_execute = _class.instanceMethodId(
    r'execute',
    r'(Lio/sentry/SentryEvent;Lio/sentry/Hint;)Lio/sentry/SentryEvent;',
  );

  static final _execute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract io.sentry.SentryEvent execute(io.sentry.SentryEvent sentryEvent, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryEvent execute(
    SentryEvent sentryEvent,
    Hint hint,
  ) {
    final _$sentryEvent = sentryEvent.reference;
    final _$hint = hint.reference;
    return _execute(reference.pointer, _id_execute as jni$_.JMethodIDPtr,
            _$sentryEvent.pointer, _$hint.pointer)
        .object<SentryEvent>(const $SentryEvent$Type());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SentryOptions$OnOversizedEventCallback>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'execute(Lio/sentry/SentryEvent;Lio/sentry/Hint;)Lio/sentry/SentryEvent;') {
        final $r = _$impls[$p]!.execute(
          $a![0]!.as(const $SentryEvent$Type(), releaseOriginal: true),
          $a![1]!.as(const $Hint$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $SentryOptions$OnOversizedEventCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.SentryOptions$OnOversizedEventCallback',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SentryOptions$OnOversizedEventCallback.implement(
    $SentryOptions$OnOversizedEventCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SentryOptions$OnOversizedEventCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $SentryOptions$OnOversizedEventCallback {
  factory $SentryOptions$OnOversizedEventCallback({
    required SentryEvent Function(SentryEvent sentryEvent, Hint hint) execute,
  }) = _$SentryOptions$OnOversizedEventCallback;

  SentryEvent execute(SentryEvent sentryEvent, Hint hint);
}

final class _$SentryOptions$OnOversizedEventCallback
    with $SentryOptions$OnOversizedEventCallback {
  _$SentryOptions$OnOversizedEventCallback({
    required SentryEvent Function(SentryEvent sentryEvent, Hint hint) execute,
  }) : _execute = execute;

  final SentryEvent Function(SentryEvent sentryEvent, Hint hint) _execute;

  SentryEvent execute(SentryEvent sentryEvent, Hint hint) {
    return _execute(sentryEvent, hint);
  }
}

final class $SentryOptions$OnOversizedEventCallback$NullableType
    extends jni$_.JObjType<SentryOptions$OnOversizedEventCallback?> {
  @jni$_.internal
  const $SentryOptions$OnOversizedEventCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$OnOversizedEventCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$OnOversizedEventCallback? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$OnOversizedEventCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$OnOversizedEventCallback?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryOptions$OnOversizedEventCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$OnOversizedEventCallback$NullableType) &&
        other is $SentryOptions$OnOversizedEventCallback$NullableType;
  }
}

final class $SentryOptions$OnOversizedEventCallback$Type
    extends jni$_.JObjType<SentryOptions$OnOversizedEventCallback> {
  @jni$_.internal
  const $SentryOptions$OnOversizedEventCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$OnOversizedEventCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$OnOversizedEventCallback fromReference(
          jni$_.JReference reference) =>
      SentryOptions$OnOversizedEventCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$OnOversizedEventCallback?> get nullableType =>
      const $SentryOptions$OnOversizedEventCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$OnOversizedEventCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$OnOversizedEventCallback$Type) &&
        other is $SentryOptions$OnOversizedEventCallback$Type;
  }
}

/// from: `io.sentry.SentryOptions$ProfilesSamplerCallback`
class SentryOptions$ProfilesSamplerCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$ProfilesSamplerCallback> $type;

  @jni$_.internal
  SentryOptions$ProfilesSamplerCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryOptions$ProfilesSamplerCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $SentryOptions$ProfilesSamplerCallback$NullableType();
  static const type = $SentryOptions$ProfilesSamplerCallback$Type();
  static final _id_sample = _class.instanceMethodId(
    r'sample',
    r'(Lio/sentry/SamplingContext;)Ljava/lang/Double;',
  );

  static final _sample = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Double sample(io.sentry.SamplingContext samplingContext)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? sample(
    jni$_.JObject samplingContext,
  ) {
    final _$samplingContext = samplingContext.reference;
    return _sample(reference.pointer, _id_sample as jni$_.JMethodIDPtr,
            _$samplingContext.pointer)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SentryOptions$ProfilesSamplerCallback> _$impls =
      {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'sample(Lio/sentry/SamplingContext;)Ljava/lang/Double;') {
        final $r = _$impls[$p]!.sample(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $SentryOptions$ProfilesSamplerCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.SentryOptions$ProfilesSamplerCallback',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SentryOptions$ProfilesSamplerCallback.implement(
    $SentryOptions$ProfilesSamplerCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SentryOptions$ProfilesSamplerCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $SentryOptions$ProfilesSamplerCallback {
  factory $SentryOptions$ProfilesSamplerCallback({
    required jni$_.JDouble? Function(jni$_.JObject samplingContext) sample,
  }) = _$SentryOptions$ProfilesSamplerCallback;

  jni$_.JDouble? sample(jni$_.JObject samplingContext);
}

final class _$SentryOptions$ProfilesSamplerCallback
    with $SentryOptions$ProfilesSamplerCallback {
  _$SentryOptions$ProfilesSamplerCallback({
    required jni$_.JDouble? Function(jni$_.JObject samplingContext) sample,
  }) : _sample = sample;

  final jni$_.JDouble? Function(jni$_.JObject samplingContext) _sample;

  jni$_.JDouble? sample(jni$_.JObject samplingContext) {
    return _sample(samplingContext);
  }
}

final class $SentryOptions$ProfilesSamplerCallback$NullableType
    extends jni$_.JObjType<SentryOptions$ProfilesSamplerCallback?> {
  @jni$_.internal
  const $SentryOptions$ProfilesSamplerCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$ProfilesSamplerCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$ProfilesSamplerCallback? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$ProfilesSamplerCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$ProfilesSamplerCallback?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryOptions$ProfilesSamplerCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$ProfilesSamplerCallback$NullableType) &&
        other is $SentryOptions$ProfilesSamplerCallback$NullableType;
  }
}

final class $SentryOptions$ProfilesSamplerCallback$Type
    extends jni$_.JObjType<SentryOptions$ProfilesSamplerCallback> {
  @jni$_.internal
  const $SentryOptions$ProfilesSamplerCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$ProfilesSamplerCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$ProfilesSamplerCallback fromReference(
          jni$_.JReference reference) =>
      SentryOptions$ProfilesSamplerCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$ProfilesSamplerCallback?> get nullableType =>
      const $SentryOptions$ProfilesSamplerCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$ProfilesSamplerCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$ProfilesSamplerCallback$Type) &&
        other is $SentryOptions$ProfilesSamplerCallback$Type;
  }
}

/// from: `io.sentry.SentryOptions$Proxy`
class SentryOptions$Proxy extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$Proxy> $type;

  @jni$_.internal
  SentryOptions$Proxy.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/SentryOptions$Proxy');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryOptions$Proxy$NullableType();
  static const type = $SentryOptions$Proxy$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryOptions$Proxy() {
    return SentryOptions$Proxy.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryOptions$Proxy.new$1(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return SentryOptions$Proxy.fromReference(_new$1(
            _class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer)
        .reference);
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/net/Proxy$Type;)V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1, java.net.Proxy$Type type)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryOptions$Proxy.new$2(
    jni$_.JString? string,
    jni$_.JString? string1,
    Proxy$Type? type,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$type = type?.reference ?? jni$_.jNullReference;
    return SentryOptions$Proxy.fromReference(_new$2(
            _class.reference.pointer,
            _id_new$2 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$type.pointer)
        .reference);
  }

  static final _id_new$3 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryOptions$Proxy.new$3(
    jni$_.JString? string,
    jni$_.JString? string1,
    jni$_.JString? string2,
    jni$_.JString? string3,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    final _$string3 = string3?.reference ?? jni$_.jNullReference;
    return SentryOptions$Proxy.fromReference(_new$3(
            _class.reference.pointer,
            _id_new$3 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$string2.pointer,
            _$string3.pointer)
        .reference);
  }

  static final _id_new$4 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/net/Proxy$Type;Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1, java.net.Proxy$Type type, java.lang.String string2, java.lang.String string3)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryOptions$Proxy.new$4(
    jni$_.JString? string,
    jni$_.JString? string1,
    Proxy$Type? type,
    jni$_.JString? string2,
    jni$_.JString? string3,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$type = type?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    final _$string3 = string3?.reference ?? jni$_.jNullReference;
    return SentryOptions$Proxy.fromReference(_new$4(
            _class.reference.pointer,
            _id_new$4 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$type.pointer,
            _$string2.pointer,
            _$string3.pointer)
        .reference);
  }

  static final _id_getHost = _class.instanceMethodId(
    r'getHost',
    r'()Ljava/lang/String;',
  );

  static final _getHost = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getHost()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getHost() {
    return _getHost(reference.pointer, _id_getHost as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setHost = _class.instanceMethodId(
    r'setHost',
    r'(Ljava/lang/String;)V',
  );

  static final _setHost = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setHost(java.lang.String string)`
  void setHost(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setHost(reference.pointer, _id_setHost as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getPort = _class.instanceMethodId(
    r'getPort',
    r'()Ljava/lang/String;',
  );

  static final _getPort = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getPort()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getPort() {
    return _getPort(reference.pointer, _id_getPort as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setPort = _class.instanceMethodId(
    r'setPort',
    r'(Ljava/lang/String;)V',
  );

  static final _setPort = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setPort(java.lang.String string)`
  void setPort(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setPort(reference.pointer, _id_setPort as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getUser = _class.instanceMethodId(
    r'getUser',
    r'()Ljava/lang/String;',
  );

  static final _getUser = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getUser()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getUser() {
    return _getUser(reference.pointer, _id_getUser as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setUser = _class.instanceMethodId(
    r'setUser',
    r'(Ljava/lang/String;)V',
  );

  static final _setUser = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setUser(java.lang.String string)`
  void setUser(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setUser(reference.pointer, _id_setUser as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getPass = _class.instanceMethodId(
    r'getPass',
    r'()Ljava/lang/String;',
  );

  static final _getPass = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getPass()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getPass() {
    return _getPass(reference.pointer, _id_getPass as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setPass = _class.instanceMethodId(
    r'setPass',
    r'(Ljava/lang/String;)V',
  );

  static final _setPass = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setPass(java.lang.String string)`
  void setPass(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setPass(reference.pointer, _id_setPass as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getType = _class.instanceMethodId(
    r'getType',
    r'()Ljava/net/Proxy$Type;',
  );

  static final _getType = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.net.Proxy$Type getType()`
  /// The returned object must be released after use, by calling the [release] method.
  Proxy$Type? getType() {
    return _getType(reference.pointer, _id_getType as jni$_.JMethodIDPtr)
        .object<Proxy$Type?>(const $Proxy$Type$NullableType());
  }

  static final _id_setType = _class.instanceMethodId(
    r'setType',
    r'(Ljava/net/Proxy$Type;)V',
  );

  static final _setType = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setType(java.net.Proxy$Type type)`
  void setType(
    Proxy$Type? type,
  ) {
    final _$type = type?.reference ?? jni$_.jNullReference;
    _setType(reference.pointer, _id_setType as jni$_.JMethodIDPtr,
            _$type.pointer)
        .check();
  }
}

final class $SentryOptions$Proxy$NullableType
    extends jni$_.JObjType<SentryOptions$Proxy?> {
  @jni$_.internal
  const $SentryOptions$Proxy$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$Proxy;';

  @jni$_.internal
  @core$_.override
  SentryOptions$Proxy? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$Proxy.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$Proxy?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$Proxy$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$Proxy$NullableType) &&
        other is $SentryOptions$Proxy$NullableType;
  }
}

final class $SentryOptions$Proxy$Type
    extends jni$_.JObjType<SentryOptions$Proxy> {
  @jni$_.internal
  const $SentryOptions$Proxy$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$Proxy;';

  @jni$_.internal
  @core$_.override
  SentryOptions$Proxy fromReference(jni$_.JReference reference) =>
      SentryOptions$Proxy.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$Proxy?> get nullableType =>
      const $SentryOptions$Proxy$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$Proxy$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$Proxy$Type) &&
        other is $SentryOptions$Proxy$Type;
  }
}

/// from: `io.sentry.SentryOptions$RequestSize`
class SentryOptions$RequestSize extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$RequestSize> $type;

  @jni$_.internal
  SentryOptions$RequestSize.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryOptions$RequestSize');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryOptions$RequestSize$NullableType();
  static const type = $SentryOptions$RequestSize$Type();
  static final _id_NONE = _class.staticFieldId(
    r'NONE',
    r'Lio/sentry/SentryOptions$RequestSize;',
  );

  /// from: `static public final io.sentry.SentryOptions$RequestSize NONE`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryOptions$RequestSize get NONE =>
      _id_NONE.get(_class, const $SentryOptions$RequestSize$Type());

  static final _id_SMALL = _class.staticFieldId(
    r'SMALL',
    r'Lio/sentry/SentryOptions$RequestSize;',
  );

  /// from: `static public final io.sentry.SentryOptions$RequestSize SMALL`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryOptions$RequestSize get SMALL =>
      _id_SMALL.get(_class, const $SentryOptions$RequestSize$Type());

  static final _id_MEDIUM = _class.staticFieldId(
    r'MEDIUM',
    r'Lio/sentry/SentryOptions$RequestSize;',
  );

  /// from: `static public final io.sentry.SentryOptions$RequestSize MEDIUM`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryOptions$RequestSize get MEDIUM =>
      _id_MEDIUM.get(_class, const $SentryOptions$RequestSize$Type());

  static final _id_ALWAYS = _class.staticFieldId(
    r'ALWAYS',
    r'Lio/sentry/SentryOptions$RequestSize;',
  );

  /// from: `static public final io.sentry.SentryOptions$RequestSize ALWAYS`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryOptions$RequestSize get ALWAYS =>
      _id_ALWAYS.get(_class, const $SentryOptions$RequestSize$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Lio/sentry/SentryOptions$RequestSize;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.SentryOptions$RequestSize[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<SentryOptions$RequestSize?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<SentryOptions$RequestSize?>?>(
            const jni$_.JArrayNullableType<SentryOptions$RequestSize?>(
                $SentryOptions$RequestSize$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Lio/sentry/SentryOptions$RequestSize;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.SentryOptions$RequestSize valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryOptions$RequestSize? valueOf(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<SentryOptions$RequestSize?>(
            const $SentryOptions$RequestSize$NullableType());
  }
}

final class $SentryOptions$RequestSize$NullableType
    extends jni$_.JObjType<SentryOptions$RequestSize?> {
  @jni$_.internal
  const $SentryOptions$RequestSize$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$RequestSize;';

  @jni$_.internal
  @core$_.override
  SentryOptions$RequestSize? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$RequestSize.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$RequestSize?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$RequestSize$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$RequestSize$NullableType) &&
        other is $SentryOptions$RequestSize$NullableType;
  }
}

final class $SentryOptions$RequestSize$Type
    extends jni$_.JObjType<SentryOptions$RequestSize> {
  @jni$_.internal
  const $SentryOptions$RequestSize$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$RequestSize;';

  @jni$_.internal
  @core$_.override
  SentryOptions$RequestSize fromReference(jni$_.JReference reference) =>
      SentryOptions$RequestSize.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$RequestSize?> get nullableType =>
      const $SentryOptions$RequestSize$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$RequestSize$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$RequestSize$Type) &&
        other is $SentryOptions$RequestSize$Type;
  }
}

/// from: `io.sentry.SentryOptions$TracesSamplerCallback`
class SentryOptions$TracesSamplerCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions$TracesSamplerCallback> $type;

  @jni$_.internal
  SentryOptions$TracesSamplerCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryOptions$TracesSamplerCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $SentryOptions$TracesSamplerCallback$NullableType();
  static const type = $SentryOptions$TracesSamplerCallback$Type();
  static final _id_sample = _class.instanceMethodId(
    r'sample',
    r'(Lio/sentry/SamplingContext;)Ljava/lang/Double;',
  );

  static final _sample = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Double sample(io.sentry.SamplingContext samplingContext)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? sample(
    jni$_.JObject samplingContext,
  ) {
    final _$samplingContext = samplingContext.reference;
    return _sample(reference.pointer, _id_sample as jni$_.JMethodIDPtr,
            _$samplingContext.pointer)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SentryOptions$TracesSamplerCallback> _$impls =
      {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'sample(Lio/sentry/SamplingContext;)Ljava/lang/Double;') {
        final $r = _$impls[$p]!.sample(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $SentryOptions$TracesSamplerCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.SentryOptions$TracesSamplerCallback',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SentryOptions$TracesSamplerCallback.implement(
    $SentryOptions$TracesSamplerCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SentryOptions$TracesSamplerCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $SentryOptions$TracesSamplerCallback {
  factory $SentryOptions$TracesSamplerCallback({
    required jni$_.JDouble? Function(jni$_.JObject samplingContext) sample,
  }) = _$SentryOptions$TracesSamplerCallback;

  jni$_.JDouble? sample(jni$_.JObject samplingContext);
}

final class _$SentryOptions$TracesSamplerCallback
    with $SentryOptions$TracesSamplerCallback {
  _$SentryOptions$TracesSamplerCallback({
    required jni$_.JDouble? Function(jni$_.JObject samplingContext) sample,
  }) : _sample = sample;

  final jni$_.JDouble? Function(jni$_.JObject samplingContext) _sample;

  jni$_.JDouble? sample(jni$_.JObject samplingContext) {
    return _sample(samplingContext);
  }
}

final class $SentryOptions$TracesSamplerCallback$NullableType
    extends jni$_.JObjType<SentryOptions$TracesSamplerCallback?> {
  @jni$_.internal
  const $SentryOptions$TracesSamplerCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$TracesSamplerCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$TracesSamplerCallback? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryOptions$TracesSamplerCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$TracesSamplerCallback?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryOptions$TracesSamplerCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryOptions$TracesSamplerCallback$NullableType) &&
        other is $SentryOptions$TracesSamplerCallback$NullableType;
  }
}

final class $SentryOptions$TracesSamplerCallback$Type
    extends jni$_.JObjType<SentryOptions$TracesSamplerCallback> {
  @jni$_.internal
  const $SentryOptions$TracesSamplerCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions$TracesSamplerCallback;';

  @jni$_.internal
  @core$_.override
  SentryOptions$TracesSamplerCallback fromReference(
          jni$_.JReference reference) =>
      SentryOptions$TracesSamplerCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions$TracesSamplerCallback?> get nullableType =>
      const $SentryOptions$TracesSamplerCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$TracesSamplerCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$TracesSamplerCallback$Type) &&
        other is $SentryOptions$TracesSamplerCallback$Type;
  }
}

/// from: `io.sentry.SentryOptions`
class SentryOptions extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryOptions> $type;

  @jni$_.internal
  SentryOptions.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/SentryOptions');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryOptions$NullableType();
  static const type = $SentryOptions$Type();
  static final _id_DEFAULT_PROPAGATION_TARGETS = _class.staticFieldId(
    r'DEFAULT_PROPAGATION_TARGETS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DEFAULT_PROPAGATION_TARGETS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString get DEFAULT_PROPAGATION_TARGETS =>
      _id_DEFAULT_PROPAGATION_TARGETS.get(_class, const jni$_.JStringType());

  /// from: `static public final long MAX_EVENT_SIZE_BYTES`
  static const MAX_EVENT_SIZE_BYTES = 1048576;
  static final _id_getProfilerConverter = _class.instanceMethodId(
    r'getProfilerConverter',
    r'()Lio/sentry/IProfileConverter;',
  );

  static final _getProfilerConverter = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.IProfileConverter getProfilerConverter()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getProfilerConverter() {
    return _getProfilerConverter(
            reference.pointer, _id_getProfilerConverter as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setProfilerConverter = _class.instanceMethodId(
    r'setProfilerConverter',
    r'(Lio/sentry/IProfileConverter;)V',
  );

  static final _setProfilerConverter = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setProfilerConverter(io.sentry.IProfileConverter iProfileConverter)`
  void setProfilerConverter(
    jni$_.JObject iProfileConverter,
  ) {
    final _$iProfileConverter = iProfileConverter.reference;
    _setProfilerConverter(
            reference.pointer,
            _id_setProfilerConverter as jni$_.JMethodIDPtr,
            _$iProfileConverter.pointer)
        .check();
  }

  static final _id_addEventProcessor = _class.instanceMethodId(
    r'addEventProcessor',
    r'(Lio/sentry/EventProcessor;)V',
  );

  static final _addEventProcessor = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addEventProcessor(io.sentry.EventProcessor eventProcessor)`
  void addEventProcessor(
    jni$_.JObject eventProcessor,
  ) {
    final _$eventProcessor = eventProcessor.reference;
    _addEventProcessor(
            reference.pointer,
            _id_addEventProcessor as jni$_.JMethodIDPtr,
            _$eventProcessor.pointer)
        .check();
  }

  static final _id_getEventProcessors = _class.instanceMethodId(
    r'getEventProcessors',
    r'()Ljava/util/List;',
  );

  static final _getEventProcessors = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<io.sentry.EventProcessor> getEventProcessors()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getEventProcessors() {
    return _getEventProcessors(
            reference.pointer, _id_getEventProcessors as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_addIntegration = _class.instanceMethodId(
    r'addIntegration',
    r'(Lio/sentry/Integration;)V',
  );

  static final _addIntegration = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addIntegration(io.sentry.Integration integration)`
  void addIntegration(
    jni$_.JObject integration,
  ) {
    final _$integration = integration.reference;
    _addIntegration(reference.pointer, _id_addIntegration as jni$_.JMethodIDPtr,
            _$integration.pointer)
        .check();
  }

  static final _id_getIntegrations = _class.instanceMethodId(
    r'getIntegrations',
    r'()Ljava/util/List;',
  );

  static final _getIntegrations = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<io.sentry.Integration> getIntegrations()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getIntegrations() {
    return _getIntegrations(
            reference.pointer, _id_getIntegrations as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_getDsn = _class.instanceMethodId(
    r'getDsn',
    r'()Ljava/lang/String;',
  );

  static final _getDsn = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getDsn()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDsn() {
    return _getDsn(reference.pointer, _id_getDsn as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setDsn = _class.instanceMethodId(
    r'setDsn',
    r'(Ljava/lang/String;)V',
  );

  static final _setDsn = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDsn(java.lang.String string)`
  void setDsn(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setDsn(reference.pointer, _id_setDsn as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_isDebug = _class.instanceMethodId(
    r'isDebug',
    r'()Z',
  );

  static final _isDebug = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isDebug()`
  bool isDebug() {
    return _isDebug(reference.pointer, _id_isDebug as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setDebug = _class.instanceMethodId(
    r'setDebug',
    r'(Z)V',
  );

  static final _setDebug = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setDebug(boolean z)`
  void setDebug(
    bool z,
  ) {
    _setDebug(reference.pointer, _id_setDebug as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getLogger = _class.instanceMethodId(
    r'getLogger',
    r'()Lio/sentry/ILogger;',
  );

  static final _getLogger = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ILogger getLogger()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getLogger() {
    return _getLogger(reference.pointer, _id_getLogger as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setLogger = _class.instanceMethodId(
    r'setLogger',
    r'(Lio/sentry/ILogger;)V',
  );

  static final _setLogger = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setLogger(io.sentry.ILogger iLogger)`
  void setLogger(
    jni$_.JObject? iLogger,
  ) {
    final _$iLogger = iLogger?.reference ?? jni$_.jNullReference;
    _setLogger(reference.pointer, _id_setLogger as jni$_.JMethodIDPtr,
            _$iLogger.pointer)
        .check();
  }

  static final _id_getFatalLogger = _class.instanceMethodId(
    r'getFatalLogger',
    r'()Lio/sentry/ILogger;',
  );

  static final _getFatalLogger = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ILogger getFatalLogger()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getFatalLogger() {
    return _getFatalLogger(
            reference.pointer, _id_getFatalLogger as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setFatalLogger = _class.instanceMethodId(
    r'setFatalLogger',
    r'(Lio/sentry/ILogger;)V',
  );

  static final _setFatalLogger = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setFatalLogger(io.sentry.ILogger iLogger)`
  void setFatalLogger(
    jni$_.JObject? iLogger,
  ) {
    final _$iLogger = iLogger?.reference ?? jni$_.jNullReference;
    _setFatalLogger(reference.pointer, _id_setFatalLogger as jni$_.JMethodIDPtr,
            _$iLogger.pointer)
        .check();
  }

  static final _id_getDiagnosticLevel = _class.instanceMethodId(
    r'getDiagnosticLevel',
    r'()Lio/sentry/SentryLevel;',
  );

  static final _getDiagnosticLevel = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryLevel getDiagnosticLevel()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryLevel getDiagnosticLevel() {
    return _getDiagnosticLevel(
            reference.pointer, _id_getDiagnosticLevel as jni$_.JMethodIDPtr)
        .object<SentryLevel>(const $SentryLevel$Type());
  }

  static final _id_setDiagnosticLevel = _class.instanceMethodId(
    r'setDiagnosticLevel',
    r'(Lio/sentry/SentryLevel;)V',
  );

  static final _setDiagnosticLevel = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDiagnosticLevel(io.sentry.SentryLevel sentryLevel)`
  void setDiagnosticLevel(
    SentryLevel? sentryLevel,
  ) {
    final _$sentryLevel = sentryLevel?.reference ?? jni$_.jNullReference;
    _setDiagnosticLevel(reference.pointer,
            _id_setDiagnosticLevel as jni$_.JMethodIDPtr, _$sentryLevel.pointer)
        .check();
  }

  static final _id_getSerializer = _class.instanceMethodId(
    r'getSerializer',
    r'()Lio/sentry/ISerializer;',
  );

  static final _getSerializer = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ISerializer getSerializer()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getSerializer() {
    return _getSerializer(
            reference.pointer, _id_getSerializer as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setSerializer = _class.instanceMethodId(
    r'setSerializer',
    r'(Lio/sentry/ISerializer;)V',
  );

  static final _setSerializer = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setSerializer(io.sentry.ISerializer iSerializer)`
  void setSerializer(
    jni$_.JObject? iSerializer,
  ) {
    final _$iSerializer = iSerializer?.reference ?? jni$_.jNullReference;
    _setSerializer(reference.pointer, _id_setSerializer as jni$_.JMethodIDPtr,
            _$iSerializer.pointer)
        .check();
  }

  static final _id_getMaxDepth = _class.instanceMethodId(
    r'getMaxDepth',
    r'()I',
  );

  static final _getMaxDepth = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getMaxDepth()`
  int getMaxDepth() {
    return _getMaxDepth(
            reference.pointer, _id_getMaxDepth as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_setMaxDepth = _class.instanceMethodId(
    r'setMaxDepth',
    r'(I)V',
  );

  static final _setMaxDepth = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setMaxDepth(int i)`
  void setMaxDepth(
    int i,
  ) {
    _setMaxDepth(reference.pointer, _id_setMaxDepth as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_getEnvelopeReader = _class.instanceMethodId(
    r'getEnvelopeReader',
    r'()Lio/sentry/IEnvelopeReader;',
  );

  static final _getEnvelopeReader = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.IEnvelopeReader getEnvelopeReader()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getEnvelopeReader() {
    return _getEnvelopeReader(
            reference.pointer, _id_getEnvelopeReader as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setEnvelopeReader = _class.instanceMethodId(
    r'setEnvelopeReader',
    r'(Lio/sentry/IEnvelopeReader;)V',
  );

  static final _setEnvelopeReader = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setEnvelopeReader(io.sentry.IEnvelopeReader iEnvelopeReader)`
  void setEnvelopeReader(
    jni$_.JObject? iEnvelopeReader,
  ) {
    final _$iEnvelopeReader =
        iEnvelopeReader?.reference ?? jni$_.jNullReference;
    _setEnvelopeReader(
            reference.pointer,
            _id_setEnvelopeReader as jni$_.JMethodIDPtr,
            _$iEnvelopeReader.pointer)
        .check();
  }

  static final _id_getShutdownTimeoutMillis = _class.instanceMethodId(
    r'getShutdownTimeoutMillis',
    r'()J',
  );

  static final _getShutdownTimeoutMillis = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long getShutdownTimeoutMillis()`
  int getShutdownTimeoutMillis() {
    return _getShutdownTimeoutMillis(reference.pointer,
            _id_getShutdownTimeoutMillis as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_setShutdownTimeoutMillis = _class.instanceMethodId(
    r'setShutdownTimeoutMillis',
    r'(J)V',
  );

  static final _setShutdownTimeoutMillis = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setShutdownTimeoutMillis(long j)`
  void setShutdownTimeoutMillis(
    int j,
  ) {
    _setShutdownTimeoutMillis(reference.pointer,
            _id_setShutdownTimeoutMillis as jni$_.JMethodIDPtr, j)
        .check();
  }

  static final _id_getSentryClientName = _class.instanceMethodId(
    r'getSentryClientName',
    r'()Ljava/lang/String;',
  );

  static final _getSentryClientName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getSentryClientName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getSentryClientName() {
    return _getSentryClientName(
            reference.pointer, _id_getSentryClientName as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setSentryClientName = _class.instanceMethodId(
    r'setSentryClientName',
    r'(Ljava/lang/String;)V',
  );

  static final _setSentryClientName = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setSentryClientName(java.lang.String string)`
  void setSentryClientName(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setSentryClientName(reference.pointer,
            _id_setSentryClientName as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_getBeforeSend = _class.instanceMethodId(
    r'getBeforeSend',
    r'()Lio/sentry/SentryOptions$BeforeSendCallback;',
  );

  static final _getBeforeSend = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryOptions$BeforeSendCallback getBeforeSend()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryOptions$BeforeSendCallback? getBeforeSend() {
    return _getBeforeSend(
            reference.pointer, _id_getBeforeSend as jni$_.JMethodIDPtr)
        .object<SentryOptions$BeforeSendCallback?>(
            const $SentryOptions$BeforeSendCallback$NullableType());
  }

  static final _id_setBeforeSend = _class.instanceMethodId(
    r'setBeforeSend',
    r'(Lio/sentry/SentryOptions$BeforeSendCallback;)V',
  );

  static final _setBeforeSend = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setBeforeSend(io.sentry.SentryOptions$BeforeSendCallback beforeSendCallback)`
  void setBeforeSend(
    SentryOptions$BeforeSendCallback? beforeSendCallback,
  ) {
    final _$beforeSendCallback =
        beforeSendCallback?.reference ?? jni$_.jNullReference;
    _setBeforeSend(reference.pointer, _id_setBeforeSend as jni$_.JMethodIDPtr,
            _$beforeSendCallback.pointer)
        .check();
  }

  static final _id_getBeforeSendTransaction = _class.instanceMethodId(
    r'getBeforeSendTransaction',
    r'()Lio/sentry/SentryOptions$BeforeSendTransactionCallback;',
  );

  static final _getBeforeSendTransaction = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryOptions$BeforeSendTransactionCallback getBeforeSendTransaction()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryOptions$BeforeSendTransactionCallback? getBeforeSendTransaction() {
    return _getBeforeSendTransaction(reference.pointer,
            _id_getBeforeSendTransaction as jni$_.JMethodIDPtr)
        .object<SentryOptions$BeforeSendTransactionCallback?>(
            const $SentryOptions$BeforeSendTransactionCallback$NullableType());
  }

  static final _id_setBeforeSendTransaction = _class.instanceMethodId(
    r'setBeforeSendTransaction',
    r'(Lio/sentry/SentryOptions$BeforeSendTransactionCallback;)V',
  );

  static final _setBeforeSendTransaction = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setBeforeSendTransaction(io.sentry.SentryOptions$BeforeSendTransactionCallback beforeSendTransactionCallback)`
  void setBeforeSendTransaction(
    SentryOptions$BeforeSendTransactionCallback? beforeSendTransactionCallback,
  ) {
    final _$beforeSendTransactionCallback =
        beforeSendTransactionCallback?.reference ?? jni$_.jNullReference;
    _setBeforeSendTransaction(
            reference.pointer,
            _id_setBeforeSendTransaction as jni$_.JMethodIDPtr,
            _$beforeSendTransactionCallback.pointer)
        .check();
  }

  static final _id_getBeforeSendFeedback = _class.instanceMethodId(
    r'getBeforeSendFeedback',
    r'()Lio/sentry/SentryOptions$BeforeSendCallback;',
  );

  static final _getBeforeSendFeedback = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryOptions$BeforeSendCallback getBeforeSendFeedback()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryOptions$BeforeSendCallback? getBeforeSendFeedback() {
    return _getBeforeSendFeedback(
            reference.pointer, _id_getBeforeSendFeedback as jni$_.JMethodIDPtr)
        .object<SentryOptions$BeforeSendCallback?>(
            const $SentryOptions$BeforeSendCallback$NullableType());
  }

  static final _id_setBeforeSendFeedback = _class.instanceMethodId(
    r'setBeforeSendFeedback',
    r'(Lio/sentry/SentryOptions$BeforeSendCallback;)V',
  );

  static final _setBeforeSendFeedback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setBeforeSendFeedback(io.sentry.SentryOptions$BeforeSendCallback beforeSendCallback)`
  void setBeforeSendFeedback(
    SentryOptions$BeforeSendCallback? beforeSendCallback,
  ) {
    final _$beforeSendCallback =
        beforeSendCallback?.reference ?? jni$_.jNullReference;
    _setBeforeSendFeedback(
            reference.pointer,
            _id_setBeforeSendFeedback as jni$_.JMethodIDPtr,
            _$beforeSendCallback.pointer)
        .check();
  }

  static final _id_getBeforeSendReplay = _class.instanceMethodId(
    r'getBeforeSendReplay',
    r'()Lio/sentry/SentryOptions$BeforeSendReplayCallback;',
  );

  static final _getBeforeSendReplay = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryOptions$BeforeSendReplayCallback getBeforeSendReplay()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryOptions$BeforeSendReplayCallback? getBeforeSendReplay() {
    return _getBeforeSendReplay(
            reference.pointer, _id_getBeforeSendReplay as jni$_.JMethodIDPtr)
        .object<SentryOptions$BeforeSendReplayCallback?>(
            const $SentryOptions$BeforeSendReplayCallback$NullableType());
  }

  static final _id_setBeforeSendReplay = _class.instanceMethodId(
    r'setBeforeSendReplay',
    r'(Lio/sentry/SentryOptions$BeforeSendReplayCallback;)V',
  );

  static final _setBeforeSendReplay = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setBeforeSendReplay(io.sentry.SentryOptions$BeforeSendReplayCallback beforeSendReplayCallback)`
  void setBeforeSendReplay(
    SentryOptions$BeforeSendReplayCallback? beforeSendReplayCallback,
  ) {
    final _$beforeSendReplayCallback =
        beforeSendReplayCallback?.reference ?? jni$_.jNullReference;
    _setBeforeSendReplay(
            reference.pointer,
            _id_setBeforeSendReplay as jni$_.JMethodIDPtr,
            _$beforeSendReplayCallback.pointer)
        .check();
  }

  static final _id_getBeforeBreadcrumb = _class.instanceMethodId(
    r'getBeforeBreadcrumb',
    r'()Lio/sentry/SentryOptions$BeforeBreadcrumbCallback;',
  );

  static final _getBeforeBreadcrumb = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryOptions$BeforeBreadcrumbCallback getBeforeBreadcrumb()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryOptions$BeforeBreadcrumbCallback? getBeforeBreadcrumb() {
    return _getBeforeBreadcrumb(
            reference.pointer, _id_getBeforeBreadcrumb as jni$_.JMethodIDPtr)
        .object<SentryOptions$BeforeBreadcrumbCallback?>(
            const $SentryOptions$BeforeBreadcrumbCallback$NullableType());
  }

  static final _id_setBeforeBreadcrumb = _class.instanceMethodId(
    r'setBeforeBreadcrumb',
    r'(Lio/sentry/SentryOptions$BeforeBreadcrumbCallback;)V',
  );

  static final _setBeforeBreadcrumb = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setBeforeBreadcrumb(io.sentry.SentryOptions$BeforeBreadcrumbCallback beforeBreadcrumbCallback)`
  void setBeforeBreadcrumb(
    SentryOptions$BeforeBreadcrumbCallback? beforeBreadcrumbCallback,
  ) {
    final _$beforeBreadcrumbCallback =
        beforeBreadcrumbCallback?.reference ?? jni$_.jNullReference;
    _setBeforeBreadcrumb(
            reference.pointer,
            _id_setBeforeBreadcrumb as jni$_.JMethodIDPtr,
            _$beforeBreadcrumbCallback.pointer)
        .check();
  }

  static final _id_getOnDiscard = _class.instanceMethodId(
    r'getOnDiscard',
    r'()Lio/sentry/SentryOptions$OnDiscardCallback;',
  );

  static final _getOnDiscard = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryOptions$OnDiscardCallback getOnDiscard()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryOptions$OnDiscardCallback? getOnDiscard() {
    return _getOnDiscard(
            reference.pointer, _id_getOnDiscard as jni$_.JMethodIDPtr)
        .object<SentryOptions$OnDiscardCallback?>(
            const $SentryOptions$OnDiscardCallback$NullableType());
  }

  static final _id_setOnDiscard = _class.instanceMethodId(
    r'setOnDiscard',
    r'(Lio/sentry/SentryOptions$OnDiscardCallback;)V',
  );

  static final _setOnDiscard = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setOnDiscard(io.sentry.SentryOptions$OnDiscardCallback onDiscardCallback)`
  void setOnDiscard(
    SentryOptions$OnDiscardCallback? onDiscardCallback,
  ) {
    final _$onDiscardCallback =
        onDiscardCallback?.reference ?? jni$_.jNullReference;
    _setOnDiscard(reference.pointer, _id_setOnDiscard as jni$_.JMethodIDPtr,
            _$onDiscardCallback.pointer)
        .check();
  }

  static final _id_getCacheDirPath = _class.instanceMethodId(
    r'getCacheDirPath',
    r'()Ljava/lang/String;',
  );

  static final _getCacheDirPath = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getCacheDirPath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getCacheDirPath() {
    return _getCacheDirPath(
            reference.pointer, _id_getCacheDirPath as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getOutboxPath = _class.instanceMethodId(
    r'getOutboxPath',
    r'()Ljava/lang/String;',
  );

  static final _getOutboxPath = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getOutboxPath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getOutboxPath() {
    return _getOutboxPath(
            reference.pointer, _id_getOutboxPath as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setCacheDirPath = _class.instanceMethodId(
    r'setCacheDirPath',
    r'(Ljava/lang/String;)V',
  );

  static final _setCacheDirPath = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setCacheDirPath(java.lang.String string)`
  void setCacheDirPath(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setCacheDirPath(reference.pointer,
            _id_setCacheDirPath as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_getMaxBreadcrumbs = _class.instanceMethodId(
    r'getMaxBreadcrumbs',
    r'()I',
  );

  static final _getMaxBreadcrumbs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getMaxBreadcrumbs()`
  int getMaxBreadcrumbs() {
    return _getMaxBreadcrumbs(
            reference.pointer, _id_getMaxBreadcrumbs as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_setMaxBreadcrumbs = _class.instanceMethodId(
    r'setMaxBreadcrumbs',
    r'(I)V',
  );

  static final _setMaxBreadcrumbs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setMaxBreadcrumbs(int i)`
  void setMaxBreadcrumbs(
    int i,
  ) {
    _setMaxBreadcrumbs(
            reference.pointer, _id_setMaxBreadcrumbs as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_getMaxFeatureFlags = _class.instanceMethodId(
    r'getMaxFeatureFlags',
    r'()I',
  );

  static final _getMaxFeatureFlags = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getMaxFeatureFlags()`
  int getMaxFeatureFlags() {
    return _getMaxFeatureFlags(
            reference.pointer, _id_getMaxFeatureFlags as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_setMaxFeatureFlags = _class.instanceMethodId(
    r'setMaxFeatureFlags',
    r'(I)V',
  );

  static final _setMaxFeatureFlags = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setMaxFeatureFlags(int i)`
  void setMaxFeatureFlags(
    int i,
  ) {
    _setMaxFeatureFlags(
            reference.pointer, _id_setMaxFeatureFlags as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_getRelease = _class.instanceMethodId(
    r'getRelease',
    r'()Ljava/lang/String;',
  );

  static final _getRelease = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getRelease()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getRelease() {
    return _getRelease(reference.pointer, _id_getRelease as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setRelease = _class.instanceMethodId(
    r'setRelease',
    r'(Ljava/lang/String;)V',
  );

  static final _setRelease = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setRelease(java.lang.String string)`
  void setRelease(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setRelease(reference.pointer, _id_setRelease as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getEnvironment = _class.instanceMethodId(
    r'getEnvironment',
    r'()Ljava/lang/String;',
  );

  static final _getEnvironment = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getEnvironment()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getEnvironment() {
    return _getEnvironment(
            reference.pointer, _id_getEnvironment as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setEnvironment = _class.instanceMethodId(
    r'setEnvironment',
    r'(Ljava/lang/String;)V',
  );

  static final _setEnvironment = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setEnvironment(java.lang.String string)`
  void setEnvironment(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setEnvironment(reference.pointer, _id_setEnvironment as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getProxy = _class.instanceMethodId(
    r'getProxy',
    r'()Lio/sentry/SentryOptions$Proxy;',
  );

  static final _getProxy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryOptions$Proxy getProxy()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryOptions$Proxy? getProxy() {
    return _getProxy(reference.pointer, _id_getProxy as jni$_.JMethodIDPtr)
        .object<SentryOptions$Proxy?>(
            const $SentryOptions$Proxy$NullableType());
  }

  static final _id_setProxy = _class.instanceMethodId(
    r'setProxy',
    r'(Lio/sentry/SentryOptions$Proxy;)V',
  );

  static final _setProxy = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setProxy(io.sentry.SentryOptions$Proxy proxy)`
  void setProxy(
    SentryOptions$Proxy? proxy,
  ) {
    final _$proxy = proxy?.reference ?? jni$_.jNullReference;
    _setProxy(reference.pointer, _id_setProxy as jni$_.JMethodIDPtr,
            _$proxy.pointer)
        .check();
  }

  static final _id_getSampleRate = _class.instanceMethodId(
    r'getSampleRate',
    r'()Ljava/lang/Double;',
  );

  static final _getSampleRate = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Double getSampleRate()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? getSampleRate() {
    return _getSampleRate(
            reference.pointer, _id_getSampleRate as jni$_.JMethodIDPtr)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_setSampleRate = _class.instanceMethodId(
    r'setSampleRate',
    r'(Ljava/lang/Double;)V',
  );

  static final _setSampleRate = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setSampleRate(java.lang.Double double)`
  void setSampleRate(
    jni$_.JDouble? double,
  ) {
    final _$double = double?.reference ?? jni$_.jNullReference;
    _setSampleRate(reference.pointer, _id_setSampleRate as jni$_.JMethodIDPtr,
            _$double.pointer)
        .check();
  }

  static final _id_getTracesSampleRate = _class.instanceMethodId(
    r'getTracesSampleRate',
    r'()Ljava/lang/Double;',
  );

  static final _getTracesSampleRate = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Double getTracesSampleRate()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? getTracesSampleRate() {
    return _getTracesSampleRate(
            reference.pointer, _id_getTracesSampleRate as jni$_.JMethodIDPtr)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_setTracesSampleRate = _class.instanceMethodId(
    r'setTracesSampleRate',
    r'(Ljava/lang/Double;)V',
  );

  static final _setTracesSampleRate = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTracesSampleRate(java.lang.Double double)`
  void setTracesSampleRate(
    jni$_.JDouble? double,
  ) {
    final _$double = double?.reference ?? jni$_.jNullReference;
    _setTracesSampleRate(reference.pointer,
            _id_setTracesSampleRate as jni$_.JMethodIDPtr, _$double.pointer)
        .check();
  }

  static final _id_getTracesSampler = _class.instanceMethodId(
    r'getTracesSampler',
    r'()Lio/sentry/SentryOptions$TracesSamplerCallback;',
  );

  static final _getTracesSampler = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryOptions$TracesSamplerCallback getTracesSampler()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryOptions$TracesSamplerCallback? getTracesSampler() {
    return _getTracesSampler(
            reference.pointer, _id_getTracesSampler as jni$_.JMethodIDPtr)
        .object<SentryOptions$TracesSamplerCallback?>(
            const $SentryOptions$TracesSamplerCallback$NullableType());
  }

  static final _id_setTracesSampler = _class.instanceMethodId(
    r'setTracesSampler',
    r'(Lio/sentry/SentryOptions$TracesSamplerCallback;)V',
  );

  static final _setTracesSampler = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTracesSampler(io.sentry.SentryOptions$TracesSamplerCallback tracesSamplerCallback)`
  void setTracesSampler(
    SentryOptions$TracesSamplerCallback? tracesSamplerCallback,
  ) {
    final _$tracesSamplerCallback =
        tracesSamplerCallback?.reference ?? jni$_.jNullReference;
    _setTracesSampler(
            reference.pointer,
            _id_setTracesSampler as jni$_.JMethodIDPtr,
            _$tracesSamplerCallback.pointer)
        .check();
  }

  static final _id_getInternalTracesSampler = _class.instanceMethodId(
    r'getInternalTracesSampler',
    r'()Lio/sentry/TracesSampler;',
  );

  static final _getInternalTracesSampler = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.TracesSampler getInternalTracesSampler()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getInternalTracesSampler() {
    return _getInternalTracesSampler(reference.pointer,
            _id_getInternalTracesSampler as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getInAppExcludes = _class.instanceMethodId(
    r'getInAppExcludes',
    r'()Ljava/util/List;',
  );

  static final _getInAppExcludes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<java.lang.String> getInAppExcludes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?> getInAppExcludes() {
    return _getInAppExcludes(
            reference.pointer, _id_getInAppExcludes as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>>(
            const jni$_.JListType<jni$_.JString?>(jni$_.JStringNullableType()));
  }

  static final _id_addInAppExclude = _class.instanceMethodId(
    r'addInAppExclude',
    r'(Ljava/lang/String;)V',
  );

  static final _addInAppExclude = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addInAppExclude(java.lang.String string)`
  void addInAppExclude(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _addInAppExclude(reference.pointer,
            _id_addInAppExclude as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_getInAppIncludes = _class.instanceMethodId(
    r'getInAppIncludes',
    r'()Ljava/util/List;',
  );

  static final _getInAppIncludes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<java.lang.String> getInAppIncludes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?> getInAppIncludes() {
    return _getInAppIncludes(
            reference.pointer, _id_getInAppIncludes as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>>(
            const jni$_.JListType<jni$_.JString?>(jni$_.JStringNullableType()));
  }

  static final _id_addInAppInclude = _class.instanceMethodId(
    r'addInAppInclude',
    r'(Ljava/lang/String;)V',
  );

  static final _addInAppInclude = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addInAppInclude(java.lang.String string)`
  void addInAppInclude(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _addInAppInclude(reference.pointer,
            _id_addInAppInclude as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_getTransportFactory = _class.instanceMethodId(
    r'getTransportFactory',
    r'()Lio/sentry/ITransportFactory;',
  );

  static final _getTransportFactory = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ITransportFactory getTransportFactory()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getTransportFactory() {
    return _getTransportFactory(
            reference.pointer, _id_getTransportFactory as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setTransportFactory = _class.instanceMethodId(
    r'setTransportFactory',
    r'(Lio/sentry/ITransportFactory;)V',
  );

  static final _setTransportFactory = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTransportFactory(io.sentry.ITransportFactory iTransportFactory)`
  void setTransportFactory(
    jni$_.JObject? iTransportFactory,
  ) {
    final _$iTransportFactory =
        iTransportFactory?.reference ?? jni$_.jNullReference;
    _setTransportFactory(
            reference.pointer,
            _id_setTransportFactory as jni$_.JMethodIDPtr,
            _$iTransportFactory.pointer)
        .check();
  }

  static final _id_getDist = _class.instanceMethodId(
    r'getDist',
    r'()Ljava/lang/String;',
  );

  static final _getDist = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getDist()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDist() {
    return _getDist(reference.pointer, _id_getDist as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setDist = _class.instanceMethodId(
    r'setDist',
    r'(Ljava/lang/String;)V',
  );

  static final _setDist = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDist(java.lang.String string)`
  void setDist(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setDist(reference.pointer, _id_setDist as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getTransportGate = _class.instanceMethodId(
    r'getTransportGate',
    r'()Lio/sentry/transport/ITransportGate;',
  );

  static final _getTransportGate = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.transport.ITransportGate getTransportGate()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getTransportGate() {
    return _getTransportGate(
            reference.pointer, _id_getTransportGate as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setTransportGate = _class.instanceMethodId(
    r'setTransportGate',
    r'(Lio/sentry/transport/ITransportGate;)V',
  );

  static final _setTransportGate = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTransportGate(io.sentry.transport.ITransportGate iTransportGate)`
  void setTransportGate(
    jni$_.JObject? iTransportGate,
  ) {
    final _$iTransportGate = iTransportGate?.reference ?? jni$_.jNullReference;
    _setTransportGate(
            reference.pointer,
            _id_setTransportGate as jni$_.JMethodIDPtr,
            _$iTransportGate.pointer)
        .check();
  }

  static final _id_isAttachStacktrace = _class.instanceMethodId(
    r'isAttachStacktrace',
    r'()Z',
  );

  static final _isAttachStacktrace = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isAttachStacktrace()`
  bool isAttachStacktrace() {
    return _isAttachStacktrace(
            reference.pointer, _id_isAttachStacktrace as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setAttachStacktrace = _class.instanceMethodId(
    r'setAttachStacktrace',
    r'(Z)V',
  );

  static final _setAttachStacktrace = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setAttachStacktrace(boolean z)`
  void setAttachStacktrace(
    bool z,
  ) {
    _setAttachStacktrace(reference.pointer,
            _id_setAttachStacktrace as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isAttachThreads = _class.instanceMethodId(
    r'isAttachThreads',
    r'()Z',
  );

  static final _isAttachThreads = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isAttachThreads()`
  bool isAttachThreads() {
    return _isAttachThreads(
            reference.pointer, _id_isAttachThreads as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setAttachThreads = _class.instanceMethodId(
    r'setAttachThreads',
    r'(Z)V',
  );

  static final _setAttachThreads = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setAttachThreads(boolean z)`
  void setAttachThreads(
    bool z,
  ) {
    _setAttachThreads(reference.pointer,
            _id_setAttachThreads as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isEnableAutoSessionTracking = _class.instanceMethodId(
    r'isEnableAutoSessionTracking',
    r'()Z',
  );

  static final _isEnableAutoSessionTracking =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEnableAutoSessionTracking()`
  bool isEnableAutoSessionTracking() {
    return _isEnableAutoSessionTracking(reference.pointer,
            _id_isEnableAutoSessionTracking as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableAutoSessionTracking = _class.instanceMethodId(
    r'setEnableAutoSessionTracking',
    r'(Z)V',
  );

  static final _setEnableAutoSessionTracking =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableAutoSessionTracking(boolean z)`
  void setEnableAutoSessionTracking(
    bool z,
  ) {
    _setEnableAutoSessionTracking(reference.pointer,
            _id_setEnableAutoSessionTracking as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getServerName = _class.instanceMethodId(
    r'getServerName',
    r'()Ljava/lang/String;',
  );

  static final _getServerName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getServerName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getServerName() {
    return _getServerName(
            reference.pointer, _id_getServerName as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setServerName = _class.instanceMethodId(
    r'setServerName',
    r'(Ljava/lang/String;)V',
  );

  static final _setServerName = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setServerName(java.lang.String string)`
  void setServerName(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setServerName(reference.pointer, _id_setServerName as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_isAttachServerName = _class.instanceMethodId(
    r'isAttachServerName',
    r'()Z',
  );

  static final _isAttachServerName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isAttachServerName()`
  bool isAttachServerName() {
    return _isAttachServerName(
            reference.pointer, _id_isAttachServerName as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setAttachServerName = _class.instanceMethodId(
    r'setAttachServerName',
    r'(Z)V',
  );

  static final _setAttachServerName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setAttachServerName(boolean z)`
  void setAttachServerName(
    bool z,
  ) {
    _setAttachServerName(reference.pointer,
            _id_setAttachServerName as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getSessionTrackingIntervalMillis = _class.instanceMethodId(
    r'getSessionTrackingIntervalMillis',
    r'()J',
  );

  static final _getSessionTrackingIntervalMillis =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallLongMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public long getSessionTrackingIntervalMillis()`
  int getSessionTrackingIntervalMillis() {
    return _getSessionTrackingIntervalMillis(reference.pointer,
            _id_getSessionTrackingIntervalMillis as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_setSessionTrackingIntervalMillis = _class.instanceMethodId(
    r'setSessionTrackingIntervalMillis',
    r'(J)V',
  );

  static final _setSessionTrackingIntervalMillis =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setSessionTrackingIntervalMillis(long j)`
  void setSessionTrackingIntervalMillis(
    int j,
  ) {
    _setSessionTrackingIntervalMillis(reference.pointer,
            _id_setSessionTrackingIntervalMillis as jni$_.JMethodIDPtr, j)
        .check();
  }

  static final _id_getDistinctId = _class.instanceMethodId(
    r'getDistinctId',
    r'()Ljava/lang/String;',
  );

  static final _getDistinctId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getDistinctId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDistinctId() {
    return _getDistinctId(
            reference.pointer, _id_getDistinctId as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setDistinctId = _class.instanceMethodId(
    r'setDistinctId',
    r'(Ljava/lang/String;)V',
  );

  static final _setDistinctId = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDistinctId(java.lang.String string)`
  void setDistinctId(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setDistinctId(reference.pointer, _id_setDistinctId as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getFlushTimeoutMillis = _class.instanceMethodId(
    r'getFlushTimeoutMillis',
    r'()J',
  );

  static final _getFlushTimeoutMillis = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long getFlushTimeoutMillis()`
  int getFlushTimeoutMillis() {
    return _getFlushTimeoutMillis(
            reference.pointer, _id_getFlushTimeoutMillis as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_setFlushTimeoutMillis = _class.instanceMethodId(
    r'setFlushTimeoutMillis',
    r'(J)V',
  );

  static final _setFlushTimeoutMillis = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setFlushTimeoutMillis(long j)`
  void setFlushTimeoutMillis(
    int j,
  ) {
    _setFlushTimeoutMillis(reference.pointer,
            _id_setFlushTimeoutMillis as jni$_.JMethodIDPtr, j)
        .check();
  }

  static final _id_isEnableUncaughtExceptionHandler = _class.instanceMethodId(
    r'isEnableUncaughtExceptionHandler',
    r'()Z',
  );

  static final _isEnableUncaughtExceptionHandler =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEnableUncaughtExceptionHandler()`
  bool isEnableUncaughtExceptionHandler() {
    return _isEnableUncaughtExceptionHandler(reference.pointer,
            _id_isEnableUncaughtExceptionHandler as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableUncaughtExceptionHandler = _class.instanceMethodId(
    r'setEnableUncaughtExceptionHandler',
    r'(Z)V',
  );

  static final _setEnableUncaughtExceptionHandler =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableUncaughtExceptionHandler(boolean z)`
  void setEnableUncaughtExceptionHandler(
    bool z,
  ) {
    _setEnableUncaughtExceptionHandler(
            reference.pointer,
            _id_setEnableUncaughtExceptionHandler as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_isPrintUncaughtStackTrace = _class.instanceMethodId(
    r'isPrintUncaughtStackTrace',
    r'()Z',
  );

  static final _isPrintUncaughtStackTrace = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isPrintUncaughtStackTrace()`
  bool isPrintUncaughtStackTrace() {
    return _isPrintUncaughtStackTrace(reference.pointer,
            _id_isPrintUncaughtStackTrace as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setPrintUncaughtStackTrace = _class.instanceMethodId(
    r'setPrintUncaughtStackTrace',
    r'(Z)V',
  );

  static final _setPrintUncaughtStackTrace =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setPrintUncaughtStackTrace(boolean z)`
  void setPrintUncaughtStackTrace(
    bool z,
  ) {
    _setPrintUncaughtStackTrace(reference.pointer,
            _id_setPrintUncaughtStackTrace as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getExecutorService = _class.instanceMethodId(
    r'getExecutorService',
    r'()Lio/sentry/ISentryExecutorService;',
  );

  static final _getExecutorService = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ISentryExecutorService getExecutorService()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getExecutorService() {
    return _getExecutorService(
            reference.pointer, _id_getExecutorService as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setExecutorService = _class.instanceMethodId(
    r'setExecutorService',
    r'(Lio/sentry/ISentryExecutorService;)V',
  );

  static final _setExecutorService = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setExecutorService(io.sentry.ISentryExecutorService iSentryExecutorService)`
  void setExecutorService(
    jni$_.JObject iSentryExecutorService,
  ) {
    final _$iSentryExecutorService = iSentryExecutorService.reference;
    _setExecutorService(
            reference.pointer,
            _id_setExecutorService as jni$_.JMethodIDPtr,
            _$iSentryExecutorService.pointer)
        .check();
  }

  static final _id_getConnectionTimeoutMillis = _class.instanceMethodId(
    r'getConnectionTimeoutMillis',
    r'()I',
  );

  static final _getConnectionTimeoutMillis =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallIntMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public int getConnectionTimeoutMillis()`
  int getConnectionTimeoutMillis() {
    return _getConnectionTimeoutMillis(reference.pointer,
            _id_getConnectionTimeoutMillis as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_setConnectionTimeoutMillis = _class.instanceMethodId(
    r'setConnectionTimeoutMillis',
    r'(I)V',
  );

  static final _setConnectionTimeoutMillis =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setConnectionTimeoutMillis(int i)`
  void setConnectionTimeoutMillis(
    int i,
  ) {
    _setConnectionTimeoutMillis(reference.pointer,
            _id_setConnectionTimeoutMillis as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_getReadTimeoutMillis = _class.instanceMethodId(
    r'getReadTimeoutMillis',
    r'()I',
  );

  static final _getReadTimeoutMillis = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getReadTimeoutMillis()`
  int getReadTimeoutMillis() {
    return _getReadTimeoutMillis(
            reference.pointer, _id_getReadTimeoutMillis as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_setReadTimeoutMillis = _class.instanceMethodId(
    r'setReadTimeoutMillis',
    r'(I)V',
  );

  static final _setReadTimeoutMillis = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setReadTimeoutMillis(int i)`
  void setReadTimeoutMillis(
    int i,
  ) {
    _setReadTimeoutMillis(reference.pointer,
            _id_setReadTimeoutMillis as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_getEnvelopeDiskCache = _class.instanceMethodId(
    r'getEnvelopeDiskCache',
    r'()Lio/sentry/cache/IEnvelopeCache;',
  );

  static final _getEnvelopeDiskCache = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.cache.IEnvelopeCache getEnvelopeDiskCache()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getEnvelopeDiskCache() {
    return _getEnvelopeDiskCache(
            reference.pointer, _id_getEnvelopeDiskCache as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setEnvelopeDiskCache = _class.instanceMethodId(
    r'setEnvelopeDiskCache',
    r'(Lio/sentry/cache/IEnvelopeCache;)V',
  );

  static final _setEnvelopeDiskCache = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setEnvelopeDiskCache(io.sentry.cache.IEnvelopeCache iEnvelopeCache)`
  void setEnvelopeDiskCache(
    jni$_.JObject? iEnvelopeCache,
  ) {
    final _$iEnvelopeCache = iEnvelopeCache?.reference ?? jni$_.jNullReference;
    _setEnvelopeDiskCache(
            reference.pointer,
            _id_setEnvelopeDiskCache as jni$_.JMethodIDPtr,
            _$iEnvelopeCache.pointer)
        .check();
  }

  static final _id_getMaxQueueSize = _class.instanceMethodId(
    r'getMaxQueueSize',
    r'()I',
  );

  static final _getMaxQueueSize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getMaxQueueSize()`
  int getMaxQueueSize() {
    return _getMaxQueueSize(
            reference.pointer, _id_getMaxQueueSize as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_setMaxQueueSize = _class.instanceMethodId(
    r'setMaxQueueSize',
    r'(I)V',
  );

  static final _setMaxQueueSize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setMaxQueueSize(int i)`
  void setMaxQueueSize(
    int i,
  ) {
    _setMaxQueueSize(
            reference.pointer, _id_setMaxQueueSize as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_getSdkVersion = _class.instanceMethodId(
    r'getSdkVersion',
    r'()Lio/sentry/protocol/SdkVersion;',
  );

  static final _getSdkVersion = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.SdkVersion getSdkVersion()`
  /// The returned object must be released after use, by calling the [release] method.
  SdkVersion? getSdkVersion() {
    return _getSdkVersion(
            reference.pointer, _id_getSdkVersion as jni$_.JMethodIDPtr)
        .object<SdkVersion?>(const $SdkVersion$NullableType());
  }

  static final _id_getSslSocketFactory = _class.instanceMethodId(
    r'getSslSocketFactory',
    r'()Ljavax/net/ssl/SSLSocketFactory;',
  );

  static final _getSslSocketFactory = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public javax.net.ssl.SSLSocketFactory getSslSocketFactory()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getSslSocketFactory() {
    return _getSslSocketFactory(
            reference.pointer, _id_getSslSocketFactory as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setSslSocketFactory = _class.instanceMethodId(
    r'setSslSocketFactory',
    r'(Ljavax/net/ssl/SSLSocketFactory;)V',
  );

  static final _setSslSocketFactory = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setSslSocketFactory(javax.net.ssl.SSLSocketFactory sSLSocketFactory)`
  void setSslSocketFactory(
    jni$_.JObject? sSLSocketFactory,
  ) {
    final _$sSLSocketFactory =
        sSLSocketFactory?.reference ?? jni$_.jNullReference;
    _setSslSocketFactory(
            reference.pointer,
            _id_setSslSocketFactory as jni$_.JMethodIDPtr,
            _$sSLSocketFactory.pointer)
        .check();
  }

  static final _id_setSdkVersion = _class.instanceMethodId(
    r'setSdkVersion',
    r'(Lio/sentry/protocol/SdkVersion;)V',
  );

  static final _setSdkVersion = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setSdkVersion(io.sentry.protocol.SdkVersion sdkVersion)`
  void setSdkVersion(
    SdkVersion? sdkVersion,
  ) {
    final _$sdkVersion = sdkVersion?.reference ?? jni$_.jNullReference;
    _setSdkVersion(reference.pointer, _id_setSdkVersion as jni$_.JMethodIDPtr,
            _$sdkVersion.pointer)
        .check();
  }

  static final _id_isSendDefaultPii = _class.instanceMethodId(
    r'isSendDefaultPii',
    r'()Z',
  );

  static final _isSendDefaultPii = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isSendDefaultPii()`
  bool isSendDefaultPii() {
    return _isSendDefaultPii(
            reference.pointer, _id_isSendDefaultPii as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setSendDefaultPii = _class.instanceMethodId(
    r'setSendDefaultPii',
    r'(Z)V',
  );

  static final _setSendDefaultPii = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setSendDefaultPii(boolean z)`
  void setSendDefaultPii(
    bool z,
  ) {
    _setSendDefaultPii(reference.pointer,
            _id_setSendDefaultPii as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_addScopeObserver = _class.instanceMethodId(
    r'addScopeObserver',
    r'(Lio/sentry/IScopeObserver;)V',
  );

  static final _addScopeObserver = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addScopeObserver(io.sentry.IScopeObserver iScopeObserver)`
  void addScopeObserver(
    jni$_.JObject iScopeObserver,
  ) {
    final _$iScopeObserver = iScopeObserver.reference;
    _addScopeObserver(
            reference.pointer,
            _id_addScopeObserver as jni$_.JMethodIDPtr,
            _$iScopeObserver.pointer)
        .check();
  }

  static final _id_getScopeObservers = _class.instanceMethodId(
    r'getScopeObservers',
    r'()Ljava/util/List;',
  );

  static final _getScopeObservers = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<io.sentry.IScopeObserver> getScopeObservers()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getScopeObservers() {
    return _getScopeObservers(
            reference.pointer, _id_getScopeObservers as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_findPersistingScopeObserver = _class.instanceMethodId(
    r'findPersistingScopeObserver',
    r'()Lio/sentry/cache/PersistingScopeObserver;',
  );

  static final _findPersistingScopeObserver =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public io.sentry.cache.PersistingScopeObserver findPersistingScopeObserver()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? findPersistingScopeObserver() {
    return _findPersistingScopeObserver(reference.pointer,
            _id_findPersistingScopeObserver as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_addOptionsObserver = _class.instanceMethodId(
    r'addOptionsObserver',
    r'(Lio/sentry/IOptionsObserver;)V',
  );

  static final _addOptionsObserver = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addOptionsObserver(io.sentry.IOptionsObserver iOptionsObserver)`
  void addOptionsObserver(
    jni$_.JObject iOptionsObserver,
  ) {
    final _$iOptionsObserver = iOptionsObserver.reference;
    _addOptionsObserver(
            reference.pointer,
            _id_addOptionsObserver as jni$_.JMethodIDPtr,
            _$iOptionsObserver.pointer)
        .check();
  }

  static final _id_getOptionsObservers = _class.instanceMethodId(
    r'getOptionsObservers',
    r'()Ljava/util/List;',
  );

  static final _getOptionsObservers = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<io.sentry.IOptionsObserver> getOptionsObservers()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getOptionsObservers() {
    return _getOptionsObservers(
            reference.pointer, _id_getOptionsObservers as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_isEnableExternalConfiguration = _class.instanceMethodId(
    r'isEnableExternalConfiguration',
    r'()Z',
  );

  static final _isEnableExternalConfiguration =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEnableExternalConfiguration()`
  bool isEnableExternalConfiguration() {
    return _isEnableExternalConfiguration(reference.pointer,
            _id_isEnableExternalConfiguration as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableExternalConfiguration = _class.instanceMethodId(
    r'setEnableExternalConfiguration',
    r'(Z)V',
  );

  static final _setEnableExternalConfiguration =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableExternalConfiguration(boolean z)`
  void setEnableExternalConfiguration(
    bool z,
  ) {
    _setEnableExternalConfiguration(reference.pointer,
            _id_setEnableExternalConfiguration as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getTags = _class.instanceMethodId(
    r'getTags',
    r'()Ljava/util/Map;',
  );

  static final _getTags = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> getTags()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?> getTags() {
    return _getTags(reference.pointer, _id_getTags as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
            const jni$_.JMapType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_setTag = _class.instanceMethodId(
    r'setTag',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setTag = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTag(java.lang.String string, java.lang.String string1)`
  void setTag(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setTag(reference.pointer, _id_setTag as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  static final _id_getMaxAttachmentSize = _class.instanceMethodId(
    r'getMaxAttachmentSize',
    r'()J',
  );

  static final _getMaxAttachmentSize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long getMaxAttachmentSize()`
  int getMaxAttachmentSize() {
    return _getMaxAttachmentSize(
            reference.pointer, _id_getMaxAttachmentSize as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_setMaxAttachmentSize = _class.instanceMethodId(
    r'setMaxAttachmentSize',
    r'(J)V',
  );

  static final _setMaxAttachmentSize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setMaxAttachmentSize(long j)`
  void setMaxAttachmentSize(
    int j,
  ) {
    _setMaxAttachmentSize(reference.pointer,
            _id_setMaxAttachmentSize as jni$_.JMethodIDPtr, j)
        .check();
  }

  static final _id_isEnableDeduplication = _class.instanceMethodId(
    r'isEnableDeduplication',
    r'()Z',
  );

  static final _isEnableDeduplication = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEnableDeduplication()`
  bool isEnableDeduplication() {
    return _isEnableDeduplication(
            reference.pointer, _id_isEnableDeduplication as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableDeduplication = _class.instanceMethodId(
    r'setEnableDeduplication',
    r'(Z)V',
  );

  static final _setEnableDeduplication = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableDeduplication(boolean z)`
  void setEnableDeduplication(
    bool z,
  ) {
    _setEnableDeduplication(reference.pointer,
            _id_setEnableDeduplication as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isEnableEventSizeLimiting = _class.instanceMethodId(
    r'isEnableEventSizeLimiting',
    r'()Z',
  );

  static final _isEnableEventSizeLimiting = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEnableEventSizeLimiting()`
  bool isEnableEventSizeLimiting() {
    return _isEnableEventSizeLimiting(reference.pointer,
            _id_isEnableEventSizeLimiting as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableEventSizeLimiting = _class.instanceMethodId(
    r'setEnableEventSizeLimiting',
    r'(Z)V',
  );

  static final _setEnableEventSizeLimiting =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableEventSizeLimiting(boolean z)`
  void setEnableEventSizeLimiting(
    bool z,
  ) {
    _setEnableEventSizeLimiting(reference.pointer,
            _id_setEnableEventSizeLimiting as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getOnOversizedEvent = _class.instanceMethodId(
    r'getOnOversizedEvent',
    r'()Lio/sentry/SentryOptions$OnOversizedEventCallback;',
  );

  static final _getOnOversizedEvent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryOptions$OnOversizedEventCallback getOnOversizedEvent()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryOptions$OnOversizedEventCallback? getOnOversizedEvent() {
    return _getOnOversizedEvent(
            reference.pointer, _id_getOnOversizedEvent as jni$_.JMethodIDPtr)
        .object<SentryOptions$OnOversizedEventCallback?>(
            const $SentryOptions$OnOversizedEventCallback$NullableType());
  }

  static final _id_setOnOversizedEvent = _class.instanceMethodId(
    r'setOnOversizedEvent',
    r'(Lio/sentry/SentryOptions$OnOversizedEventCallback;)V',
  );

  static final _setOnOversizedEvent = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setOnOversizedEvent(io.sentry.SentryOptions$OnOversizedEventCallback onOversizedEventCallback)`
  void setOnOversizedEvent(
    SentryOptions$OnOversizedEventCallback? onOversizedEventCallback,
  ) {
    final _$onOversizedEventCallback =
        onOversizedEventCallback?.reference ?? jni$_.jNullReference;
    _setOnOversizedEvent(
            reference.pointer,
            _id_setOnOversizedEvent as jni$_.JMethodIDPtr,
            _$onOversizedEventCallback.pointer)
        .check();
  }

  static final _id_isTracingEnabled = _class.instanceMethodId(
    r'isTracingEnabled',
    r'()Z',
  );

  static final _isTracingEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isTracingEnabled()`
  bool isTracingEnabled() {
    return _isTracingEnabled(
            reference.pointer, _id_isTracingEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getIgnoredExceptionsForType = _class.instanceMethodId(
    r'getIgnoredExceptionsForType',
    r'()Ljava/util/Set;',
  );

  static final _getIgnoredExceptionsForType =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public java.util.Set<java.lang.Class<? extends java.lang.Throwable>> getIgnoredExceptionsForType()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<jni$_.JObject?> getIgnoredExceptionsForType() {
    return _getIgnoredExceptionsForType(reference.pointer,
            _id_getIgnoredExceptionsForType as jni$_.JMethodIDPtr)
        .object<jni$_.JSet<jni$_.JObject?>>(
            const jni$_.JSetType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_addIgnoredExceptionForType = _class.instanceMethodId(
    r'addIgnoredExceptionForType',
    r'(Ljava/lang/Class;)V',
  );

  static final _addIgnoredExceptionForType =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addIgnoredExceptionForType(java.lang.Class<? extends java.lang.Throwable> class)`
  void addIgnoredExceptionForType(
    jni$_.JObject class$,
  ) {
    final _$class$ = class$.reference;
    _addIgnoredExceptionForType(
            reference.pointer,
            _id_addIgnoredExceptionForType as jni$_.JMethodIDPtr,
            _$class$.pointer)
        .check();
  }

  static final _id_getIgnoredErrors = _class.instanceMethodId(
    r'getIgnoredErrors',
    r'()Ljava/util/List;',
  );

  static final _getIgnoredErrors = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<io.sentry.FilterString> getIgnoredErrors()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getIgnoredErrors() {
    return _getIgnoredErrors(
            reference.pointer, _id_getIgnoredErrors as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_setIgnoredErrors = _class.instanceMethodId(
    r'setIgnoredErrors',
    r'(Ljava/util/List;)V',
  );

  static final _setIgnoredErrors = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setIgnoredErrors(java.util.List<java.lang.String> list)`
  void setIgnoredErrors(
    jni$_.JList<jni$_.JString?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    _setIgnoredErrors(reference.pointer,
            _id_setIgnoredErrors as jni$_.JMethodIDPtr, _$list.pointer)
        .check();
  }

  static final _id_addIgnoredError = _class.instanceMethodId(
    r'addIgnoredError',
    r'(Ljava/lang/String;)V',
  );

  static final _addIgnoredError = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addIgnoredError(java.lang.String string)`
  void addIgnoredError(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _addIgnoredError(reference.pointer,
            _id_addIgnoredError as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_getMaxSpans = _class.instanceMethodId(
    r'getMaxSpans',
    r'()I',
  );

  static final _getMaxSpans = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getMaxSpans()`
  int getMaxSpans() {
    return _getMaxSpans(
            reference.pointer, _id_getMaxSpans as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_setMaxSpans = _class.instanceMethodId(
    r'setMaxSpans',
    r'(I)V',
  );

  static final _setMaxSpans = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setMaxSpans(int i)`
  void setMaxSpans(
    int i,
  ) {
    _setMaxSpans(reference.pointer, _id_setMaxSpans as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_isEnableShutdownHook = _class.instanceMethodId(
    r'isEnableShutdownHook',
    r'()Z',
  );

  static final _isEnableShutdownHook = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEnableShutdownHook()`
  bool isEnableShutdownHook() {
    return _isEnableShutdownHook(
            reference.pointer, _id_isEnableShutdownHook as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableShutdownHook = _class.instanceMethodId(
    r'setEnableShutdownHook',
    r'(Z)V',
  );

  static final _setEnableShutdownHook = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableShutdownHook(boolean z)`
  void setEnableShutdownHook(
    bool z,
  ) {
    _setEnableShutdownHook(reference.pointer,
            _id_setEnableShutdownHook as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getMaxCacheItems = _class.instanceMethodId(
    r'getMaxCacheItems',
    r'()I',
  );

  static final _getMaxCacheItems = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getMaxCacheItems()`
  int getMaxCacheItems() {
    return _getMaxCacheItems(
            reference.pointer, _id_getMaxCacheItems as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_setMaxCacheItems = _class.instanceMethodId(
    r'setMaxCacheItems',
    r'(I)V',
  );

  static final _setMaxCacheItems = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setMaxCacheItems(int i)`
  void setMaxCacheItems(
    int i,
  ) {
    _setMaxCacheItems(
            reference.pointer, _id_setMaxCacheItems as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_getMaxRequestBodySize = _class.instanceMethodId(
    r'getMaxRequestBodySize',
    r'()Lio/sentry/SentryOptions$RequestSize;',
  );

  static final _getMaxRequestBodySize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryOptions$RequestSize getMaxRequestBodySize()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryOptions$RequestSize getMaxRequestBodySize() {
    return _getMaxRequestBodySize(
            reference.pointer, _id_getMaxRequestBodySize as jni$_.JMethodIDPtr)
        .object<SentryOptions$RequestSize>(
            const $SentryOptions$RequestSize$Type());
  }

  static final _id_setMaxRequestBodySize = _class.instanceMethodId(
    r'setMaxRequestBodySize',
    r'(Lio/sentry/SentryOptions$RequestSize;)V',
  );

  static final _setMaxRequestBodySize = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setMaxRequestBodySize(io.sentry.SentryOptions$RequestSize requestSize)`
  void setMaxRequestBodySize(
    SentryOptions$RequestSize requestSize,
  ) {
    final _$requestSize = requestSize.reference;
    _setMaxRequestBodySize(
            reference.pointer,
            _id_setMaxRequestBodySize as jni$_.JMethodIDPtr,
            _$requestSize.pointer)
        .check();
  }

  static final _id_isTraceSampling = _class.instanceMethodId(
    r'isTraceSampling',
    r'()Z',
  );

  static final _isTraceSampling = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isTraceSampling()`
  bool isTraceSampling() {
    return _isTraceSampling(
            reference.pointer, _id_isTraceSampling as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setTraceSampling = _class.instanceMethodId(
    r'setTraceSampling',
    r'(Z)V',
  );

  static final _setTraceSampling = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setTraceSampling(boolean z)`
  void setTraceSampling(
    bool z,
  ) {
    _setTraceSampling(reference.pointer,
            _id_setTraceSampling as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getMaxTraceFileSize = _class.instanceMethodId(
    r'getMaxTraceFileSize',
    r'()J',
  );

  static final _getMaxTraceFileSize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long getMaxTraceFileSize()`
  int getMaxTraceFileSize() {
    return _getMaxTraceFileSize(
            reference.pointer, _id_getMaxTraceFileSize as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_setMaxTraceFileSize = _class.instanceMethodId(
    r'setMaxTraceFileSize',
    r'(J)V',
  );

  static final _setMaxTraceFileSize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setMaxTraceFileSize(long j)`
  void setMaxTraceFileSize(
    int j,
  ) {
    _setMaxTraceFileSize(
            reference.pointer, _id_setMaxTraceFileSize as jni$_.JMethodIDPtr, j)
        .check();
  }

  static final _id_getTransactionProfiler = _class.instanceMethodId(
    r'getTransactionProfiler',
    r'()Lio/sentry/ITransactionProfiler;',
  );

  static final _getTransactionProfiler = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ITransactionProfiler getTransactionProfiler()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getTransactionProfiler() {
    return _getTransactionProfiler(
            reference.pointer, _id_getTransactionProfiler as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setTransactionProfiler = _class.instanceMethodId(
    r'setTransactionProfiler',
    r'(Lio/sentry/ITransactionProfiler;)V',
  );

  static final _setTransactionProfiler = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTransactionProfiler(io.sentry.ITransactionProfiler iTransactionProfiler)`
  void setTransactionProfiler(
    jni$_.JObject? iTransactionProfiler,
  ) {
    final _$iTransactionProfiler =
        iTransactionProfiler?.reference ?? jni$_.jNullReference;
    _setTransactionProfiler(
            reference.pointer,
            _id_setTransactionProfiler as jni$_.JMethodIDPtr,
            _$iTransactionProfiler.pointer)
        .check();
  }

  static final _id_getContinuousProfiler = _class.instanceMethodId(
    r'getContinuousProfiler',
    r'()Lio/sentry/IContinuousProfiler;',
  );

  static final _getContinuousProfiler = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.IContinuousProfiler getContinuousProfiler()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getContinuousProfiler() {
    return _getContinuousProfiler(
            reference.pointer, _id_getContinuousProfiler as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setContinuousProfiler = _class.instanceMethodId(
    r'setContinuousProfiler',
    r'(Lio/sentry/IContinuousProfiler;)V',
  );

  static final _setContinuousProfiler = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setContinuousProfiler(io.sentry.IContinuousProfiler iContinuousProfiler)`
  void setContinuousProfiler(
    jni$_.JObject? iContinuousProfiler,
  ) {
    final _$iContinuousProfiler =
        iContinuousProfiler?.reference ?? jni$_.jNullReference;
    _setContinuousProfiler(
            reference.pointer,
            _id_setContinuousProfiler as jni$_.JMethodIDPtr,
            _$iContinuousProfiler.pointer)
        .check();
  }

  static final _id_isProfilingEnabled = _class.instanceMethodId(
    r'isProfilingEnabled',
    r'()Z',
  );

  static final _isProfilingEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isProfilingEnabled()`
  bool isProfilingEnabled() {
    return _isProfilingEnabled(
            reference.pointer, _id_isProfilingEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_isContinuousProfilingEnabled = _class.instanceMethodId(
    r'isContinuousProfilingEnabled',
    r'()Z',
  );

  static final _isContinuousProfilingEnabled =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isContinuousProfilingEnabled()`
  bool isContinuousProfilingEnabled() {
    return _isContinuousProfilingEnabled(reference.pointer,
            _id_isContinuousProfilingEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getProfilesSampler = _class.instanceMethodId(
    r'getProfilesSampler',
    r'()Lio/sentry/SentryOptions$ProfilesSamplerCallback;',
  );

  static final _getProfilesSampler = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryOptions$ProfilesSamplerCallback getProfilesSampler()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryOptions$ProfilesSamplerCallback? getProfilesSampler() {
    return _getProfilesSampler(
            reference.pointer, _id_getProfilesSampler as jni$_.JMethodIDPtr)
        .object<SentryOptions$ProfilesSamplerCallback?>(
            const $SentryOptions$ProfilesSamplerCallback$NullableType());
  }

  static final _id_setProfilesSampler = _class.instanceMethodId(
    r'setProfilesSampler',
    r'(Lio/sentry/SentryOptions$ProfilesSamplerCallback;)V',
  );

  static final _setProfilesSampler = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setProfilesSampler(io.sentry.SentryOptions$ProfilesSamplerCallback profilesSamplerCallback)`
  void setProfilesSampler(
    SentryOptions$ProfilesSamplerCallback? profilesSamplerCallback,
  ) {
    final _$profilesSamplerCallback =
        profilesSamplerCallback?.reference ?? jni$_.jNullReference;
    _setProfilesSampler(
            reference.pointer,
            _id_setProfilesSampler as jni$_.JMethodIDPtr,
            _$profilesSamplerCallback.pointer)
        .check();
  }

  static final _id_getProfilesSampleRate = _class.instanceMethodId(
    r'getProfilesSampleRate',
    r'()Ljava/lang/Double;',
  );

  static final _getProfilesSampleRate = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Double getProfilesSampleRate()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? getProfilesSampleRate() {
    return _getProfilesSampleRate(
            reference.pointer, _id_getProfilesSampleRate as jni$_.JMethodIDPtr)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_setProfilesSampleRate = _class.instanceMethodId(
    r'setProfilesSampleRate',
    r'(Ljava/lang/Double;)V',
  );

  static final _setProfilesSampleRate = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setProfilesSampleRate(java.lang.Double double)`
  void setProfilesSampleRate(
    jni$_.JDouble? double,
  ) {
    final _$double = double?.reference ?? jni$_.jNullReference;
    _setProfilesSampleRate(reference.pointer,
            _id_setProfilesSampleRate as jni$_.JMethodIDPtr, _$double.pointer)
        .check();
  }

  static final _id_getProfileSessionSampleRate = _class.instanceMethodId(
    r'getProfileSessionSampleRate',
    r'()Ljava/lang/Double;',
  );

  static final _getProfileSessionSampleRate =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public java.lang.Double getProfileSessionSampleRate()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? getProfileSessionSampleRate() {
    return _getProfileSessionSampleRate(reference.pointer,
            _id_getProfileSessionSampleRate as jni$_.JMethodIDPtr)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_setProfileSessionSampleRate = _class.instanceMethodId(
    r'setProfileSessionSampleRate',
    r'(Ljava/lang/Double;)V',
  );

  static final _setProfileSessionSampleRate =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setProfileSessionSampleRate(java.lang.Double double)`
  void setProfileSessionSampleRate(
    jni$_.JDouble? double,
  ) {
    final _$double = double?.reference ?? jni$_.jNullReference;
    _setProfileSessionSampleRate(
            reference.pointer,
            _id_setProfileSessionSampleRate as jni$_.JMethodIDPtr,
            _$double.pointer)
        .check();
  }

  static final _id_getProfileLifecycle = _class.instanceMethodId(
    r'getProfileLifecycle',
    r'()Lio/sentry/ProfileLifecycle;',
  );

  static final _getProfileLifecycle = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ProfileLifecycle getProfileLifecycle()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getProfileLifecycle() {
    return _getProfileLifecycle(
            reference.pointer, _id_getProfileLifecycle as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setProfileLifecycle = _class.instanceMethodId(
    r'setProfileLifecycle',
    r'(Lio/sentry/ProfileLifecycle;)V',
  );

  static final _setProfileLifecycle = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setProfileLifecycle(io.sentry.ProfileLifecycle profileLifecycle)`
  void setProfileLifecycle(
    jni$_.JObject profileLifecycle,
  ) {
    final _$profileLifecycle = profileLifecycle.reference;
    _setProfileLifecycle(
            reference.pointer,
            _id_setProfileLifecycle as jni$_.JMethodIDPtr,
            _$profileLifecycle.pointer)
        .check();
  }

  static final _id_isStartProfilerOnAppStart = _class.instanceMethodId(
    r'isStartProfilerOnAppStart',
    r'()Z',
  );

  static final _isStartProfilerOnAppStart = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isStartProfilerOnAppStart()`
  bool isStartProfilerOnAppStart() {
    return _isStartProfilerOnAppStart(reference.pointer,
            _id_isStartProfilerOnAppStart as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setStartProfilerOnAppStart = _class.instanceMethodId(
    r'setStartProfilerOnAppStart',
    r'(Z)V',
  );

  static final _setStartProfilerOnAppStart =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setStartProfilerOnAppStart(boolean z)`
  void setStartProfilerOnAppStart(
    bool z,
  ) {
    _setStartProfilerOnAppStart(reference.pointer,
            _id_setStartProfilerOnAppStart as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getDeadlineTimeout = _class.instanceMethodId(
    r'getDeadlineTimeout',
    r'()J',
  );

  static final _getDeadlineTimeout = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long getDeadlineTimeout()`
  int getDeadlineTimeout() {
    return _getDeadlineTimeout(
            reference.pointer, _id_getDeadlineTimeout as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_setDeadlineTimeout = _class.instanceMethodId(
    r'setDeadlineTimeout',
    r'(J)V',
  );

  static final _setDeadlineTimeout = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setDeadlineTimeout(long j)`
  void setDeadlineTimeout(
    int j,
  ) {
    _setDeadlineTimeout(
            reference.pointer, _id_setDeadlineTimeout as jni$_.JMethodIDPtr, j)
        .check();
  }

  static final _id_getProfilingTracesDirPath = _class.instanceMethodId(
    r'getProfilingTracesDirPath',
    r'()Ljava/lang/String;',
  );

  static final _getProfilingTracesDirPath = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getProfilingTracesDirPath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getProfilingTracesDirPath() {
    return _getProfilingTracesDirPath(reference.pointer,
            _id_getProfilingTracesDirPath as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setProfilingTracesDirPath = _class.instanceMethodId(
    r'setProfilingTracesDirPath',
    r'(Ljava/lang/String;)V',
  );

  static final _setProfilingTracesDirPath = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setProfilingTracesDirPath(java.lang.String string)`
  void setProfilingTracesDirPath(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setProfilingTracesDirPath(
            reference.pointer,
            _id_setProfilingTracesDirPath as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getTracePropagationTargets = _class.instanceMethodId(
    r'getTracePropagationTargets',
    r'()Ljava/util/List;',
  );

  static final _getTracePropagationTargets =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public java.util.List<java.lang.String> getTracePropagationTargets()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?> getTracePropagationTargets() {
    return _getTracePropagationTargets(reference.pointer,
            _id_getTracePropagationTargets as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>>(
            const jni$_.JListType<jni$_.JString?>(jni$_.JStringNullableType()));
  }

  static final _id_setTracePropagationTargets = _class.instanceMethodId(
    r'setTracePropagationTargets',
    r'(Ljava/util/List;)V',
  );

  static final _setTracePropagationTargets =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTracePropagationTargets(java.util.List<java.lang.String> list)`
  void setTracePropagationTargets(
    jni$_.JList<jni$_.JString?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    _setTracePropagationTargets(
            reference.pointer,
            _id_setTracePropagationTargets as jni$_.JMethodIDPtr,
            _$list.pointer)
        .check();
  }

  static final _id_isPropagateTraceparent = _class.instanceMethodId(
    r'isPropagateTraceparent',
    r'()Z',
  );

  static final _isPropagateTraceparent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isPropagateTraceparent()`
  bool isPropagateTraceparent() {
    return _isPropagateTraceparent(
            reference.pointer, _id_isPropagateTraceparent as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setPropagateTraceparent = _class.instanceMethodId(
    r'setPropagateTraceparent',
    r'(Z)V',
  );

  static final _setPropagateTraceparent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setPropagateTraceparent(boolean z)`
  void setPropagateTraceparent(
    bool z,
  ) {
    _setPropagateTraceparent(reference.pointer,
            _id_setPropagateTraceparent as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getProguardUuid = _class.instanceMethodId(
    r'getProguardUuid',
    r'()Ljava/lang/String;',
  );

  static final _getProguardUuid = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getProguardUuid()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getProguardUuid() {
    return _getProguardUuid(
            reference.pointer, _id_getProguardUuid as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setProguardUuid = _class.instanceMethodId(
    r'setProguardUuid',
    r'(Ljava/lang/String;)V',
  );

  static final _setProguardUuid = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setProguardUuid(java.lang.String string)`
  void setProguardUuid(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setProguardUuid(reference.pointer,
            _id_setProguardUuid as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_addBundleId = _class.instanceMethodId(
    r'addBundleId',
    r'(Ljava/lang/String;)V',
  );

  static final _addBundleId = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addBundleId(java.lang.String string)`
  void addBundleId(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _addBundleId(reference.pointer, _id_addBundleId as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getBundleIds = _class.instanceMethodId(
    r'getBundleIds',
    r'()Ljava/util/Set;',
  );

  static final _getBundleIds = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Set<java.lang.String> getBundleIds()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<jni$_.JString?> getBundleIds() {
    return _getBundleIds(
            reference.pointer, _id_getBundleIds as jni$_.JMethodIDPtr)
        .object<jni$_.JSet<jni$_.JString?>>(
            const jni$_.JSetType<jni$_.JString?>(jni$_.JStringNullableType()));
  }

  static final _id_getContextTags = _class.instanceMethodId(
    r'getContextTags',
    r'()Ljava/util/List;',
  );

  static final _getContextTags = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<java.lang.String> getContextTags()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?> getContextTags() {
    return _getContextTags(
            reference.pointer, _id_getContextTags as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>>(
            const jni$_.JListType<jni$_.JString?>(jni$_.JStringNullableType()));
  }

  static final _id_addContextTag = _class.instanceMethodId(
    r'addContextTag',
    r'(Ljava/lang/String;)V',
  );

  static final _addContextTag = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addContextTag(java.lang.String string)`
  void addContextTag(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _addContextTag(reference.pointer, _id_addContextTag as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getIdleTimeout = _class.instanceMethodId(
    r'getIdleTimeout',
    r'()Ljava/lang/Long;',
  );

  static final _getIdleTimeout = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Long getIdleTimeout()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getIdleTimeout() {
    return _getIdleTimeout(
            reference.pointer, _id_getIdleTimeout as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_setIdleTimeout = _class.instanceMethodId(
    r'setIdleTimeout',
    r'(Ljava/lang/Long;)V',
  );

  static final _setIdleTimeout = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setIdleTimeout(java.lang.Long long)`
  void setIdleTimeout(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    _setIdleTimeout(reference.pointer, _id_setIdleTimeout as jni$_.JMethodIDPtr,
            _$long.pointer)
        .check();
  }

  static final _id_isSendClientReports = _class.instanceMethodId(
    r'isSendClientReports',
    r'()Z',
  );

  static final _isSendClientReports = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isSendClientReports()`
  bool isSendClientReports() {
    return _isSendClientReports(
            reference.pointer, _id_isSendClientReports as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setSendClientReports = _class.instanceMethodId(
    r'setSendClientReports',
    r'(Z)V',
  );

  static final _setSendClientReports = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setSendClientReports(boolean z)`
  void setSendClientReports(
    bool z,
  ) {
    _setSendClientReports(reference.pointer,
            _id_setSendClientReports as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isEnableUserInteractionTracing = _class.instanceMethodId(
    r'isEnableUserInteractionTracing',
    r'()Z',
  );

  static final _isEnableUserInteractionTracing =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEnableUserInteractionTracing()`
  bool isEnableUserInteractionTracing() {
    return _isEnableUserInteractionTracing(reference.pointer,
            _id_isEnableUserInteractionTracing as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableUserInteractionTracing = _class.instanceMethodId(
    r'setEnableUserInteractionTracing',
    r'(Z)V',
  );

  static final _setEnableUserInteractionTracing =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableUserInteractionTracing(boolean z)`
  void setEnableUserInteractionTracing(
    bool z,
  ) {
    _setEnableUserInteractionTracing(
            reference.pointer,
            _id_setEnableUserInteractionTracing as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_isEnableUserInteractionBreadcrumbs = _class.instanceMethodId(
    r'isEnableUserInteractionBreadcrumbs',
    r'()Z',
  );

  static final _isEnableUserInteractionBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEnableUserInteractionBreadcrumbs()`
  bool isEnableUserInteractionBreadcrumbs() {
    return _isEnableUserInteractionBreadcrumbs(reference.pointer,
            _id_isEnableUserInteractionBreadcrumbs as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableUserInteractionBreadcrumbs =
      _class.instanceMethodId(
    r'setEnableUserInteractionBreadcrumbs',
    r'(Z)V',
  );

  static final _setEnableUserInteractionBreadcrumbs =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableUserInteractionBreadcrumbs(boolean z)`
  void setEnableUserInteractionBreadcrumbs(
    bool z,
  ) {
    _setEnableUserInteractionBreadcrumbs(
            reference.pointer,
            _id_setEnableUserInteractionBreadcrumbs as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_setInstrumenter = _class.instanceMethodId(
    r'setInstrumenter',
    r'(Lio/sentry/Instrumenter;)V',
  );

  static final _setInstrumenter = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setInstrumenter(io.sentry.Instrumenter instrumenter)`
  void setInstrumenter(
    jni$_.JObject instrumenter,
  ) {
    final _$instrumenter = instrumenter.reference;
    _setInstrumenter(reference.pointer,
            _id_setInstrumenter as jni$_.JMethodIDPtr, _$instrumenter.pointer)
        .check();
  }

  static final _id_getInstrumenter = _class.instanceMethodId(
    r'getInstrumenter',
    r'()Lio/sentry/Instrumenter;',
  );

  static final _getInstrumenter = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.Instrumenter getInstrumenter()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getInstrumenter() {
    return _getInstrumenter(
            reference.pointer, _id_getInstrumenter as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getClientReportRecorder = _class.instanceMethodId(
    r'getClientReportRecorder',
    r'()Lio/sentry/clientreport/IClientReportRecorder;',
  );

  static final _getClientReportRecorder = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.clientreport.IClientReportRecorder getClientReportRecorder()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getClientReportRecorder() {
    return _getClientReportRecorder(reference.pointer,
            _id_getClientReportRecorder as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getModulesLoader = _class.instanceMethodId(
    r'getModulesLoader',
    r'()Lio/sentry/internal/modules/IModulesLoader;',
  );

  static final _getModulesLoader = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.internal.modules.IModulesLoader getModulesLoader()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getModulesLoader() {
    return _getModulesLoader(
            reference.pointer, _id_getModulesLoader as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setModulesLoader = _class.instanceMethodId(
    r'setModulesLoader',
    r'(Lio/sentry/internal/modules/IModulesLoader;)V',
  );

  static final _setModulesLoader = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setModulesLoader(io.sentry.internal.modules.IModulesLoader iModulesLoader)`
  void setModulesLoader(
    jni$_.JObject? iModulesLoader,
  ) {
    final _$iModulesLoader = iModulesLoader?.reference ?? jni$_.jNullReference;
    _setModulesLoader(
            reference.pointer,
            _id_setModulesLoader as jni$_.JMethodIDPtr,
            _$iModulesLoader.pointer)
        .check();
  }

  static final _id_getDebugMetaLoader = _class.instanceMethodId(
    r'getDebugMetaLoader',
    r'()Lio/sentry/internal/debugmeta/IDebugMetaLoader;',
  );

  static final _getDebugMetaLoader = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.internal.debugmeta.IDebugMetaLoader getDebugMetaLoader()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getDebugMetaLoader() {
    return _getDebugMetaLoader(
            reference.pointer, _id_getDebugMetaLoader as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setDebugMetaLoader = _class.instanceMethodId(
    r'setDebugMetaLoader',
    r'(Lio/sentry/internal/debugmeta/IDebugMetaLoader;)V',
  );

  static final _setDebugMetaLoader = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDebugMetaLoader(io.sentry.internal.debugmeta.IDebugMetaLoader iDebugMetaLoader)`
  void setDebugMetaLoader(
    jni$_.JObject? iDebugMetaLoader,
  ) {
    final _$iDebugMetaLoader =
        iDebugMetaLoader?.reference ?? jni$_.jNullReference;
    _setDebugMetaLoader(
            reference.pointer,
            _id_setDebugMetaLoader as jni$_.JMethodIDPtr,
            _$iDebugMetaLoader.pointer)
        .check();
  }

  static final _id_getGestureTargetLocators = _class.instanceMethodId(
    r'getGestureTargetLocators',
    r'()Ljava/util/List;',
  );

  static final _getGestureTargetLocators = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<io.sentry.internal.gestures.GestureTargetLocator> getGestureTargetLocators()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getGestureTargetLocators() {
    return _getGestureTargetLocators(reference.pointer,
            _id_getGestureTargetLocators as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_setGestureTargetLocators = _class.instanceMethodId(
    r'setGestureTargetLocators',
    r'(Ljava/util/List;)V',
  );

  static final _setGestureTargetLocators = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setGestureTargetLocators(java.util.List<io.sentry.internal.gestures.GestureTargetLocator> list)`
  void setGestureTargetLocators(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    _setGestureTargetLocators(reference.pointer,
            _id_setGestureTargetLocators as jni$_.JMethodIDPtr, _$list.pointer)
        .check();
  }

  static final _id_getViewHierarchyExporters = _class.instanceMethodId(
    r'getViewHierarchyExporters',
    r'()Ljava/util/List;',
  );

  static final _getViewHierarchyExporters = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<io.sentry.internal.viewhierarchy.ViewHierarchyExporter> getViewHierarchyExporters()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getViewHierarchyExporters() {
    return _getViewHierarchyExporters(reference.pointer,
            _id_getViewHierarchyExporters as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_setViewHierarchyExporters = _class.instanceMethodId(
    r'setViewHierarchyExporters',
    r'(Ljava/util/List;)V',
  );

  static final _setViewHierarchyExporters = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setViewHierarchyExporters(java.util.List<io.sentry.internal.viewhierarchy.ViewHierarchyExporter> list)`
  void setViewHierarchyExporters(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    _setViewHierarchyExporters(reference.pointer,
            _id_setViewHierarchyExporters as jni$_.JMethodIDPtr, _$list.pointer)
        .check();
  }

  static final _id_getThreadChecker = _class.instanceMethodId(
    r'getThreadChecker',
    r'()Lio/sentry/util/thread/IThreadChecker;',
  );

  static final _getThreadChecker = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.util.thread.IThreadChecker getThreadChecker()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getThreadChecker() {
    return _getThreadChecker(
            reference.pointer, _id_getThreadChecker as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setThreadChecker = _class.instanceMethodId(
    r'setThreadChecker',
    r'(Lio/sentry/util/thread/IThreadChecker;)V',
  );

  static final _setThreadChecker = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setThreadChecker(io.sentry.util.thread.IThreadChecker iThreadChecker)`
  void setThreadChecker(
    jni$_.JObject iThreadChecker,
  ) {
    final _$iThreadChecker = iThreadChecker.reference;
    _setThreadChecker(
            reference.pointer,
            _id_setThreadChecker as jni$_.JMethodIDPtr,
            _$iThreadChecker.pointer)
        .check();
  }

  static final _id_getCompositePerformanceCollector = _class.instanceMethodId(
    r'getCompositePerformanceCollector',
    r'()Lio/sentry/CompositePerformanceCollector;',
  );

  static final _getCompositePerformanceCollector =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public io.sentry.CompositePerformanceCollector getCompositePerformanceCollector()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getCompositePerformanceCollector() {
    return _getCompositePerformanceCollector(reference.pointer,
            _id_getCompositePerformanceCollector as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setCompositePerformanceCollector = _class.instanceMethodId(
    r'setCompositePerformanceCollector',
    r'(Lio/sentry/CompositePerformanceCollector;)V',
  );

  static final _setCompositePerformanceCollector =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setCompositePerformanceCollector(io.sentry.CompositePerformanceCollector compositePerformanceCollector)`
  void setCompositePerformanceCollector(
    jni$_.JObject compositePerformanceCollector,
  ) {
    final _$compositePerformanceCollector =
        compositePerformanceCollector.reference;
    _setCompositePerformanceCollector(
            reference.pointer,
            _id_setCompositePerformanceCollector as jni$_.JMethodIDPtr,
            _$compositePerformanceCollector.pointer)
        .check();
  }

  static final _id_isEnableTimeToFullDisplayTracing = _class.instanceMethodId(
    r'isEnableTimeToFullDisplayTracing',
    r'()Z',
  );

  static final _isEnableTimeToFullDisplayTracing =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEnableTimeToFullDisplayTracing()`
  bool isEnableTimeToFullDisplayTracing() {
    return _isEnableTimeToFullDisplayTracing(reference.pointer,
            _id_isEnableTimeToFullDisplayTracing as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableTimeToFullDisplayTracing = _class.instanceMethodId(
    r'setEnableTimeToFullDisplayTracing',
    r'(Z)V',
  );

  static final _setEnableTimeToFullDisplayTracing =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableTimeToFullDisplayTracing(boolean z)`
  void setEnableTimeToFullDisplayTracing(
    bool z,
  ) {
    _setEnableTimeToFullDisplayTracing(
            reference.pointer,
            _id_setEnableTimeToFullDisplayTracing as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_getFullyDisplayedReporter = _class.instanceMethodId(
    r'getFullyDisplayedReporter',
    r'()Lio/sentry/FullyDisplayedReporter;',
  );

  static final _getFullyDisplayedReporter = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.FullyDisplayedReporter getFullyDisplayedReporter()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getFullyDisplayedReporter() {
    return _getFullyDisplayedReporter(reference.pointer,
            _id_getFullyDisplayedReporter as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setFullyDisplayedReporter = _class.instanceMethodId(
    r'setFullyDisplayedReporter',
    r'(Lio/sentry/FullyDisplayedReporter;)V',
  );

  static final _setFullyDisplayedReporter = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setFullyDisplayedReporter(io.sentry.FullyDisplayedReporter fullyDisplayedReporter)`
  void setFullyDisplayedReporter(
    jni$_.JObject fullyDisplayedReporter,
  ) {
    final _$fullyDisplayedReporter = fullyDisplayedReporter.reference;
    _setFullyDisplayedReporter(
            reference.pointer,
            _id_setFullyDisplayedReporter as jni$_.JMethodIDPtr,
            _$fullyDisplayedReporter.pointer)
        .check();
  }

  static final _id_isTraceOptionsRequests = _class.instanceMethodId(
    r'isTraceOptionsRequests',
    r'()Z',
  );

  static final _isTraceOptionsRequests = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isTraceOptionsRequests()`
  bool isTraceOptionsRequests() {
    return _isTraceOptionsRequests(
            reference.pointer, _id_isTraceOptionsRequests as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setTraceOptionsRequests = _class.instanceMethodId(
    r'setTraceOptionsRequests',
    r'(Z)V',
  );

  static final _setTraceOptionsRequests = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setTraceOptionsRequests(boolean z)`
  void setTraceOptionsRequests(
    bool z,
  ) {
    _setTraceOptionsRequests(reference.pointer,
            _id_setTraceOptionsRequests as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isEnabled = _class.instanceMethodId(
    r'isEnabled',
    r'()Z',
  );

  static final _isEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEnabled()`
  bool isEnabled() {
    return _isEnabled(reference.pointer, _id_isEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnabled = _class.instanceMethodId(
    r'setEnabled',
    r'(Z)V',
  );

  static final _setEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnabled(boolean z)`
  void setEnabled(
    bool z,
  ) {
    _setEnabled(
            reference.pointer, _id_setEnabled as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isEnablePrettySerializationOutput = _class.instanceMethodId(
    r'isEnablePrettySerializationOutput',
    r'()Z',
  );

  static final _isEnablePrettySerializationOutput =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEnablePrettySerializationOutput()`
  bool isEnablePrettySerializationOutput() {
    return _isEnablePrettySerializationOutput(reference.pointer,
            _id_isEnablePrettySerializationOutput as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_isSendModules = _class.instanceMethodId(
    r'isSendModules',
    r'()Z',
  );

  static final _isSendModules = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isSendModules()`
  bool isSendModules() {
    return _isSendModules(
            reference.pointer, _id_isSendModules as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnablePrettySerializationOutput = _class.instanceMethodId(
    r'setEnablePrettySerializationOutput',
    r'(Z)V',
  );

  static final _setEnablePrettySerializationOutput =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnablePrettySerializationOutput(boolean z)`
  void setEnablePrettySerializationOutput(
    bool z,
  ) {
    _setEnablePrettySerializationOutput(
            reference.pointer,
            _id_setEnablePrettySerializationOutput as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_isEnableAppStartProfiling = _class.instanceMethodId(
    r'isEnableAppStartProfiling',
    r'()Z',
  );

  static final _isEnableAppStartProfiling = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEnableAppStartProfiling()`
  bool isEnableAppStartProfiling() {
    return _isEnableAppStartProfiling(reference.pointer,
            _id_isEnableAppStartProfiling as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableAppStartProfiling = _class.instanceMethodId(
    r'setEnableAppStartProfiling',
    r'(Z)V',
  );

  static final _setEnableAppStartProfiling =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableAppStartProfiling(boolean z)`
  void setEnableAppStartProfiling(
    bool z,
  ) {
    _setEnableAppStartProfiling(reference.pointer,
            _id_setEnableAppStartProfiling as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_setSendModules = _class.instanceMethodId(
    r'setSendModules',
    r'(Z)V',
  );

  static final _setSendModules = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setSendModules(boolean z)`
  void setSendModules(
    bool z,
  ) {
    _setSendModules(reference.pointer, _id_setSendModules as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_getIgnoredSpanOrigins = _class.instanceMethodId(
    r'getIgnoredSpanOrigins',
    r'()Ljava/util/List;',
  );

  static final _getIgnoredSpanOrigins = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<io.sentry.FilterString> getIgnoredSpanOrigins()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getIgnoredSpanOrigins() {
    return _getIgnoredSpanOrigins(
            reference.pointer, _id_getIgnoredSpanOrigins as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_addIgnoredSpanOrigin = _class.instanceMethodId(
    r'addIgnoredSpanOrigin',
    r'(Ljava/lang/String;)V',
  );

  static final _addIgnoredSpanOrigin = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addIgnoredSpanOrigin(java.lang.String string)`
  void addIgnoredSpanOrigin(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _addIgnoredSpanOrigin(reference.pointer,
            _id_addIgnoredSpanOrigin as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_setIgnoredSpanOrigins = _class.instanceMethodId(
    r'setIgnoredSpanOrigins',
    r'(Ljava/util/List;)V',
  );

  static final _setIgnoredSpanOrigins = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setIgnoredSpanOrigins(java.util.List<java.lang.String> list)`
  void setIgnoredSpanOrigins(
    jni$_.JList<jni$_.JString?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    _setIgnoredSpanOrigins(reference.pointer,
            _id_setIgnoredSpanOrigins as jni$_.JMethodIDPtr, _$list.pointer)
        .check();
  }

  static final _id_getIgnoredCheckIns = _class.instanceMethodId(
    r'getIgnoredCheckIns',
    r'()Ljava/util/List;',
  );

  static final _getIgnoredCheckIns = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<io.sentry.FilterString> getIgnoredCheckIns()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getIgnoredCheckIns() {
    return _getIgnoredCheckIns(
            reference.pointer, _id_getIgnoredCheckIns as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_addIgnoredCheckIn = _class.instanceMethodId(
    r'addIgnoredCheckIn',
    r'(Ljava/lang/String;)V',
  );

  static final _addIgnoredCheckIn = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addIgnoredCheckIn(java.lang.String string)`
  void addIgnoredCheckIn(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _addIgnoredCheckIn(reference.pointer,
            _id_addIgnoredCheckIn as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_setIgnoredCheckIns = _class.instanceMethodId(
    r'setIgnoredCheckIns',
    r'(Ljava/util/List;)V',
  );

  static final _setIgnoredCheckIns = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setIgnoredCheckIns(java.util.List<java.lang.String> list)`
  void setIgnoredCheckIns(
    jni$_.JList<jni$_.JString?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    _setIgnoredCheckIns(reference.pointer,
            _id_setIgnoredCheckIns as jni$_.JMethodIDPtr, _$list.pointer)
        .check();
  }

  static final _id_getIgnoredTransactions = _class.instanceMethodId(
    r'getIgnoredTransactions',
    r'()Ljava/util/List;',
  );

  static final _getIgnoredTransactions = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<io.sentry.FilterString> getIgnoredTransactions()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getIgnoredTransactions() {
    return _getIgnoredTransactions(
            reference.pointer, _id_getIgnoredTransactions as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_addIgnoredTransaction = _class.instanceMethodId(
    r'addIgnoredTransaction',
    r'(Ljava/lang/String;)V',
  );

  static final _addIgnoredTransaction = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addIgnoredTransaction(java.lang.String string)`
  void addIgnoredTransaction(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _addIgnoredTransaction(reference.pointer,
            _id_addIgnoredTransaction as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_setIgnoredTransactions = _class.instanceMethodId(
    r'setIgnoredTransactions',
    r'(Ljava/util/List;)V',
  );

  static final _setIgnoredTransactions = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setIgnoredTransactions(java.util.List<java.lang.String> list)`
  void setIgnoredTransactions(
    jni$_.JList<jni$_.JString?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    _setIgnoredTransactions(reference.pointer,
            _id_setIgnoredTransactions as jni$_.JMethodIDPtr, _$list.pointer)
        .check();
  }

  static final _id_getDateProvider = _class.instanceMethodId(
    r'getDateProvider',
    r'()Lio/sentry/SentryDateProvider;',
  );

  static final _getDateProvider = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryDateProvider getDateProvider()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getDateProvider() {
    return _getDateProvider(
            reference.pointer, _id_getDateProvider as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setDateProvider = _class.instanceMethodId(
    r'setDateProvider',
    r'(Lio/sentry/SentryDateProvider;)V',
  );

  static final _setDateProvider = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDateProvider(io.sentry.SentryDateProvider sentryDateProvider)`
  void setDateProvider(
    jni$_.JObject sentryDateProvider,
  ) {
    final _$sentryDateProvider = sentryDateProvider.reference;
    _setDateProvider(
            reference.pointer,
            _id_setDateProvider as jni$_.JMethodIDPtr,
            _$sentryDateProvider.pointer)
        .check();
  }

  static final _id_addPerformanceCollector = _class.instanceMethodId(
    r'addPerformanceCollector',
    r'(Lio/sentry/IPerformanceCollector;)V',
  );

  static final _addPerformanceCollector = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addPerformanceCollector(io.sentry.IPerformanceCollector iPerformanceCollector)`
  void addPerformanceCollector(
    jni$_.JObject iPerformanceCollector,
  ) {
    final _$iPerformanceCollector = iPerformanceCollector.reference;
    _addPerformanceCollector(
            reference.pointer,
            _id_addPerformanceCollector as jni$_.JMethodIDPtr,
            _$iPerformanceCollector.pointer)
        .check();
  }

  static final _id_getPerformanceCollectors = _class.instanceMethodId(
    r'getPerformanceCollectors',
    r'()Ljava/util/List;',
  );

  static final _getPerformanceCollectors = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<io.sentry.IPerformanceCollector> getPerformanceCollectors()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getPerformanceCollectors() {
    return _getPerformanceCollectors(reference.pointer,
            _id_getPerformanceCollectors as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_getConnectionStatusProvider = _class.instanceMethodId(
    r'getConnectionStatusProvider',
    r'()Lio/sentry/IConnectionStatusProvider;',
  );

  static final _getConnectionStatusProvider =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public io.sentry.IConnectionStatusProvider getConnectionStatusProvider()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getConnectionStatusProvider() {
    return _getConnectionStatusProvider(reference.pointer,
            _id_getConnectionStatusProvider as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setConnectionStatusProvider = _class.instanceMethodId(
    r'setConnectionStatusProvider',
    r'(Lio/sentry/IConnectionStatusProvider;)V',
  );

  static final _setConnectionStatusProvider =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setConnectionStatusProvider(io.sentry.IConnectionStatusProvider iConnectionStatusProvider)`
  void setConnectionStatusProvider(
    jni$_.JObject iConnectionStatusProvider,
  ) {
    final _$iConnectionStatusProvider = iConnectionStatusProvider.reference;
    _setConnectionStatusProvider(
            reference.pointer,
            _id_setConnectionStatusProvider as jni$_.JMethodIDPtr,
            _$iConnectionStatusProvider.pointer)
        .check();
  }

  static final _id_getBackpressureMonitor = _class.instanceMethodId(
    r'getBackpressureMonitor',
    r'()Lio/sentry/backpressure/IBackpressureMonitor;',
  );

  static final _getBackpressureMonitor = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.backpressure.IBackpressureMonitor getBackpressureMonitor()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getBackpressureMonitor() {
    return _getBackpressureMonitor(
            reference.pointer, _id_getBackpressureMonitor as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setBackpressureMonitor = _class.instanceMethodId(
    r'setBackpressureMonitor',
    r'(Lio/sentry/backpressure/IBackpressureMonitor;)V',
  );

  static final _setBackpressureMonitor = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setBackpressureMonitor(io.sentry.backpressure.IBackpressureMonitor iBackpressureMonitor)`
  void setBackpressureMonitor(
    jni$_.JObject iBackpressureMonitor,
  ) {
    final _$iBackpressureMonitor = iBackpressureMonitor.reference;
    _setBackpressureMonitor(
            reference.pointer,
            _id_setBackpressureMonitor as jni$_.JMethodIDPtr,
            _$iBackpressureMonitor.pointer)
        .check();
  }

  static final _id_setEnableBackpressureHandling = _class.instanceMethodId(
    r'setEnableBackpressureHandling',
    r'(Z)V',
  );

  static final _setEnableBackpressureHandling =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableBackpressureHandling(boolean z)`
  void setEnableBackpressureHandling(
    bool z,
  ) {
    _setEnableBackpressureHandling(reference.pointer,
            _id_setEnableBackpressureHandling as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getVersionDetector = _class.instanceMethodId(
    r'getVersionDetector',
    r'()Lio/sentry/IVersionDetector;',
  );

  static final _getVersionDetector = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.IVersionDetector getVersionDetector()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getVersionDetector() {
    return _getVersionDetector(
            reference.pointer, _id_getVersionDetector as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setVersionDetector = _class.instanceMethodId(
    r'setVersionDetector',
    r'(Lio/sentry/IVersionDetector;)V',
  );

  static final _setVersionDetector = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setVersionDetector(io.sentry.IVersionDetector iVersionDetector)`
  void setVersionDetector(
    jni$_.JObject iVersionDetector,
  ) {
    final _$iVersionDetector = iVersionDetector.reference;
    _setVersionDetector(
            reference.pointer,
            _id_setVersionDetector as jni$_.JMethodIDPtr,
            _$iVersionDetector.pointer)
        .check();
  }

  static final _id_getProfilingTracesHz = _class.instanceMethodId(
    r'getProfilingTracesHz',
    r'()I',
  );

  static final _getProfilingTracesHz = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getProfilingTracesHz()`
  int getProfilingTracesHz() {
    return _getProfilingTracesHz(
            reference.pointer, _id_getProfilingTracesHz as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_setProfilingTracesHz = _class.instanceMethodId(
    r'setProfilingTracesHz',
    r'(I)V',
  );

  static final _setProfilingTracesHz = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setProfilingTracesHz(int i)`
  void setProfilingTracesHz(
    int i,
  ) {
    _setProfilingTracesHz(reference.pointer,
            _id_setProfilingTracesHz as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_isEnableBackpressureHandling = _class.instanceMethodId(
    r'isEnableBackpressureHandling',
    r'()Z',
  );

  static final _isEnableBackpressureHandling =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEnableBackpressureHandling()`
  bool isEnableBackpressureHandling() {
    return _isEnableBackpressureHandling(reference.pointer,
            _id_isEnableBackpressureHandling as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getSessionFlushTimeoutMillis = _class.instanceMethodId(
    r'getSessionFlushTimeoutMillis',
    r'()J',
  );

  static final _getSessionFlushTimeoutMillis =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallLongMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public long getSessionFlushTimeoutMillis()`
  int getSessionFlushTimeoutMillis() {
    return _getSessionFlushTimeoutMillis(reference.pointer,
            _id_getSessionFlushTimeoutMillis as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_setSessionFlushTimeoutMillis = _class.instanceMethodId(
    r'setSessionFlushTimeoutMillis',
    r'(J)V',
  );

  static final _setSessionFlushTimeoutMillis =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setSessionFlushTimeoutMillis(long j)`
  void setSessionFlushTimeoutMillis(
    int j,
  ) {
    _setSessionFlushTimeoutMillis(reference.pointer,
            _id_setSessionFlushTimeoutMillis as jni$_.JMethodIDPtr, j)
        .check();
  }

  static final _id_getBeforeEnvelopeCallback = _class.instanceMethodId(
    r'getBeforeEnvelopeCallback',
    r'()Lio/sentry/SentryOptions$BeforeEnvelopeCallback;',
  );

  static final _getBeforeEnvelopeCallback = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryOptions$BeforeEnvelopeCallback getBeforeEnvelopeCallback()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryOptions$BeforeEnvelopeCallback? getBeforeEnvelopeCallback() {
    return _getBeforeEnvelopeCallback(reference.pointer,
            _id_getBeforeEnvelopeCallback as jni$_.JMethodIDPtr)
        .object<SentryOptions$BeforeEnvelopeCallback?>(
            const $SentryOptions$BeforeEnvelopeCallback$NullableType());
  }

  static final _id_setBeforeEnvelopeCallback = _class.instanceMethodId(
    r'setBeforeEnvelopeCallback',
    r'(Lio/sentry/SentryOptions$BeforeEnvelopeCallback;)V',
  );

  static final _setBeforeEnvelopeCallback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setBeforeEnvelopeCallback(io.sentry.SentryOptions$BeforeEnvelopeCallback beforeEnvelopeCallback)`
  void setBeforeEnvelopeCallback(
    SentryOptions$BeforeEnvelopeCallback? beforeEnvelopeCallback,
  ) {
    final _$beforeEnvelopeCallback =
        beforeEnvelopeCallback?.reference ?? jni$_.jNullReference;
    _setBeforeEnvelopeCallback(
            reference.pointer,
            _id_setBeforeEnvelopeCallback as jni$_.JMethodIDPtr,
            _$beforeEnvelopeCallback.pointer)
        .check();
  }

  static final _id_getSpotlightConnectionUrl = _class.instanceMethodId(
    r'getSpotlightConnectionUrl',
    r'()Ljava/lang/String;',
  );

  static final _getSpotlightConnectionUrl = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getSpotlightConnectionUrl()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getSpotlightConnectionUrl() {
    return _getSpotlightConnectionUrl(reference.pointer,
            _id_getSpotlightConnectionUrl as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setSpotlightConnectionUrl = _class.instanceMethodId(
    r'setSpotlightConnectionUrl',
    r'(Ljava/lang/String;)V',
  );

  static final _setSpotlightConnectionUrl = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setSpotlightConnectionUrl(java.lang.String string)`
  void setSpotlightConnectionUrl(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setSpotlightConnectionUrl(
            reference.pointer,
            _id_setSpotlightConnectionUrl as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_isEnableSpotlight = _class.instanceMethodId(
    r'isEnableSpotlight',
    r'()Z',
  );

  static final _isEnableSpotlight = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEnableSpotlight()`
  bool isEnableSpotlight() {
    return _isEnableSpotlight(
            reference.pointer, _id_isEnableSpotlight as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableSpotlight = _class.instanceMethodId(
    r'setEnableSpotlight',
    r'(Z)V',
  );

  static final _setEnableSpotlight = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableSpotlight(boolean z)`
  void setEnableSpotlight(
    bool z,
  ) {
    _setEnableSpotlight(reference.pointer,
            _id_setEnableSpotlight as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isEnableScopePersistence = _class.instanceMethodId(
    r'isEnableScopePersistence',
    r'()Z',
  );

  static final _isEnableScopePersistence = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEnableScopePersistence()`
  bool isEnableScopePersistence() {
    return _isEnableScopePersistence(reference.pointer,
            _id_isEnableScopePersistence as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableScopePersistence = _class.instanceMethodId(
    r'setEnableScopePersistence',
    r'(Z)V',
  );

  static final _setEnableScopePersistence = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableScopePersistence(boolean z)`
  void setEnableScopePersistence(
    bool z,
  ) {
    _setEnableScopePersistence(reference.pointer,
            _id_setEnableScopePersistence as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getCron = _class.instanceMethodId(
    r'getCron',
    r'()Lio/sentry/SentryOptions$Cron;',
  );

  static final _getCron = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryOptions$Cron getCron()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryOptions$Cron? getCron() {
    return _getCron(reference.pointer, _id_getCron as jni$_.JMethodIDPtr)
        .object<SentryOptions$Cron?>(const $SentryOptions$Cron$NullableType());
  }

  static final _id_setCron = _class.instanceMethodId(
    r'setCron',
    r'(Lio/sentry/SentryOptions$Cron;)V',
  );

  static final _setCron = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setCron(io.sentry.SentryOptions$Cron cron)`
  void setCron(
    SentryOptions$Cron? cron,
  ) {
    final _$cron = cron?.reference ?? jni$_.jNullReference;
    _setCron(reference.pointer, _id_setCron as jni$_.JMethodIDPtr,
            _$cron.pointer)
        .check();
  }

  static final _id_getExperimental = _class.instanceMethodId(
    r'getExperimental',
    r'()Lio/sentry/ExperimentalOptions;',
  );

  static final _getExperimental = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ExperimentalOptions getExperimental()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getExperimental() {
    return _getExperimental(
            reference.pointer, _id_getExperimental as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getReplayController = _class.instanceMethodId(
    r'getReplayController',
    r'()Lio/sentry/ReplayController;',
  );

  static final _getReplayController = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ReplayController getReplayController()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getReplayController() {
    return _getReplayController(
            reference.pointer, _id_getReplayController as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setReplayController = _class.instanceMethodId(
    r'setReplayController',
    r'(Lio/sentry/ReplayController;)V',
  );

  static final _setReplayController = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setReplayController(io.sentry.ReplayController replayController)`
  void setReplayController(
    jni$_.JObject? replayController,
  ) {
    final _$replayController =
        replayController?.reference ?? jni$_.jNullReference;
    _setReplayController(
            reference.pointer,
            _id_setReplayController as jni$_.JMethodIDPtr,
            _$replayController.pointer)
        .check();
  }

  static final _id_getDistributionController = _class.instanceMethodId(
    r'getDistributionController',
    r'()Lio/sentry/IDistributionApi;',
  );

  static final _getDistributionController = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.IDistributionApi getDistributionController()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getDistributionController() {
    return _getDistributionController(reference.pointer,
            _id_getDistributionController as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setDistributionController = _class.instanceMethodId(
    r'setDistributionController',
    r'(Lio/sentry/IDistributionApi;)V',
  );

  static final _setDistributionController = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDistributionController(io.sentry.IDistributionApi iDistributionApi)`
  void setDistributionController(
    jni$_.JObject? iDistributionApi,
  ) {
    final _$iDistributionApi =
        iDistributionApi?.reference ?? jni$_.jNullReference;
    _setDistributionController(
            reference.pointer,
            _id_setDistributionController as jni$_.JMethodIDPtr,
            _$iDistributionApi.pointer)
        .check();
  }

  static final _id_isEnableScreenTracking = _class.instanceMethodId(
    r'isEnableScreenTracking',
    r'()Z',
  );

  static final _isEnableScreenTracking = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEnableScreenTracking()`
  bool isEnableScreenTracking() {
    return _isEnableScreenTracking(
            reference.pointer, _id_isEnableScreenTracking as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setEnableScreenTracking = _class.instanceMethodId(
    r'setEnableScreenTracking',
    r'(Z)V',
  );

  static final _setEnableScreenTracking = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEnableScreenTracking(boolean z)`
  void setEnableScreenTracking(
    bool z,
  ) {
    _setEnableScreenTracking(reference.pointer,
            _id_setEnableScreenTracking as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_setDefaultScopeType = _class.instanceMethodId(
    r'setDefaultScopeType',
    r'(Lio/sentry/ScopeType;)V',
  );

  static final _setDefaultScopeType = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDefaultScopeType(io.sentry.ScopeType scopeType)`
  void setDefaultScopeType(
    jni$_.JObject scopeType,
  ) {
    final _$scopeType = scopeType.reference;
    _setDefaultScopeType(reference.pointer,
            _id_setDefaultScopeType as jni$_.JMethodIDPtr, _$scopeType.pointer)
        .check();
  }

  static final _id_getDefaultScopeType = _class.instanceMethodId(
    r'getDefaultScopeType',
    r'()Lio/sentry/ScopeType;',
  );

  static final _getDefaultScopeType = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ScopeType getDefaultScopeType()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getDefaultScopeType() {
    return _getDefaultScopeType(
            reference.pointer, _id_getDefaultScopeType as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setInitPriority = _class.instanceMethodId(
    r'setInitPriority',
    r'(Lio/sentry/InitPriority;)V',
  );

  static final _setInitPriority = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setInitPriority(io.sentry.InitPriority initPriority)`
  void setInitPriority(
    jni$_.JObject initPriority,
  ) {
    final _$initPriority = initPriority.reference;
    _setInitPriority(reference.pointer,
            _id_setInitPriority as jni$_.JMethodIDPtr, _$initPriority.pointer)
        .check();
  }

  static final _id_getInitPriority = _class.instanceMethodId(
    r'getInitPriority',
    r'()Lio/sentry/InitPriority;',
  );

  static final _getInitPriority = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.InitPriority getInitPriority()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getInitPriority() {
    return _getInitPriority(
            reference.pointer, _id_getInitPriority as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setForceInit = _class.instanceMethodId(
    r'setForceInit',
    r'(Z)V',
  );

  static final _setForceInit = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setForceInit(boolean z)`
  void setForceInit(
    bool z,
  ) {
    _setForceInit(reference.pointer, _id_setForceInit as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_isForceInit = _class.instanceMethodId(
    r'isForceInit',
    r'()Z',
  );

  static final _isForceInit = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isForceInit()`
  bool isForceInit() {
    return _isForceInit(
            reference.pointer, _id_isForceInit as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setGlobalHubMode = _class.instanceMethodId(
    r'setGlobalHubMode',
    r'(Ljava/lang/Boolean;)V',
  );

  static final _setGlobalHubMode = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setGlobalHubMode(java.lang.Boolean boolean)`
  void setGlobalHubMode(
    jni$_.JBoolean? boolean,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    _setGlobalHubMode(reference.pointer,
            _id_setGlobalHubMode as jni$_.JMethodIDPtr, _$boolean.pointer)
        .check();
  }

  static final _id_isGlobalHubMode = _class.instanceMethodId(
    r'isGlobalHubMode',
    r'()Ljava/lang/Boolean;',
  );

  static final _isGlobalHubMode = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Boolean isGlobalHubMode()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? isGlobalHubMode() {
    return _isGlobalHubMode(
            reference.pointer, _id_isGlobalHubMode as jni$_.JMethodIDPtr)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_setOpenTelemetryMode = _class.instanceMethodId(
    r'setOpenTelemetryMode',
    r'(Lio/sentry/SentryOpenTelemetryMode;)V',
  );

  static final _setOpenTelemetryMode = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setOpenTelemetryMode(io.sentry.SentryOpenTelemetryMode sentryOpenTelemetryMode)`
  void setOpenTelemetryMode(
    jni$_.JObject sentryOpenTelemetryMode,
  ) {
    final _$sentryOpenTelemetryMode = sentryOpenTelemetryMode.reference;
    _setOpenTelemetryMode(
            reference.pointer,
            _id_setOpenTelemetryMode as jni$_.JMethodIDPtr,
            _$sentryOpenTelemetryMode.pointer)
        .check();
  }

  static final _id_getOpenTelemetryMode = _class.instanceMethodId(
    r'getOpenTelemetryMode',
    r'()Lio/sentry/SentryOpenTelemetryMode;',
  );

  static final _getOpenTelemetryMode = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryOpenTelemetryMode getOpenTelemetryMode()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getOpenTelemetryMode() {
    return _getOpenTelemetryMode(
            reference.pointer, _id_getOpenTelemetryMode as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getSessionReplay = _class.instanceMethodId(
    r'getSessionReplay',
    r'()Lio/sentry/SentryReplayOptions;',
  );

  static final _getSessionReplay = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryReplayOptions getSessionReplay()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryReplayOptions getSessionReplay() {
    return _getSessionReplay(
            reference.pointer, _id_getSessionReplay as jni$_.JMethodIDPtr)
        .object<SentryReplayOptions>(const $SentryReplayOptions$Type());
  }

  static final _id_setSessionReplay = _class.instanceMethodId(
    r'setSessionReplay',
    r'(Lio/sentry/SentryReplayOptions;)V',
  );

  static final _setSessionReplay = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setSessionReplay(io.sentry.SentryReplayOptions sentryReplayOptions)`
  void setSessionReplay(
    SentryReplayOptions sentryReplayOptions,
  ) {
    final _$sentryReplayOptions = sentryReplayOptions.reference;
    _setSessionReplay(
            reference.pointer,
            _id_setSessionReplay as jni$_.JMethodIDPtr,
            _$sentryReplayOptions.pointer)
        .check();
  }

  static final _id_getFeedbackOptions = _class.instanceMethodId(
    r'getFeedbackOptions',
    r'()Lio/sentry/SentryFeedbackOptions;',
  );

  static final _getFeedbackOptions = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryFeedbackOptions getFeedbackOptions()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getFeedbackOptions() {
    return _getFeedbackOptions(
            reference.pointer, _id_getFeedbackOptions as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setFeedbackOptions = _class.instanceMethodId(
    r'setFeedbackOptions',
    r'(Lio/sentry/SentryFeedbackOptions;)V',
  );

  static final _setFeedbackOptions = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setFeedbackOptions(io.sentry.SentryFeedbackOptions sentryFeedbackOptions)`
  void setFeedbackOptions(
    jni$_.JObject sentryFeedbackOptions,
  ) {
    final _$sentryFeedbackOptions = sentryFeedbackOptions.reference;
    _setFeedbackOptions(
            reference.pointer,
            _id_setFeedbackOptions as jni$_.JMethodIDPtr,
            _$sentryFeedbackOptions.pointer)
        .check();
  }

  static final _id_setCaptureOpenTelemetryEvents = _class.instanceMethodId(
    r'setCaptureOpenTelemetryEvents',
    r'(Z)V',
  );

  static final _setCaptureOpenTelemetryEvents =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setCaptureOpenTelemetryEvents(boolean z)`
  void setCaptureOpenTelemetryEvents(
    bool z,
  ) {
    _setCaptureOpenTelemetryEvents(reference.pointer,
            _id_setCaptureOpenTelemetryEvents as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_isCaptureOpenTelemetryEvents = _class.instanceMethodId(
    r'isCaptureOpenTelemetryEvents',
    r'()Z',
  );

  static final _isCaptureOpenTelemetryEvents =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isCaptureOpenTelemetryEvents()`
  bool isCaptureOpenTelemetryEvents() {
    return _isCaptureOpenTelemetryEvents(reference.pointer,
            _id_isCaptureOpenTelemetryEvents as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getSocketTagger = _class.instanceMethodId(
    r'getSocketTagger',
    r'()Lio/sentry/ISocketTagger;',
  );

  static final _getSocketTagger = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ISocketTagger getSocketTagger()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getSocketTagger() {
    return _getSocketTagger(
            reference.pointer, _id_getSocketTagger as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setSocketTagger = _class.instanceMethodId(
    r'setSocketTagger',
    r'(Lio/sentry/ISocketTagger;)V',
  );

  static final _setSocketTagger = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setSocketTagger(io.sentry.ISocketTagger iSocketTagger)`
  void setSocketTagger(
    jni$_.JObject? iSocketTagger,
  ) {
    final _$iSocketTagger = iSocketTagger?.reference ?? jni$_.jNullReference;
    _setSocketTagger(reference.pointer,
            _id_setSocketTagger as jni$_.JMethodIDPtr, _$iSocketTagger.pointer)
        .check();
  }

  static final _id_getRuntimeManager = _class.instanceMethodId(
    r'getRuntimeManager',
    r'()Lio/sentry/util/runtime/IRuntimeManager;',
  );

  static final _getRuntimeManager = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.util.runtime.IRuntimeManager getRuntimeManager()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getRuntimeManager() {
    return _getRuntimeManager(
            reference.pointer, _id_getRuntimeManager as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setRuntimeManager = _class.instanceMethodId(
    r'setRuntimeManager',
    r'(Lio/sentry/util/runtime/IRuntimeManager;)V',
  );

  static final _setRuntimeManager = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setRuntimeManager(io.sentry.util.runtime.IRuntimeManager iRuntimeManager)`
  void setRuntimeManager(
    jni$_.JObject iRuntimeManager,
  ) {
    final _$iRuntimeManager = iRuntimeManager.reference;
    _setRuntimeManager(
            reference.pointer,
            _id_setRuntimeManager as jni$_.JMethodIDPtr,
            _$iRuntimeManager.pointer)
        .check();
  }

  static final _id_empty = _class.staticMethodId(
    r'empty',
    r'()Lio/sentry/SentryOptions;',
  );

  static final _empty = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.SentryOptions empty()`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryOptions empty() {
    return _empty(_class.reference.pointer, _id_empty as jni$_.JMethodIDPtr)
        .object<SentryOptions>(const $SentryOptions$Type());
  }

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryOptions() {
    return SentryOptions.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_merge = _class.instanceMethodId(
    r'merge',
    r'(Lio/sentry/ExternalOptions;)V',
  );

  static final _merge = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void merge(io.sentry.ExternalOptions externalOptions)`
  void merge(
    jni$_.JObject externalOptions,
  ) {
    final _$externalOptions = externalOptions.reference;
    _merge(reference.pointer, _id_merge as jni$_.JMethodIDPtr,
            _$externalOptions.pointer)
        .check();
  }

  static final _id_getSpanFactory = _class.instanceMethodId(
    r'getSpanFactory',
    r'()Lio/sentry/ISpanFactory;',
  );

  static final _getSpanFactory = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ISpanFactory getSpanFactory()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getSpanFactory() {
    return _getSpanFactory(
            reference.pointer, _id_getSpanFactory as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setSpanFactory = _class.instanceMethodId(
    r'setSpanFactory',
    r'(Lio/sentry/ISpanFactory;)V',
  );

  static final _setSpanFactory = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setSpanFactory(io.sentry.ISpanFactory iSpanFactory)`
  void setSpanFactory(
    jni$_.JObject iSpanFactory,
  ) {
    final _$iSpanFactory = iSpanFactory.reference;
    _setSpanFactory(reference.pointer, _id_setSpanFactory as jni$_.JMethodIDPtr,
            _$iSpanFactory.pointer)
        .check();
  }

  static final _id_getLogs = _class.instanceMethodId(
    r'getLogs',
    r'()Lio/sentry/SentryOptions$Logs;',
  );

  static final _getLogs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryOptions$Logs getLogs()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryOptions$Logs getLogs() {
    return _getLogs(reference.pointer, _id_getLogs as jni$_.JMethodIDPtr)
        .object<SentryOptions$Logs>(const $SentryOptions$Logs$Type());
  }

  static final _id_setLogs = _class.instanceMethodId(
    r'setLogs',
    r'(Lio/sentry/SentryOptions$Logs;)V',
  );

  static final _setLogs = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setLogs(io.sentry.SentryOptions$Logs logs)`
  void setLogs(
    SentryOptions$Logs logs,
  ) {
    final _$logs = logs.reference;
    _setLogs(reference.pointer, _id_setLogs as jni$_.JMethodIDPtr,
            _$logs.pointer)
        .check();
  }

  static final _id_getMetrics = _class.instanceMethodId(
    r'getMetrics',
    r'()Lio/sentry/SentryOptions$Metrics;',
  );

  static final _getMetrics = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryOptions$Metrics getMetrics()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryOptions$Metrics getMetrics() {
    return _getMetrics(reference.pointer, _id_getMetrics as jni$_.JMethodIDPtr)
        .object<SentryOptions$Metrics>(const $SentryOptions$Metrics$Type());
  }

  static final _id_setMetrics = _class.instanceMethodId(
    r'setMetrics',
    r'(Lio/sentry/SentryOptions$Metrics;)V',
  );

  static final _setMetrics = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setMetrics(io.sentry.SentryOptions$Metrics metrics)`
  void setMetrics(
    SentryOptions$Metrics metrics,
  ) {
    final _$metrics = metrics.reference;
    _setMetrics(reference.pointer, _id_setMetrics as jni$_.JMethodIDPtr,
            _$metrics.pointer)
        .check();
  }

  static final _id_getDistribution = _class.instanceMethodId(
    r'getDistribution',
    r'()Lio/sentry/SentryOptions$DistributionOptions;',
  );

  static final _getDistribution = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryOptions$DistributionOptions getDistribution()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryOptions$DistributionOptions getDistribution() {
    return _getDistribution(
            reference.pointer, _id_getDistribution as jni$_.JMethodIDPtr)
        .object<SentryOptions$DistributionOptions>(
            const $SentryOptions$DistributionOptions$Type());
  }

  static final _id_setDistribution = _class.instanceMethodId(
    r'setDistribution',
    r'(Lio/sentry/SentryOptions$DistributionOptions;)V',
  );

  static final _setDistribution = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDistribution(io.sentry.SentryOptions$DistributionOptions distributionOptions)`
  void setDistribution(
    SentryOptions$DistributionOptions distributionOptions,
  ) {
    final _$distributionOptions = distributionOptions.reference;
    _setDistribution(
            reference.pointer,
            _id_setDistribution as jni$_.JMethodIDPtr,
            _$distributionOptions.pointer)
        .check();
  }
}

final class $SentryOptions$NullableType extends jni$_.JObjType<SentryOptions?> {
  @jni$_.internal
  const $SentryOptions$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions;';

  @jni$_.internal
  @core$_.override
  SentryOptions? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : SentryOptions.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$NullableType) &&
        other is $SentryOptions$NullableType;
  }
}

final class $SentryOptions$Type extends jni$_.JObjType<SentryOptions> {
  @jni$_.internal
  const $SentryOptions$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryOptions;';

  @jni$_.internal
  @core$_.override
  SentryOptions fromReference(jni$_.JReference reference) =>
      SentryOptions.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryOptions?> get nullableType =>
      const $SentryOptions$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryOptions$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryOptions$Type) &&
        other is $SentryOptions$Type;
  }
}

/// from: `io.sentry.SentryReplayOptions$SentryReplayQuality`
class SentryReplayOptions$SentryReplayQuality extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryReplayOptions$SentryReplayQuality> $type;

  @jni$_.internal
  SentryReplayOptions$SentryReplayQuality.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'io/sentry/SentryReplayOptions$SentryReplayQuality');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $SentryReplayOptions$SentryReplayQuality$NullableType();
  static const type = $SentryReplayOptions$SentryReplayQuality$Type();
  static final _id_LOW = _class.staticFieldId(
    r'LOW',
    r'Lio/sentry/SentryReplayOptions$SentryReplayQuality;',
  );

  /// from: `static public final io.sentry.SentryReplayOptions$SentryReplayQuality LOW`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryReplayOptions$SentryReplayQuality get LOW => _id_LOW.get(
      _class, const $SentryReplayOptions$SentryReplayQuality$Type());

  static final _id_MEDIUM = _class.staticFieldId(
    r'MEDIUM',
    r'Lio/sentry/SentryReplayOptions$SentryReplayQuality;',
  );

  /// from: `static public final io.sentry.SentryReplayOptions$SentryReplayQuality MEDIUM`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryReplayOptions$SentryReplayQuality get MEDIUM => _id_MEDIUM.get(
      _class, const $SentryReplayOptions$SentryReplayQuality$Type());

  static final _id_HIGH = _class.staticFieldId(
    r'HIGH',
    r'Lio/sentry/SentryReplayOptions$SentryReplayQuality;',
  );

  /// from: `static public final io.sentry.SentryReplayOptions$SentryReplayQuality HIGH`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryReplayOptions$SentryReplayQuality get HIGH => _id_HIGH.get(
      _class, const $SentryReplayOptions$SentryReplayQuality$Type());

  static final _id_sizeScale = _class.instanceFieldId(
    r'sizeScale',
    r'F',
  );

  /// from: `public final float sizeScale`
  double get sizeScale => _id_sizeScale.get(this, const jni$_.jfloatType());

  static final _id_bitRate = _class.instanceFieldId(
    r'bitRate',
    r'I',
  );

  /// from: `public final int bitRate`
  int get bitRate => _id_bitRate.get(this, const jni$_.jintType());

  static final _id_screenshotQuality = _class.instanceFieldId(
    r'screenshotQuality',
    r'I',
  );

  /// from: `public final int screenshotQuality`
  int get screenshotQuality =>
      _id_screenshotQuality.get(this, const jni$_.jintType());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Lio/sentry/SentryReplayOptions$SentryReplayQuality;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.SentryReplayOptions$SentryReplayQuality[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<SentryReplayOptions$SentryReplayQuality?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<SentryReplayOptions$SentryReplayQuality?>?>(
            const jni$_
                .JArrayNullableType<SentryReplayOptions$SentryReplayQuality?>(
                $SentryReplayOptions$SentryReplayQuality$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Lio/sentry/SentryReplayOptions$SentryReplayQuality;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.SentryReplayOptions$SentryReplayQuality valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryReplayOptions$SentryReplayQuality? valueOf(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<SentryReplayOptions$SentryReplayQuality?>(
            const $SentryReplayOptions$SentryReplayQuality$NullableType());
  }

  static final _id_serializedName = _class.instanceMethodId(
    r'serializedName',
    r'()Ljava/lang/String;',
  );

  static final _serializedName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String serializedName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString serializedName() {
    return _serializedName(
            reference.pointer, _id_serializedName as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }
}

final class $SentryReplayOptions$SentryReplayQuality$NullableType
    extends jni$_.JObjType<SentryReplayOptions$SentryReplayQuality?> {
  @jni$_.internal
  const $SentryReplayOptions$SentryReplayQuality$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/SentryReplayOptions$SentryReplayQuality;';

  @jni$_.internal
  @core$_.override
  SentryReplayOptions$SentryReplayQuality? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryReplayOptions$SentryReplayQuality.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayOptions$SentryReplayQuality?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryReplayOptions$SentryReplayQuality$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryReplayOptions$SentryReplayQuality$NullableType) &&
        other is $SentryReplayOptions$SentryReplayQuality$NullableType;
  }
}

final class $SentryReplayOptions$SentryReplayQuality$Type
    extends jni$_.JObjType<SentryReplayOptions$SentryReplayQuality> {
  @jni$_.internal
  const $SentryReplayOptions$SentryReplayQuality$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/SentryReplayOptions$SentryReplayQuality;';

  @jni$_.internal
  @core$_.override
  SentryReplayOptions$SentryReplayQuality fromReference(
          jni$_.JReference reference) =>
      SentryReplayOptions$SentryReplayQuality.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayOptions$SentryReplayQuality?> get nullableType =>
      const $SentryReplayOptions$SentryReplayQuality$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryReplayOptions$SentryReplayQuality$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryReplayOptions$SentryReplayQuality$Type) &&
        other is $SentryReplayOptions$SentryReplayQuality$Type;
  }
}

/// from: `io.sentry.SentryReplayOptions`
class SentryReplayOptions extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryReplayOptions> $type;

  @jni$_.internal
  SentryReplayOptions.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/SentryReplayOptions');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryReplayOptions$NullableType();
  static const type = $SentryReplayOptions$Type();
  static final _id_TEXT_VIEW_CLASS_NAME = _class.staticFieldId(
    r'TEXT_VIEW_CLASS_NAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_VIEW_CLASS_NAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_VIEW_CLASS_NAME =>
      _id_TEXT_VIEW_CLASS_NAME.get(_class, const jni$_.JStringNullableType());

  static final _id_IMAGE_VIEW_CLASS_NAME = _class.staticFieldId(
    r'IMAGE_VIEW_CLASS_NAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String IMAGE_VIEW_CLASS_NAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get IMAGE_VIEW_CLASS_NAME =>
      _id_IMAGE_VIEW_CLASS_NAME.get(_class, const jni$_.JStringNullableType());

  static final _id_WEB_VIEW_CLASS_NAME = _class.staticFieldId(
    r'WEB_VIEW_CLASS_NAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String WEB_VIEW_CLASS_NAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get WEB_VIEW_CLASS_NAME =>
      _id_WEB_VIEW_CLASS_NAME.get(_class, const jni$_.JStringNullableType());

  static final _id_VIDEO_VIEW_CLASS_NAME = _class.staticFieldId(
    r'VIDEO_VIEW_CLASS_NAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String VIDEO_VIEW_CLASS_NAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get VIDEO_VIEW_CLASS_NAME =>
      _id_VIDEO_VIEW_CLASS_NAME.get(_class, const jni$_.JStringNullableType());

  static final _id_ANDROIDX_MEDIA_VIEW_CLASS_NAME = _class.staticFieldId(
    r'ANDROIDX_MEDIA_VIEW_CLASS_NAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ANDROIDX_MEDIA_VIEW_CLASS_NAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ANDROIDX_MEDIA_VIEW_CLASS_NAME =>
      _id_ANDROIDX_MEDIA_VIEW_CLASS_NAME.get(
          _class, const jni$_.JStringNullableType());

  static final _id_EXOPLAYER_CLASS_NAME = _class.staticFieldId(
    r'EXOPLAYER_CLASS_NAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EXOPLAYER_CLASS_NAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EXOPLAYER_CLASS_NAME =>
      _id_EXOPLAYER_CLASS_NAME.get(_class, const jni$_.JStringNullableType());

  static final _id_EXOPLAYER_STYLED_CLASS_NAME = _class.staticFieldId(
    r'EXOPLAYER_STYLED_CLASS_NAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EXOPLAYER_STYLED_CLASS_NAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EXOPLAYER_STYLED_CLASS_NAME =>
      _id_EXOPLAYER_STYLED_CLASS_NAME.get(
          _class, const jni$_.JStringNullableType());

  /// from: `static public final int MAX_NETWORK_BODY_SIZE`
  static const MAX_NETWORK_BODY_SIZE = 153600;
  static final _id_getNetworkDetailsDefaultHeaders = _class.staticMethodId(
    r'getNetworkDetailsDefaultHeaders',
    r'()Ljava/util/List;',
  );

  static final _getNetworkDetailsDefaultHeaders =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `static public java.util.List<java.lang.String> getNetworkDetailsDefaultHeaders()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JList<jni$_.JString?> getNetworkDetailsDefaultHeaders() {
    return _getNetworkDetailsDefaultHeaders(_class.reference.pointer,
            _id_getNetworkDetailsDefaultHeaders as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>>(
            const jni$_.JListType<jni$_.JString?>(jni$_.JStringNullableType()));
  }

  static final _id_new$ = _class.constructorId(
    r'(ZLio/sentry/protocol/SdkVersion;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(boolean z, io.sentry.protocol.SdkVersion sdkVersion)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryReplayOptions(
    bool z,
    SdkVersion? sdkVersion,
  ) {
    final _$sdkVersion = sdkVersion?.reference ?? jni$_.jNullReference;
    return SentryReplayOptions.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, z ? 1 : 0, _$sdkVersion.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/Double;Ljava/lang/Double;Lio/sentry/protocol/SdkVersion;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.Double double, java.lang.Double double1, io.sentry.protocol.SdkVersion sdkVersion)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryReplayOptions.new$1(
    jni$_.JDouble? double,
    jni$_.JDouble? double1,
    SdkVersion? sdkVersion,
  ) {
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$double1 = double1?.reference ?? jni$_.jNullReference;
    final _$sdkVersion = sdkVersion?.reference ?? jni$_.jNullReference;
    return SentryReplayOptions.fromReference(_new$1(
            _class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr,
            _$double.pointer,
            _$double1.pointer,
            _$sdkVersion.pointer)
        .reference);
  }

  static final _id_getOnErrorSampleRate = _class.instanceMethodId(
    r'getOnErrorSampleRate',
    r'()Ljava/lang/Double;',
  );

  static final _getOnErrorSampleRate = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Double getOnErrorSampleRate()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? getOnErrorSampleRate() {
    return _getOnErrorSampleRate(
            reference.pointer, _id_getOnErrorSampleRate as jni$_.JMethodIDPtr)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_isSessionReplayEnabled = _class.instanceMethodId(
    r'isSessionReplayEnabled',
    r'()Z',
  );

  static final _isSessionReplayEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isSessionReplayEnabled()`
  bool isSessionReplayEnabled() {
    return _isSessionReplayEnabled(
            reference.pointer, _id_isSessionReplayEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setOnErrorSampleRate = _class.instanceMethodId(
    r'setOnErrorSampleRate',
    r'(Ljava/lang/Double;)V',
  );

  static final _setOnErrorSampleRate = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setOnErrorSampleRate(java.lang.Double double)`
  void setOnErrorSampleRate(
    jni$_.JDouble? double,
  ) {
    final _$double = double?.reference ?? jni$_.jNullReference;
    _setOnErrorSampleRate(reference.pointer,
            _id_setOnErrorSampleRate as jni$_.JMethodIDPtr, _$double.pointer)
        .check();
  }

  static final _id_getSessionSampleRate = _class.instanceMethodId(
    r'getSessionSampleRate',
    r'()Ljava/lang/Double;',
  );

  static final _getSessionSampleRate = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Double getSessionSampleRate()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? getSessionSampleRate() {
    return _getSessionSampleRate(
            reference.pointer, _id_getSessionSampleRate as jni$_.JMethodIDPtr)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_isSessionReplayForErrorsEnabled = _class.instanceMethodId(
    r'isSessionReplayForErrorsEnabled',
    r'()Z',
  );

  static final _isSessionReplayForErrorsEnabled =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isSessionReplayForErrorsEnabled()`
  bool isSessionReplayForErrorsEnabled() {
    return _isSessionReplayForErrorsEnabled(reference.pointer,
            _id_isSessionReplayForErrorsEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setSessionSampleRate = _class.instanceMethodId(
    r'setSessionSampleRate',
    r'(Ljava/lang/Double;)V',
  );

  static final _setSessionSampleRate = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setSessionSampleRate(java.lang.Double double)`
  void setSessionSampleRate(
    jni$_.JDouble? double,
  ) {
    final _$double = double?.reference ?? jni$_.jNullReference;
    _setSessionSampleRate(reference.pointer,
            _id_setSessionSampleRate as jni$_.JMethodIDPtr, _$double.pointer)
        .check();
  }

  static final _id_setMaskAllText = _class.instanceMethodId(
    r'setMaskAllText',
    r'(Z)V',
  );

  static final _setMaskAllText = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setMaskAllText(boolean z)`
  void setMaskAllText(
    bool z,
  ) {
    _setMaskAllText(reference.pointer, _id_setMaskAllText as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_setMaskAllImages = _class.instanceMethodId(
    r'setMaskAllImages',
    r'(Z)V',
  );

  static final _setMaskAllImages = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setMaskAllImages(boolean z)`
  void setMaskAllImages(
    bool z,
  ) {
    _setMaskAllImages(reference.pointer,
            _id_setMaskAllImages as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getMaskViewClasses = _class.instanceMethodId(
    r'getMaskViewClasses',
    r'()Ljava/util/Set;',
  );

  static final _getMaskViewClasses = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Set<java.lang.String> getMaskViewClasses()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<jni$_.JString?> getMaskViewClasses() {
    return _getMaskViewClasses(
            reference.pointer, _id_getMaskViewClasses as jni$_.JMethodIDPtr)
        .object<jni$_.JSet<jni$_.JString?>>(
            const jni$_.JSetType<jni$_.JString?>(jni$_.JStringNullableType()));
  }

  static final _id_addMaskViewClass = _class.instanceMethodId(
    r'addMaskViewClass',
    r'(Ljava/lang/String;)V',
  );

  static final _addMaskViewClass = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addMaskViewClass(java.lang.String string)`
  void addMaskViewClass(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _addMaskViewClass(reference.pointer,
            _id_addMaskViewClass as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_getUnmaskViewClasses = _class.instanceMethodId(
    r'getUnmaskViewClasses',
    r'()Ljava/util/Set;',
  );

  static final _getUnmaskViewClasses = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Set<java.lang.String> getUnmaskViewClasses()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<jni$_.JString?> getUnmaskViewClasses() {
    return _getUnmaskViewClasses(
            reference.pointer, _id_getUnmaskViewClasses as jni$_.JMethodIDPtr)
        .object<jni$_.JSet<jni$_.JString?>>(
            const jni$_.JSetType<jni$_.JString?>(jni$_.JStringNullableType()));
  }

  static final _id_addUnmaskViewClass = _class.instanceMethodId(
    r'addUnmaskViewClass',
    r'(Ljava/lang/String;)V',
  );

  static final _addUnmaskViewClass = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addUnmaskViewClass(java.lang.String string)`
  void addUnmaskViewClass(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _addUnmaskViewClass(reference.pointer,
            _id_addUnmaskViewClass as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_getQuality = _class.instanceMethodId(
    r'getQuality',
    r'()Lio/sentry/SentryReplayOptions$SentryReplayQuality;',
  );

  static final _getQuality = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryReplayOptions$SentryReplayQuality getQuality()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryReplayOptions$SentryReplayQuality getQuality() {
    return _getQuality(reference.pointer, _id_getQuality as jni$_.JMethodIDPtr)
        .object<SentryReplayOptions$SentryReplayQuality>(
            const $SentryReplayOptions$SentryReplayQuality$Type());
  }

  static final _id_setQuality = _class.instanceMethodId(
    r'setQuality',
    r'(Lio/sentry/SentryReplayOptions$SentryReplayQuality;)V',
  );

  static final _setQuality = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setQuality(io.sentry.SentryReplayOptions$SentryReplayQuality sentryReplayQuality)`
  void setQuality(
    SentryReplayOptions$SentryReplayQuality sentryReplayQuality,
  ) {
    final _$sentryReplayQuality = sentryReplayQuality.reference;
    _setQuality(reference.pointer, _id_setQuality as jni$_.JMethodIDPtr,
            _$sentryReplayQuality.pointer)
        .check();
  }

  static final _id_getFrameRate = _class.instanceMethodId(
    r'getFrameRate',
    r'()I',
  );

  static final _getFrameRate = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getFrameRate()`
  int getFrameRate() {
    return _getFrameRate(
            reference.pointer, _id_getFrameRate as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getErrorReplayDuration = _class.instanceMethodId(
    r'getErrorReplayDuration',
    r'()J',
  );

  static final _getErrorReplayDuration = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long getErrorReplayDuration()`
  int getErrorReplayDuration() {
    return _getErrorReplayDuration(
            reference.pointer, _id_getErrorReplayDuration as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_getSessionSegmentDuration = _class.instanceMethodId(
    r'getSessionSegmentDuration',
    r'()J',
  );

  static final _getSessionSegmentDuration = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long getSessionSegmentDuration()`
  int getSessionSegmentDuration() {
    return _getSessionSegmentDuration(reference.pointer,
            _id_getSessionSegmentDuration as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_getSessionDuration = _class.instanceMethodId(
    r'getSessionDuration',
    r'()J',
  );

  static final _getSessionDuration = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long getSessionDuration()`
  int getSessionDuration() {
    return _getSessionDuration(
            reference.pointer, _id_getSessionDuration as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_setMaskViewContainerClass = _class.instanceMethodId(
    r'setMaskViewContainerClass',
    r'(Ljava/lang/String;)V',
  );

  static final _setMaskViewContainerClass = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setMaskViewContainerClass(java.lang.String string)`
  void setMaskViewContainerClass(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _setMaskViewContainerClass(
            reference.pointer,
            _id_setMaskViewContainerClass as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_setUnmaskViewContainerClass = _class.instanceMethodId(
    r'setUnmaskViewContainerClass',
    r'(Ljava/lang/String;)V',
  );

  static final _setUnmaskViewContainerClass =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setUnmaskViewContainerClass(java.lang.String string)`
  void setUnmaskViewContainerClass(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _setUnmaskViewContainerClass(
            reference.pointer,
            _id_setUnmaskViewContainerClass as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getMaskViewContainerClass = _class.instanceMethodId(
    r'getMaskViewContainerClass',
    r'()Ljava/lang/String;',
  );

  static final _getMaskViewContainerClass = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getMaskViewContainerClass()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getMaskViewContainerClass() {
    return _getMaskViewContainerClass(reference.pointer,
            _id_getMaskViewContainerClass as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getUnmaskViewContainerClass = _class.instanceMethodId(
    r'getUnmaskViewContainerClass',
    r'()Ljava/lang/String;',
  );

  static final _getUnmaskViewContainerClass =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public java.lang.String getUnmaskViewContainerClass()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getUnmaskViewContainerClass() {
    return _getUnmaskViewContainerClass(reference.pointer,
            _id_getUnmaskViewContainerClass as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_isTrackConfiguration = _class.instanceMethodId(
    r'isTrackConfiguration',
    r'()Z',
  );

  static final _isTrackConfiguration = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isTrackConfiguration()`
  bool isTrackConfiguration() {
    return _isTrackConfiguration(
            reference.pointer, _id_isTrackConfiguration as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setTrackConfiguration = _class.instanceMethodId(
    r'setTrackConfiguration',
    r'(Z)V',
  );

  static final _setTrackConfiguration = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setTrackConfiguration(boolean z)`
  void setTrackConfiguration(
    bool z,
  ) {
    _setTrackConfiguration(reference.pointer,
            _id_setTrackConfiguration as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getSdkVersion = _class.instanceMethodId(
    r'getSdkVersion',
    r'()Lio/sentry/protocol/SdkVersion;',
  );

  static final _getSdkVersion = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.SdkVersion getSdkVersion()`
  /// The returned object must be released after use, by calling the [release] method.
  SdkVersion? getSdkVersion() {
    return _getSdkVersion(
            reference.pointer, _id_getSdkVersion as jni$_.JMethodIDPtr)
        .object<SdkVersion?>(const $SdkVersion$NullableType());
  }

  static final _id_setSdkVersion = _class.instanceMethodId(
    r'setSdkVersion',
    r'(Lio/sentry/protocol/SdkVersion;)V',
  );

  static final _setSdkVersion = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setSdkVersion(io.sentry.protocol.SdkVersion sdkVersion)`
  void setSdkVersion(
    SdkVersion? sdkVersion,
  ) {
    final _$sdkVersion = sdkVersion?.reference ?? jni$_.jNullReference;
    _setSdkVersion(reference.pointer, _id_setSdkVersion as jni$_.JMethodIDPtr,
            _$sdkVersion.pointer)
        .check();
  }

  static final _id_isDebug = _class.instanceMethodId(
    r'isDebug',
    r'()Z',
  );

  static final _isDebug = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isDebug()`
  bool isDebug() {
    return _isDebug(reference.pointer, _id_isDebug as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setDebug = _class.instanceMethodId(
    r'setDebug',
    r'(Z)V',
  );

  static final _setDebug = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setDebug(boolean z)`
  void setDebug(
    bool z,
  ) {
    _setDebug(reference.pointer, _id_setDebug as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getScreenshotStrategy = _class.instanceMethodId(
    r'getScreenshotStrategy',
    r'()Lio/sentry/ScreenshotStrategyType;',
  );

  static final _getScreenshotStrategy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ScreenshotStrategyType getScreenshotStrategy()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getScreenshotStrategy() {
    return _getScreenshotStrategy(
            reference.pointer, _id_getScreenshotStrategy as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setScreenshotStrategy = _class.instanceMethodId(
    r'setScreenshotStrategy',
    r'(Lio/sentry/ScreenshotStrategyType;)V',
  );

  static final _setScreenshotStrategy = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setScreenshotStrategy(io.sentry.ScreenshotStrategyType screenshotStrategyType)`
  void setScreenshotStrategy(
    jni$_.JObject screenshotStrategyType,
  ) {
    final _$screenshotStrategyType = screenshotStrategyType.reference;
    _setScreenshotStrategy(
            reference.pointer,
            _id_setScreenshotStrategy as jni$_.JMethodIDPtr,
            _$screenshotStrategyType.pointer)
        .check();
  }

  static final _id_getNetworkDetailAllowUrls = _class.instanceMethodId(
    r'getNetworkDetailAllowUrls',
    r'()Ljava/util/List;',
  );

  static final _getNetworkDetailAllowUrls = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<java.lang.String> getNetworkDetailAllowUrls()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?> getNetworkDetailAllowUrls() {
    return _getNetworkDetailAllowUrls(reference.pointer,
            _id_getNetworkDetailAllowUrls as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>>(
            const jni$_.JListType<jni$_.JString?>(jni$_.JStringNullableType()));
  }

  static final _id_setNetworkDetailAllowUrls = _class.instanceMethodId(
    r'setNetworkDetailAllowUrls',
    r'(Ljava/util/List;)V',
  );

  static final _setNetworkDetailAllowUrls = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setNetworkDetailAllowUrls(java.util.List<java.lang.String> list)`
  void setNetworkDetailAllowUrls(
    jni$_.JList<jni$_.JString?> list,
  ) {
    final _$list = list.reference;
    _setNetworkDetailAllowUrls(reference.pointer,
            _id_setNetworkDetailAllowUrls as jni$_.JMethodIDPtr, _$list.pointer)
        .check();
  }

  static final _id_getNetworkDetailDenyUrls = _class.instanceMethodId(
    r'getNetworkDetailDenyUrls',
    r'()Ljava/util/List;',
  );

  static final _getNetworkDetailDenyUrls = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<java.lang.String> getNetworkDetailDenyUrls()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?> getNetworkDetailDenyUrls() {
    return _getNetworkDetailDenyUrls(reference.pointer,
            _id_getNetworkDetailDenyUrls as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>>(
            const jni$_.JListType<jni$_.JString?>(jni$_.JStringNullableType()));
  }

  static final _id_setNetworkDetailDenyUrls = _class.instanceMethodId(
    r'setNetworkDetailDenyUrls',
    r'(Ljava/util/List;)V',
  );

  static final _setNetworkDetailDenyUrls = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setNetworkDetailDenyUrls(java.util.List<java.lang.String> list)`
  void setNetworkDetailDenyUrls(
    jni$_.JList<jni$_.JString?> list,
  ) {
    final _$list = list.reference;
    _setNetworkDetailDenyUrls(reference.pointer,
            _id_setNetworkDetailDenyUrls as jni$_.JMethodIDPtr, _$list.pointer)
        .check();
  }

  static final _id_isNetworkCaptureBodies = _class.instanceMethodId(
    r'isNetworkCaptureBodies',
    r'()Z',
  );

  static final _isNetworkCaptureBodies = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isNetworkCaptureBodies()`
  bool isNetworkCaptureBodies() {
    return _isNetworkCaptureBodies(
            reference.pointer, _id_isNetworkCaptureBodies as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setNetworkCaptureBodies = _class.instanceMethodId(
    r'setNetworkCaptureBodies',
    r'(Z)V',
  );

  static final _setNetworkCaptureBodies = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setNetworkCaptureBodies(boolean z)`
  void setNetworkCaptureBodies(
    bool z,
  ) {
    _setNetworkCaptureBodies(reference.pointer,
            _id_setNetworkCaptureBodies as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getNetworkRequestHeaders = _class.instanceMethodId(
    r'getNetworkRequestHeaders',
    r'()Ljava/util/List;',
  );

  static final _getNetworkRequestHeaders = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<java.lang.String> getNetworkRequestHeaders()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?> getNetworkRequestHeaders() {
    return _getNetworkRequestHeaders(reference.pointer,
            _id_getNetworkRequestHeaders as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>>(
            const jni$_.JListType<jni$_.JString?>(jni$_.JStringNullableType()));
  }

  static final _id_setNetworkRequestHeaders = _class.instanceMethodId(
    r'setNetworkRequestHeaders',
    r'(Ljava/util/List;)V',
  );

  static final _setNetworkRequestHeaders = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setNetworkRequestHeaders(java.util.List<java.lang.String> list)`
  void setNetworkRequestHeaders(
    jni$_.JList<jni$_.JString?> list,
  ) {
    final _$list = list.reference;
    _setNetworkRequestHeaders(reference.pointer,
            _id_setNetworkRequestHeaders as jni$_.JMethodIDPtr, _$list.pointer)
        .check();
  }

  static final _id_getNetworkResponseHeaders = _class.instanceMethodId(
    r'getNetworkResponseHeaders',
    r'()Ljava/util/List;',
  );

  static final _getNetworkResponseHeaders = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<java.lang.String> getNetworkResponseHeaders()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?> getNetworkResponseHeaders() {
    return _getNetworkResponseHeaders(reference.pointer,
            _id_getNetworkResponseHeaders as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>>(
            const jni$_.JListType<jni$_.JString?>(jni$_.JStringNullableType()));
  }

  static final _id_setNetworkResponseHeaders = _class.instanceMethodId(
    r'setNetworkResponseHeaders',
    r'(Ljava/util/List;)V',
  );

  static final _setNetworkResponseHeaders = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setNetworkResponseHeaders(java.util.List<java.lang.String> list)`
  void setNetworkResponseHeaders(
    jni$_.JList<jni$_.JString?> list,
  ) {
    final _$list = list.reference;
    _setNetworkResponseHeaders(reference.pointer,
            _id_setNetworkResponseHeaders as jni$_.JMethodIDPtr, _$list.pointer)
        .check();
  }
}

final class $SentryReplayOptions$NullableType
    extends jni$_.JObjType<SentryReplayOptions?> {
  @jni$_.internal
  const $SentryReplayOptions$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryReplayOptions;';

  @jni$_.internal
  @core$_.override
  SentryReplayOptions? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryReplayOptions.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayOptions?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryReplayOptions$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryReplayOptions$NullableType) &&
        other is $SentryReplayOptions$NullableType;
  }
}

final class $SentryReplayOptions$Type
    extends jni$_.JObjType<SentryReplayOptions> {
  @jni$_.internal
  const $SentryReplayOptions$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryReplayOptions;';

  @jni$_.internal
  @core$_.override
  SentryReplayOptions fromReference(jni$_.JReference reference) =>
      SentryReplayOptions.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayOptions?> get nullableType =>
      const $SentryReplayOptions$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryReplayOptions$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryReplayOptions$Type) &&
        other is $SentryReplayOptions$Type;
  }
}

/// from: `io.sentry.SentryReplayEvent$Deserializer`
class SentryReplayEvent$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryReplayEvent$Deserializer> $type;

  @jni$_.internal
  SentryReplayEvent$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryReplayEvent$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryReplayEvent$Deserializer$NullableType();
  static const type = $SentryReplayEvent$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryReplayEvent$Deserializer() {
    return SentryReplayEvent$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserialize = _class.instanceMethodId(
    r'deserialize',
    r'(Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Lio/sentry/SentryReplayEvent;',
  );

  static final _deserialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.SentryReplayEvent deserialize(io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryReplayEvent deserialize(
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserialize(
            reference.pointer,
            _id_deserialize as jni$_.JMethodIDPtr,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .object<SentryReplayEvent>(const $SentryReplayEvent$Type());
  }
}

final class $SentryReplayEvent$Deserializer$NullableType
    extends jni$_.JObjType<SentryReplayEvent$Deserializer?> {
  @jni$_.internal
  const $SentryReplayEvent$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryReplayEvent$Deserializer;';

  @jni$_.internal
  @core$_.override
  SentryReplayEvent$Deserializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryReplayEvent$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayEvent$Deserializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryReplayEvent$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryReplayEvent$Deserializer$NullableType) &&
        other is $SentryReplayEvent$Deserializer$NullableType;
  }
}

final class $SentryReplayEvent$Deserializer$Type
    extends jni$_.JObjType<SentryReplayEvent$Deserializer> {
  @jni$_.internal
  const $SentryReplayEvent$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryReplayEvent$Deserializer;';

  @jni$_.internal
  @core$_.override
  SentryReplayEvent$Deserializer fromReference(jni$_.JReference reference) =>
      SentryReplayEvent$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayEvent$Deserializer?> get nullableType =>
      const $SentryReplayEvent$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryReplayEvent$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryReplayEvent$Deserializer$Type) &&
        other is $SentryReplayEvent$Deserializer$Type;
  }
}

/// from: `io.sentry.SentryReplayEvent$JsonKeys`
class SentryReplayEvent$JsonKeys extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryReplayEvent$JsonKeys> $type;

  @jni$_.internal
  SentryReplayEvent$JsonKeys.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryReplayEvent$JsonKeys');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryReplayEvent$JsonKeys$NullableType();
  static const type = $SentryReplayEvent$JsonKeys$Type();
  static final _id_TYPE = _class.staticFieldId(
    r'TYPE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TYPE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TYPE =>
      _id_TYPE.get(_class, const jni$_.JStringNullableType());

  static final _id_REPLAY_TYPE = _class.staticFieldId(
    r'REPLAY_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String REPLAY_TYPE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get REPLAY_TYPE =>
      _id_REPLAY_TYPE.get(_class, const jni$_.JStringNullableType());

  static final _id_REPLAY_ID = _class.staticFieldId(
    r'REPLAY_ID',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String REPLAY_ID`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get REPLAY_ID =>
      _id_REPLAY_ID.get(_class, const jni$_.JStringNullableType());

  static final _id_SEGMENT_ID = _class.staticFieldId(
    r'SEGMENT_ID',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SEGMENT_ID`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SEGMENT_ID =>
      _id_SEGMENT_ID.get(_class, const jni$_.JStringNullableType());

  static final _id_TIMESTAMP = _class.staticFieldId(
    r'TIMESTAMP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TIMESTAMP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TIMESTAMP =>
      _id_TIMESTAMP.get(_class, const jni$_.JStringNullableType());

  static final _id_REPLAY_START_TIMESTAMP = _class.staticFieldId(
    r'REPLAY_START_TIMESTAMP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String REPLAY_START_TIMESTAMP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get REPLAY_START_TIMESTAMP =>
      _id_REPLAY_START_TIMESTAMP.get(_class, const jni$_.JStringNullableType());

  static final _id_URLS = _class.staticFieldId(
    r'URLS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String URLS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get URLS =>
      _id_URLS.get(_class, const jni$_.JStringNullableType());

  static final _id_ERROR_IDS = _class.staticFieldId(
    r'ERROR_IDS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ERROR_IDS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ERROR_IDS =>
      _id_ERROR_IDS.get(_class, const jni$_.JStringNullableType());

  static final _id_TRACE_IDS = _class.staticFieldId(
    r'TRACE_IDS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TRACE_IDS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TRACE_IDS =>
      _id_TRACE_IDS.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryReplayEvent$JsonKeys() {
    return SentryReplayEvent$JsonKeys.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $SentryReplayEvent$JsonKeys$NullableType
    extends jni$_.JObjType<SentryReplayEvent$JsonKeys?> {
  @jni$_.internal
  const $SentryReplayEvent$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryReplayEvent$JsonKeys;';

  @jni$_.internal
  @core$_.override
  SentryReplayEvent$JsonKeys? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryReplayEvent$JsonKeys.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayEvent$JsonKeys?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryReplayEvent$JsonKeys$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryReplayEvent$JsonKeys$NullableType) &&
        other is $SentryReplayEvent$JsonKeys$NullableType;
  }
}

final class $SentryReplayEvent$JsonKeys$Type
    extends jni$_.JObjType<SentryReplayEvent$JsonKeys> {
  @jni$_.internal
  const $SentryReplayEvent$JsonKeys$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryReplayEvent$JsonKeys;';

  @jni$_.internal
  @core$_.override
  SentryReplayEvent$JsonKeys fromReference(jni$_.JReference reference) =>
      SentryReplayEvent$JsonKeys.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayEvent$JsonKeys?> get nullableType =>
      const $SentryReplayEvent$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryReplayEvent$JsonKeys$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryReplayEvent$JsonKeys$Type) &&
        other is $SentryReplayEvent$JsonKeys$Type;
  }
}

/// from: `io.sentry.SentryReplayEvent$ReplayType$Deserializer`
class SentryReplayEvent$ReplayType$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryReplayEvent$ReplayType$Deserializer> $type;

  @jni$_.internal
  SentryReplayEvent$ReplayType$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'io/sentry/SentryReplayEvent$ReplayType$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $SentryReplayEvent$ReplayType$Deserializer$NullableType();
  static const type = $SentryReplayEvent$ReplayType$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryReplayEvent$ReplayType$Deserializer() {
    return SentryReplayEvent$ReplayType$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserialize = _class.instanceMethodId(
    r'deserialize',
    r'(Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Lio/sentry/SentryReplayEvent$ReplayType;',
  );

  static final _deserialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.SentryReplayEvent$ReplayType deserialize(io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryReplayEvent$ReplayType deserialize(
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserialize(
            reference.pointer,
            _id_deserialize as jni$_.JMethodIDPtr,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .object<SentryReplayEvent$ReplayType>(
            const $SentryReplayEvent$ReplayType$Type());
  }
}

final class $SentryReplayEvent$ReplayType$Deserializer$NullableType
    extends jni$_.JObjType<SentryReplayEvent$ReplayType$Deserializer?> {
  @jni$_.internal
  const $SentryReplayEvent$ReplayType$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/SentryReplayEvent$ReplayType$Deserializer;';

  @jni$_.internal
  @core$_.override
  SentryReplayEvent$ReplayType$Deserializer? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryReplayEvent$ReplayType$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayEvent$ReplayType$Deserializer?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryReplayEvent$ReplayType$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryReplayEvent$ReplayType$Deserializer$NullableType) &&
        other is $SentryReplayEvent$ReplayType$Deserializer$NullableType;
  }
}

final class $SentryReplayEvent$ReplayType$Deserializer$Type
    extends jni$_.JObjType<SentryReplayEvent$ReplayType$Deserializer> {
  @jni$_.internal
  const $SentryReplayEvent$ReplayType$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/sentry/SentryReplayEvent$ReplayType$Deserializer;';

  @jni$_.internal
  @core$_.override
  SentryReplayEvent$ReplayType$Deserializer fromReference(
          jni$_.JReference reference) =>
      SentryReplayEvent$ReplayType$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayEvent$ReplayType$Deserializer?> get nullableType =>
      const $SentryReplayEvent$ReplayType$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($SentryReplayEvent$ReplayType$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($SentryReplayEvent$ReplayType$Deserializer$Type) &&
        other is $SentryReplayEvent$ReplayType$Deserializer$Type;
  }
}

/// from: `io.sentry.SentryReplayEvent$ReplayType`
class SentryReplayEvent$ReplayType extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryReplayEvent$ReplayType> $type;

  @jni$_.internal
  SentryReplayEvent$ReplayType.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryReplayEvent$ReplayType');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryReplayEvent$ReplayType$NullableType();
  static const type = $SentryReplayEvent$ReplayType$Type();
  static final _id_SESSION = _class.staticFieldId(
    r'SESSION',
    r'Lio/sentry/SentryReplayEvent$ReplayType;',
  );

  /// from: `static public final io.sentry.SentryReplayEvent$ReplayType SESSION`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryReplayEvent$ReplayType get SESSION =>
      _id_SESSION.get(_class, const $SentryReplayEvent$ReplayType$Type());

  static final _id_BUFFER = _class.staticFieldId(
    r'BUFFER',
    r'Lio/sentry/SentryReplayEvent$ReplayType;',
  );

  /// from: `static public final io.sentry.SentryReplayEvent$ReplayType BUFFER`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryReplayEvent$ReplayType get BUFFER =>
      _id_BUFFER.get(_class, const $SentryReplayEvent$ReplayType$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Lio/sentry/SentryReplayEvent$ReplayType;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.SentryReplayEvent$ReplayType[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<SentryReplayEvent$ReplayType?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<SentryReplayEvent$ReplayType?>?>(
            const jni$_.JArrayNullableType<SentryReplayEvent$ReplayType?>(
                $SentryReplayEvent$ReplayType$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Lio/sentry/SentryReplayEvent$ReplayType;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.SentryReplayEvent$ReplayType valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryReplayEvent$ReplayType? valueOf(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<SentryReplayEvent$ReplayType?>(
            const $SentryReplayEvent$ReplayType$NullableType());
  }

  static final _id_serialize = _class.instanceMethodId(
    r'serialize',
    r'(Lio/sentry/ObjectWriter;Lio/sentry/ILogger;)V',
  );

  static final _serialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void serialize(io.sentry.ObjectWriter objectWriter, io.sentry.ILogger iLogger)`
  void serialize(
    jni$_.JObject objectWriter,
    jni$_.JObject iLogger,
  ) {
    final _$objectWriter = objectWriter.reference;
    final _$iLogger = iLogger.reference;
    _serialize(reference.pointer, _id_serialize as jni$_.JMethodIDPtr,
            _$objectWriter.pointer, _$iLogger.pointer)
        .check();
  }
}

final class $SentryReplayEvent$ReplayType$NullableType
    extends jni$_.JObjType<SentryReplayEvent$ReplayType?> {
  @jni$_.internal
  const $SentryReplayEvent$ReplayType$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryReplayEvent$ReplayType;';

  @jni$_.internal
  @core$_.override
  SentryReplayEvent$ReplayType? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryReplayEvent$ReplayType.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayEvent$ReplayType?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryReplayEvent$ReplayType$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryReplayEvent$ReplayType$NullableType) &&
        other is $SentryReplayEvent$ReplayType$NullableType;
  }
}

final class $SentryReplayEvent$ReplayType$Type
    extends jni$_.JObjType<SentryReplayEvent$ReplayType> {
  @jni$_.internal
  const $SentryReplayEvent$ReplayType$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryReplayEvent$ReplayType;';

  @jni$_.internal
  @core$_.override
  SentryReplayEvent$ReplayType fromReference(jni$_.JReference reference) =>
      SentryReplayEvent$ReplayType.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayEvent$ReplayType?> get nullableType =>
      const $SentryReplayEvent$ReplayType$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryReplayEvent$ReplayType$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryReplayEvent$ReplayType$Type) &&
        other is $SentryReplayEvent$ReplayType$Type;
  }
}

/// from: `io.sentry.SentryReplayEvent`
class SentryReplayEvent extends SentryBaseEvent {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryReplayEvent> $type;

  @jni$_.internal
  SentryReplayEvent.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/SentryReplayEvent');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryReplayEvent$NullableType();
  static const type = $SentryReplayEvent$Type();

  /// from: `static public final long REPLAY_VIDEO_MAX_SIZE`
  static const REPLAY_VIDEO_MAX_SIZE = 10485760;
  static final _id_REPLAY_EVENT_TYPE = _class.staticFieldId(
    r'REPLAY_EVENT_TYPE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String REPLAY_EVENT_TYPE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get REPLAY_EVENT_TYPE =>
      _id_REPLAY_EVENT_TYPE.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryReplayEvent() {
    return SentryReplayEvent.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_getVideoFile = _class.instanceMethodId(
    r'getVideoFile',
    r'()Ljava/io/File;',
  );

  static final _getVideoFile = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.io.File getVideoFile()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getVideoFile() {
    return _getVideoFile(
            reference.pointer, _id_getVideoFile as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setVideoFile = _class.instanceMethodId(
    r'setVideoFile',
    r'(Ljava/io/File;)V',
  );

  static final _setVideoFile = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setVideoFile(java.io.File file)`
  void setVideoFile(
    jni$_.JObject? file,
  ) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    _setVideoFile(reference.pointer, _id_setVideoFile as jni$_.JMethodIDPtr,
            _$file.pointer)
        .check();
  }

  static final _id_getType = _class.instanceMethodId(
    r'getType',
    r'()Ljava/lang/String;',
  );

  static final _getType = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getType()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getType() {
    return _getType(reference.pointer, _id_getType as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_setType = _class.instanceMethodId(
    r'setType',
    r'(Ljava/lang/String;)V',
  );

  static final _setType = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setType(java.lang.String string)`
  void setType(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _setType(reference.pointer, _id_setType as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getReplayId = _class.instanceMethodId(
    r'getReplayId',
    r'()Lio/sentry/protocol/SentryId;',
  );

  static final _getReplayId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.SentryId getReplayId()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryId? getReplayId() {
    return _getReplayId(
            reference.pointer, _id_getReplayId as jni$_.JMethodIDPtr)
        .object<SentryId?>(const $SentryId$NullableType());
  }

  static final _id_setReplayId = _class.instanceMethodId(
    r'setReplayId',
    r'(Lio/sentry/protocol/SentryId;)V',
  );

  static final _setReplayId = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setReplayId(io.sentry.protocol.SentryId sentryId)`
  void setReplayId(
    SentryId? sentryId,
  ) {
    final _$sentryId = sentryId?.reference ?? jni$_.jNullReference;
    _setReplayId(reference.pointer, _id_setReplayId as jni$_.JMethodIDPtr,
            _$sentryId.pointer)
        .check();
  }

  static final _id_getSegmentId = _class.instanceMethodId(
    r'getSegmentId',
    r'()I',
  );

  static final _getSegmentId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getSegmentId()`
  int getSegmentId() {
    return _getSegmentId(
            reference.pointer, _id_getSegmentId as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_setSegmentId = _class.instanceMethodId(
    r'setSegmentId',
    r'(I)V',
  );

  static final _setSegmentId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setSegmentId(int i)`
  void setSegmentId(
    int i,
  ) {
    _setSegmentId(reference.pointer, _id_setSegmentId as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_getTimestamp = _class.instanceMethodId(
    r'getTimestamp',
    r'()Ljava/util/Date;',
  );

  static final _getTimestamp = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Date getTimestamp()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getTimestamp() {
    return _getTimestamp(
            reference.pointer, _id_getTimestamp as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setTimestamp = _class.instanceMethodId(
    r'setTimestamp',
    r'(Ljava/util/Date;)V',
  );

  static final _setTimestamp = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTimestamp(java.util.Date date)`
  void setTimestamp(
    jni$_.JObject date,
  ) {
    final _$date = date.reference;
    _setTimestamp(reference.pointer, _id_setTimestamp as jni$_.JMethodIDPtr,
            _$date.pointer)
        .check();
  }

  static final _id_getReplayStartTimestamp = _class.instanceMethodId(
    r'getReplayStartTimestamp',
    r'()Ljava/util/Date;',
  );

  static final _getReplayStartTimestamp = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Date getReplayStartTimestamp()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getReplayStartTimestamp() {
    return _getReplayStartTimestamp(reference.pointer,
            _id_getReplayStartTimestamp as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setReplayStartTimestamp = _class.instanceMethodId(
    r'setReplayStartTimestamp',
    r'(Ljava/util/Date;)V',
  );

  static final _setReplayStartTimestamp = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setReplayStartTimestamp(java.util.Date date)`
  void setReplayStartTimestamp(
    jni$_.JObject? date,
  ) {
    final _$date = date?.reference ?? jni$_.jNullReference;
    _setReplayStartTimestamp(reference.pointer,
            _id_setReplayStartTimestamp as jni$_.JMethodIDPtr, _$date.pointer)
        .check();
  }

  static final _id_getUrls = _class.instanceMethodId(
    r'getUrls',
    r'()Ljava/util/List;',
  );

  static final _getUrls = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<java.lang.String> getUrls()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? getUrls() {
    return _getUrls(reference.pointer, _id_getUrls as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>?>(
            const jni$_.JListNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_setUrls = _class.instanceMethodId(
    r'setUrls',
    r'(Ljava/util/List;)V',
  );

  static final _setUrls = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setUrls(java.util.List<java.lang.String> list)`
  void setUrls(
    jni$_.JList<jni$_.JString?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    _setUrls(reference.pointer, _id_setUrls as jni$_.JMethodIDPtr,
            _$list.pointer)
        .check();
  }

  static final _id_getErrorIds = _class.instanceMethodId(
    r'getErrorIds',
    r'()Ljava/util/List;',
  );

  static final _getErrorIds = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<java.lang.String> getErrorIds()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? getErrorIds() {
    return _getErrorIds(
            reference.pointer, _id_getErrorIds as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>?>(
            const jni$_.JListNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_setErrorIds = _class.instanceMethodId(
    r'setErrorIds',
    r'(Ljava/util/List;)V',
  );

  static final _setErrorIds = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setErrorIds(java.util.List<java.lang.String> list)`
  void setErrorIds(
    jni$_.JList<jni$_.JString?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    _setErrorIds(reference.pointer, _id_setErrorIds as jni$_.JMethodIDPtr,
            _$list.pointer)
        .check();
  }

  static final _id_getTraceIds = _class.instanceMethodId(
    r'getTraceIds',
    r'()Ljava/util/List;',
  );

  static final _getTraceIds = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<java.lang.String> getTraceIds()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? getTraceIds() {
    return _getTraceIds(
            reference.pointer, _id_getTraceIds as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>?>(
            const jni$_.JListNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_setTraceIds = _class.instanceMethodId(
    r'setTraceIds',
    r'(Ljava/util/List;)V',
  );

  static final _setTraceIds = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTraceIds(java.util.List<java.lang.String> list)`
  void setTraceIds(
    jni$_.JList<jni$_.JString?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    _setTraceIds(reference.pointer, _id_setTraceIds as jni$_.JMethodIDPtr,
            _$list.pointer)
        .check();
  }

  static final _id_getReplayType = _class.instanceMethodId(
    r'getReplayType',
    r'()Lio/sentry/SentryReplayEvent$ReplayType;',
  );

  static final _getReplayType = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryReplayEvent$ReplayType getReplayType()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryReplayEvent$ReplayType getReplayType() {
    return _getReplayType(
            reference.pointer, _id_getReplayType as jni$_.JMethodIDPtr)
        .object<SentryReplayEvent$ReplayType>(
            const $SentryReplayEvent$ReplayType$Type());
  }

  static final _id_setReplayType = _class.instanceMethodId(
    r'setReplayType',
    r'(Lio/sentry/SentryReplayEvent$ReplayType;)V',
  );

  static final _setReplayType = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setReplayType(io.sentry.SentryReplayEvent$ReplayType replayType)`
  void setReplayType(
    SentryReplayEvent$ReplayType replayType,
  ) {
    final _$replayType = replayType.reference;
    _setReplayType(reference.pointer, _id_setReplayType as jni$_.JMethodIDPtr,
            _$replayType.pointer)
        .check();
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_serialize = _class.instanceMethodId(
    r'serialize',
    r'(Lio/sentry/ObjectWriter;Lio/sentry/ILogger;)V',
  );

  static final _serialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void serialize(io.sentry.ObjectWriter objectWriter, io.sentry.ILogger iLogger)`
  void serialize(
    jni$_.JObject objectWriter,
    jni$_.JObject iLogger,
  ) {
    final _$objectWriter = objectWriter.reference;
    final _$iLogger = iLogger.reference;
    _serialize(reference.pointer, _id_serialize as jni$_.JMethodIDPtr,
            _$objectWriter.pointer, _$iLogger.pointer)
        .check();
  }

  static final _id_getUnknown = _class.instanceMethodId(
    r'getUnknown',
    r'()Ljava/util/Map;',
  );

  static final _getUnknown = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Map<java.lang.String, java.lang.Object> getUnknown()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JObject?>? getUnknown() {
    return _getUnknown(reference.pointer, _id_getUnknown as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JObject?>(
                jni$_.JStringNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_setUnknown = _class.instanceMethodId(
    r'setUnknown',
    r'(Ljava/util/Map;)V',
  );

  static final _setUnknown = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setUnknown(java.util.Map<java.lang.String, java.lang.Object> map)`
  void setUnknown(
    jni$_.JMap<jni$_.JString?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    _setUnknown(reference.pointer, _id_setUnknown as jni$_.JMethodIDPtr,
            _$map.pointer)
        .check();
  }
}

final class $SentryReplayEvent$NullableType
    extends jni$_.JObjType<SentryReplayEvent?> {
  @jni$_.internal
  const $SentryReplayEvent$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryReplayEvent;';

  @jni$_.internal
  @core$_.override
  SentryReplayEvent? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryReplayEvent.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $SentryBaseEvent$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayEvent?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($SentryReplayEvent$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryReplayEvent$NullableType) &&
        other is $SentryReplayEvent$NullableType;
  }
}

final class $SentryReplayEvent$Type extends jni$_.JObjType<SentryReplayEvent> {
  @jni$_.internal
  const $SentryReplayEvent$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryReplayEvent;';

  @jni$_.internal
  @core$_.override
  SentryReplayEvent fromReference(jni$_.JReference reference) =>
      SentryReplayEvent.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $SentryBaseEvent$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryReplayEvent?> get nullableType =>
      const $SentryReplayEvent$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($SentryReplayEvent$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryReplayEvent$Type) &&
        other is $SentryReplayEvent$Type;
  }
}

/// from: `io.sentry.SentryEvent$Deserializer`
class SentryEvent$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryEvent$Deserializer> $type;

  @jni$_.internal
  SentryEvent$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryEvent$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryEvent$Deserializer$NullableType();
  static const type = $SentryEvent$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryEvent$Deserializer() {
    return SentryEvent$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserialize = _class.instanceMethodId(
    r'deserialize',
    r'(Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Lio/sentry/SentryEvent;',
  );

  static final _deserialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.SentryEvent deserialize(io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryEvent deserialize(
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserialize(
            reference.pointer,
            _id_deserialize as jni$_.JMethodIDPtr,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .object<SentryEvent>(const $SentryEvent$Type());
  }
}

final class $SentryEvent$Deserializer$NullableType
    extends jni$_.JObjType<SentryEvent$Deserializer?> {
  @jni$_.internal
  const $SentryEvent$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryEvent$Deserializer;';

  @jni$_.internal
  @core$_.override
  SentryEvent$Deserializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryEvent$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryEvent$Deserializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryEvent$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryEvent$Deserializer$NullableType) &&
        other is $SentryEvent$Deserializer$NullableType;
  }
}

final class $SentryEvent$Deserializer$Type
    extends jni$_.JObjType<SentryEvent$Deserializer> {
  @jni$_.internal
  const $SentryEvent$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryEvent$Deserializer;';

  @jni$_.internal
  @core$_.override
  SentryEvent$Deserializer fromReference(jni$_.JReference reference) =>
      SentryEvent$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryEvent$Deserializer?> get nullableType =>
      const $SentryEvent$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryEvent$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryEvent$Deserializer$Type) &&
        other is $SentryEvent$Deserializer$Type;
  }
}

/// from: `io.sentry.SentryEvent$JsonKeys`
class SentryEvent$JsonKeys extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryEvent$JsonKeys> $type;

  @jni$_.internal
  SentryEvent$JsonKeys.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/SentryEvent$JsonKeys');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryEvent$JsonKeys$NullableType();
  static const type = $SentryEvent$JsonKeys$Type();
  static final _id_TIMESTAMP = _class.staticFieldId(
    r'TIMESTAMP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TIMESTAMP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TIMESTAMP =>
      _id_TIMESTAMP.get(_class, const jni$_.JStringNullableType());

  static final _id_MESSAGE = _class.staticFieldId(
    r'MESSAGE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MESSAGE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get MESSAGE =>
      _id_MESSAGE.get(_class, const jni$_.JStringNullableType());

  static final _id_LOGGER = _class.staticFieldId(
    r'LOGGER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LOGGER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get LOGGER =>
      _id_LOGGER.get(_class, const jni$_.JStringNullableType());

  static final _id_THREADS = _class.staticFieldId(
    r'THREADS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String THREADS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get THREADS =>
      _id_THREADS.get(_class, const jni$_.JStringNullableType());

  static final _id_EXCEPTION = _class.staticFieldId(
    r'EXCEPTION',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EXCEPTION`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EXCEPTION =>
      _id_EXCEPTION.get(_class, const jni$_.JStringNullableType());

  static final _id_LEVEL = _class.staticFieldId(
    r'LEVEL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LEVEL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get LEVEL =>
      _id_LEVEL.get(_class, const jni$_.JStringNullableType());

  static final _id_TRANSACTION = _class.staticFieldId(
    r'TRANSACTION',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TRANSACTION`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TRANSACTION =>
      _id_TRANSACTION.get(_class, const jni$_.JStringNullableType());

  static final _id_FINGERPRINT = _class.staticFieldId(
    r'FINGERPRINT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FINGERPRINT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get FINGERPRINT =>
      _id_FINGERPRINT.get(_class, const jni$_.JStringNullableType());

  static final _id_MODULES = _class.staticFieldId(
    r'MODULES',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MODULES`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get MODULES =>
      _id_MODULES.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryEvent$JsonKeys() {
    return SentryEvent$JsonKeys.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $SentryEvent$JsonKeys$NullableType
    extends jni$_.JObjType<SentryEvent$JsonKeys?> {
  @jni$_.internal
  const $SentryEvent$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryEvent$JsonKeys;';

  @jni$_.internal
  @core$_.override
  SentryEvent$JsonKeys? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryEvent$JsonKeys.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryEvent$JsonKeys?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryEvent$JsonKeys$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryEvent$JsonKeys$NullableType) &&
        other is $SentryEvent$JsonKeys$NullableType;
  }
}

final class $SentryEvent$JsonKeys$Type
    extends jni$_.JObjType<SentryEvent$JsonKeys> {
  @jni$_.internal
  const $SentryEvent$JsonKeys$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryEvent$JsonKeys;';

  @jni$_.internal
  @core$_.override
  SentryEvent$JsonKeys fromReference(jni$_.JReference reference) =>
      SentryEvent$JsonKeys.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryEvent$JsonKeys?> get nullableType =>
      const $SentryEvent$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryEvent$JsonKeys$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryEvent$JsonKeys$Type) &&
        other is $SentryEvent$JsonKeys$Type;
  }
}

/// from: `io.sentry.SentryEvent`
class SentryEvent extends SentryBaseEvent {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryEvent> $type;

  @jni$_.internal
  SentryEvent.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/SentryEvent');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryEvent$NullableType();
  static const type = $SentryEvent$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Throwable;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.Throwable throwable)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryEvent(
    jni$_.JObject? throwable,
  ) {
    final _$throwable = throwable?.reference ?? jni$_.jNullReference;
    return SentryEvent.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$throwable.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'()V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryEvent.new$1() {
    return SentryEvent.fromReference(
        _new$1(_class.reference.pointer, _id_new$1 as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/util/Date;)V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.util.Date date)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryEvent.new$2(
    jni$_.JObject date,
  ) {
    final _$date = date.reference;
    return SentryEvent.fromReference(_new$2(_class.reference.pointer,
            _id_new$2 as jni$_.JMethodIDPtr, _$date.pointer)
        .reference);
  }

  static final _id_getTimestamp = _class.instanceMethodId(
    r'getTimestamp',
    r'()Ljava/util/Date;',
  );

  static final _getTimestamp = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Date getTimestamp()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getTimestamp() {
    return _getTimestamp(
            reference.pointer, _id_getTimestamp as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setTimestamp = _class.instanceMethodId(
    r'setTimestamp',
    r'(Ljava/util/Date;)V',
  );

  static final _setTimestamp = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTimestamp(java.util.Date date)`
  void setTimestamp(
    jni$_.JObject date,
  ) {
    final _$date = date.reference;
    _setTimestamp(reference.pointer, _id_setTimestamp as jni$_.JMethodIDPtr,
            _$date.pointer)
        .check();
  }

  static final _id_getMessage = _class.instanceMethodId(
    r'getMessage',
    r'()Lio/sentry/protocol/Message;',
  );

  static final _getMessage = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.Message getMessage()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getMessage() {
    return _getMessage(reference.pointer, _id_getMessage as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setMessage = _class.instanceMethodId(
    r'setMessage',
    r'(Lio/sentry/protocol/Message;)V',
  );

  static final _setMessage = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setMessage(io.sentry.protocol.Message message)`
  void setMessage(
    jni$_.JObject? message,
  ) {
    final _$message = message?.reference ?? jni$_.jNullReference;
    _setMessage(reference.pointer, _id_setMessage as jni$_.JMethodIDPtr,
            _$message.pointer)
        .check();
  }

  static final _id_getLogger = _class.instanceMethodId(
    r'getLogger',
    r'()Ljava/lang/String;',
  );

  static final _getLogger = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getLogger()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getLogger() {
    return _getLogger(reference.pointer, _id_getLogger as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setLogger = _class.instanceMethodId(
    r'setLogger',
    r'(Ljava/lang/String;)V',
  );

  static final _setLogger = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setLogger(java.lang.String string)`
  void setLogger(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setLogger(reference.pointer, _id_setLogger as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getThreads = _class.instanceMethodId(
    r'getThreads',
    r'()Ljava/util/List;',
  );

  static final _getThreads = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<io.sentry.protocol.SentryThread> getThreads()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getThreads() {
    return _getThreads(reference.pointer, _id_getThreads as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_setThreads = _class.instanceMethodId(
    r'setThreads',
    r'(Ljava/util/List;)V',
  );

  static final _setThreads = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setThreads(java.util.List<io.sentry.protocol.SentryThread> list)`
  void setThreads(
    jni$_.JList<jni$_.JObject?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    _setThreads(reference.pointer, _id_setThreads as jni$_.JMethodIDPtr,
            _$list.pointer)
        .check();
  }

  static final _id_getExceptions = _class.instanceMethodId(
    r'getExceptions',
    r'()Ljava/util/List;',
  );

  static final _getExceptions = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<io.sentry.protocol.SentryException> getExceptions()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getExceptions() {
    return _getExceptions(
            reference.pointer, _id_getExceptions as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_setExceptions = _class.instanceMethodId(
    r'setExceptions',
    r'(Ljava/util/List;)V',
  );

  static final _setExceptions = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setExceptions(java.util.List<io.sentry.protocol.SentryException> list)`
  void setExceptions(
    jni$_.JList<jni$_.JObject?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    _setExceptions(reference.pointer, _id_setExceptions as jni$_.JMethodIDPtr,
            _$list.pointer)
        .check();
  }

  static final _id_getLevel = _class.instanceMethodId(
    r'getLevel',
    r'()Lio/sentry/SentryLevel;',
  );

  static final _getLevel = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryLevel getLevel()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryLevel? getLevel() {
    return _getLevel(reference.pointer, _id_getLevel as jni$_.JMethodIDPtr)
        .object<SentryLevel?>(const $SentryLevel$NullableType());
  }

  static final _id_setLevel = _class.instanceMethodId(
    r'setLevel',
    r'(Lio/sentry/SentryLevel;)V',
  );

  static final _setLevel = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setLevel(io.sentry.SentryLevel sentryLevel)`
  void setLevel(
    SentryLevel? sentryLevel,
  ) {
    final _$sentryLevel = sentryLevel?.reference ?? jni$_.jNullReference;
    _setLevel(reference.pointer, _id_setLevel as jni$_.JMethodIDPtr,
            _$sentryLevel.pointer)
        .check();
  }

  static final _id_getTransaction = _class.instanceMethodId(
    r'getTransaction',
    r'()Ljava/lang/String;',
  );

  static final _getTransaction = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getTransaction()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getTransaction() {
    return _getTransaction(
            reference.pointer, _id_getTransaction as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setTransaction = _class.instanceMethodId(
    r'setTransaction',
    r'(Ljava/lang/String;)V',
  );

  static final _setTransaction = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTransaction(java.lang.String string)`
  void setTransaction(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setTransaction(reference.pointer, _id_setTransaction as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getFingerprints = _class.instanceMethodId(
    r'getFingerprints',
    r'()Ljava/util/List;',
  );

  static final _getFingerprints = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<java.lang.String> getFingerprints()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? getFingerprints() {
    return _getFingerprints(
            reference.pointer, _id_getFingerprints as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>?>(
            const jni$_.JListNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_setFingerprints = _class.instanceMethodId(
    r'setFingerprints',
    r'(Ljava/util/List;)V',
  );

  static final _setFingerprints = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setFingerprints(java.util.List<java.lang.String> list)`
  void setFingerprints(
    jni$_.JList<jni$_.JString?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    _setFingerprints(reference.pointer,
            _id_setFingerprints as jni$_.JMethodIDPtr, _$list.pointer)
        .check();
  }

  static final _id_setModules = _class.instanceMethodId(
    r'setModules',
    r'(Ljava/util/Map;)V',
  );

  static final _setModules = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setModules(java.util.Map<java.lang.String, java.lang.String> map)`
  void setModules(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    _setModules(reference.pointer, _id_setModules as jni$_.JMethodIDPtr,
            _$map.pointer)
        .check();
  }

  static final _id_setModule = _class.instanceMethodId(
    r'setModule',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setModule = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setModule(java.lang.String string, java.lang.String string1)`
  void setModule(
    jni$_.JString string,
    jni$_.JString string1,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    _setModule(reference.pointer, _id_setModule as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  static final _id_removeModule = _class.instanceMethodId(
    r'removeModule',
    r'(Ljava/lang/String;)V',
  );

  static final _removeModule = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeModule(java.lang.String string)`
  void removeModule(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _removeModule(reference.pointer, _id_removeModule as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getModule = _class.instanceMethodId(
    r'getModule',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _getModule = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String getModule(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getModule(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _getModule(reference.pointer, _id_getModule as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_isCrashed = _class.instanceMethodId(
    r'isCrashed',
    r'()Z',
  );

  static final _isCrashed = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isCrashed()`
  bool isCrashed() {
    return _isCrashed(reference.pointer, _id_isCrashed as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getUnhandledException = _class.instanceMethodId(
    r'getUnhandledException',
    r'()Lio/sentry/protocol/SentryException;',
  );

  static final _getUnhandledException = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.SentryException getUnhandledException()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getUnhandledException() {
    return _getUnhandledException(
            reference.pointer, _id_getUnhandledException as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_isErrored = _class.instanceMethodId(
    r'isErrored',
    r'()Z',
  );

  static final _isErrored = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isErrored()`
  bool isErrored() {
    return _isErrored(reference.pointer, _id_isErrored as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_serialize = _class.instanceMethodId(
    r'serialize',
    r'(Lio/sentry/ObjectWriter;Lio/sentry/ILogger;)V',
  );

  static final _serialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void serialize(io.sentry.ObjectWriter objectWriter, io.sentry.ILogger iLogger)`
  void serialize(
    jni$_.JObject objectWriter,
    jni$_.JObject iLogger,
  ) {
    final _$objectWriter = objectWriter.reference;
    final _$iLogger = iLogger.reference;
    _serialize(reference.pointer, _id_serialize as jni$_.JMethodIDPtr,
            _$objectWriter.pointer, _$iLogger.pointer)
        .check();
  }

  static final _id_getUnknown = _class.instanceMethodId(
    r'getUnknown',
    r'()Ljava/util/Map;',
  );

  static final _getUnknown = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Map<java.lang.String, java.lang.Object> getUnknown()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JObject?>? getUnknown() {
    return _getUnknown(reference.pointer, _id_getUnknown as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JObject?>(
                jni$_.JStringNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_setUnknown = _class.instanceMethodId(
    r'setUnknown',
    r'(Ljava/util/Map;)V',
  );

  static final _setUnknown = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setUnknown(java.util.Map<java.lang.String, java.lang.Object> map)`
  void setUnknown(
    jni$_.JMap<jni$_.JString?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    _setUnknown(reference.pointer, _id_setUnknown as jni$_.JMethodIDPtr,
            _$map.pointer)
        .check();
  }
}

final class $SentryEvent$NullableType extends jni$_.JObjType<SentryEvent?> {
  @jni$_.internal
  const $SentryEvent$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryEvent;';

  @jni$_.internal
  @core$_.override
  SentryEvent? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : SentryEvent.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $SentryBaseEvent$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryEvent?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($SentryEvent$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryEvent$NullableType) &&
        other is $SentryEvent$NullableType;
  }
}

final class $SentryEvent$Type extends jni$_.JObjType<SentryEvent> {
  @jni$_.internal
  const $SentryEvent$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryEvent;';

  @jni$_.internal
  @core$_.override
  SentryEvent fromReference(jni$_.JReference reference) =>
      SentryEvent.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $SentryBaseEvent$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryEvent?> get nullableType =>
      const $SentryEvent$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($SentryEvent$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryEvent$Type) &&
        other is $SentryEvent$Type;
  }
}

/// from: `io.sentry.SentryBaseEvent$Deserializer`
class SentryBaseEvent$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryBaseEvent$Deserializer> $type;

  @jni$_.internal
  SentryBaseEvent$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryBaseEvent$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryBaseEvent$Deserializer$NullableType();
  static const type = $SentryBaseEvent$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryBaseEvent$Deserializer() {
    return SentryBaseEvent$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserializeValue = _class.instanceMethodId(
    r'deserializeValue',
    r'(Lio/sentry/SentryBaseEvent;Ljava/lang/String;Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Z',
  );

  static final _deserializeValue = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean deserializeValue(io.sentry.SentryBaseEvent sentryBaseEvent, java.lang.String string, io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  bool deserializeValue(
    SentryBaseEvent sentryBaseEvent,
    jni$_.JString string,
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$sentryBaseEvent = sentryBaseEvent.reference;
    final _$string = string.reference;
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserializeValue(
            reference.pointer,
            _id_deserializeValue as jni$_.JMethodIDPtr,
            _$sentryBaseEvent.pointer,
            _$string.pointer,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .boolean;
  }
}

final class $SentryBaseEvent$Deserializer$NullableType
    extends jni$_.JObjType<SentryBaseEvent$Deserializer?> {
  @jni$_.internal
  const $SentryBaseEvent$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryBaseEvent$Deserializer;';

  @jni$_.internal
  @core$_.override
  SentryBaseEvent$Deserializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryBaseEvent$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryBaseEvent$Deserializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryBaseEvent$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryBaseEvent$Deserializer$NullableType) &&
        other is $SentryBaseEvent$Deserializer$NullableType;
  }
}

final class $SentryBaseEvent$Deserializer$Type
    extends jni$_.JObjType<SentryBaseEvent$Deserializer> {
  @jni$_.internal
  const $SentryBaseEvent$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryBaseEvent$Deserializer;';

  @jni$_.internal
  @core$_.override
  SentryBaseEvent$Deserializer fromReference(jni$_.JReference reference) =>
      SentryBaseEvent$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryBaseEvent$Deserializer?> get nullableType =>
      const $SentryBaseEvent$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryBaseEvent$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryBaseEvent$Deserializer$Type) &&
        other is $SentryBaseEvent$Deserializer$Type;
  }
}

/// from: `io.sentry.SentryBaseEvent$JsonKeys`
class SentryBaseEvent$JsonKeys extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryBaseEvent$JsonKeys> $type;

  @jni$_.internal
  SentryBaseEvent$JsonKeys.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryBaseEvent$JsonKeys');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryBaseEvent$JsonKeys$NullableType();
  static const type = $SentryBaseEvent$JsonKeys$Type();
  static final _id_EVENT_ID = _class.staticFieldId(
    r'EVENT_ID',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EVENT_ID`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EVENT_ID =>
      _id_EVENT_ID.get(_class, const jni$_.JStringNullableType());

  static final _id_CONTEXTS = _class.staticFieldId(
    r'CONTEXTS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CONTEXTS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CONTEXTS =>
      _id_CONTEXTS.get(_class, const jni$_.JStringNullableType());

  static final _id_SDK = _class.staticFieldId(
    r'SDK',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SDK`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SDK =>
      _id_SDK.get(_class, const jni$_.JStringNullableType());

  static final _id_REQUEST = _class.staticFieldId(
    r'REQUEST',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String REQUEST`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get REQUEST =>
      _id_REQUEST.get(_class, const jni$_.JStringNullableType());

  static final _id_TAGS = _class.staticFieldId(
    r'TAGS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TAGS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TAGS =>
      _id_TAGS.get(_class, const jni$_.JStringNullableType());

  static final _id_RELEASE = _class.staticFieldId(
    r'RELEASE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RELEASE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get RELEASE =>
      _id_RELEASE.get(_class, const jni$_.JStringNullableType());

  static final _id_ENVIRONMENT = _class.staticFieldId(
    r'ENVIRONMENT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ENVIRONMENT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ENVIRONMENT =>
      _id_ENVIRONMENT.get(_class, const jni$_.JStringNullableType());

  static final _id_PLATFORM = _class.staticFieldId(
    r'PLATFORM',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PLATFORM`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get PLATFORM =>
      _id_PLATFORM.get(_class, const jni$_.JStringNullableType());

  static final _id_USER = _class.staticFieldId(
    r'USER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String USER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get USER =>
      _id_USER.get(_class, const jni$_.JStringNullableType());

  static final _id_SERVER_NAME = _class.staticFieldId(
    r'SERVER_NAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SERVER_NAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SERVER_NAME =>
      _id_SERVER_NAME.get(_class, const jni$_.JStringNullableType());

  static final _id_DIST = _class.staticFieldId(
    r'DIST',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DIST`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DIST =>
      _id_DIST.get(_class, const jni$_.JStringNullableType());

  static final _id_BREADCRUMBS = _class.staticFieldId(
    r'BREADCRUMBS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BREADCRUMBS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BREADCRUMBS =>
      _id_BREADCRUMBS.get(_class, const jni$_.JStringNullableType());

  static final _id_DEBUG_META = _class.staticFieldId(
    r'DEBUG_META',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DEBUG_META`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DEBUG_META =>
      _id_DEBUG_META.get(_class, const jni$_.JStringNullableType());

  static final _id_EXTRA = _class.staticFieldId(
    r'EXTRA',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EXTRA`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EXTRA =>
      _id_EXTRA.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryBaseEvent$JsonKeys() {
    return SentryBaseEvent$JsonKeys.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $SentryBaseEvent$JsonKeys$NullableType
    extends jni$_.JObjType<SentryBaseEvent$JsonKeys?> {
  @jni$_.internal
  const $SentryBaseEvent$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryBaseEvent$JsonKeys;';

  @jni$_.internal
  @core$_.override
  SentryBaseEvent$JsonKeys? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryBaseEvent$JsonKeys.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryBaseEvent$JsonKeys?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryBaseEvent$JsonKeys$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryBaseEvent$JsonKeys$NullableType) &&
        other is $SentryBaseEvent$JsonKeys$NullableType;
  }
}

final class $SentryBaseEvent$JsonKeys$Type
    extends jni$_.JObjType<SentryBaseEvent$JsonKeys> {
  @jni$_.internal
  const $SentryBaseEvent$JsonKeys$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryBaseEvent$JsonKeys;';

  @jni$_.internal
  @core$_.override
  SentryBaseEvent$JsonKeys fromReference(jni$_.JReference reference) =>
      SentryBaseEvent$JsonKeys.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryBaseEvent$JsonKeys?> get nullableType =>
      const $SentryBaseEvent$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryBaseEvent$JsonKeys$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryBaseEvent$JsonKeys$Type) &&
        other is $SentryBaseEvent$JsonKeys$Type;
  }
}

/// from: `io.sentry.SentryBaseEvent$Serializer`
class SentryBaseEvent$Serializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryBaseEvent$Serializer> $type;

  @jni$_.internal
  SentryBaseEvent$Serializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryBaseEvent$Serializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryBaseEvent$Serializer$NullableType();
  static const type = $SentryBaseEvent$Serializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryBaseEvent$Serializer() {
    return SentryBaseEvent$Serializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_serialize = _class.instanceMethodId(
    r'serialize',
    r'(Lio/sentry/SentryBaseEvent;Lio/sentry/ObjectWriter;Lio/sentry/ILogger;)V',
  );

  static final _serialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void serialize(io.sentry.SentryBaseEvent sentryBaseEvent, io.sentry.ObjectWriter objectWriter, io.sentry.ILogger iLogger)`
  void serialize(
    SentryBaseEvent sentryBaseEvent,
    jni$_.JObject objectWriter,
    jni$_.JObject iLogger,
  ) {
    final _$sentryBaseEvent = sentryBaseEvent.reference;
    final _$objectWriter = objectWriter.reference;
    final _$iLogger = iLogger.reference;
    _serialize(
            reference.pointer,
            _id_serialize as jni$_.JMethodIDPtr,
            _$sentryBaseEvent.pointer,
            _$objectWriter.pointer,
            _$iLogger.pointer)
        .check();
  }
}

final class $SentryBaseEvent$Serializer$NullableType
    extends jni$_.JObjType<SentryBaseEvent$Serializer?> {
  @jni$_.internal
  const $SentryBaseEvent$Serializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryBaseEvent$Serializer;';

  @jni$_.internal
  @core$_.override
  SentryBaseEvent$Serializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryBaseEvent$Serializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryBaseEvent$Serializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryBaseEvent$Serializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryBaseEvent$Serializer$NullableType) &&
        other is $SentryBaseEvent$Serializer$NullableType;
  }
}

final class $SentryBaseEvent$Serializer$Type
    extends jni$_.JObjType<SentryBaseEvent$Serializer> {
  @jni$_.internal
  const $SentryBaseEvent$Serializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryBaseEvent$Serializer;';

  @jni$_.internal
  @core$_.override
  SentryBaseEvent$Serializer fromReference(jni$_.JReference reference) =>
      SentryBaseEvent$Serializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryBaseEvent$Serializer?> get nullableType =>
      const $SentryBaseEvent$Serializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryBaseEvent$Serializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryBaseEvent$Serializer$Type) &&
        other is $SentryBaseEvent$Serializer$Type;
  }
}

/// from: `io.sentry.SentryBaseEvent`
class SentryBaseEvent extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryBaseEvent> $type;

  @jni$_.internal
  SentryBaseEvent.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/SentryBaseEvent');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryBaseEvent$NullableType();
  static const type = $SentryBaseEvent$Type();
  static final _id_DEFAULT_PLATFORM = _class.staticFieldId(
    r'DEFAULT_PLATFORM',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DEFAULT_PLATFORM`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DEFAULT_PLATFORM =>
      _id_DEFAULT_PLATFORM.get(_class, const jni$_.JStringNullableType());

  static final _id_getEventId = _class.instanceMethodId(
    r'getEventId',
    r'()Lio/sentry/protocol/SentryId;',
  );

  static final _getEventId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.SentryId getEventId()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryId? getEventId() {
    return _getEventId(reference.pointer, _id_getEventId as jni$_.JMethodIDPtr)
        .object<SentryId?>(const $SentryId$NullableType());
  }

  static final _id_setEventId = _class.instanceMethodId(
    r'setEventId',
    r'(Lio/sentry/protocol/SentryId;)V',
  );

  static final _setEventId = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setEventId(io.sentry.protocol.SentryId sentryId)`
  void setEventId(
    SentryId? sentryId,
  ) {
    final _$sentryId = sentryId?.reference ?? jni$_.jNullReference;
    _setEventId(reference.pointer, _id_setEventId as jni$_.JMethodIDPtr,
            _$sentryId.pointer)
        .check();
  }

  static final _id_getContexts = _class.instanceMethodId(
    r'getContexts',
    r'()Lio/sentry/protocol/Contexts;',
  );

  static final _getContexts = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.Contexts getContexts()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getContexts() {
    return _getContexts(
            reference.pointer, _id_getContexts as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getSdk = _class.instanceMethodId(
    r'getSdk',
    r'()Lio/sentry/protocol/SdkVersion;',
  );

  static final _getSdk = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.SdkVersion getSdk()`
  /// The returned object must be released after use, by calling the [release] method.
  SdkVersion? getSdk() {
    return _getSdk(reference.pointer, _id_getSdk as jni$_.JMethodIDPtr)
        .object<SdkVersion?>(const $SdkVersion$NullableType());
  }

  static final _id_setSdk = _class.instanceMethodId(
    r'setSdk',
    r'(Lio/sentry/protocol/SdkVersion;)V',
  );

  static final _setSdk = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setSdk(io.sentry.protocol.SdkVersion sdkVersion)`
  void setSdk(
    SdkVersion? sdkVersion,
  ) {
    final _$sdkVersion = sdkVersion?.reference ?? jni$_.jNullReference;
    _setSdk(reference.pointer, _id_setSdk as jni$_.JMethodIDPtr,
            _$sdkVersion.pointer)
        .check();
  }

  static final _id_getRequest = _class.instanceMethodId(
    r'getRequest',
    r'()Lio/sentry/protocol/Request;',
  );

  static final _getRequest = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.Request getRequest()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getRequest() {
    return _getRequest(reference.pointer, _id_getRequest as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setRequest = _class.instanceMethodId(
    r'setRequest',
    r'(Lio/sentry/protocol/Request;)V',
  );

  static final _setRequest = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setRequest(io.sentry.protocol.Request request)`
  void setRequest(
    jni$_.JObject? request,
  ) {
    final _$request = request?.reference ?? jni$_.jNullReference;
    _setRequest(reference.pointer, _id_setRequest as jni$_.JMethodIDPtr,
            _$request.pointer)
        .check();
  }

  static final _id_getThrowable = _class.instanceMethodId(
    r'getThrowable',
    r'()Ljava/lang/Throwable;',
  );

  static final _getThrowable = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Throwable getThrowable()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getThrowable() {
    return _getThrowable(
            reference.pointer, _id_getThrowable as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getThrowableMechanism = _class.instanceMethodId(
    r'getThrowableMechanism',
    r'()Ljava/lang/Throwable;',
  );

  static final _getThrowableMechanism = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Throwable getThrowableMechanism()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getThrowableMechanism() {
    return _getThrowableMechanism(
            reference.pointer, _id_getThrowableMechanism as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setThrowable = _class.instanceMethodId(
    r'setThrowable',
    r'(Ljava/lang/Throwable;)V',
  );

  static final _setThrowable = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setThrowable(java.lang.Throwable throwable)`
  void setThrowable(
    jni$_.JObject? throwable,
  ) {
    final _$throwable = throwable?.reference ?? jni$_.jNullReference;
    _setThrowable(reference.pointer, _id_setThrowable as jni$_.JMethodIDPtr,
            _$throwable.pointer)
        .check();
  }

  static final _id_getTags = _class.instanceMethodId(
    r'getTags',
    r'()Ljava/util/Map;',
  );

  static final _getTags = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> getTags()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? getTags() {
    return _getTags(reference.pointer, _id_getTags as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_setTags = _class.instanceMethodId(
    r'setTags',
    r'(Ljava/util/Map;)V',
  );

  static final _setTags = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTags(java.util.Map<java.lang.String, java.lang.String> map)`
  void setTags(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    _setTags(
            reference.pointer, _id_setTags as jni$_.JMethodIDPtr, _$map.pointer)
        .check();
  }

  static final _id_removeTag = _class.instanceMethodId(
    r'removeTag',
    r'(Ljava/lang/String;)V',
  );

  static final _removeTag = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeTag(java.lang.String string)`
  void removeTag(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _removeTag(reference.pointer, _id_removeTag as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getTag = _class.instanceMethodId(
    r'getTag',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _getTag = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String getTag(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getTag(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getTag(reference.pointer, _id_getTag as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setTag = _class.instanceMethodId(
    r'setTag',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setTag = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTag(java.lang.String string, java.lang.String string1)`
  void setTag(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setTag(reference.pointer, _id_setTag as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  static final _id_getRelease = _class.instanceMethodId(
    r'getRelease',
    r'()Ljava/lang/String;',
  );

  static final _getRelease = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getRelease()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getRelease() {
    return _getRelease(reference.pointer, _id_getRelease as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setRelease = _class.instanceMethodId(
    r'setRelease',
    r'(Ljava/lang/String;)V',
  );

  static final _setRelease = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setRelease(java.lang.String string)`
  void setRelease(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setRelease(reference.pointer, _id_setRelease as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getEnvironment = _class.instanceMethodId(
    r'getEnvironment',
    r'()Ljava/lang/String;',
  );

  static final _getEnvironment = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getEnvironment()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getEnvironment() {
    return _getEnvironment(
            reference.pointer, _id_getEnvironment as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setEnvironment = _class.instanceMethodId(
    r'setEnvironment',
    r'(Ljava/lang/String;)V',
  );

  static final _setEnvironment = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setEnvironment(java.lang.String string)`
  void setEnvironment(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setEnvironment(reference.pointer, _id_setEnvironment as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getPlatform = _class.instanceMethodId(
    r'getPlatform',
    r'()Ljava/lang/String;',
  );

  static final _getPlatform = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getPlatform()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getPlatform() {
    return _getPlatform(
            reference.pointer, _id_getPlatform as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setPlatform = _class.instanceMethodId(
    r'setPlatform',
    r'(Ljava/lang/String;)V',
  );

  static final _setPlatform = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setPlatform(java.lang.String string)`
  void setPlatform(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setPlatform(reference.pointer, _id_setPlatform as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getServerName = _class.instanceMethodId(
    r'getServerName',
    r'()Ljava/lang/String;',
  );

  static final _getServerName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getServerName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getServerName() {
    return _getServerName(
            reference.pointer, _id_getServerName as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setServerName = _class.instanceMethodId(
    r'setServerName',
    r'(Ljava/lang/String;)V',
  );

  static final _setServerName = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setServerName(java.lang.String string)`
  void setServerName(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setServerName(reference.pointer, _id_setServerName as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getDist = _class.instanceMethodId(
    r'getDist',
    r'()Ljava/lang/String;',
  );

  static final _getDist = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getDist()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDist() {
    return _getDist(reference.pointer, _id_getDist as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setDist = _class.instanceMethodId(
    r'setDist',
    r'(Ljava/lang/String;)V',
  );

  static final _setDist = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDist(java.lang.String string)`
  void setDist(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setDist(reference.pointer, _id_setDist as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getUser = _class.instanceMethodId(
    r'getUser',
    r'()Lio/sentry/protocol/User;',
  );

  static final _getUser = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.User getUser()`
  /// The returned object must be released after use, by calling the [release] method.
  User? getUser() {
    return _getUser(reference.pointer, _id_getUser as jni$_.JMethodIDPtr)
        .object<User?>(const $User$NullableType());
  }

  static final _id_setUser = _class.instanceMethodId(
    r'setUser',
    r'(Lio/sentry/protocol/User;)V',
  );

  static final _setUser = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setUser(io.sentry.protocol.User user)`
  void setUser(
    User? user,
  ) {
    final _$user = user?.reference ?? jni$_.jNullReference;
    _setUser(reference.pointer, _id_setUser as jni$_.JMethodIDPtr,
            _$user.pointer)
        .check();
  }

  static final _id_getBreadcrumbs = _class.instanceMethodId(
    r'getBreadcrumbs',
    r'()Ljava/util/List;',
  );

  static final _getBreadcrumbs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<io.sentry.Breadcrumb> getBreadcrumbs()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<Breadcrumb?>? getBreadcrumbs() {
    return _getBreadcrumbs(
            reference.pointer, _id_getBreadcrumbs as jni$_.JMethodIDPtr)
        .object<jni$_.JList<Breadcrumb?>?>(
            const jni$_.JListNullableType<Breadcrumb?>(
                $Breadcrumb$NullableType()));
  }

  static final _id_setBreadcrumbs = _class.instanceMethodId(
    r'setBreadcrumbs',
    r'(Ljava/util/List;)V',
  );

  static final _setBreadcrumbs = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setBreadcrumbs(java.util.List<io.sentry.Breadcrumb> list)`
  void setBreadcrumbs(
    jni$_.JList<Breadcrumb?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    _setBreadcrumbs(reference.pointer, _id_setBreadcrumbs as jni$_.JMethodIDPtr,
            _$list.pointer)
        .check();
  }

  static final _id_addBreadcrumb = _class.instanceMethodId(
    r'addBreadcrumb',
    r'(Lio/sentry/Breadcrumb;)V',
  );

  static final _addBreadcrumb = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addBreadcrumb(io.sentry.Breadcrumb breadcrumb)`
  void addBreadcrumb(
    Breadcrumb breadcrumb,
  ) {
    final _$breadcrumb = breadcrumb.reference;
    _addBreadcrumb(reference.pointer, _id_addBreadcrumb as jni$_.JMethodIDPtr,
            _$breadcrumb.pointer)
        .check();
  }

  static final _id_getDebugMeta = _class.instanceMethodId(
    r'getDebugMeta',
    r'()Lio/sentry/protocol/DebugMeta;',
  );

  static final _getDebugMeta = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.DebugMeta getDebugMeta()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getDebugMeta() {
    return _getDebugMeta(
            reference.pointer, _id_getDebugMeta as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setDebugMeta = _class.instanceMethodId(
    r'setDebugMeta',
    r'(Lio/sentry/protocol/DebugMeta;)V',
  );

  static final _setDebugMeta = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDebugMeta(io.sentry.protocol.DebugMeta debugMeta)`
  void setDebugMeta(
    jni$_.JObject? debugMeta,
  ) {
    final _$debugMeta = debugMeta?.reference ?? jni$_.jNullReference;
    _setDebugMeta(reference.pointer, _id_setDebugMeta as jni$_.JMethodIDPtr,
            _$debugMeta.pointer)
        .check();
  }

  static final _id_getExtras = _class.instanceMethodId(
    r'getExtras',
    r'()Ljava/util/Map;',
  );

  static final _getExtras = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Map<java.lang.String, java.lang.Object> getExtras()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JObject?>? getExtras() {
    return _getExtras(reference.pointer, _id_getExtras as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JObject?>(
                jni$_.JStringNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_setExtras = _class.instanceMethodId(
    r'setExtras',
    r'(Ljava/util/Map;)V',
  );

  static final _setExtras = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setExtras(java.util.Map<java.lang.String, java.lang.Object> map)`
  void setExtras(
    jni$_.JMap<jni$_.JString?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    _setExtras(reference.pointer, _id_setExtras as jni$_.JMethodIDPtr,
            _$map.pointer)
        .check();
  }

  static final _id_setExtra = _class.instanceMethodId(
    r'setExtra',
    r'(Ljava/lang/String;Ljava/lang/Object;)V',
  );

  static final _setExtra = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setExtra(java.lang.String string, java.lang.Object object)`
  void setExtra(
    jni$_.JString? string,
    jni$_.JObject? object,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    _setExtra(reference.pointer, _id_setExtra as jni$_.JMethodIDPtr,
            _$string.pointer, _$object.pointer)
        .check();
  }

  static final _id_removeExtra = _class.instanceMethodId(
    r'removeExtra',
    r'(Ljava/lang/String;)V',
  );

  static final _removeExtra = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeExtra(java.lang.String string)`
  void removeExtra(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _removeExtra(reference.pointer, _id_removeExtra as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getExtra = _class.instanceMethodId(
    r'getExtra',
    r'(Ljava/lang/String;)Ljava/lang/Object;',
  );

  static final _getExtra = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object getExtra(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getExtra(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getExtra(reference.pointer, _id_getExtra as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_addBreadcrumb$1 = _class.instanceMethodId(
    r'addBreadcrumb',
    r'(Ljava/lang/String;)V',
  );

  static final _addBreadcrumb$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addBreadcrumb(java.lang.String string)`
  void addBreadcrumb$1(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _addBreadcrumb$1(reference.pointer,
            _id_addBreadcrumb$1 as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }
}

final class $SentryBaseEvent$NullableType
    extends jni$_.JObjType<SentryBaseEvent?> {
  @jni$_.internal
  const $SentryBaseEvent$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryBaseEvent;';

  @jni$_.internal
  @core$_.override
  SentryBaseEvent? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : SentryBaseEvent.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryBaseEvent?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryBaseEvent$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryBaseEvent$NullableType) &&
        other is $SentryBaseEvent$NullableType;
  }
}

final class $SentryBaseEvent$Type extends jni$_.JObjType<SentryBaseEvent> {
  @jni$_.internal
  const $SentryBaseEvent$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryBaseEvent;';

  @jni$_.internal
  @core$_.override
  SentryBaseEvent fromReference(jni$_.JReference reference) =>
      SentryBaseEvent.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryBaseEvent?> get nullableType =>
      const $SentryBaseEvent$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryBaseEvent$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryBaseEvent$Type) &&
        other is $SentryBaseEvent$Type;
  }
}

/// from: `io.sentry.SentryLevel$Deserializer`
class SentryLevel$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryLevel$Deserializer> $type;

  @jni$_.internal
  SentryLevel$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/SentryLevel$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryLevel$Deserializer$NullableType();
  static const type = $SentryLevel$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryLevel$Deserializer() {
    return SentryLevel$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserialize = _class.instanceMethodId(
    r'deserialize',
    r'(Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Lio/sentry/SentryLevel;',
  );

  static final _deserialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.SentryLevel deserialize(io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryLevel deserialize(
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserialize(
            reference.pointer,
            _id_deserialize as jni$_.JMethodIDPtr,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .object<SentryLevel>(const $SentryLevel$Type());
  }
}

final class $SentryLevel$Deserializer$NullableType
    extends jni$_.JObjType<SentryLevel$Deserializer?> {
  @jni$_.internal
  const $SentryLevel$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryLevel$Deserializer;';

  @jni$_.internal
  @core$_.override
  SentryLevel$Deserializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryLevel$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryLevel$Deserializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryLevel$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryLevel$Deserializer$NullableType) &&
        other is $SentryLevel$Deserializer$NullableType;
  }
}

final class $SentryLevel$Deserializer$Type
    extends jni$_.JObjType<SentryLevel$Deserializer> {
  @jni$_.internal
  const $SentryLevel$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryLevel$Deserializer;';

  @jni$_.internal
  @core$_.override
  SentryLevel$Deserializer fromReference(jni$_.JReference reference) =>
      SentryLevel$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryLevel$Deserializer?> get nullableType =>
      const $SentryLevel$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryLevel$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryLevel$Deserializer$Type) &&
        other is $SentryLevel$Deserializer$Type;
  }
}

/// from: `io.sentry.SentryLevel`
class SentryLevel extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryLevel> $type;

  @jni$_.internal
  SentryLevel.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/SentryLevel');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryLevel$NullableType();
  static const type = $SentryLevel$Type();
  static final _id_DEBUG = _class.staticFieldId(
    r'DEBUG',
    r'Lio/sentry/SentryLevel;',
  );

  /// from: `static public final io.sentry.SentryLevel DEBUG`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryLevel get DEBUG =>
      _id_DEBUG.get(_class, const $SentryLevel$Type());

  static final _id_INFO = _class.staticFieldId(
    r'INFO',
    r'Lio/sentry/SentryLevel;',
  );

  /// from: `static public final io.sentry.SentryLevel INFO`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryLevel get INFO =>
      _id_INFO.get(_class, const $SentryLevel$Type());

  static final _id_WARNING = _class.staticFieldId(
    r'WARNING',
    r'Lio/sentry/SentryLevel;',
  );

  /// from: `static public final io.sentry.SentryLevel WARNING`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryLevel get WARNING =>
      _id_WARNING.get(_class, const $SentryLevel$Type());

  static final _id_ERROR = _class.staticFieldId(
    r'ERROR',
    r'Lio/sentry/SentryLevel;',
  );

  /// from: `static public final io.sentry.SentryLevel ERROR`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryLevel get ERROR =>
      _id_ERROR.get(_class, const $SentryLevel$Type());

  static final _id_FATAL = _class.staticFieldId(
    r'FATAL',
    r'Lio/sentry/SentryLevel;',
  );

  /// from: `static public final io.sentry.SentryLevel FATAL`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryLevel get FATAL =>
      _id_FATAL.get(_class, const $SentryLevel$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Lio/sentry/SentryLevel;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.SentryLevel[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<SentryLevel?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<SentryLevel?>?>(
            const jni$_.JArrayNullableType<SentryLevel?>(
                $SentryLevel$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Lio/sentry/SentryLevel;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.SentryLevel valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryLevel? valueOf(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<SentryLevel?>(const $SentryLevel$NullableType());
  }

  static final _id_serialize = _class.instanceMethodId(
    r'serialize',
    r'(Lio/sentry/ObjectWriter;Lio/sentry/ILogger;)V',
  );

  static final _serialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void serialize(io.sentry.ObjectWriter objectWriter, io.sentry.ILogger iLogger)`
  void serialize(
    jni$_.JObject objectWriter,
    jni$_.JObject iLogger,
  ) {
    final _$objectWriter = objectWriter.reference;
    final _$iLogger = iLogger.reference;
    _serialize(reference.pointer, _id_serialize as jni$_.JMethodIDPtr,
            _$objectWriter.pointer, _$iLogger.pointer)
        .check();
  }
}

final class $SentryLevel$NullableType extends jni$_.JObjType<SentryLevel?> {
  @jni$_.internal
  const $SentryLevel$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryLevel;';

  @jni$_.internal
  @core$_.override
  SentryLevel? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : SentryLevel.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryLevel?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryLevel$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryLevel$NullableType) &&
        other is $SentryLevel$NullableType;
  }
}

final class $SentryLevel$Type extends jni$_.JObjType<SentryLevel> {
  @jni$_.internal
  const $SentryLevel$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/SentryLevel;';

  @jni$_.internal
  @core$_.override
  SentryLevel fromReference(jni$_.JReference reference) =>
      SentryLevel.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryLevel?> get nullableType =>
      const $SentryLevel$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryLevel$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryLevel$Type) &&
        other is $SentryLevel$Type;
  }
}

/// from: `io.sentry.Hint`
class Hint extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Hint> $type;

  @jni$_.internal
  Hint.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/Hint');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Hint$NullableType();
  static const type = $Hint$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Hint() {
    return Hint.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_withAttachment = _class.staticMethodId(
    r'withAttachment',
    r'(Lio/sentry/Attachment;)Lio/sentry/Hint;',
  );

  static final _withAttachment = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Hint withAttachment(io.sentry.Attachment attachment)`
  /// The returned object must be released after use, by calling the [release] method.
  static Hint withAttachment(
    jni$_.JObject? attachment,
  ) {
    final _$attachment = attachment?.reference ?? jni$_.jNullReference;
    return _withAttachment(_class.reference.pointer,
            _id_withAttachment as jni$_.JMethodIDPtr, _$attachment.pointer)
        .object<Hint>(const $Hint$Type());
  }

  static final _id_withAttachments = _class.staticMethodId(
    r'withAttachments',
    r'(Ljava/util/List;)Lio/sentry/Hint;',
  );

  static final _withAttachments = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Hint withAttachments(java.util.List<io.sentry.Attachment> list)`
  /// The returned object must be released after use, by calling the [release] method.
  static Hint withAttachments(
    jni$_.JList<jni$_.JObject?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _withAttachments(_class.reference.pointer,
            _id_withAttachments as jni$_.JMethodIDPtr, _$list.pointer)
        .object<Hint>(const $Hint$Type());
  }

  static final _id_set = _class.instanceMethodId(
    r'set',
    r'(Ljava/lang/String;Ljava/lang/Object;)V',
  );

  static final _set = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void set(java.lang.String string, java.lang.Object object)`
  void set(
    jni$_.JString string,
    jni$_.JObject? object,
  ) {
    final _$string = string.reference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    _set(reference.pointer, _id_set as jni$_.JMethodIDPtr, _$string.pointer,
            _$object.pointer)
        .check();
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/String;)Ljava/lang/Object;',
  );

  static final _get = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object get(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? get(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _get(
            reference.pointer, _id_get as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getAs = _class.instanceMethodId(
    r'getAs',
    r'(Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/Object;',
  );

  static final _getAs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public T getAs(java.lang.String string, java.lang.Class<T> class)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? getAs<$T extends jni$_.JObject?>(
    jni$_.JString string,
    jni$_.JObject class$, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$string = string.reference;
    final _$class$ = class$.reference;
    return _getAs(reference.pointer, _id_getAs as jni$_.JMethodIDPtr,
            _$string.pointer, _$class$.pointer)
        .object<$T?>(T.nullableType);
  }

  static final _id_remove = _class.instanceMethodId(
    r'remove',
    r'(Ljava/lang/String;)V',
  );

  static final _remove = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void remove(java.lang.String string)`
  void remove(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _remove(reference.pointer, _id_remove as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_addAttachment = _class.instanceMethodId(
    r'addAttachment',
    r'(Lio/sentry/Attachment;)V',
  );

  static final _addAttachment = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addAttachment(io.sentry.Attachment attachment)`
  void addAttachment(
    jni$_.JObject? attachment,
  ) {
    final _$attachment = attachment?.reference ?? jni$_.jNullReference;
    _addAttachment(reference.pointer, _id_addAttachment as jni$_.JMethodIDPtr,
            _$attachment.pointer)
        .check();
  }

  static final _id_addAttachments = _class.instanceMethodId(
    r'addAttachments',
    r'(Ljava/util/List;)V',
  );

  static final _addAttachments = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addAttachments(java.util.List<io.sentry.Attachment> list)`
  void addAttachments(
    jni$_.JList<jni$_.JObject?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    _addAttachments(reference.pointer, _id_addAttachments as jni$_.JMethodIDPtr,
            _$list.pointer)
        .check();
  }

  static final _id_getAttachments = _class.instanceMethodId(
    r'getAttachments',
    r'()Ljava/util/List;',
  );

  static final _getAttachments = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<io.sentry.Attachment> getAttachments()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getAttachments() {
    return _getAttachments(
            reference.pointer, _id_getAttachments as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_replaceAttachments = _class.instanceMethodId(
    r'replaceAttachments',
    r'(Ljava/util/List;)V',
  );

  static final _replaceAttachments = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void replaceAttachments(java.util.List<io.sentry.Attachment> list)`
  void replaceAttachments(
    jni$_.JList<jni$_.JObject?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    _replaceAttachments(reference.pointer,
            _id_replaceAttachments as jni$_.JMethodIDPtr, _$list.pointer)
        .check();
  }

  static final _id_clearAttachments = _class.instanceMethodId(
    r'clearAttachments',
    r'()V',
  );

  static final _clearAttachments = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void clearAttachments()`
  void clearAttachments() {
    _clearAttachments(
            reference.pointer, _id_clearAttachments as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_clear = _class.instanceMethodId(
    r'clear',
    r'()V',
  );

  static final _clear = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void clear()`
  void clear() {
    _clear(reference.pointer, _id_clear as jni$_.JMethodIDPtr).check();
  }

  static final _id_setScreenshot = _class.instanceMethodId(
    r'setScreenshot',
    r'(Lio/sentry/Attachment;)V',
  );

  static final _setScreenshot = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setScreenshot(io.sentry.Attachment attachment)`
  void setScreenshot(
    jni$_.JObject? attachment,
  ) {
    final _$attachment = attachment?.reference ?? jni$_.jNullReference;
    _setScreenshot(reference.pointer, _id_setScreenshot as jni$_.JMethodIDPtr,
            _$attachment.pointer)
        .check();
  }

  static final _id_getScreenshot = _class.instanceMethodId(
    r'getScreenshot',
    r'()Lio/sentry/Attachment;',
  );

  static final _getScreenshot = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.Attachment getScreenshot()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getScreenshot() {
    return _getScreenshot(
            reference.pointer, _id_getScreenshot as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setViewHierarchy = _class.instanceMethodId(
    r'setViewHierarchy',
    r'(Lio/sentry/Attachment;)V',
  );

  static final _setViewHierarchy = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setViewHierarchy(io.sentry.Attachment attachment)`
  void setViewHierarchy(
    jni$_.JObject? attachment,
  ) {
    final _$attachment = attachment?.reference ?? jni$_.jNullReference;
    _setViewHierarchy(reference.pointer,
            _id_setViewHierarchy as jni$_.JMethodIDPtr, _$attachment.pointer)
        .check();
  }

  static final _id_getViewHierarchy = _class.instanceMethodId(
    r'getViewHierarchy',
    r'()Lio/sentry/Attachment;',
  );

  static final _getViewHierarchy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.Attachment getViewHierarchy()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getViewHierarchy() {
    return _getViewHierarchy(
            reference.pointer, _id_getViewHierarchy as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setThreadDump = _class.instanceMethodId(
    r'setThreadDump',
    r'(Lio/sentry/Attachment;)V',
  );

  static final _setThreadDump = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setThreadDump(io.sentry.Attachment attachment)`
  void setThreadDump(
    jni$_.JObject? attachment,
  ) {
    final _$attachment = attachment?.reference ?? jni$_.jNullReference;
    _setThreadDump(reference.pointer, _id_setThreadDump as jni$_.JMethodIDPtr,
            _$attachment.pointer)
        .check();
  }

  static final _id_getThreadDump = _class.instanceMethodId(
    r'getThreadDump',
    r'()Lio/sentry/Attachment;',
  );

  static final _getThreadDump = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.Attachment getThreadDump()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getThreadDump() {
    return _getThreadDump(
            reference.pointer, _id_getThreadDump as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getReplayRecording = _class.instanceMethodId(
    r'getReplayRecording',
    r'()Lio/sentry/ReplayRecording;',
  );

  static final _getReplayRecording = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ReplayRecording getReplayRecording()`
  /// The returned object must be released after use, by calling the [release] method.
  ReplayRecording? getReplayRecording() {
    return _getReplayRecording(
            reference.pointer, _id_getReplayRecording as jni$_.JMethodIDPtr)
        .object<ReplayRecording?>(const $ReplayRecording$NullableType());
  }

  static final _id_setReplayRecording = _class.instanceMethodId(
    r'setReplayRecording',
    r'(Lio/sentry/ReplayRecording;)V',
  );

  static final _setReplayRecording = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setReplayRecording(io.sentry.ReplayRecording replayRecording)`
  void setReplayRecording(
    ReplayRecording? replayRecording,
  ) {
    final _$replayRecording =
        replayRecording?.reference ?? jni$_.jNullReference;
    _setReplayRecording(
            reference.pointer,
            _id_setReplayRecording as jni$_.JMethodIDPtr,
            _$replayRecording.pointer)
        .check();
  }
}

final class $Hint$NullableType extends jni$_.JObjType<Hint?> {
  @jni$_.internal
  const $Hint$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Hint;';

  @jni$_.internal
  @core$_.override
  Hint? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Hint.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Hint?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Hint$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Hint$NullableType) &&
        other is $Hint$NullableType;
  }
}

final class $Hint$Type extends jni$_.JObjType<Hint> {
  @jni$_.internal
  const $Hint$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Hint;';

  @jni$_.internal
  @core$_.override
  Hint fromReference(jni$_.JReference reference) => Hint.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Hint?> get nullableType => const $Hint$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Hint$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Hint$Type) && other is $Hint$Type;
  }
}

/// from: `io.sentry.ReplayRecording$Deserializer`
class ReplayRecording$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ReplayRecording$Deserializer> $type;

  @jni$_.internal
  ReplayRecording$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/ReplayRecording$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ReplayRecording$Deserializer$NullableType();
  static const type = $ReplayRecording$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory ReplayRecording$Deserializer() {
    return ReplayRecording$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserialize = _class.instanceMethodId(
    r'deserialize',
    r'(Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Lio/sentry/ReplayRecording;',
  );

  static final _deserialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.ReplayRecording deserialize(io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  /// The returned object must be released after use, by calling the [release] method.
  ReplayRecording deserialize(
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserialize(
            reference.pointer,
            _id_deserialize as jni$_.JMethodIDPtr,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .object<ReplayRecording>(const $ReplayRecording$Type());
  }
}

final class $ReplayRecording$Deserializer$NullableType
    extends jni$_.JObjType<ReplayRecording$Deserializer?> {
  @jni$_.internal
  const $ReplayRecording$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/ReplayRecording$Deserializer;';

  @jni$_.internal
  @core$_.override
  ReplayRecording$Deserializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ReplayRecording$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ReplayRecording$Deserializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ReplayRecording$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ReplayRecording$Deserializer$NullableType) &&
        other is $ReplayRecording$Deserializer$NullableType;
  }
}

final class $ReplayRecording$Deserializer$Type
    extends jni$_.JObjType<ReplayRecording$Deserializer> {
  @jni$_.internal
  const $ReplayRecording$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/ReplayRecording$Deserializer;';

  @jni$_.internal
  @core$_.override
  ReplayRecording$Deserializer fromReference(jni$_.JReference reference) =>
      ReplayRecording$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ReplayRecording$Deserializer?> get nullableType =>
      const $ReplayRecording$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ReplayRecording$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ReplayRecording$Deserializer$Type) &&
        other is $ReplayRecording$Deserializer$Type;
  }
}

/// from: `io.sentry.ReplayRecording$JsonKeys`
class ReplayRecording$JsonKeys extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ReplayRecording$JsonKeys> $type;

  @jni$_.internal
  ReplayRecording$JsonKeys.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/ReplayRecording$JsonKeys');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ReplayRecording$JsonKeys$NullableType();
  static const type = $ReplayRecording$JsonKeys$Type();
  static final _id_SEGMENT_ID = _class.staticFieldId(
    r'SEGMENT_ID',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SEGMENT_ID`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SEGMENT_ID =>
      _id_SEGMENT_ID.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory ReplayRecording$JsonKeys() {
    return ReplayRecording$JsonKeys.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $ReplayRecording$JsonKeys$NullableType
    extends jni$_.JObjType<ReplayRecording$JsonKeys?> {
  @jni$_.internal
  const $ReplayRecording$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/ReplayRecording$JsonKeys;';

  @jni$_.internal
  @core$_.override
  ReplayRecording$JsonKeys? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ReplayRecording$JsonKeys.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ReplayRecording$JsonKeys?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ReplayRecording$JsonKeys$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ReplayRecording$JsonKeys$NullableType) &&
        other is $ReplayRecording$JsonKeys$NullableType;
  }
}

final class $ReplayRecording$JsonKeys$Type
    extends jni$_.JObjType<ReplayRecording$JsonKeys> {
  @jni$_.internal
  const $ReplayRecording$JsonKeys$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/ReplayRecording$JsonKeys;';

  @jni$_.internal
  @core$_.override
  ReplayRecording$JsonKeys fromReference(jni$_.JReference reference) =>
      ReplayRecording$JsonKeys.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ReplayRecording$JsonKeys?> get nullableType =>
      const $ReplayRecording$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ReplayRecording$JsonKeys$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ReplayRecording$JsonKeys$Type) &&
        other is $ReplayRecording$JsonKeys$Type;
  }
}

/// from: `io.sentry.ReplayRecording`
class ReplayRecording extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ReplayRecording> $type;

  @jni$_.internal
  ReplayRecording.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/ReplayRecording');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ReplayRecording$NullableType();
  static const type = $ReplayRecording$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory ReplayRecording() {
    return ReplayRecording.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_getSegmentId = _class.instanceMethodId(
    r'getSegmentId',
    r'()Ljava/lang/Integer;',
  );

  static final _getSegmentId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Integer getSegmentId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JInteger? getSegmentId() {
    return _getSegmentId(
            reference.pointer, _id_getSegmentId as jni$_.JMethodIDPtr)
        .object<jni$_.JInteger?>(const jni$_.JIntegerNullableType());
  }

  static final _id_setSegmentId = _class.instanceMethodId(
    r'setSegmentId',
    r'(Ljava/lang/Integer;)V',
  );

  static final _setSegmentId = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setSegmentId(java.lang.Integer integer)`
  void setSegmentId(
    jni$_.JInteger? integer,
  ) {
    final _$integer = integer?.reference ?? jni$_.jNullReference;
    _setSegmentId(reference.pointer, _id_setSegmentId as jni$_.JMethodIDPtr,
            _$integer.pointer)
        .check();
  }

  static final _id_getPayload = _class.instanceMethodId(
    r'getPayload',
    r'()Ljava/util/List;',
  );

  static final _getPayload = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<? extends io.sentry.rrweb.RRWebEvent> getPayload()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<RRWebEvent?>? getPayload() {
    return _getPayload(reference.pointer, _id_getPayload as jni$_.JMethodIDPtr)
        .object<jni$_.JList<RRWebEvent?>?>(
            const jni$_.JListNullableType<RRWebEvent?>(
                $RRWebEvent$NullableType()));
  }

  static final _id_setPayload = _class.instanceMethodId(
    r'setPayload',
    r'(Ljava/util/List;)V',
  );

  static final _setPayload = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setPayload(java.util.List<? extends io.sentry.rrweb.RRWebEvent> list)`
  void setPayload(
    jni$_.JList<RRWebEvent?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    _setPayload(reference.pointer, _id_setPayload as jni$_.JMethodIDPtr,
            _$list.pointer)
        .check();
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_serialize = _class.instanceMethodId(
    r'serialize',
    r'(Lio/sentry/ObjectWriter;Lio/sentry/ILogger;)V',
  );

  static final _serialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void serialize(io.sentry.ObjectWriter objectWriter, io.sentry.ILogger iLogger)`
  void serialize(
    jni$_.JObject objectWriter,
    jni$_.JObject iLogger,
  ) {
    final _$objectWriter = objectWriter.reference;
    final _$iLogger = iLogger.reference;
    _serialize(reference.pointer, _id_serialize as jni$_.JMethodIDPtr,
            _$objectWriter.pointer, _$iLogger.pointer)
        .check();
  }

  static final _id_getUnknown = _class.instanceMethodId(
    r'getUnknown',
    r'()Ljava/util/Map;',
  );

  static final _getUnknown = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Map<java.lang.String, java.lang.Object> getUnknown()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JObject?>? getUnknown() {
    return _getUnknown(reference.pointer, _id_getUnknown as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JObject?>(
                jni$_.JStringNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_setUnknown = _class.instanceMethodId(
    r'setUnknown',
    r'(Ljava/util/Map;)V',
  );

  static final _setUnknown = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setUnknown(java.util.Map<java.lang.String, java.lang.Object> map)`
  void setUnknown(
    jni$_.JMap<jni$_.JString?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    _setUnknown(reference.pointer, _id_setUnknown as jni$_.JMethodIDPtr,
            _$map.pointer)
        .check();
  }
}

final class $ReplayRecording$NullableType
    extends jni$_.JObjType<ReplayRecording?> {
  @jni$_.internal
  const $ReplayRecording$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/ReplayRecording;';

  @jni$_.internal
  @core$_.override
  ReplayRecording? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : ReplayRecording.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ReplayRecording?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ReplayRecording$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ReplayRecording$NullableType) &&
        other is $ReplayRecording$NullableType;
  }
}

final class $ReplayRecording$Type extends jni$_.JObjType<ReplayRecording> {
  @jni$_.internal
  const $ReplayRecording$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/ReplayRecording;';

  @jni$_.internal
  @core$_.override
  ReplayRecording fromReference(jni$_.JReference reference) =>
      ReplayRecording.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ReplayRecording?> get nullableType =>
      const $ReplayRecording$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ReplayRecording$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ReplayRecording$Type) &&
        other is $ReplayRecording$Type;
  }
}

/// from: `io.sentry.Breadcrumb$Deserializer`
class Breadcrumb$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Breadcrumb$Deserializer> $type;

  @jni$_.internal
  Breadcrumb$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/Breadcrumb$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Breadcrumb$Deserializer$NullableType();
  static const type = $Breadcrumb$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Breadcrumb$Deserializer() {
    return Breadcrumb$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserialize = _class.instanceMethodId(
    r'deserialize',
    r'(Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Lio/sentry/Breadcrumb;',
  );

  static final _deserialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.Breadcrumb deserialize(io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  /// The returned object must be released after use, by calling the [release] method.
  Breadcrumb deserialize(
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserialize(
            reference.pointer,
            _id_deserialize as jni$_.JMethodIDPtr,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }
}

final class $Breadcrumb$Deserializer$NullableType
    extends jni$_.JObjType<Breadcrumb$Deserializer?> {
  @jni$_.internal
  const $Breadcrumb$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Breadcrumb$Deserializer;';

  @jni$_.internal
  @core$_.override
  Breadcrumb$Deserializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Breadcrumb$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Breadcrumb$Deserializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Breadcrumb$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Breadcrumb$Deserializer$NullableType) &&
        other is $Breadcrumb$Deserializer$NullableType;
  }
}

final class $Breadcrumb$Deserializer$Type
    extends jni$_.JObjType<Breadcrumb$Deserializer> {
  @jni$_.internal
  const $Breadcrumb$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Breadcrumb$Deserializer;';

  @jni$_.internal
  @core$_.override
  Breadcrumb$Deserializer fromReference(jni$_.JReference reference) =>
      Breadcrumb$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Breadcrumb$Deserializer?> get nullableType =>
      const $Breadcrumb$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Breadcrumb$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Breadcrumb$Deserializer$Type) &&
        other is $Breadcrumb$Deserializer$Type;
  }
}

/// from: `io.sentry.Breadcrumb$JsonKeys`
class Breadcrumb$JsonKeys extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Breadcrumb$JsonKeys> $type;

  @jni$_.internal
  Breadcrumb$JsonKeys.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/Breadcrumb$JsonKeys');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Breadcrumb$JsonKeys$NullableType();
  static const type = $Breadcrumb$JsonKeys$Type();
  static final _id_TIMESTAMP = _class.staticFieldId(
    r'TIMESTAMP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TIMESTAMP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TIMESTAMP =>
      _id_TIMESTAMP.get(_class, const jni$_.JStringNullableType());

  static final _id_MESSAGE = _class.staticFieldId(
    r'MESSAGE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MESSAGE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get MESSAGE =>
      _id_MESSAGE.get(_class, const jni$_.JStringNullableType());

  static final _id_TYPE = _class.staticFieldId(
    r'TYPE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TYPE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TYPE =>
      _id_TYPE.get(_class, const jni$_.JStringNullableType());

  static final _id_DATA = _class.staticFieldId(
    r'DATA',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DATA`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DATA =>
      _id_DATA.get(_class, const jni$_.JStringNullableType());

  static final _id_CATEGORY = _class.staticFieldId(
    r'CATEGORY',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CATEGORY`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CATEGORY =>
      _id_CATEGORY.get(_class, const jni$_.JStringNullableType());

  static final _id_ORIGIN = _class.staticFieldId(
    r'ORIGIN',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ORIGIN`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ORIGIN =>
      _id_ORIGIN.get(_class, const jni$_.JStringNullableType());

  static final _id_LEVEL = _class.staticFieldId(
    r'LEVEL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LEVEL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get LEVEL =>
      _id_LEVEL.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Breadcrumb$JsonKeys() {
    return Breadcrumb$JsonKeys.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $Breadcrumb$JsonKeys$NullableType
    extends jni$_.JObjType<Breadcrumb$JsonKeys?> {
  @jni$_.internal
  const $Breadcrumb$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Breadcrumb$JsonKeys;';

  @jni$_.internal
  @core$_.override
  Breadcrumb$JsonKeys? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Breadcrumb$JsonKeys.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Breadcrumb$JsonKeys?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Breadcrumb$JsonKeys$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Breadcrumb$JsonKeys$NullableType) &&
        other is $Breadcrumb$JsonKeys$NullableType;
  }
}

final class $Breadcrumb$JsonKeys$Type
    extends jni$_.JObjType<Breadcrumb$JsonKeys> {
  @jni$_.internal
  const $Breadcrumb$JsonKeys$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Breadcrumb$JsonKeys;';

  @jni$_.internal
  @core$_.override
  Breadcrumb$JsonKeys fromReference(jni$_.JReference reference) =>
      Breadcrumb$JsonKeys.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Breadcrumb$JsonKeys?> get nullableType =>
      const $Breadcrumb$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Breadcrumb$JsonKeys$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Breadcrumb$JsonKeys$Type) &&
        other is $Breadcrumb$JsonKeys$Type;
  }
}

/// from: `io.sentry.Breadcrumb`
class Breadcrumb extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Breadcrumb> $type;

  @jni$_.internal
  Breadcrumb.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/Breadcrumb');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Breadcrumb$NullableType();
  static const type = $Breadcrumb$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/util/Date;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.util.Date date)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Breadcrumb(
    jni$_.JObject date,
  ) {
    final _$date = date.reference;
    return Breadcrumb.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$date.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(J)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void <init>(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Breadcrumb.new$1(
    int j,
  ) {
    return Breadcrumb.fromReference(
        _new$1(_class.reference.pointer, _id_new$1 as jni$_.JMethodIDPtr, j)
            .reference);
  }

  static final _id_fromMap = _class.staticMethodId(
    r'fromMap',
    r'(Ljava/util/Map;Lio/sentry/SentryOptions;)Lio/sentry/Breadcrumb;',
  );

  static final _fromMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb fromMap(java.util.Map<java.lang.String, java.lang.Object> map, io.sentry.SentryOptions sentryOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb? fromMap(
    jni$_.JMap<jni$_.JString?, jni$_.JObject?> map,
    SentryOptions sentryOptions,
  ) {
    final _$map = map.reference;
    final _$sentryOptions = sentryOptions.reference;
    return _fromMap(_class.reference.pointer, _id_fromMap as jni$_.JMethodIDPtr,
            _$map.pointer, _$sentryOptions.pointer)
        .object<Breadcrumb?>(const $Breadcrumb$NullableType());
  }

  static final _id_http = _class.staticMethodId(
    r'http',
    r'(Ljava/lang/String;Ljava/lang/String;)Lio/sentry/Breadcrumb;',
  );

  static final _http = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb http(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb http(
    jni$_.JString string,
    jni$_.JString string1,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    return _http(_class.reference.pointer, _id_http as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_http$1 = _class.staticMethodId(
    r'http',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/Integer;)Lio/sentry/Breadcrumb;',
  );

  static final _http$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb http(java.lang.String string, java.lang.String string1, java.lang.Integer integer)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb http$1(
    jni$_.JString string,
    jni$_.JString string1,
    jni$_.JInteger? integer,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    final _$integer = integer?.reference ?? jni$_.jNullReference;
    return _http$1(_class.reference.pointer, _id_http$1 as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer, _$integer.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_graphqlOperation = _class.staticMethodId(
    r'graphqlOperation',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lio/sentry/Breadcrumb;',
  );

  static final _graphqlOperation = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb graphqlOperation(java.lang.String string, java.lang.String string1, java.lang.String string2)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb graphqlOperation(
    jni$_.JString? string,
    jni$_.JString? string1,
    jni$_.JString? string2,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    return _graphqlOperation(
            _class.reference.pointer,
            _id_graphqlOperation as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$string2.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_graphqlDataFetcher = _class.staticMethodId(
    r'graphqlDataFetcher',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lio/sentry/Breadcrumb;',
  );

  static final _graphqlDataFetcher = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb graphqlDataFetcher(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb graphqlDataFetcher(
    jni$_.JString? string,
    jni$_.JString? string1,
    jni$_.JString? string2,
    jni$_.JString? string3,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    final _$string3 = string3?.reference ?? jni$_.jNullReference;
    return _graphqlDataFetcher(
            _class.reference.pointer,
            _id_graphqlDataFetcher as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$string2.pointer,
            _$string3.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_graphqlDataLoader = _class.staticMethodId(
    r'graphqlDataLoader',
    r'(Ljava/lang/Iterable;Ljava/lang/Class;Ljava/lang/Class;Ljava/lang/String;)Lio/sentry/Breadcrumb;',
  );

  static final _graphqlDataLoader = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb graphqlDataLoader(java.lang.Iterable<?> iterable, java.lang.Class<?> class, java.lang.Class<?> class1, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb graphqlDataLoader(
    jni$_.JObject iterable,
    jni$_.JObject? class$,
    jni$_.JObject? class1,
    jni$_.JString? string,
  ) {
    final _$iterable = iterable.reference;
    final _$class$ = class$?.reference ?? jni$_.jNullReference;
    final _$class1 = class1?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _graphqlDataLoader(
            _class.reference.pointer,
            _id_graphqlDataLoader as jni$_.JMethodIDPtr,
            _$iterable.pointer,
            _$class$.pointer,
            _$class1.pointer,
            _$string.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_navigation = _class.staticMethodId(
    r'navigation',
    r'(Ljava/lang/String;Ljava/lang/String;)Lio/sentry/Breadcrumb;',
  );

  static final _navigation = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb navigation(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb navigation(
    jni$_.JString string,
    jni$_.JString string1,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    return _navigation(
            _class.reference.pointer,
            _id_navigation as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_transaction = _class.staticMethodId(
    r'transaction',
    r'(Ljava/lang/String;)Lio/sentry/Breadcrumb;',
  );

  static final _transaction = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb transaction(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb transaction(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _transaction(_class.reference.pointer,
            _id_transaction as jni$_.JMethodIDPtr, _$string.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_debug = _class.staticMethodId(
    r'debug',
    r'(Ljava/lang/String;)Lio/sentry/Breadcrumb;',
  );

  static final _debug = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb debug(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb debug(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _debug(_class.reference.pointer, _id_debug as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_error = _class.staticMethodId(
    r'error',
    r'(Ljava/lang/String;)Lio/sentry/Breadcrumb;',
  );

  static final _error = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb error(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb error(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _error(_class.reference.pointer, _id_error as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_info = _class.staticMethodId(
    r'info',
    r'(Ljava/lang/String;)Lio/sentry/Breadcrumb;',
  );

  static final _info = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb info(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb info(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _info(_class.reference.pointer, _id_info as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_query = _class.staticMethodId(
    r'query',
    r'(Ljava/lang/String;)Lio/sentry/Breadcrumb;',
  );

  static final _query = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb query(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb query(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _query(_class.reference.pointer, _id_query as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_ui = _class.staticMethodId(
    r'ui',
    r'(Ljava/lang/String;Ljava/lang/String;)Lio/sentry/Breadcrumb;',
  );

  static final _ui = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb ui(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb ui(
    jni$_.JString string,
    jni$_.JString string1,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    return _ui(_class.reference.pointer, _id_ui as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_user = _class.staticMethodId(
    r'user',
    r'(Ljava/lang/String;Ljava/lang/String;)Lio/sentry/Breadcrumb;',
  );

  static final _user = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb user(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb user(
    jni$_.JString string,
    jni$_.JString string1,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    return _user(_class.reference.pointer, _id_user as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_userInteraction = _class.staticMethodId(
    r'userInteraction',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lio/sentry/Breadcrumb;',
  );

  static final _userInteraction = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb userInteraction(java.lang.String string, java.lang.String string1, java.lang.String string2)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb userInteraction(
    jni$_.JString string,
    jni$_.JString? string1,
    jni$_.JString? string2,
  ) {
    final _$string = string.reference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    return _userInteraction(
            _class.reference.pointer,
            _id_userInteraction as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$string2.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_userInteraction$1 = _class.staticMethodId(
    r'userInteraction',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/util/Map;)Lio/sentry/Breadcrumb;',
  );

  static final _userInteraction$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb userInteraction(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.util.Map<java.lang.String, java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb userInteraction$1(
    jni$_.JString string,
    jni$_.JString? string1,
    jni$_.JString? string2,
    jni$_.JString? string3,
    jni$_.JMap<jni$_.JString?, jni$_.JObject?> map,
  ) {
    final _$string = string.reference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    final _$string3 = string3?.reference ?? jni$_.jNullReference;
    final _$map = map.reference;
    return _userInteraction$1(
            _class.reference.pointer,
            _id_userInteraction$1 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$string2.pointer,
            _$string3.pointer,
            _$map.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_userInteraction$2 = _class.staticMethodId(
    r'userInteraction',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/util/Map;)Lio/sentry/Breadcrumb;',
  );

  static final _userInteraction$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb userInteraction(java.lang.String string, java.lang.String string1, java.lang.String string2, java.util.Map<java.lang.String, java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb userInteraction$2(
    jni$_.JString string,
    jni$_.JString? string1,
    jni$_.JString? string2,
    jni$_.JMap<jni$_.JString?, jni$_.JObject?> map,
  ) {
    final _$string = string.reference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    final _$map = map.reference;
    return _userInteraction$2(
            _class.reference.pointer,
            _id_userInteraction$2 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$string2.pointer,
            _$map.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_new$2 = _class.constructorId(
    r'()V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Breadcrumb.new$2() {
    return Breadcrumb.fromReference(
        _new$2(_class.reference.pointer, _id_new$2 as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_new$3 = _class.constructorId(
    r'(Ljava/lang/String;)V',
  );

  static final _new$3 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Breadcrumb.new$3(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return Breadcrumb.fromReference(_new$3(_class.reference.pointer,
            _id_new$3 as jni$_.JMethodIDPtr, _$string.pointer)
        .reference);
  }

  static final _id_getTimestamp = _class.instanceMethodId(
    r'getTimestamp',
    r'()Ljava/util/Date;',
  );

  static final _getTimestamp = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Date getTimestamp()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getTimestamp() {
    return _getTimestamp(
            reference.pointer, _id_getTimestamp as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getMessage = _class.instanceMethodId(
    r'getMessage',
    r'()Ljava/lang/String;',
  );

  static final _getMessage = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getMessage()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getMessage() {
    return _getMessage(reference.pointer, _id_getMessage as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setMessage = _class.instanceMethodId(
    r'setMessage',
    r'(Ljava/lang/String;)V',
  );

  static final _setMessage = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setMessage(java.lang.String string)`
  void setMessage(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setMessage(reference.pointer, _id_setMessage as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getType = _class.instanceMethodId(
    r'getType',
    r'()Ljava/lang/String;',
  );

  static final _getType = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getType()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getType() {
    return _getType(reference.pointer, _id_getType as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setType = _class.instanceMethodId(
    r'setType',
    r'(Ljava/lang/String;)V',
  );

  static final _setType = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setType(java.lang.String string)`
  void setType(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setType(reference.pointer, _id_setType as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getData = _class.instanceMethodId(
    r'getData',
    r'()Ljava/util/Map;',
  );

  static final _getData = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Map<java.lang.String, java.lang.Object> getData()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JObject?> getData() {
    return _getData(reference.pointer, _id_getData as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JString?, jni$_.JObject?>(
                jni$_.JStringNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_getData$1 = _class.instanceMethodId(
    r'getData',
    r'(Ljava/lang/String;)Ljava/lang/Object;',
  );

  static final _getData$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object getData(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getData$1(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getData$1(reference.pointer, _id_getData$1 as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setData = _class.instanceMethodId(
    r'setData',
    r'(Ljava/lang/String;Ljava/lang/Object;)V',
  );

  static final _setData = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setData(java.lang.String string, java.lang.Object object)`
  void setData(
    jni$_.JString? string,
    jni$_.JObject? object,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    _setData(reference.pointer, _id_setData as jni$_.JMethodIDPtr,
            _$string.pointer, _$object.pointer)
        .check();
  }

  static final _id_removeData = _class.instanceMethodId(
    r'removeData',
    r'(Ljava/lang/String;)V',
  );

  static final _removeData = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeData(java.lang.String string)`
  void removeData(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _removeData(reference.pointer, _id_removeData as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getCategory = _class.instanceMethodId(
    r'getCategory',
    r'()Ljava/lang/String;',
  );

  static final _getCategory = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getCategory()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getCategory() {
    return _getCategory(
            reference.pointer, _id_getCategory as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setCategory = _class.instanceMethodId(
    r'setCategory',
    r'(Ljava/lang/String;)V',
  );

  static final _setCategory = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setCategory(java.lang.String string)`
  void setCategory(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setCategory(reference.pointer, _id_setCategory as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getOrigin = _class.instanceMethodId(
    r'getOrigin',
    r'()Ljava/lang/String;',
  );

  static final _getOrigin = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getOrigin()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getOrigin() {
    return _getOrigin(reference.pointer, _id_getOrigin as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setOrigin = _class.instanceMethodId(
    r'setOrigin',
    r'(Ljava/lang/String;)V',
  );

  static final _setOrigin = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setOrigin(java.lang.String string)`
  void setOrigin(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setOrigin(reference.pointer, _id_setOrigin as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getLevel = _class.instanceMethodId(
    r'getLevel',
    r'()Lio/sentry/SentryLevel;',
  );

  static final _getLevel = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryLevel getLevel()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryLevel? getLevel() {
    return _getLevel(reference.pointer, _id_getLevel as jni$_.JMethodIDPtr)
        .object<SentryLevel?>(const $SentryLevel$NullableType());
  }

  static final _id_setLevel = _class.instanceMethodId(
    r'setLevel',
    r'(Lio/sentry/SentryLevel;)V',
  );

  static final _setLevel = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setLevel(io.sentry.SentryLevel sentryLevel)`
  void setLevel(
    SentryLevel? sentryLevel,
  ) {
    final _$sentryLevel = sentryLevel?.reference ?? jni$_.jNullReference;
    _setLevel(reference.pointer, _id_setLevel as jni$_.JMethodIDPtr,
            _$sentryLevel.pointer)
        .check();
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getUnknown = _class.instanceMethodId(
    r'getUnknown',
    r'()Ljava/util/Map;',
  );

  static final _getUnknown = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Map<java.lang.String, java.lang.Object> getUnknown()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JObject?>? getUnknown() {
    return _getUnknown(reference.pointer, _id_getUnknown as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JObject?>(
                jni$_.JStringNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_setUnknown = _class.instanceMethodId(
    r'setUnknown',
    r'(Ljava/util/Map;)V',
  );

  static final _setUnknown = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setUnknown(java.util.Map<java.lang.String, java.lang.Object> map)`
  void setUnknown(
    jni$_.JMap<jni$_.JString?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    _setUnknown(reference.pointer, _id_setUnknown as jni$_.JMethodIDPtr,
            _$map.pointer)
        .check();
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Lio/sentry/Breadcrumb;)I',
  );

  static final _compareTo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int compareTo(io.sentry.Breadcrumb breadcrumb)`
  int compareTo(
    Breadcrumb breadcrumb,
  ) {
    final _$breadcrumb = breadcrumb.reference;
    return _compareTo(reference.pointer, _id_compareTo as jni$_.JMethodIDPtr,
            _$breadcrumb.pointer)
        .integer;
  }

  static final _id_serialize = _class.instanceMethodId(
    r'serialize',
    r'(Lio/sentry/ObjectWriter;Lio/sentry/ILogger;)V',
  );

  static final _serialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void serialize(io.sentry.ObjectWriter objectWriter, io.sentry.ILogger iLogger)`
  void serialize(
    jni$_.JObject objectWriter,
    jni$_.JObject iLogger,
  ) {
    final _$objectWriter = objectWriter.reference;
    final _$iLogger = iLogger.reference;
    _serialize(reference.pointer, _id_serialize as jni$_.JMethodIDPtr,
            _$objectWriter.pointer, _$iLogger.pointer)
        .check();
  }

  bool operator <(Breadcrumb breadcrumb) {
    return compareTo(breadcrumb) < 0;
  }

  bool operator <=(Breadcrumb breadcrumb) {
    return compareTo(breadcrumb) <= 0;
  }

  bool operator >(Breadcrumb breadcrumb) {
    return compareTo(breadcrumb) > 0;
  }

  bool operator >=(Breadcrumb breadcrumb) {
    return compareTo(breadcrumb) >= 0;
  }
}

final class $Breadcrumb$NullableType extends jni$_.JObjType<Breadcrumb?> {
  @jni$_.internal
  const $Breadcrumb$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Breadcrumb;';

  @jni$_.internal
  @core$_.override
  Breadcrumb? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Breadcrumb.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Breadcrumb?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Breadcrumb$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Breadcrumb$NullableType) &&
        other is $Breadcrumb$NullableType;
  }
}

final class $Breadcrumb$Type extends jni$_.JObjType<Breadcrumb> {
  @jni$_.internal
  const $Breadcrumb$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Breadcrumb;';

  @jni$_.internal
  @core$_.override
  Breadcrumb fromReference(jni$_.JReference reference) =>
      Breadcrumb.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Breadcrumb?> get nullableType =>
      const $Breadcrumb$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Breadcrumb$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Breadcrumb$Type) && other is $Breadcrumb$Type;
  }
}

/// from: `io.sentry.ScopesAdapter`
class ScopesAdapter extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ScopesAdapter> $type;

  @jni$_.internal
  ScopesAdapter.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/ScopesAdapter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ScopesAdapter$NullableType();
  static const type = $ScopesAdapter$Type();
  static final _id_getInstance = _class.staticMethodId(
    r'getInstance',
    r'()Lio/sentry/ScopesAdapter;',
  );

  static final _getInstance = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.ScopesAdapter getInstance()`
  /// The returned object must be released after use, by calling the [release] method.
  static ScopesAdapter? getInstance() {
    return _getInstance(
            _class.reference.pointer, _id_getInstance as jni$_.JMethodIDPtr)
        .object<ScopesAdapter?>(const $ScopesAdapter$NullableType());
  }

  static final _id_isEnabled = _class.instanceMethodId(
    r'isEnabled',
    r'()Z',
  );

  static final _isEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEnabled()`
  bool isEnabled() {
    return _isEnabled(reference.pointer, _id_isEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_captureEvent = _class.instanceMethodId(
    r'captureEvent',
    r'(Lio/sentry/SentryEvent;Lio/sentry/Hint;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureEvent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureEvent(io.sentry.SentryEvent sentryEvent, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryId captureEvent(
    SentryEvent sentryEvent,
    Hint? hint,
  ) {
    final _$sentryEvent = sentryEvent.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    return _captureEvent(
            reference.pointer,
            _id_captureEvent as jni$_.JMethodIDPtr,
            _$sentryEvent.pointer,
            _$hint.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_captureEvent$1 = _class.instanceMethodId(
    r'captureEvent',
    r'(Lio/sentry/SentryEvent;Lio/sentry/Hint;Lio/sentry/ScopeCallback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureEvent$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureEvent(io.sentry.SentryEvent sentryEvent, io.sentry.Hint hint, io.sentry.ScopeCallback scopeCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryId captureEvent$1(
    SentryEvent sentryEvent,
    Hint? hint,
    ScopeCallback scopeCallback,
  ) {
    final _$sentryEvent = sentryEvent.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    final _$scopeCallback = scopeCallback.reference;
    return _captureEvent$1(
            reference.pointer,
            _id_captureEvent$1 as jni$_.JMethodIDPtr,
            _$sentryEvent.pointer,
            _$hint.pointer,
            _$scopeCallback.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_captureMessage = _class.instanceMethodId(
    r'captureMessage',
    r'(Ljava/lang/String;Lio/sentry/SentryLevel;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureMessage = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureMessage(java.lang.String string, io.sentry.SentryLevel sentryLevel)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryId captureMessage(
    jni$_.JString string,
    SentryLevel sentryLevel,
  ) {
    final _$string = string.reference;
    final _$sentryLevel = sentryLevel.reference;
    return _captureMessage(
            reference.pointer,
            _id_captureMessage as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$sentryLevel.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_captureMessage$1 = _class.instanceMethodId(
    r'captureMessage',
    r'(Ljava/lang/String;Lio/sentry/SentryLevel;Lio/sentry/ScopeCallback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureMessage$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureMessage(java.lang.String string, io.sentry.SentryLevel sentryLevel, io.sentry.ScopeCallback scopeCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryId captureMessage$1(
    jni$_.JString string,
    SentryLevel sentryLevel,
    ScopeCallback scopeCallback,
  ) {
    final _$string = string.reference;
    final _$sentryLevel = sentryLevel.reference;
    final _$scopeCallback = scopeCallback.reference;
    return _captureMessage$1(
            reference.pointer,
            _id_captureMessage$1 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$sentryLevel.pointer,
            _$scopeCallback.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_captureFeedback = _class.instanceMethodId(
    r'captureFeedback',
    r'(Lio/sentry/protocol/Feedback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureFeedback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureFeedback(io.sentry.protocol.Feedback feedback)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryId captureFeedback(
    jni$_.JObject feedback,
  ) {
    final _$feedback = feedback.reference;
    return _captureFeedback(reference.pointer,
            _id_captureFeedback as jni$_.JMethodIDPtr, _$feedback.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_captureFeedback$1 = _class.instanceMethodId(
    r'captureFeedback',
    r'(Lio/sentry/protocol/Feedback;Lio/sentry/Hint;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureFeedback$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureFeedback(io.sentry.protocol.Feedback feedback, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryId captureFeedback$1(
    jni$_.JObject feedback,
    Hint? hint,
  ) {
    final _$feedback = feedback.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    return _captureFeedback$1(
            reference.pointer,
            _id_captureFeedback$1 as jni$_.JMethodIDPtr,
            _$feedback.pointer,
            _$hint.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_captureFeedback$2 = _class.instanceMethodId(
    r'captureFeedback',
    r'(Lio/sentry/protocol/Feedback;Lio/sentry/Hint;Lio/sentry/ScopeCallback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureFeedback$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureFeedback(io.sentry.protocol.Feedback feedback, io.sentry.Hint hint, io.sentry.ScopeCallback scopeCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryId captureFeedback$2(
    jni$_.JObject feedback,
    Hint? hint,
    ScopeCallback? scopeCallback,
  ) {
    final _$feedback = feedback.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    final _$scopeCallback = scopeCallback?.reference ?? jni$_.jNullReference;
    return _captureFeedback$2(
            reference.pointer,
            _id_captureFeedback$2 as jni$_.JMethodIDPtr,
            _$feedback.pointer,
            _$hint.pointer,
            _$scopeCallback.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_captureEnvelope = _class.instanceMethodId(
    r'captureEnvelope',
    r'(Lio/sentry/SentryEnvelope;Lio/sentry/Hint;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureEnvelope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureEnvelope(io.sentry.SentryEnvelope sentryEnvelope, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryId captureEnvelope(
    jni$_.JObject sentryEnvelope,
    Hint? hint,
  ) {
    final _$sentryEnvelope = sentryEnvelope.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    return _captureEnvelope(
            reference.pointer,
            _id_captureEnvelope as jni$_.JMethodIDPtr,
            _$sentryEnvelope.pointer,
            _$hint.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_captureException = _class.instanceMethodId(
    r'captureException',
    r'(Ljava/lang/Throwable;Lio/sentry/Hint;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureException = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureException(java.lang.Throwable throwable, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryId captureException(
    jni$_.JObject throwable,
    Hint? hint,
  ) {
    final _$throwable = throwable.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    return _captureException(
            reference.pointer,
            _id_captureException as jni$_.JMethodIDPtr,
            _$throwable.pointer,
            _$hint.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_captureException$1 = _class.instanceMethodId(
    r'captureException',
    r'(Ljava/lang/Throwable;Lio/sentry/Hint;Lio/sentry/ScopeCallback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureException$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureException(java.lang.Throwable throwable, io.sentry.Hint hint, io.sentry.ScopeCallback scopeCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryId captureException$1(
    jni$_.JObject throwable,
    Hint? hint,
    ScopeCallback scopeCallback,
  ) {
    final _$throwable = throwable.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    final _$scopeCallback = scopeCallback.reference;
    return _captureException$1(
            reference.pointer,
            _id_captureException$1 as jni$_.JMethodIDPtr,
            _$throwable.pointer,
            _$hint.pointer,
            _$scopeCallback.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_captureUserFeedback = _class.instanceMethodId(
    r'captureUserFeedback',
    r'(Lio/sentry/UserFeedback;)V',
  );

  static final _captureUserFeedback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void captureUserFeedback(io.sentry.UserFeedback userFeedback)`
  void captureUserFeedback(
    jni$_.JObject userFeedback,
  ) {
    final _$userFeedback = userFeedback.reference;
    _captureUserFeedback(
            reference.pointer,
            _id_captureUserFeedback as jni$_.JMethodIDPtr,
            _$userFeedback.pointer)
        .check();
  }

  static final _id_startSession = _class.instanceMethodId(
    r'startSession',
    r'()V',
  );

  static final _startSession = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void startSession()`
  void startSession() {
    _startSession(reference.pointer, _id_startSession as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_endSession = _class.instanceMethodId(
    r'endSession',
    r'()V',
  );

  static final _endSession = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void endSession()`
  void endSession() {
    _endSession(reference.pointer, _id_endSession as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_close = _class.instanceMethodId(
    r'close',
    r'(Z)V',
  );

  static final _close = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void close(boolean z)`
  void close(
    bool z,
  ) {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_close$1 = _class.instanceMethodId(
    r'close',
    r'()V',
  );

  static final _close$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void close()`
  void close$1() {
    _close$1(reference.pointer, _id_close$1 as jni$_.JMethodIDPtr).check();
  }

  static final _id_addBreadcrumb = _class.instanceMethodId(
    r'addBreadcrumb',
    r'(Lio/sentry/Breadcrumb;Lio/sentry/Hint;)V',
  );

  static final _addBreadcrumb = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addBreadcrumb(io.sentry.Breadcrumb breadcrumb, io.sentry.Hint hint)`
  void addBreadcrumb(
    Breadcrumb breadcrumb,
    Hint? hint,
  ) {
    final _$breadcrumb = breadcrumb.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    _addBreadcrumb(reference.pointer, _id_addBreadcrumb as jni$_.JMethodIDPtr,
            _$breadcrumb.pointer, _$hint.pointer)
        .check();
  }

  static final _id_addBreadcrumb$1 = _class.instanceMethodId(
    r'addBreadcrumb',
    r'(Lio/sentry/Breadcrumb;)V',
  );

  static final _addBreadcrumb$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addBreadcrumb(io.sentry.Breadcrumb breadcrumb)`
  void addBreadcrumb$1(
    Breadcrumb breadcrumb,
  ) {
    final _$breadcrumb = breadcrumb.reference;
    _addBreadcrumb$1(reference.pointer,
            _id_addBreadcrumb$1 as jni$_.JMethodIDPtr, _$breadcrumb.pointer)
        .check();
  }

  static final _id_setLevel = _class.instanceMethodId(
    r'setLevel',
    r'(Lio/sentry/SentryLevel;)V',
  );

  static final _setLevel = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setLevel(io.sentry.SentryLevel sentryLevel)`
  void setLevel(
    SentryLevel? sentryLevel,
  ) {
    final _$sentryLevel = sentryLevel?.reference ?? jni$_.jNullReference;
    _setLevel(reference.pointer, _id_setLevel as jni$_.JMethodIDPtr,
            _$sentryLevel.pointer)
        .check();
  }

  static final _id_setTransaction = _class.instanceMethodId(
    r'setTransaction',
    r'(Ljava/lang/String;)V',
  );

  static final _setTransaction = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTransaction(java.lang.String string)`
  void setTransaction(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setTransaction(reference.pointer, _id_setTransaction as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_setUser = _class.instanceMethodId(
    r'setUser',
    r'(Lio/sentry/protocol/User;)V',
  );

  static final _setUser = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setUser(io.sentry.protocol.User user)`
  void setUser(
    User? user,
  ) {
    final _$user = user?.reference ?? jni$_.jNullReference;
    _setUser(reference.pointer, _id_setUser as jni$_.JMethodIDPtr,
            _$user.pointer)
        .check();
  }

  static final _id_setFingerprint = _class.instanceMethodId(
    r'setFingerprint',
    r'(Ljava/util/List;)V',
  );

  static final _setFingerprint = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setFingerprint(java.util.List<java.lang.String> list)`
  void setFingerprint(
    jni$_.JList<jni$_.JString?> list,
  ) {
    final _$list = list.reference;
    _setFingerprint(reference.pointer, _id_setFingerprint as jni$_.JMethodIDPtr,
            _$list.pointer)
        .check();
  }

  static final _id_clearBreadcrumbs = _class.instanceMethodId(
    r'clearBreadcrumbs',
    r'()V',
  );

  static final _clearBreadcrumbs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void clearBreadcrumbs()`
  void clearBreadcrumbs() {
    _clearBreadcrumbs(
            reference.pointer, _id_clearBreadcrumbs as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_setTag = _class.instanceMethodId(
    r'setTag',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setTag = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTag(java.lang.String string, java.lang.String string1)`
  void setTag(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setTag(reference.pointer, _id_setTag as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  static final _id_removeTag = _class.instanceMethodId(
    r'removeTag',
    r'(Ljava/lang/String;)V',
  );

  static final _removeTag = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeTag(java.lang.String string)`
  void removeTag(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _removeTag(reference.pointer, _id_removeTag as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_setExtra = _class.instanceMethodId(
    r'setExtra',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setExtra = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setExtra(java.lang.String string, java.lang.String string1)`
  void setExtra(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setExtra(reference.pointer, _id_setExtra as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  static final _id_removeExtra = _class.instanceMethodId(
    r'removeExtra',
    r'(Ljava/lang/String;)V',
  );

  static final _removeExtra = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeExtra(java.lang.String string)`
  void removeExtra(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _removeExtra(reference.pointer, _id_removeExtra as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getLastEventId = _class.instanceMethodId(
    r'getLastEventId',
    r'()Lio/sentry/protocol/SentryId;',
  );

  static final _getLastEventId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.SentryId getLastEventId()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryId getLastEventId() {
    return _getLastEventId(
            reference.pointer, _id_getLastEventId as jni$_.JMethodIDPtr)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_pushScope = _class.instanceMethodId(
    r'pushScope',
    r'()Lio/sentry/ISentryLifecycleToken;',
  );

  static final _pushScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ISentryLifecycleToken pushScope()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject pushScope() {
    return _pushScope(reference.pointer, _id_pushScope as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_pushIsolationScope = _class.instanceMethodId(
    r'pushIsolationScope',
    r'()Lio/sentry/ISentryLifecycleToken;',
  );

  static final _pushIsolationScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ISentryLifecycleToken pushIsolationScope()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject pushIsolationScope() {
    return _pushIsolationScope(
            reference.pointer, _id_pushIsolationScope as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_popScope = _class.instanceMethodId(
    r'popScope',
    r'()V',
  );

  static final _popScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void popScope()`
  void popScope() {
    _popScope(reference.pointer, _id_popScope as jni$_.JMethodIDPtr).check();
  }

  static final _id_withScope = _class.instanceMethodId(
    r'withScope',
    r'(Lio/sentry/ScopeCallback;)V',
  );

  static final _withScope = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void withScope(io.sentry.ScopeCallback scopeCallback)`
  void withScope(
    ScopeCallback scopeCallback,
  ) {
    final _$scopeCallback = scopeCallback.reference;
    _withScope(reference.pointer, _id_withScope as jni$_.JMethodIDPtr,
            _$scopeCallback.pointer)
        .check();
  }

  static final _id_withIsolationScope = _class.instanceMethodId(
    r'withIsolationScope',
    r'(Lio/sentry/ScopeCallback;)V',
  );

  static final _withIsolationScope = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void withIsolationScope(io.sentry.ScopeCallback scopeCallback)`
  void withIsolationScope(
    ScopeCallback scopeCallback,
  ) {
    final _$scopeCallback = scopeCallback.reference;
    _withIsolationScope(
            reference.pointer,
            _id_withIsolationScope as jni$_.JMethodIDPtr,
            _$scopeCallback.pointer)
        .check();
  }

  static final _id_configureScope = _class.instanceMethodId(
    r'configureScope',
    r'(Lio/sentry/ScopeType;Lio/sentry/ScopeCallback;)V',
  );

  static final _configureScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void configureScope(io.sentry.ScopeType scopeType, io.sentry.ScopeCallback scopeCallback)`
  void configureScope(
    jni$_.JObject? scopeType,
    ScopeCallback scopeCallback,
  ) {
    final _$scopeType = scopeType?.reference ?? jni$_.jNullReference;
    final _$scopeCallback = scopeCallback.reference;
    _configureScope(reference.pointer, _id_configureScope as jni$_.JMethodIDPtr,
            _$scopeType.pointer, _$scopeCallback.pointer)
        .check();
  }

  static final _id_bindClient = _class.instanceMethodId(
    r'bindClient',
    r'(Lio/sentry/ISentryClient;)V',
  );

  static final _bindClient = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void bindClient(io.sentry.ISentryClient iSentryClient)`
  void bindClient(
    jni$_.JObject iSentryClient,
  ) {
    final _$iSentryClient = iSentryClient.reference;
    _bindClient(reference.pointer, _id_bindClient as jni$_.JMethodIDPtr,
            _$iSentryClient.pointer)
        .check();
  }

  static final _id_isHealthy = _class.instanceMethodId(
    r'isHealthy',
    r'()Z',
  );

  static final _isHealthy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isHealthy()`
  bool isHealthy() {
    return _isHealthy(reference.pointer, _id_isHealthy as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_flush = _class.instanceMethodId(
    r'flush',
    r'(J)V',
  );

  static final _flush = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void flush(long j)`
  void flush(
    int j,
  ) {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr, j).check();
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Lio/sentry/IHub;',
  );

  static final _clone = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.IHub clone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject clone() {
    return _clone(reference.pointer, _id_clone as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_forkedScopes = _class.instanceMethodId(
    r'forkedScopes',
    r'(Ljava/lang/String;)Lio/sentry/IScopes;',
  );

  static final _forkedScopes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.IScopes forkedScopes(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject forkedScopes(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _forkedScopes(reference.pointer,
            _id_forkedScopes as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_forkedCurrentScope = _class.instanceMethodId(
    r'forkedCurrentScope',
    r'(Ljava/lang/String;)Lio/sentry/IScopes;',
  );

  static final _forkedCurrentScope = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.IScopes forkedCurrentScope(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject forkedCurrentScope(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _forkedCurrentScope(reference.pointer,
            _id_forkedCurrentScope as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_forkedRootScopes = _class.instanceMethodId(
    r'forkedRootScopes',
    r'(Ljava/lang/String;)Lio/sentry/IScopes;',
  );

  static final _forkedRootScopes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.IScopes forkedRootScopes(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject forkedRootScopes(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _forkedRootScopes(reference.pointer,
            _id_forkedRootScopes as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_makeCurrent = _class.instanceMethodId(
    r'makeCurrent',
    r'()Lio/sentry/ISentryLifecycleToken;',
  );

  static final _makeCurrent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ISentryLifecycleToken makeCurrent()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject makeCurrent() {
    return _makeCurrent(
            reference.pointer, _id_makeCurrent as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getScope = _class.instanceMethodId(
    r'getScope',
    r'()Lio/sentry/IScope;',
  );

  static final _getScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.IScope getScope()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getScope() {
    return _getScope(reference.pointer, _id_getScope as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getIsolationScope = _class.instanceMethodId(
    r'getIsolationScope',
    r'()Lio/sentry/IScope;',
  );

  static final _getIsolationScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.IScope getIsolationScope()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getIsolationScope() {
    return _getIsolationScope(
            reference.pointer, _id_getIsolationScope as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getGlobalScope = _class.instanceMethodId(
    r'getGlobalScope',
    r'()Lio/sentry/IScope;',
  );

  static final _getGlobalScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.IScope getGlobalScope()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getGlobalScope() {
    return _getGlobalScope(
            reference.pointer, _id_getGlobalScope as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getParentScopes = _class.instanceMethodId(
    r'getParentScopes',
    r'()Lio/sentry/IScopes;',
  );

  static final _getParentScopes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.IScopes getParentScopes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getParentScopes() {
    return _getParentScopes(
            reference.pointer, _id_getParentScopes as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_isAncestorOf = _class.instanceMethodId(
    r'isAncestorOf',
    r'(Lio/sentry/IScopes;)Z',
  );

  static final _isAncestorOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean isAncestorOf(io.sentry.IScopes iScopes)`
  bool isAncestorOf(
    jni$_.JObject? iScopes,
  ) {
    final _$iScopes = iScopes?.reference ?? jni$_.jNullReference;
    return _isAncestorOf(reference.pointer,
            _id_isAncestorOf as jni$_.JMethodIDPtr, _$iScopes.pointer)
        .boolean;
  }

  static final _id_captureTransaction = _class.instanceMethodId(
    r'captureTransaction',
    r'(Lio/sentry/protocol/SentryTransaction;Lio/sentry/TraceContext;Lio/sentry/Hint;Lio/sentry/ProfilingTraceData;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureTransaction = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureTransaction(io.sentry.protocol.SentryTransaction sentryTransaction, io.sentry.TraceContext traceContext, io.sentry.Hint hint, io.sentry.ProfilingTraceData profilingTraceData)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryId captureTransaction(
    jni$_.JObject sentryTransaction,
    jni$_.JObject? traceContext,
    Hint? hint,
    jni$_.JObject? profilingTraceData,
  ) {
    final _$sentryTransaction = sentryTransaction.reference;
    final _$traceContext = traceContext?.reference ?? jni$_.jNullReference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    final _$profilingTraceData =
        profilingTraceData?.reference ?? jni$_.jNullReference;
    return _captureTransaction(
            reference.pointer,
            _id_captureTransaction as jni$_.JMethodIDPtr,
            _$sentryTransaction.pointer,
            _$traceContext.pointer,
            _$hint.pointer,
            _$profilingTraceData.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_captureProfileChunk = _class.instanceMethodId(
    r'captureProfileChunk',
    r'(Lio/sentry/ProfileChunk;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureProfileChunk = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureProfileChunk(io.sentry.ProfileChunk profileChunk)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryId captureProfileChunk(
    jni$_.JObject profileChunk,
  ) {
    final _$profileChunk = profileChunk.reference;
    return _captureProfileChunk(
            reference.pointer,
            _id_captureProfileChunk as jni$_.JMethodIDPtr,
            _$profileChunk.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_startTransaction = _class.instanceMethodId(
    r'startTransaction',
    r'(Lio/sentry/TransactionContext;Lio/sentry/TransactionOptions;)Lio/sentry/ITransaction;',
  );

  static final _startTransaction = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.ITransaction startTransaction(io.sentry.TransactionContext transactionContext, io.sentry.TransactionOptions transactionOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject startTransaction(
    jni$_.JObject transactionContext,
    jni$_.JObject transactionOptions,
  ) {
    final _$transactionContext = transactionContext.reference;
    final _$transactionOptions = transactionOptions.reference;
    return _startTransaction(
            reference.pointer,
            _id_startTransaction as jni$_.JMethodIDPtr,
            _$transactionContext.pointer,
            _$transactionOptions.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_startProfiler = _class.instanceMethodId(
    r'startProfiler',
    r'()V',
  );

  static final _startProfiler = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void startProfiler()`
  void startProfiler() {
    _startProfiler(reference.pointer, _id_startProfiler as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_stopProfiler = _class.instanceMethodId(
    r'stopProfiler',
    r'()V',
  );

  static final _stopProfiler = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void stopProfiler()`
  void stopProfiler() {
    _stopProfiler(reference.pointer, _id_stopProfiler as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_setSpanContext = _class.instanceMethodId(
    r'setSpanContext',
    r'(Ljava/lang/Throwable;Lio/sentry/ISpan;Ljava/lang/String;)V',
  );

  static final _setSpanContext = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setSpanContext(java.lang.Throwable throwable, io.sentry.ISpan iSpan, java.lang.String string)`
  void setSpanContext(
    jni$_.JObject throwable,
    jni$_.JObject iSpan,
    jni$_.JString string,
  ) {
    final _$throwable = throwable.reference;
    final _$iSpan = iSpan.reference;
    final _$string = string.reference;
    _setSpanContext(reference.pointer, _id_setSpanContext as jni$_.JMethodIDPtr,
            _$throwable.pointer, _$iSpan.pointer, _$string.pointer)
        .check();
  }

  static final _id_getSpan = _class.instanceMethodId(
    r'getSpan',
    r'()Lio/sentry/ISpan;',
  );

  static final _getSpan = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ISpan getSpan()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getSpan() {
    return _getSpan(reference.pointer, _id_getSpan as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setActiveSpan = _class.instanceMethodId(
    r'setActiveSpan',
    r'(Lio/sentry/ISpan;)V',
  );

  static final _setActiveSpan = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setActiveSpan(io.sentry.ISpan iSpan)`
  void setActiveSpan(
    jni$_.JObject? iSpan,
  ) {
    final _$iSpan = iSpan?.reference ?? jni$_.jNullReference;
    _setActiveSpan(reference.pointer, _id_setActiveSpan as jni$_.JMethodIDPtr,
            _$iSpan.pointer)
        .check();
  }

  static final _id_getTransaction = _class.instanceMethodId(
    r'getTransaction',
    r'()Lio/sentry/ITransaction;',
  );

  static final _getTransaction = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ITransaction getTransaction()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getTransaction() {
    return _getTransaction(
            reference.pointer, _id_getTransaction as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getOptions = _class.instanceMethodId(
    r'getOptions',
    r'()Lio/sentry/SentryOptions;',
  );

  static final _getOptions = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryOptions getOptions()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryOptions getOptions() {
    return _getOptions(reference.pointer, _id_getOptions as jni$_.JMethodIDPtr)
        .object<SentryOptions>(const $SentryOptions$Type());
  }

  static final _id_isCrashedLastRun = _class.instanceMethodId(
    r'isCrashedLastRun',
    r'()Ljava/lang/Boolean;',
  );

  static final _isCrashedLastRun = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Boolean isCrashedLastRun()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? isCrashedLastRun() {
    return _isCrashedLastRun(
            reference.pointer, _id_isCrashedLastRun as jni$_.JMethodIDPtr)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_reportFullyDisplayed = _class.instanceMethodId(
    r'reportFullyDisplayed',
    r'()V',
  );

  static final _reportFullyDisplayed = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void reportFullyDisplayed()`
  void reportFullyDisplayed() {
    _reportFullyDisplayed(
            reference.pointer, _id_reportFullyDisplayed as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_continueTrace = _class.instanceMethodId(
    r'continueTrace',
    r'(Ljava/lang/String;Ljava/util/List;)Lio/sentry/TransactionContext;',
  );

  static final _continueTrace = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.TransactionContext continueTrace(java.lang.String string, java.util.List<java.lang.String> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? continueTrace(
    jni$_.JString? string,
    jni$_.JList<jni$_.JString?>? list,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _continueTrace(
            reference.pointer,
            _id_continueTrace as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$list.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getTraceparent = _class.instanceMethodId(
    r'getTraceparent',
    r'()Lio/sentry/SentryTraceHeader;',
  );

  static final _getTraceparent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryTraceHeader getTraceparent()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getTraceparent() {
    return _getTraceparent(
            reference.pointer, _id_getTraceparent as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getBaggage = _class.instanceMethodId(
    r'getBaggage',
    r'()Lio/sentry/BaggageHeader;',
  );

  static final _getBaggage = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.BaggageHeader getBaggage()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getBaggage() {
    return _getBaggage(reference.pointer, _id_getBaggage as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_captureCheckIn = _class.instanceMethodId(
    r'captureCheckIn',
    r'(Lio/sentry/CheckIn;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureCheckIn = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureCheckIn(io.sentry.CheckIn checkIn)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryId captureCheckIn(
    jni$_.JObject checkIn,
  ) {
    final _$checkIn = checkIn.reference;
    return _captureCheckIn(reference.pointer,
            _id_captureCheckIn as jni$_.JMethodIDPtr, _$checkIn.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_getRateLimiter = _class.instanceMethodId(
    r'getRateLimiter',
    r'()Lio/sentry/transport/RateLimiter;',
  );

  static final _getRateLimiter = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.transport.RateLimiter getRateLimiter()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getRateLimiter() {
    return _getRateLimiter(
            reference.pointer, _id_getRateLimiter as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_captureReplay = _class.instanceMethodId(
    r'captureReplay',
    r'(Lio/sentry/SentryReplayEvent;Lio/sentry/Hint;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureReplay = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureReplay(io.sentry.SentryReplayEvent sentryReplayEvent, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryId captureReplay(
    SentryReplayEvent sentryReplayEvent,
    Hint? hint,
  ) {
    final _$sentryReplayEvent = sentryReplayEvent.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    return _captureReplay(
            reference.pointer,
            _id_captureReplay as jni$_.JMethodIDPtr,
            _$sentryReplayEvent.pointer,
            _$hint.pointer)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_logger = _class.instanceMethodId(
    r'logger',
    r'()Lio/sentry/logger/ILoggerApi;',
  );

  static final _logger = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.logger.ILoggerApi logger()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject logger() {
    return _logger(reference.pointer, _id_logger as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_metrics = _class.instanceMethodId(
    r'metrics',
    r'()Lio/sentry/metrics/IMetricsApi;',
  );

  static final _metrics = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.metrics.IMetricsApi metrics()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject metrics() {
    return _metrics(reference.pointer, _id_metrics as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_addFeatureFlag = _class.instanceMethodId(
    r'addFeatureFlag',
    r'(Ljava/lang/String;Ljava/lang/Boolean;)V',
  );

  static final _addFeatureFlag = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addFeatureFlag(java.lang.String string, java.lang.Boolean boolean)`
  void addFeatureFlag(
    jni$_.JString? string,
    jni$_.JBoolean? boolean,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    _addFeatureFlag(reference.pointer, _id_addFeatureFlag as jni$_.JMethodIDPtr,
            _$string.pointer, _$boolean.pointer)
        .check();
  }
}

final class $ScopesAdapter$NullableType extends jni$_.JObjType<ScopesAdapter?> {
  @jni$_.internal
  const $ScopesAdapter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/ScopesAdapter;';

  @jni$_.internal
  @core$_.override
  ScopesAdapter? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : ScopesAdapter.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ScopesAdapter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ScopesAdapter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ScopesAdapter$NullableType) &&
        other is $ScopesAdapter$NullableType;
  }
}

final class $ScopesAdapter$Type extends jni$_.JObjType<ScopesAdapter> {
  @jni$_.internal
  const $ScopesAdapter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/ScopesAdapter;';

  @jni$_.internal
  @core$_.override
  ScopesAdapter fromReference(jni$_.JReference reference) =>
      ScopesAdapter.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ScopesAdapter?> get nullableType =>
      const $ScopesAdapter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ScopesAdapter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ScopesAdapter$Type) &&
        other is $ScopesAdapter$Type;
  }
}

/// from: `io.sentry.Scope$IWithPropagationContext`
class Scope$IWithPropagationContext extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Scope$IWithPropagationContext> $type;

  @jni$_.internal
  Scope$IWithPropagationContext.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/Scope$IWithPropagationContext');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Scope$IWithPropagationContext$NullableType();
  static const type = $Scope$IWithPropagationContext$Type();
  static final _id_accept = _class.instanceMethodId(
    r'accept',
    r'(Lio/sentry/PropagationContext;)V',
  );

  static final _accept = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void accept(io.sentry.PropagationContext propagationContext)`
  void accept(
    jni$_.JObject propagationContext,
  ) {
    final _$propagationContext = propagationContext.reference;
    _accept(reference.pointer, _id_accept as jni$_.JMethodIDPtr,
            _$propagationContext.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Scope$IWithPropagationContext> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'accept(Lio/sentry/PropagationContext;)V') {
        _$impls[$p]!.accept(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Scope$IWithPropagationContext $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.Scope$IWithPropagationContext',
      $p,
      _$invokePointer,
      [
        if ($impl.accept$async) r'accept(Lio/sentry/PropagationContext;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Scope$IWithPropagationContext.implement(
    $Scope$IWithPropagationContext $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Scope$IWithPropagationContext.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Scope$IWithPropagationContext {
  factory $Scope$IWithPropagationContext({
    required void Function(jni$_.JObject propagationContext) accept,
    bool accept$async,
  }) = _$Scope$IWithPropagationContext;

  void accept(jni$_.JObject propagationContext);
  bool get accept$async => false;
}

final class _$Scope$IWithPropagationContext
    with $Scope$IWithPropagationContext {
  _$Scope$IWithPropagationContext({
    required void Function(jni$_.JObject propagationContext) accept,
    this.accept$async = false,
  }) : _accept = accept;

  final void Function(jni$_.JObject propagationContext) _accept;
  final bool accept$async;

  void accept(jni$_.JObject propagationContext) {
    return _accept(propagationContext);
  }
}

final class $Scope$IWithPropagationContext$NullableType
    extends jni$_.JObjType<Scope$IWithPropagationContext?> {
  @jni$_.internal
  const $Scope$IWithPropagationContext$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Scope$IWithPropagationContext;';

  @jni$_.internal
  @core$_.override
  Scope$IWithPropagationContext? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Scope$IWithPropagationContext.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Scope$IWithPropagationContext?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Scope$IWithPropagationContext$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Scope$IWithPropagationContext$NullableType) &&
        other is $Scope$IWithPropagationContext$NullableType;
  }
}

final class $Scope$IWithPropagationContext$Type
    extends jni$_.JObjType<Scope$IWithPropagationContext> {
  @jni$_.internal
  const $Scope$IWithPropagationContext$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Scope$IWithPropagationContext;';

  @jni$_.internal
  @core$_.override
  Scope$IWithPropagationContext fromReference(jni$_.JReference reference) =>
      Scope$IWithPropagationContext.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Scope$IWithPropagationContext?> get nullableType =>
      const $Scope$IWithPropagationContext$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Scope$IWithPropagationContext$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Scope$IWithPropagationContext$Type) &&
        other is $Scope$IWithPropagationContext$Type;
  }
}

/// from: `io.sentry.Scope$IWithTransaction`
class Scope$IWithTransaction extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Scope$IWithTransaction> $type;

  @jni$_.internal
  Scope$IWithTransaction.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/Scope$IWithTransaction');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Scope$IWithTransaction$NullableType();
  static const type = $Scope$IWithTransaction$Type();
  static final _id_accept = _class.instanceMethodId(
    r'accept',
    r'(Lio/sentry/ITransaction;)V',
  );

  static final _accept = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void accept(io.sentry.ITransaction iTransaction)`
  void accept(
    jni$_.JObject? iTransaction,
  ) {
    final _$iTransaction = iTransaction?.reference ?? jni$_.jNullReference;
    _accept(reference.pointer, _id_accept as jni$_.JMethodIDPtr,
            _$iTransaction.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Scope$IWithTransaction> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'accept(Lio/sentry/ITransaction;)V') {
        _$impls[$p]!.accept(
          $a![0]?.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Scope$IWithTransaction $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.Scope$IWithTransaction',
      $p,
      _$invokePointer,
      [
        if ($impl.accept$async) r'accept(Lio/sentry/ITransaction;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Scope$IWithTransaction.implement(
    $Scope$IWithTransaction $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Scope$IWithTransaction.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Scope$IWithTransaction {
  factory $Scope$IWithTransaction({
    required void Function(jni$_.JObject? iTransaction) accept,
    bool accept$async,
  }) = _$Scope$IWithTransaction;

  void accept(jni$_.JObject? iTransaction);
  bool get accept$async => false;
}

final class _$Scope$IWithTransaction with $Scope$IWithTransaction {
  _$Scope$IWithTransaction({
    required void Function(jni$_.JObject? iTransaction) accept,
    this.accept$async = false,
  }) : _accept = accept;

  final void Function(jni$_.JObject? iTransaction) _accept;
  final bool accept$async;

  void accept(jni$_.JObject? iTransaction) {
    return _accept(iTransaction);
  }
}

final class $Scope$IWithTransaction$NullableType
    extends jni$_.JObjType<Scope$IWithTransaction?> {
  @jni$_.internal
  const $Scope$IWithTransaction$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Scope$IWithTransaction;';

  @jni$_.internal
  @core$_.override
  Scope$IWithTransaction? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Scope$IWithTransaction.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Scope$IWithTransaction?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Scope$IWithTransaction$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Scope$IWithTransaction$NullableType) &&
        other is $Scope$IWithTransaction$NullableType;
  }
}

final class $Scope$IWithTransaction$Type
    extends jni$_.JObjType<Scope$IWithTransaction> {
  @jni$_.internal
  const $Scope$IWithTransaction$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Scope$IWithTransaction;';

  @jni$_.internal
  @core$_.override
  Scope$IWithTransaction fromReference(jni$_.JReference reference) =>
      Scope$IWithTransaction.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Scope$IWithTransaction?> get nullableType =>
      const $Scope$IWithTransaction$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Scope$IWithTransaction$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Scope$IWithTransaction$Type) &&
        other is $Scope$IWithTransaction$Type;
  }
}

/// from: `io.sentry.Scope`
class Scope extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Scope> $type;

  @jni$_.internal
  Scope.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/Scope');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Scope$NullableType();
  static const type = $Scope$Type();
  static final _id_new$ = _class.constructorId(
    r'(Lio/sentry/SentryOptions;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(io.sentry.SentryOptions sentryOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Scope(
    SentryOptions sentryOptions,
  ) {
    final _$sentryOptions = sentryOptions.reference;
    return Scope.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$sentryOptions.pointer)
        .reference);
  }

  static final _id_getLevel = _class.instanceMethodId(
    r'getLevel',
    r'()Lio/sentry/SentryLevel;',
  );

  static final _getLevel = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryLevel getLevel()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryLevel? getLevel() {
    return _getLevel(reference.pointer, _id_getLevel as jni$_.JMethodIDPtr)
        .object<SentryLevel?>(const $SentryLevel$NullableType());
  }

  static final _id_setLevel = _class.instanceMethodId(
    r'setLevel',
    r'(Lio/sentry/SentryLevel;)V',
  );

  static final _setLevel = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setLevel(io.sentry.SentryLevel sentryLevel)`
  void setLevel(
    SentryLevel? sentryLevel,
  ) {
    final _$sentryLevel = sentryLevel?.reference ?? jni$_.jNullReference;
    _setLevel(reference.pointer, _id_setLevel as jni$_.JMethodIDPtr,
            _$sentryLevel.pointer)
        .check();
  }

  static final _id_getTransactionName = _class.instanceMethodId(
    r'getTransactionName',
    r'()Ljava/lang/String;',
  );

  static final _getTransactionName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getTransactionName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getTransactionName() {
    return _getTransactionName(
            reference.pointer, _id_getTransactionName as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setTransaction = _class.instanceMethodId(
    r'setTransaction',
    r'(Ljava/lang/String;)V',
  );

  static final _setTransaction = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTransaction(java.lang.String string)`
  void setTransaction(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _setTransaction(reference.pointer, _id_setTransaction as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getSpan = _class.instanceMethodId(
    r'getSpan',
    r'()Lio/sentry/ISpan;',
  );

  static final _getSpan = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ISpan getSpan()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getSpan() {
    return _getSpan(reference.pointer, _id_getSpan as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setActiveSpan = _class.instanceMethodId(
    r'setActiveSpan',
    r'(Lio/sentry/ISpan;)V',
  );

  static final _setActiveSpan = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setActiveSpan(io.sentry.ISpan iSpan)`
  void setActiveSpan(
    jni$_.JObject? iSpan,
  ) {
    final _$iSpan = iSpan?.reference ?? jni$_.jNullReference;
    _setActiveSpan(reference.pointer, _id_setActiveSpan as jni$_.JMethodIDPtr,
            _$iSpan.pointer)
        .check();
  }

  static final _id_setTransaction$1 = _class.instanceMethodId(
    r'setTransaction',
    r'(Lio/sentry/ITransaction;)V',
  );

  static final _setTransaction$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTransaction(io.sentry.ITransaction iTransaction)`
  void setTransaction$1(
    jni$_.JObject? iTransaction,
  ) {
    final _$iTransaction = iTransaction?.reference ?? jni$_.jNullReference;
    _setTransaction$1(reference.pointer,
            _id_setTransaction$1 as jni$_.JMethodIDPtr, _$iTransaction.pointer)
        .check();
  }

  static final _id_getUser = _class.instanceMethodId(
    r'getUser',
    r'()Lio/sentry/protocol/User;',
  );

  static final _getUser = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.User getUser()`
  /// The returned object must be released after use, by calling the [release] method.
  User? getUser() {
    return _getUser(reference.pointer, _id_getUser as jni$_.JMethodIDPtr)
        .object<User?>(const $User$NullableType());
  }

  static final _id_setUser = _class.instanceMethodId(
    r'setUser',
    r'(Lio/sentry/protocol/User;)V',
  );

  static final _setUser = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setUser(io.sentry.protocol.User user)`
  void setUser(
    User? user,
  ) {
    final _$user = user?.reference ?? jni$_.jNullReference;
    _setUser(reference.pointer, _id_setUser as jni$_.JMethodIDPtr,
            _$user.pointer)
        .check();
  }

  static final _id_getScreen = _class.instanceMethodId(
    r'getScreen',
    r'()Ljava/lang/String;',
  );

  static final _getScreen = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getScreen()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getScreen() {
    return _getScreen(reference.pointer, _id_getScreen as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setScreen = _class.instanceMethodId(
    r'setScreen',
    r'(Ljava/lang/String;)V',
  );

  static final _setScreen = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setScreen(java.lang.String string)`
  void setScreen(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setScreen(reference.pointer, _id_setScreen as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getReplayId = _class.instanceMethodId(
    r'getReplayId',
    r'()Lio/sentry/protocol/SentryId;',
  );

  static final _getReplayId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.SentryId getReplayId()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryId getReplayId() {
    return _getReplayId(
            reference.pointer, _id_getReplayId as jni$_.JMethodIDPtr)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_setReplayId = _class.instanceMethodId(
    r'setReplayId',
    r'(Lio/sentry/protocol/SentryId;)V',
  );

  static final _setReplayId = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setReplayId(io.sentry.protocol.SentryId sentryId)`
  void setReplayId(
    SentryId sentryId,
  ) {
    final _$sentryId = sentryId.reference;
    _setReplayId(reference.pointer, _id_setReplayId as jni$_.JMethodIDPtr,
            _$sentryId.pointer)
        .check();
  }

  static final _id_getRequest = _class.instanceMethodId(
    r'getRequest',
    r'()Lio/sentry/protocol/Request;',
  );

  static final _getRequest = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.Request getRequest()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getRequest() {
    return _getRequest(reference.pointer, _id_getRequest as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setRequest = _class.instanceMethodId(
    r'setRequest',
    r'(Lio/sentry/protocol/Request;)V',
  );

  static final _setRequest = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setRequest(io.sentry.protocol.Request request)`
  void setRequest(
    jni$_.JObject? request,
  ) {
    final _$request = request?.reference ?? jni$_.jNullReference;
    _setRequest(reference.pointer, _id_setRequest as jni$_.JMethodIDPtr,
            _$request.pointer)
        .check();
  }

  static final _id_getFingerprint = _class.instanceMethodId(
    r'getFingerprint',
    r'()Ljava/util/List;',
  );

  static final _getFingerprint = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<java.lang.String> getFingerprint()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?> getFingerprint() {
    return _getFingerprint(
            reference.pointer, _id_getFingerprint as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>>(
            const jni$_.JListType<jni$_.JString?>(jni$_.JStringNullableType()));
  }

  static final _id_setFingerprint = _class.instanceMethodId(
    r'setFingerprint',
    r'(Ljava/util/List;)V',
  );

  static final _setFingerprint = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setFingerprint(java.util.List<java.lang.String> list)`
  void setFingerprint(
    jni$_.JList<jni$_.JString?> list,
  ) {
    final _$list = list.reference;
    _setFingerprint(reference.pointer, _id_setFingerprint as jni$_.JMethodIDPtr,
            _$list.pointer)
        .check();
  }

  static final _id_getBreadcrumbs = _class.instanceMethodId(
    r'getBreadcrumbs',
    r'()Ljava/util/Queue;',
  );

  static final _getBreadcrumbs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Queue<io.sentry.Breadcrumb> getBreadcrumbs()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getBreadcrumbs() {
    return _getBreadcrumbs(
            reference.pointer, _id_getBreadcrumbs as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_addBreadcrumb = _class.instanceMethodId(
    r'addBreadcrumb',
    r'(Lio/sentry/Breadcrumb;Lio/sentry/Hint;)V',
  );

  static final _addBreadcrumb = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addBreadcrumb(io.sentry.Breadcrumb breadcrumb, io.sentry.Hint hint)`
  void addBreadcrumb(
    Breadcrumb breadcrumb,
    Hint? hint,
  ) {
    final _$breadcrumb = breadcrumb.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    _addBreadcrumb(reference.pointer, _id_addBreadcrumb as jni$_.JMethodIDPtr,
            _$breadcrumb.pointer, _$hint.pointer)
        .check();
  }

  static final _id_addBreadcrumb$1 = _class.instanceMethodId(
    r'addBreadcrumb',
    r'(Lio/sentry/Breadcrumb;)V',
  );

  static final _addBreadcrumb$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addBreadcrumb(io.sentry.Breadcrumb breadcrumb)`
  void addBreadcrumb$1(
    Breadcrumb breadcrumb,
  ) {
    final _$breadcrumb = breadcrumb.reference;
    _addBreadcrumb$1(reference.pointer,
            _id_addBreadcrumb$1 as jni$_.JMethodIDPtr, _$breadcrumb.pointer)
        .check();
  }

  static final _id_clearBreadcrumbs = _class.instanceMethodId(
    r'clearBreadcrumbs',
    r'()V',
  );

  static final _clearBreadcrumbs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void clearBreadcrumbs()`
  void clearBreadcrumbs() {
    _clearBreadcrumbs(
            reference.pointer, _id_clearBreadcrumbs as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_clearTransaction = _class.instanceMethodId(
    r'clearTransaction',
    r'()V',
  );

  static final _clearTransaction = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void clearTransaction()`
  void clearTransaction() {
    _clearTransaction(
            reference.pointer, _id_clearTransaction as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_getTransaction = _class.instanceMethodId(
    r'getTransaction',
    r'()Lio/sentry/ITransaction;',
  );

  static final _getTransaction = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ITransaction getTransaction()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getTransaction() {
    return _getTransaction(
            reference.pointer, _id_getTransaction as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_clear = _class.instanceMethodId(
    r'clear',
    r'()V',
  );

  static final _clear = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void clear()`
  void clear() {
    _clear(reference.pointer, _id_clear as jni$_.JMethodIDPtr).check();
  }

  static final _id_getTags = _class.instanceMethodId(
    r'getTags',
    r'()Ljava/util/Map;',
  );

  static final _getTags = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> getTags()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?> getTags() {
    return _getTags(reference.pointer, _id_getTags as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
            const jni$_.JMapType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_setTag = _class.instanceMethodId(
    r'setTag',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setTag = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTag(java.lang.String string, java.lang.String string1)`
  void setTag(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setTag(reference.pointer, _id_setTag as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  static final _id_removeTag = _class.instanceMethodId(
    r'removeTag',
    r'(Ljava/lang/String;)V',
  );

  static final _removeTag = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeTag(java.lang.String string)`
  void removeTag(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _removeTag(reference.pointer, _id_removeTag as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getExtras = _class.instanceMethodId(
    r'getExtras',
    r'()Ljava/util/Map;',
  );

  static final _getExtras = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Map<java.lang.String, java.lang.Object> getExtras()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JObject?> getExtras() {
    return _getExtras(reference.pointer, _id_getExtras as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JString?, jni$_.JObject?>(
                jni$_.JStringNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_setExtra = _class.instanceMethodId(
    r'setExtra',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setExtra = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setExtra(java.lang.String string, java.lang.String string1)`
  void setExtra(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setExtra(reference.pointer, _id_setExtra as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  static final _id_removeExtra = _class.instanceMethodId(
    r'removeExtra',
    r'(Ljava/lang/String;)V',
  );

  static final _removeExtra = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeExtra(java.lang.String string)`
  void removeExtra(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _removeExtra(reference.pointer, _id_removeExtra as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getContexts = _class.instanceMethodId(
    r'getContexts',
    r'()Lio/sentry/protocol/Contexts;',
  );

  static final _getContexts = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.Contexts getContexts()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getContexts() {
    return _getContexts(
            reference.pointer, _id_getContexts as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setContexts = _class.instanceMethodId(
    r'setContexts',
    r'(Ljava/lang/String;Ljava/lang/Object;)V',
  );

  static final _setContexts = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setContexts(java.lang.String string, java.lang.Object object)`
  void setContexts(
    jni$_.JString? string,
    jni$_.JObject? object,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    _setContexts(reference.pointer, _id_setContexts as jni$_.JMethodIDPtr,
            _$string.pointer, _$object.pointer)
        .check();
  }

  static final _id_setContexts$1 = _class.instanceMethodId(
    r'setContexts',
    r'(Ljava/lang/String;Ljava/lang/Boolean;)V',
  );

  static final _setContexts$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setContexts(java.lang.String string, java.lang.Boolean boolean)`
  void setContexts$1(
    jni$_.JString? string,
    jni$_.JBoolean? boolean,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    _setContexts$1(reference.pointer, _id_setContexts$1 as jni$_.JMethodIDPtr,
            _$string.pointer, _$boolean.pointer)
        .check();
  }

  static final _id_setContexts$2 = _class.instanceMethodId(
    r'setContexts',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setContexts$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setContexts(java.lang.String string, java.lang.String string1)`
  void setContexts$2(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setContexts$2(reference.pointer, _id_setContexts$2 as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  static final _id_setContexts$3 = _class.instanceMethodId(
    r'setContexts',
    r'(Ljava/lang/String;Ljava/lang/Number;)V',
  );

  static final _setContexts$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setContexts(java.lang.String string, java.lang.Number number)`
  void setContexts$3(
    jni$_.JString? string,
    jni$_.JNumber? number,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$number = number?.reference ?? jni$_.jNullReference;
    _setContexts$3(reference.pointer, _id_setContexts$3 as jni$_.JMethodIDPtr,
            _$string.pointer, _$number.pointer)
        .check();
  }

  static final _id_setContexts$4 = _class.instanceMethodId(
    r'setContexts',
    r'(Ljava/lang/String;Ljava/util/Collection;)V',
  );

  static final _setContexts$4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setContexts(java.lang.String string, java.util.Collection<?> collection)`
  void setContexts$4(
    jni$_.JString? string,
    jni$_.JObject? collection,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$collection = collection?.reference ?? jni$_.jNullReference;
    _setContexts$4(reference.pointer, _id_setContexts$4 as jni$_.JMethodIDPtr,
            _$string.pointer, _$collection.pointer)
        .check();
  }

  static final _id_setContexts$5 = _class.instanceMethodId(
    r'setContexts',
    r'(Ljava/lang/String;[Ljava/lang/Object;)V',
  );

  static final _setContexts$5 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setContexts(java.lang.String string, java.lang.Object[] objects)`
  void setContexts$5(
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    _setContexts$5(reference.pointer, _id_setContexts$5 as jni$_.JMethodIDPtr,
            _$string.pointer, _$objects.pointer)
        .check();
  }

  static final _id_setContexts$6 = _class.instanceMethodId(
    r'setContexts',
    r'(Ljava/lang/String;Ljava/lang/Character;)V',
  );

  static final _setContexts$6 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setContexts(java.lang.String string, java.lang.Character character)`
  void setContexts$6(
    jni$_.JString? string,
    jni$_.JCharacter? character,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$character = character?.reference ?? jni$_.jNullReference;
    _setContexts$6(reference.pointer, _id_setContexts$6 as jni$_.JMethodIDPtr,
            _$string.pointer, _$character.pointer)
        .check();
  }

  static final _id_removeContexts = _class.instanceMethodId(
    r'removeContexts',
    r'(Ljava/lang/String;)V',
  );

  static final _removeContexts = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeContexts(java.lang.String string)`
  void removeContexts(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _removeContexts(reference.pointer, _id_removeContexts as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getAttachments = _class.instanceMethodId(
    r'getAttachments',
    r'()Ljava/util/List;',
  );

  static final _getAttachments = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<io.sentry.Attachment> getAttachments()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getAttachments() {
    return _getAttachments(
            reference.pointer, _id_getAttachments as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_addAttachment = _class.instanceMethodId(
    r'addAttachment',
    r'(Lio/sentry/Attachment;)V',
  );

  static final _addAttachment = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addAttachment(io.sentry.Attachment attachment)`
  void addAttachment(
    jni$_.JObject attachment,
  ) {
    final _$attachment = attachment.reference;
    _addAttachment(reference.pointer, _id_addAttachment as jni$_.JMethodIDPtr,
            _$attachment.pointer)
        .check();
  }

  static final _id_clearAttachments = _class.instanceMethodId(
    r'clearAttachments',
    r'()V',
  );

  static final _clearAttachments = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void clearAttachments()`
  void clearAttachments() {
    _clearAttachments(
            reference.pointer, _id_clearAttachments as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_getEventProcessors = _class.instanceMethodId(
    r'getEventProcessors',
    r'()Ljava/util/List;',
  );

  static final _getEventProcessors = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<io.sentry.EventProcessor> getEventProcessors()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getEventProcessors() {
    return _getEventProcessors(
            reference.pointer, _id_getEventProcessors as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_getEventProcessorsWithOrder = _class.instanceMethodId(
    r'getEventProcessorsWithOrder',
    r'()Ljava/util/List;',
  );

  static final _getEventProcessorsWithOrder =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public java.util.List<io.sentry.internal.eventprocessor.EventProcessorAndOrder> getEventProcessorsWithOrder()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getEventProcessorsWithOrder() {
    return _getEventProcessorsWithOrder(reference.pointer,
            _id_getEventProcessorsWithOrder as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_addEventProcessor = _class.instanceMethodId(
    r'addEventProcessor',
    r'(Lio/sentry/EventProcessor;)V',
  );

  static final _addEventProcessor = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addEventProcessor(io.sentry.EventProcessor eventProcessor)`
  void addEventProcessor(
    jni$_.JObject eventProcessor,
  ) {
    final _$eventProcessor = eventProcessor.reference;
    _addEventProcessor(
            reference.pointer,
            _id_addEventProcessor as jni$_.JMethodIDPtr,
            _$eventProcessor.pointer)
        .check();
  }

  static final _id_withSession = _class.instanceMethodId(
    r'withSession',
    r'(Lio/sentry/Scope$IWithSession;)Lio/sentry/Session;',
  );

  static final _withSession = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.Session withSession(io.sentry.Scope$IWithSession iWithSession)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? withSession(
    jni$_.JObject iWithSession,
  ) {
    final _$iWithSession = iWithSession.reference;
    return _withSession(reference.pointer,
            _id_withSession as jni$_.JMethodIDPtr, _$iWithSession.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_startSession = _class.instanceMethodId(
    r'startSession',
    r'()Lio/sentry/Scope$SessionPair;',
  );

  static final _startSession = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.Scope$SessionPair startSession()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? startSession() {
    return _startSession(
            reference.pointer, _id_startSession as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_endSession = _class.instanceMethodId(
    r'endSession',
    r'()Lio/sentry/Session;',
  );

  static final _endSession = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.Session endSession()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? endSession() {
    return _endSession(reference.pointer, _id_endSession as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_withTransaction = _class.instanceMethodId(
    r'withTransaction',
    r'(Lio/sentry/Scope$IWithTransaction;)V',
  );

  static final _withTransaction = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void withTransaction(io.sentry.Scope$IWithTransaction iWithTransaction)`
  void withTransaction(
    Scope$IWithTransaction iWithTransaction,
  ) {
    final _$iWithTransaction = iWithTransaction.reference;
    _withTransaction(
            reference.pointer,
            _id_withTransaction as jni$_.JMethodIDPtr,
            _$iWithTransaction.pointer)
        .check();
  }

  static final _id_getOptions = _class.instanceMethodId(
    r'getOptions',
    r'()Lio/sentry/SentryOptions;',
  );

  static final _getOptions = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryOptions getOptions()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryOptions getOptions() {
    return _getOptions(reference.pointer, _id_getOptions as jni$_.JMethodIDPtr)
        .object<SentryOptions>(const $SentryOptions$Type());
  }

  static final _id_getSession = _class.instanceMethodId(
    r'getSession',
    r'()Lio/sentry/Session;',
  );

  static final _getSession = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.Session getSession()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getSession() {
    return _getSession(reference.pointer, _id_getSession as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_clearSession = _class.instanceMethodId(
    r'clearSession',
    r'()V',
  );

  static final _clearSession = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void clearSession()`
  void clearSession() {
    _clearSession(reference.pointer, _id_clearSession as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_setPropagationContext = _class.instanceMethodId(
    r'setPropagationContext',
    r'(Lio/sentry/PropagationContext;)V',
  );

  static final _setPropagationContext = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setPropagationContext(io.sentry.PropagationContext propagationContext)`
  void setPropagationContext(
    jni$_.JObject propagationContext,
  ) {
    final _$propagationContext = propagationContext.reference;
    _setPropagationContext(
            reference.pointer,
            _id_setPropagationContext as jni$_.JMethodIDPtr,
            _$propagationContext.pointer)
        .check();
  }

  static final _id_getPropagationContext = _class.instanceMethodId(
    r'getPropagationContext',
    r'()Lio/sentry/PropagationContext;',
  );

  static final _getPropagationContext = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.PropagationContext getPropagationContext()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getPropagationContext() {
    return _getPropagationContext(
            reference.pointer, _id_getPropagationContext as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_withPropagationContext = _class.instanceMethodId(
    r'withPropagationContext',
    r'(Lio/sentry/Scope$IWithPropagationContext;)Lio/sentry/PropagationContext;',
  );

  static final _withPropagationContext = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.PropagationContext withPropagationContext(io.sentry.Scope$IWithPropagationContext iWithPropagationContext)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject withPropagationContext(
    Scope$IWithPropagationContext iWithPropagationContext,
  ) {
    final _$iWithPropagationContext = iWithPropagationContext.reference;
    return _withPropagationContext(
            reference.pointer,
            _id_withPropagationContext as jni$_.JMethodIDPtr,
            _$iWithPropagationContext.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Lio/sentry/IScope;',
  );

  static final _clone = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.IScope clone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject clone() {
    return _clone(reference.pointer, _id_clone as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setLastEventId = _class.instanceMethodId(
    r'setLastEventId',
    r'(Lio/sentry/protocol/SentryId;)V',
  );

  static final _setLastEventId = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setLastEventId(io.sentry.protocol.SentryId sentryId)`
  void setLastEventId(
    SentryId sentryId,
  ) {
    final _$sentryId = sentryId.reference;
    _setLastEventId(reference.pointer, _id_setLastEventId as jni$_.JMethodIDPtr,
            _$sentryId.pointer)
        .check();
  }

  static final _id_getLastEventId = _class.instanceMethodId(
    r'getLastEventId',
    r'()Lio/sentry/protocol/SentryId;',
  );

  static final _getLastEventId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.SentryId getLastEventId()`
  /// The returned object must be released after use, by calling the [release] method.
  SentryId getLastEventId() {
    return _getLastEventId(
            reference.pointer, _id_getLastEventId as jni$_.JMethodIDPtr)
        .object<SentryId>(const $SentryId$Type());
  }

  static final _id_bindClient = _class.instanceMethodId(
    r'bindClient',
    r'(Lio/sentry/ISentryClient;)V',
  );

  static final _bindClient = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void bindClient(io.sentry.ISentryClient iSentryClient)`
  void bindClient(
    jni$_.JObject iSentryClient,
  ) {
    final _$iSentryClient = iSentryClient.reference;
    _bindClient(reference.pointer, _id_bindClient as jni$_.JMethodIDPtr,
            _$iSentryClient.pointer)
        .check();
  }

  static final _id_getClient = _class.instanceMethodId(
    r'getClient',
    r'()Lio/sentry/ISentryClient;',
  );

  static final _getClient = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ISentryClient getClient()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getClient() {
    return _getClient(reference.pointer, _id_getClient as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_addFeatureFlag = _class.instanceMethodId(
    r'addFeatureFlag',
    r'(Ljava/lang/String;Ljava/lang/Boolean;)V',
  );

  static final _addFeatureFlag = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addFeatureFlag(java.lang.String string, java.lang.Boolean boolean)`
  void addFeatureFlag(
    jni$_.JString? string,
    jni$_.JBoolean? boolean,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    _addFeatureFlag(reference.pointer, _id_addFeatureFlag as jni$_.JMethodIDPtr,
            _$string.pointer, _$boolean.pointer)
        .check();
  }

  static final _id_getFeatureFlags = _class.instanceMethodId(
    r'getFeatureFlags',
    r'()Lio/sentry/protocol/FeatureFlags;',
  );

  static final _getFeatureFlags = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.FeatureFlags getFeatureFlags()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getFeatureFlags() {
    return _getFeatureFlags(
            reference.pointer, _id_getFeatureFlags as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getFeatureFlagBuffer = _class.instanceMethodId(
    r'getFeatureFlagBuffer',
    r'()Lio/sentry/featureflags/IFeatureFlagBuffer;',
  );

  static final _getFeatureFlagBuffer = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.featureflags.IFeatureFlagBuffer getFeatureFlagBuffer()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getFeatureFlagBuffer() {
    return _getFeatureFlagBuffer(
            reference.pointer, _id_getFeatureFlagBuffer as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_assignTraceContext = _class.instanceMethodId(
    r'assignTraceContext',
    r'(Lio/sentry/SentryEvent;)V',
  );

  static final _assignTraceContext = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void assignTraceContext(io.sentry.SentryEvent sentryEvent)`
  void assignTraceContext(
    SentryEvent sentryEvent,
  ) {
    final _$sentryEvent = sentryEvent.reference;
    _assignTraceContext(reference.pointer,
            _id_assignTraceContext as jni$_.JMethodIDPtr, _$sentryEvent.pointer)
        .check();
  }

  static final _id_setSpanContext = _class.instanceMethodId(
    r'setSpanContext',
    r'(Ljava/lang/Throwable;Lio/sentry/ISpan;Ljava/lang/String;)V',
  );

  static final _setSpanContext = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setSpanContext(java.lang.Throwable throwable, io.sentry.ISpan iSpan, java.lang.String string)`
  void setSpanContext(
    jni$_.JObject throwable,
    jni$_.JObject iSpan,
    jni$_.JString string,
  ) {
    final _$throwable = throwable.reference;
    final _$iSpan = iSpan.reference;
    final _$string = string.reference;
    _setSpanContext(reference.pointer, _id_setSpanContext as jni$_.JMethodIDPtr,
            _$throwable.pointer, _$iSpan.pointer, _$string.pointer)
        .check();
  }

  static final _id_replaceOptions = _class.instanceMethodId(
    r'replaceOptions',
    r'(Lio/sentry/SentryOptions;)V',
  );

  static final _replaceOptions = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void replaceOptions(io.sentry.SentryOptions sentryOptions)`
  void replaceOptions(
    SentryOptions sentryOptions,
  ) {
    final _$sentryOptions = sentryOptions.reference;
    _replaceOptions(reference.pointer, _id_replaceOptions as jni$_.JMethodIDPtr,
            _$sentryOptions.pointer)
        .check();
  }
}

final class $Scope$NullableType extends jni$_.JObjType<Scope?> {
  @jni$_.internal
  const $Scope$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Scope;';

  @jni$_.internal
  @core$_.override
  Scope? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Scope.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Scope?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Scope$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Scope$NullableType) &&
        other is $Scope$NullableType;
  }
}

final class $Scope$Type extends jni$_.JObjType<Scope> {
  @jni$_.internal
  const $Scope$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Scope;';

  @jni$_.internal
  @core$_.override
  Scope fromReference(jni$_.JReference reference) => Scope.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Scope?> get nullableType => const $Scope$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Scope$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Scope$Type) && other is $Scope$Type;
  }
}

/// from: `io.sentry.ScopeCallback`
class ScopeCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ScopeCallback> $type;

  @jni$_.internal
  ScopeCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/ScopeCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ScopeCallback$NullableType();
  static const type = $ScopeCallback$Type();
  static final _id_run = _class.instanceMethodId(
    r'run',
    r'(Lio/sentry/IScope;)V',
  );

  static final _run = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void run(io.sentry.IScope iScope)`
  void run(
    jni$_.JObject iScope,
  ) {
    final _$iScope = iScope.reference;
    _run(reference.pointer, _id_run as jni$_.JMethodIDPtr, _$iScope.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ScopeCallback> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'run(Lio/sentry/IScope;)V') {
        _$impls[$p]!.run(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $ScopeCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.ScopeCallback',
      $p,
      _$invokePointer,
      [
        if ($impl.run$async) r'run(Lio/sentry/IScope;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ScopeCallback.implement(
    $ScopeCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ScopeCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $ScopeCallback {
  factory $ScopeCallback({
    required void Function(jni$_.JObject iScope) run,
    bool run$async,
  }) = _$ScopeCallback;

  void run(jni$_.JObject iScope);
  bool get run$async => false;
}

final class _$ScopeCallback with $ScopeCallback {
  _$ScopeCallback({
    required void Function(jni$_.JObject iScope) run,
    this.run$async = false,
  }) : _run = run;

  final void Function(jni$_.JObject iScope) _run;
  final bool run$async;

  void run(jni$_.JObject iScope) {
    return _run(iScope);
  }
}

final class $ScopeCallback$NullableType extends jni$_.JObjType<ScopeCallback?> {
  @jni$_.internal
  const $ScopeCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/ScopeCallback;';

  @jni$_.internal
  @core$_.override
  ScopeCallback? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : ScopeCallback.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ScopeCallback?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ScopeCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ScopeCallback$NullableType) &&
        other is $ScopeCallback$NullableType;
  }
}

final class $ScopeCallback$Type extends jni$_.JObjType<ScopeCallback> {
  @jni$_.internal
  const $ScopeCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/ScopeCallback;';

  @jni$_.internal
  @core$_.override
  ScopeCallback fromReference(jni$_.JReference reference) =>
      ScopeCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ScopeCallback?> get nullableType =>
      const $ScopeCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ScopeCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ScopeCallback$Type) &&
        other is $ScopeCallback$Type;
  }
}

/// from: `io.sentry.protocol.User$Deserializer`
class User$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<User$Deserializer> $type;

  @jni$_.internal
  User$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/protocol/User$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $User$Deserializer$NullableType();
  static const type = $User$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory User$Deserializer() {
    return User$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserialize = _class.instanceMethodId(
    r'deserialize',
    r'(Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Lio/sentry/protocol/User;',
  );

  static final _deserialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.User deserialize(io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  /// The returned object must be released after use, by calling the [release] method.
  User deserialize(
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserialize(
            reference.pointer,
            _id_deserialize as jni$_.JMethodIDPtr,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .object<User>(const $User$Type());
  }
}

final class $User$Deserializer$NullableType
    extends jni$_.JObjType<User$Deserializer?> {
  @jni$_.internal
  const $User$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/User$Deserializer;';

  @jni$_.internal
  @core$_.override
  User$Deserializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : User$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<User$Deserializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($User$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($User$Deserializer$NullableType) &&
        other is $User$Deserializer$NullableType;
  }
}

final class $User$Deserializer$Type extends jni$_.JObjType<User$Deserializer> {
  @jni$_.internal
  const $User$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/User$Deserializer;';

  @jni$_.internal
  @core$_.override
  User$Deserializer fromReference(jni$_.JReference reference) =>
      User$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<User$Deserializer?> get nullableType =>
      const $User$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($User$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($User$Deserializer$Type) &&
        other is $User$Deserializer$Type;
  }
}

/// from: `io.sentry.protocol.User$JsonKeys`
class User$JsonKeys extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<User$JsonKeys> $type;

  @jni$_.internal
  User$JsonKeys.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/protocol/User$JsonKeys');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $User$JsonKeys$NullableType();
  static const type = $User$JsonKeys$Type();
  static final _id_EMAIL = _class.staticFieldId(
    r'EMAIL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EMAIL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EMAIL =>
      _id_EMAIL.get(_class, const jni$_.JStringNullableType());

  static final _id_ID = _class.staticFieldId(
    r'ID',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ID`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ID =>
      _id_ID.get(_class, const jni$_.JStringNullableType());

  static final _id_USERNAME = _class.staticFieldId(
    r'USERNAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String USERNAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get USERNAME =>
      _id_USERNAME.get(_class, const jni$_.JStringNullableType());

  static final _id_IP_ADDRESS = _class.staticFieldId(
    r'IP_ADDRESS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String IP_ADDRESS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get IP_ADDRESS =>
      _id_IP_ADDRESS.get(_class, const jni$_.JStringNullableType());

  static final _id_NAME = _class.staticFieldId(
    r'NAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String NAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get NAME =>
      _id_NAME.get(_class, const jni$_.JStringNullableType());

  static final _id_GEO = _class.staticFieldId(
    r'GEO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String GEO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get GEO =>
      _id_GEO.get(_class, const jni$_.JStringNullableType());

  static final _id_DATA = _class.staticFieldId(
    r'DATA',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DATA`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DATA =>
      _id_DATA.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory User$JsonKeys() {
    return User$JsonKeys.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $User$JsonKeys$NullableType extends jni$_.JObjType<User$JsonKeys?> {
  @jni$_.internal
  const $User$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/User$JsonKeys;';

  @jni$_.internal
  @core$_.override
  User$JsonKeys? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : User$JsonKeys.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<User$JsonKeys?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($User$JsonKeys$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($User$JsonKeys$NullableType) &&
        other is $User$JsonKeys$NullableType;
  }
}

final class $User$JsonKeys$Type extends jni$_.JObjType<User$JsonKeys> {
  @jni$_.internal
  const $User$JsonKeys$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/User$JsonKeys;';

  @jni$_.internal
  @core$_.override
  User$JsonKeys fromReference(jni$_.JReference reference) =>
      User$JsonKeys.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<User$JsonKeys?> get nullableType =>
      const $User$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($User$JsonKeys$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($User$JsonKeys$Type) &&
        other is $User$JsonKeys$Type;
  }
}

/// from: `io.sentry.protocol.User`
class User extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<User> $type;

  @jni$_.internal
  User.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/protocol/User');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $User$NullableType();
  static const type = $User$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory User() {
    return User.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Lio/sentry/protocol/User;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(io.sentry.protocol.User user)`
  /// The returned object must be released after use, by calling the [release] method.
  factory User.new$1(
    User user,
  ) {
    final _$user = user.reference;
    return User.fromReference(_new$1(_class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr, _$user.pointer)
        .reference);
  }

  static final _id_fromMap = _class.staticMethodId(
    r'fromMap',
    r'(Ljava/util/Map;Lio/sentry/SentryOptions;)Lio/sentry/protocol/User;',
  );

  static final _fromMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.User fromMap(java.util.Map<java.lang.String, java.lang.Object> map, io.sentry.SentryOptions sentryOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  static User? fromMap(
    jni$_.JMap<jni$_.JString?, jni$_.JObject?> map,
    SentryOptions sentryOptions,
  ) {
    final _$map = map.reference;
    final _$sentryOptions = sentryOptions.reference;
    return _fromMap(_class.reference.pointer, _id_fromMap as jni$_.JMethodIDPtr,
            _$map.pointer, _$sentryOptions.pointer)
        .object<User?>(const $User$NullableType());
  }

  static final _id_getEmail = _class.instanceMethodId(
    r'getEmail',
    r'()Ljava/lang/String;',
  );

  static final _getEmail = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getEmail()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getEmail() {
    return _getEmail(reference.pointer, _id_getEmail as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setEmail = _class.instanceMethodId(
    r'setEmail',
    r'(Ljava/lang/String;)V',
  );

  static final _setEmail = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setEmail(java.lang.String string)`
  void setEmail(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setEmail(reference.pointer, _id_setEmail as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getId = _class.instanceMethodId(
    r'getId',
    r'()Ljava/lang/String;',
  );

  static final _getId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getId() {
    return _getId(reference.pointer, _id_getId as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setId = _class.instanceMethodId(
    r'setId',
    r'(Ljava/lang/String;)V',
  );

  static final _setId = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setId(java.lang.String string)`
  void setId(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setId(reference.pointer, _id_setId as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_getUsername = _class.instanceMethodId(
    r'getUsername',
    r'()Ljava/lang/String;',
  );

  static final _getUsername = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getUsername()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getUsername() {
    return _getUsername(
            reference.pointer, _id_getUsername as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setUsername = _class.instanceMethodId(
    r'setUsername',
    r'(Ljava/lang/String;)V',
  );

  static final _setUsername = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setUsername(java.lang.String string)`
  void setUsername(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setUsername(reference.pointer, _id_setUsername as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getIpAddress = _class.instanceMethodId(
    r'getIpAddress',
    r'()Ljava/lang/String;',
  );

  static final _getIpAddress = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getIpAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getIpAddress() {
    return _getIpAddress(
            reference.pointer, _id_getIpAddress as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setIpAddress = _class.instanceMethodId(
    r'setIpAddress',
    r'(Ljava/lang/String;)V',
  );

  static final _setIpAddress = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setIpAddress(java.lang.String string)`
  void setIpAddress(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setIpAddress(reference.pointer, _id_setIpAddress as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getName() {
    return _getName(reference.pointer, _id_getName as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setName = _class.instanceMethodId(
    r'setName',
    r'(Ljava/lang/String;)V',
  );

  static final _setName = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setName(java.lang.String string)`
  void setName(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setName(reference.pointer, _id_setName as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getGeo = _class.instanceMethodId(
    r'getGeo',
    r'()Lio/sentry/protocol/Geo;',
  );

  static final _getGeo = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.Geo getGeo()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getGeo() {
    return _getGeo(reference.pointer, _id_getGeo as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setGeo = _class.instanceMethodId(
    r'setGeo',
    r'(Lio/sentry/protocol/Geo;)V',
  );

  static final _setGeo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setGeo(io.sentry.protocol.Geo geo)`
  void setGeo(
    jni$_.JObject? geo,
  ) {
    final _$geo = geo?.reference ?? jni$_.jNullReference;
    _setGeo(reference.pointer, _id_setGeo as jni$_.JMethodIDPtr, _$geo.pointer)
        .check();
  }

  static final _id_getData = _class.instanceMethodId(
    r'getData',
    r'()Ljava/util/Map;',
  );

  static final _getData = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> getData()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString>? getData() {
    return _getData(reference.pointer, _id_getData as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString>(
                jni$_.JStringNullableType(), jni$_.JStringType()));
  }

  static final _id_setData = _class.instanceMethodId(
    r'setData',
    r'(Ljava/util/Map;)V',
  );

  static final _setData = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setData(java.util.Map<java.lang.String, java.lang.String> map)`
  void setData(
    jni$_.JMap<jni$_.JString?, jni$_.JString>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    _setData(
            reference.pointer, _id_setData as jni$_.JMethodIDPtr, _$map.pointer)
        .check();
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getUnknown = _class.instanceMethodId(
    r'getUnknown',
    r'()Ljava/util/Map;',
  );

  static final _getUnknown = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Map<java.lang.String, java.lang.Object> getUnknown()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JObject?>? getUnknown() {
    return _getUnknown(reference.pointer, _id_getUnknown as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JObject?>(
                jni$_.JStringNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_setUnknown = _class.instanceMethodId(
    r'setUnknown',
    r'(Ljava/util/Map;)V',
  );

  static final _setUnknown = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setUnknown(java.util.Map<java.lang.String, java.lang.Object> map)`
  void setUnknown(
    jni$_.JMap<jni$_.JString?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    _setUnknown(reference.pointer, _id_setUnknown as jni$_.JMethodIDPtr,
            _$map.pointer)
        .check();
  }

  static final _id_serialize = _class.instanceMethodId(
    r'serialize',
    r'(Lio/sentry/ObjectWriter;Lio/sentry/ILogger;)V',
  );

  static final _serialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void serialize(io.sentry.ObjectWriter objectWriter, io.sentry.ILogger iLogger)`
  void serialize(
    jni$_.JObject objectWriter,
    jni$_.JObject iLogger,
  ) {
    final _$objectWriter = objectWriter.reference;
    final _$iLogger = iLogger.reference;
    _serialize(reference.pointer, _id_serialize as jni$_.JMethodIDPtr,
            _$objectWriter.pointer, _$iLogger.pointer)
        .check();
  }
}

final class $User$NullableType extends jni$_.JObjType<User?> {
  @jni$_.internal
  const $User$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/User;';

  @jni$_.internal
  @core$_.override
  User? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : User.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<User?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($User$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($User$NullableType) &&
        other is $User$NullableType;
  }
}

final class $User$Type extends jni$_.JObjType<User> {
  @jni$_.internal
  const $User$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/User;';

  @jni$_.internal
  @core$_.override
  User fromReference(jni$_.JReference reference) => User.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<User?> get nullableType => const $User$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($User$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($User$Type) && other is $User$Type;
  }
}

/// from: `io.sentry.protocol.SentryId$Deserializer`
class SentryId$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryId$Deserializer> $type;

  @jni$_.internal
  SentryId$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/protocol/SentryId$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryId$Deserializer$NullableType();
  static const type = $SentryId$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryId$Deserializer() {
    return SentryId$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserialize = _class.instanceMethodId(
    r'deserialize',
    r'(Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Lio/sentry/protocol/SentryId;',
  );

  static final _deserialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId deserialize(io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryId deserialize(
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserialize(
            reference.pointer,
            _id_deserialize as jni$_.JMethodIDPtr,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .object<SentryId>(const $SentryId$Type());
  }
}

final class $SentryId$Deserializer$NullableType
    extends jni$_.JObjType<SentryId$Deserializer?> {
  @jni$_.internal
  const $SentryId$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/SentryId$Deserializer;';

  @jni$_.internal
  @core$_.override
  SentryId$Deserializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryId$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryId$Deserializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryId$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryId$Deserializer$NullableType) &&
        other is $SentryId$Deserializer$NullableType;
  }
}

final class $SentryId$Deserializer$Type
    extends jni$_.JObjType<SentryId$Deserializer> {
  @jni$_.internal
  const $SentryId$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/SentryId$Deserializer;';

  @jni$_.internal
  @core$_.override
  SentryId$Deserializer fromReference(jni$_.JReference reference) =>
      SentryId$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryId$Deserializer?> get nullableType =>
      const $SentryId$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryId$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryId$Deserializer$Type) &&
        other is $SentryId$Deserializer$Type;
  }
}

/// from: `io.sentry.protocol.SentryId`
class SentryId extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryId> $type;

  @jni$_.internal
  SentryId.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/protocol/SentryId');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryId$NullableType();
  static const type = $SentryId$Type();
  static final _id_EMPTY_ID = _class.staticFieldId(
    r'EMPTY_ID',
    r'Lio/sentry/protocol/SentryId;',
  );

  /// from: `static public final io.sentry.protocol.SentryId EMPTY_ID`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryId? get EMPTY_ID =>
      _id_EMPTY_ID.get(_class, const $SentryId$NullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryId() {
    return SentryId.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/util/UUID;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.util.UUID uUID)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryId.new$1(
    jni$_.JObject? uUID,
  ) {
    final _$uUID = uUID?.reference ?? jni$_.jNullReference;
    return SentryId.fromReference(_new$1(_class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr, _$uUID.pointer)
        .reference);
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/lang/String;)V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryId.new$2(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return SentryId.fromReference(_new$2(_class.reference.pointer,
            _id_new$2 as jni$_.JMethodIDPtr, _$string.pointer)
        .reference);
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_serialize = _class.instanceMethodId(
    r'serialize',
    r'(Lio/sentry/ObjectWriter;Lio/sentry/ILogger;)V',
  );

  static final _serialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void serialize(io.sentry.ObjectWriter objectWriter, io.sentry.ILogger iLogger)`
  void serialize(
    jni$_.JObject objectWriter,
    jni$_.JObject iLogger,
  ) {
    final _$objectWriter = objectWriter.reference;
    final _$iLogger = iLogger.reference;
    _serialize(reference.pointer, _id_serialize as jni$_.JMethodIDPtr,
            _$objectWriter.pointer, _$iLogger.pointer)
        .check();
  }
}

final class $SentryId$NullableType extends jni$_.JObjType<SentryId?> {
  @jni$_.internal
  const $SentryId$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/SentryId;';

  @jni$_.internal
  @core$_.override
  SentryId? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : SentryId.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryId?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryId$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryId$NullableType) &&
        other is $SentryId$NullableType;
  }
}

final class $SentryId$Type extends jni$_.JObjType<SentryId> {
  @jni$_.internal
  const $SentryId$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/SentryId;';

  @jni$_.internal
  @core$_.override
  SentryId fromReference(jni$_.JReference reference) => SentryId.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryId?> get nullableType => const $SentryId$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryId$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryId$Type) && other is $SentryId$Type;
  }
}

/// from: `io.sentry.protocol.SdkVersion$Deserializer`
class SdkVersion$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SdkVersion$Deserializer> $type;

  @jni$_.internal
  SdkVersion$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/protocol/SdkVersion$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SdkVersion$Deserializer$NullableType();
  static const type = $SdkVersion$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SdkVersion$Deserializer() {
    return SdkVersion$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserialize = _class.instanceMethodId(
    r'deserialize',
    r'(Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Lio/sentry/protocol/SdkVersion;',
  );

  static final _deserialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SdkVersion deserialize(io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  /// The returned object must be released after use, by calling the [release] method.
  SdkVersion deserialize(
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserialize(
            reference.pointer,
            _id_deserialize as jni$_.JMethodIDPtr,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .object<SdkVersion>(const $SdkVersion$Type());
  }
}

final class $SdkVersion$Deserializer$NullableType
    extends jni$_.JObjType<SdkVersion$Deserializer?> {
  @jni$_.internal
  const $SdkVersion$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/SdkVersion$Deserializer;';

  @jni$_.internal
  @core$_.override
  SdkVersion$Deserializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SdkVersion$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SdkVersion$Deserializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SdkVersion$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SdkVersion$Deserializer$NullableType) &&
        other is $SdkVersion$Deserializer$NullableType;
  }
}

final class $SdkVersion$Deserializer$Type
    extends jni$_.JObjType<SdkVersion$Deserializer> {
  @jni$_.internal
  const $SdkVersion$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/SdkVersion$Deserializer;';

  @jni$_.internal
  @core$_.override
  SdkVersion$Deserializer fromReference(jni$_.JReference reference) =>
      SdkVersion$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SdkVersion$Deserializer?> get nullableType =>
      const $SdkVersion$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SdkVersion$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SdkVersion$Deserializer$Type) &&
        other is $SdkVersion$Deserializer$Type;
  }
}

/// from: `io.sentry.protocol.SdkVersion$JsonKeys`
class SdkVersion$JsonKeys extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SdkVersion$JsonKeys> $type;

  @jni$_.internal
  SdkVersion$JsonKeys.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/protocol/SdkVersion$JsonKeys');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SdkVersion$JsonKeys$NullableType();
  static const type = $SdkVersion$JsonKeys$Type();
  static final _id_NAME = _class.staticFieldId(
    r'NAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String NAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get NAME =>
      _id_NAME.get(_class, const jni$_.JStringNullableType());

  static final _id_VERSION = _class.staticFieldId(
    r'VERSION',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String VERSION`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get VERSION =>
      _id_VERSION.get(_class, const jni$_.JStringNullableType());

  static final _id_PACKAGES = _class.staticFieldId(
    r'PACKAGES',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PACKAGES`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get PACKAGES =>
      _id_PACKAGES.get(_class, const jni$_.JStringNullableType());

  static final _id_INTEGRATIONS = _class.staticFieldId(
    r'INTEGRATIONS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String INTEGRATIONS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get INTEGRATIONS =>
      _id_INTEGRATIONS.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SdkVersion$JsonKeys() {
    return SdkVersion$JsonKeys.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $SdkVersion$JsonKeys$NullableType
    extends jni$_.JObjType<SdkVersion$JsonKeys?> {
  @jni$_.internal
  const $SdkVersion$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/SdkVersion$JsonKeys;';

  @jni$_.internal
  @core$_.override
  SdkVersion$JsonKeys? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SdkVersion$JsonKeys.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SdkVersion$JsonKeys?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SdkVersion$JsonKeys$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SdkVersion$JsonKeys$NullableType) &&
        other is $SdkVersion$JsonKeys$NullableType;
  }
}

final class $SdkVersion$JsonKeys$Type
    extends jni$_.JObjType<SdkVersion$JsonKeys> {
  @jni$_.internal
  const $SdkVersion$JsonKeys$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/SdkVersion$JsonKeys;';

  @jni$_.internal
  @core$_.override
  SdkVersion$JsonKeys fromReference(jni$_.JReference reference) =>
      SdkVersion$JsonKeys.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SdkVersion$JsonKeys?> get nullableType =>
      const $SdkVersion$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SdkVersion$JsonKeys$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SdkVersion$JsonKeys$Type) &&
        other is $SdkVersion$JsonKeys$Type;
  }
}

/// from: `io.sentry.protocol.SdkVersion`
class SdkVersion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SdkVersion> $type;

  @jni$_.internal
  SdkVersion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/protocol/SdkVersion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SdkVersion$NullableType();
  static const type = $SdkVersion$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SdkVersion(
    jni$_.JString string,
    jni$_.JString string1,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    return SdkVersion.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$string.pointer, _$string1.pointer)
        .reference);
  }

  static final _id_getVersion = _class.instanceMethodId(
    r'getVersion',
    r'()Ljava/lang/String;',
  );

  static final _getVersion = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getVersion()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getVersion() {
    return _getVersion(reference.pointer, _id_getVersion as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_setVersion = _class.instanceMethodId(
    r'setVersion',
    r'(Ljava/lang/String;)V',
  );

  static final _setVersion = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setVersion(java.lang.String string)`
  void setVersion(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _setVersion(reference.pointer, _id_setVersion as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getName() {
    return _getName(reference.pointer, _id_getName as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_setName = _class.instanceMethodId(
    r'setName',
    r'(Ljava/lang/String;)V',
  );

  static final _setName = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setName(java.lang.String string)`
  void setName(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _setName(reference.pointer, _id_setName as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_addPackage = _class.instanceMethodId(
    r'addPackage',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _addPackage = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addPackage(java.lang.String string, java.lang.String string1)`
  void addPackage(
    jni$_.JString string,
    jni$_.JString string1,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    _addPackage(reference.pointer, _id_addPackage as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  static final _id_addIntegration = _class.instanceMethodId(
    r'addIntegration',
    r'(Ljava/lang/String;)V',
  );

  static final _addIntegration = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addIntegration(java.lang.String string)`
  void addIntegration(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _addIntegration(reference.pointer, _id_addIntegration as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getPackageSet = _class.instanceMethodId(
    r'getPackageSet',
    r'()Ljava/util/Set;',
  );

  static final _getPackageSet = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Set<io.sentry.protocol.SentryPackage> getPackageSet()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<SentryPackage?> getPackageSet() {
    return _getPackageSet(
            reference.pointer, _id_getPackageSet as jni$_.JMethodIDPtr)
        .object<jni$_.JSet<SentryPackage?>>(
            const jni$_.JSetType<SentryPackage?>(
                $SentryPackage$NullableType()));
  }

  static final _id_getIntegrationSet = _class.instanceMethodId(
    r'getIntegrationSet',
    r'()Ljava/util/Set;',
  );

  static final _getIntegrationSet = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Set<java.lang.String> getIntegrationSet()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<jni$_.JString?> getIntegrationSet() {
    return _getIntegrationSet(
            reference.pointer, _id_getIntegrationSet as jni$_.JMethodIDPtr)
        .object<jni$_.JSet<jni$_.JString?>>(
            const jni$_.JSetType<jni$_.JString?>(jni$_.JStringNullableType()));
  }

  static final _id_updateSdkVersion = _class.staticMethodId(
    r'updateSdkVersion',
    r'(Lio/sentry/protocol/SdkVersion;Ljava/lang/String;Ljava/lang/String;)Lio/sentry/protocol/SdkVersion;',
  );

  static final _updateSdkVersion = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SdkVersion updateSdkVersion(io.sentry.protocol.SdkVersion sdkVersion, java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  static SdkVersion updateSdkVersion(
    SdkVersion? sdkVersion,
    jni$_.JString string,
    jni$_.JString string1,
  ) {
    final _$sdkVersion = sdkVersion?.reference ?? jni$_.jNullReference;
    final _$string = string.reference;
    final _$string1 = string1.reference;
    return _updateSdkVersion(
            _class.reference.pointer,
            _id_updateSdkVersion as jni$_.JMethodIDPtr,
            _$sdkVersion.pointer,
            _$string.pointer,
            _$string1.pointer)
        .object<SdkVersion>(const $SdkVersion$Type());
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getUnknown = _class.instanceMethodId(
    r'getUnknown',
    r'()Ljava/util/Map;',
  );

  static final _getUnknown = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Map<java.lang.String, java.lang.Object> getUnknown()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JObject?>? getUnknown() {
    return _getUnknown(reference.pointer, _id_getUnknown as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JObject?>(
                jni$_.JStringNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_setUnknown = _class.instanceMethodId(
    r'setUnknown',
    r'(Ljava/util/Map;)V',
  );

  static final _setUnknown = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setUnknown(java.util.Map<java.lang.String, java.lang.Object> map)`
  void setUnknown(
    jni$_.JMap<jni$_.JString?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    _setUnknown(reference.pointer, _id_setUnknown as jni$_.JMethodIDPtr,
            _$map.pointer)
        .check();
  }

  static final _id_serialize = _class.instanceMethodId(
    r'serialize',
    r'(Lio/sentry/ObjectWriter;Lio/sentry/ILogger;)V',
  );

  static final _serialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void serialize(io.sentry.ObjectWriter objectWriter, io.sentry.ILogger iLogger)`
  void serialize(
    jni$_.JObject objectWriter,
    jni$_.JObject iLogger,
  ) {
    final _$objectWriter = objectWriter.reference;
    final _$iLogger = iLogger.reference;
    _serialize(reference.pointer, _id_serialize as jni$_.JMethodIDPtr,
            _$objectWriter.pointer, _$iLogger.pointer)
        .check();
  }
}

final class $SdkVersion$NullableType extends jni$_.JObjType<SdkVersion?> {
  @jni$_.internal
  const $SdkVersion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/SdkVersion;';

  @jni$_.internal
  @core$_.override
  SdkVersion? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : SdkVersion.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SdkVersion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SdkVersion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SdkVersion$NullableType) &&
        other is $SdkVersion$NullableType;
  }
}

final class $SdkVersion$Type extends jni$_.JObjType<SdkVersion> {
  @jni$_.internal
  const $SdkVersion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/SdkVersion;';

  @jni$_.internal
  @core$_.override
  SdkVersion fromReference(jni$_.JReference reference) =>
      SdkVersion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SdkVersion?> get nullableType =>
      const $SdkVersion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SdkVersion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SdkVersion$Type) && other is $SdkVersion$Type;
  }
}

/// from: `io.sentry.protocol.SentryPackage$Deserializer`
class SentryPackage$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryPackage$Deserializer> $type;

  @jni$_.internal
  SentryPackage$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/protocol/SentryPackage$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryPackage$Deserializer$NullableType();
  static const type = $SentryPackage$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryPackage$Deserializer() {
    return SentryPackage$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserialize = _class.instanceMethodId(
    r'deserialize',
    r'(Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Lio/sentry/protocol/SentryPackage;',
  );

  static final _deserialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryPackage deserialize(io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  /// The returned object must be released after use, by calling the [release] method.
  SentryPackage deserialize(
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserialize(
            reference.pointer,
            _id_deserialize as jni$_.JMethodIDPtr,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .object<SentryPackage>(const $SentryPackage$Type());
  }
}

final class $SentryPackage$Deserializer$NullableType
    extends jni$_.JObjType<SentryPackage$Deserializer?> {
  @jni$_.internal
  const $SentryPackage$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/SentryPackage$Deserializer;';

  @jni$_.internal
  @core$_.override
  SentryPackage$Deserializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryPackage$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryPackage$Deserializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryPackage$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryPackage$Deserializer$NullableType) &&
        other is $SentryPackage$Deserializer$NullableType;
  }
}

final class $SentryPackage$Deserializer$Type
    extends jni$_.JObjType<SentryPackage$Deserializer> {
  @jni$_.internal
  const $SentryPackage$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/SentryPackage$Deserializer;';

  @jni$_.internal
  @core$_.override
  SentryPackage$Deserializer fromReference(jni$_.JReference reference) =>
      SentryPackage$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryPackage$Deserializer?> get nullableType =>
      const $SentryPackage$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryPackage$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryPackage$Deserializer$Type) &&
        other is $SentryPackage$Deserializer$Type;
  }
}

/// from: `io.sentry.protocol.SentryPackage$JsonKeys`
class SentryPackage$JsonKeys extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryPackage$JsonKeys> $type;

  @jni$_.internal
  SentryPackage$JsonKeys.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/protocol/SentryPackage$JsonKeys');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryPackage$JsonKeys$NullableType();
  static const type = $SentryPackage$JsonKeys$Type();
  static final _id_NAME = _class.staticFieldId(
    r'NAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String NAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get NAME =>
      _id_NAME.get(_class, const jni$_.JStringNullableType());

  static final _id_VERSION = _class.staticFieldId(
    r'VERSION',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String VERSION`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get VERSION =>
      _id_VERSION.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryPackage$JsonKeys() {
    return SentryPackage$JsonKeys.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $SentryPackage$JsonKeys$NullableType
    extends jni$_.JObjType<SentryPackage$JsonKeys?> {
  @jni$_.internal
  const $SentryPackage$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/SentryPackage$JsonKeys;';

  @jni$_.internal
  @core$_.override
  SentryPackage$JsonKeys? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryPackage$JsonKeys.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryPackage$JsonKeys?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryPackage$JsonKeys$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryPackage$JsonKeys$NullableType) &&
        other is $SentryPackage$JsonKeys$NullableType;
  }
}

final class $SentryPackage$JsonKeys$Type
    extends jni$_.JObjType<SentryPackage$JsonKeys> {
  @jni$_.internal
  const $SentryPackage$JsonKeys$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/SentryPackage$JsonKeys;';

  @jni$_.internal
  @core$_.override
  SentryPackage$JsonKeys fromReference(jni$_.JReference reference) =>
      SentryPackage$JsonKeys.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryPackage$JsonKeys?> get nullableType =>
      const $SentryPackage$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryPackage$JsonKeys$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryPackage$JsonKeys$Type) &&
        other is $SentryPackage$JsonKeys$Type;
  }
}

/// from: `io.sentry.protocol.SentryPackage`
class SentryPackage extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryPackage> $type;

  @jni$_.internal
  SentryPackage.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/protocol/SentryPackage');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryPackage$NullableType();
  static const type = $SentryPackage$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryPackage(
    jni$_.JString string,
    jni$_.JString string1,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    return SentryPackage.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$string.pointer, _$string1.pointer)
        .reference);
  }

  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getName() {
    return _getName(reference.pointer, _id_getName as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_setName = _class.instanceMethodId(
    r'setName',
    r'(Ljava/lang/String;)V',
  );

  static final _setName = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setName(java.lang.String string)`
  void setName(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _setName(reference.pointer, _id_setName as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getVersion = _class.instanceMethodId(
    r'getVersion',
    r'()Ljava/lang/String;',
  );

  static final _getVersion = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getVersion()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getVersion() {
    return _getVersion(reference.pointer, _id_getVersion as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_setVersion = _class.instanceMethodId(
    r'setVersion',
    r'(Ljava/lang/String;)V',
  );

  static final _setVersion = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setVersion(java.lang.String string)`
  void setVersion(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _setVersion(reference.pointer, _id_setVersion as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getUnknown = _class.instanceMethodId(
    r'getUnknown',
    r'()Ljava/util/Map;',
  );

  static final _getUnknown = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Map<java.lang.String, java.lang.Object> getUnknown()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JObject?>? getUnknown() {
    return _getUnknown(reference.pointer, _id_getUnknown as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JObject?>(
                jni$_.JStringNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_setUnknown = _class.instanceMethodId(
    r'setUnknown',
    r'(Ljava/util/Map;)V',
  );

  static final _setUnknown = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setUnknown(java.util.Map<java.lang.String, java.lang.Object> map)`
  void setUnknown(
    jni$_.JMap<jni$_.JString?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    _setUnknown(reference.pointer, _id_setUnknown as jni$_.JMethodIDPtr,
            _$map.pointer)
        .check();
  }

  static final _id_serialize = _class.instanceMethodId(
    r'serialize',
    r'(Lio/sentry/ObjectWriter;Lio/sentry/ILogger;)V',
  );

  static final _serialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void serialize(io.sentry.ObjectWriter objectWriter, io.sentry.ILogger iLogger)`
  void serialize(
    jni$_.JObject objectWriter,
    jni$_.JObject iLogger,
  ) {
    final _$objectWriter = objectWriter.reference;
    final _$iLogger = iLogger.reference;
    _serialize(reference.pointer, _id_serialize as jni$_.JMethodIDPtr,
            _$objectWriter.pointer, _$iLogger.pointer)
        .check();
  }
}

final class $SentryPackage$NullableType extends jni$_.JObjType<SentryPackage?> {
  @jni$_.internal
  const $SentryPackage$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/SentryPackage;';

  @jni$_.internal
  @core$_.override
  SentryPackage? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : SentryPackage.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryPackage?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryPackage$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryPackage$NullableType) &&
        other is $SentryPackage$NullableType;
  }
}

final class $SentryPackage$Type extends jni$_.JObjType<SentryPackage> {
  @jni$_.internal
  const $SentryPackage$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/SentryPackage;';

  @jni$_.internal
  @core$_.override
  SentryPackage fromReference(jni$_.JReference reference) =>
      SentryPackage.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryPackage?> get nullableType =>
      const $SentryPackage$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryPackage$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryPackage$Type) &&
        other is $SentryPackage$Type;
  }
}

/// from: `io.sentry.rrweb.RRWebOptionsEvent$Deserializer`
class RRWebOptionsEvent$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<RRWebOptionsEvent$Deserializer> $type;

  @jni$_.internal
  RRWebOptionsEvent$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/rrweb/RRWebOptionsEvent$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $RRWebOptionsEvent$Deserializer$NullableType();
  static const type = $RRWebOptionsEvent$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory RRWebOptionsEvent$Deserializer() {
    return RRWebOptionsEvent$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserialize = _class.instanceMethodId(
    r'deserialize',
    r'(Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Lio/sentry/rrweb/RRWebOptionsEvent;',
  );

  static final _deserialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.rrweb.RRWebOptionsEvent deserialize(io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  /// The returned object must be released after use, by calling the [release] method.
  RRWebOptionsEvent deserialize(
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserialize(
            reference.pointer,
            _id_deserialize as jni$_.JMethodIDPtr,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .object<RRWebOptionsEvent>(const $RRWebOptionsEvent$Type());
  }
}

final class $RRWebOptionsEvent$Deserializer$NullableType
    extends jni$_.JObjType<RRWebOptionsEvent$Deserializer?> {
  @jni$_.internal
  const $RRWebOptionsEvent$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/rrweb/RRWebOptionsEvent$Deserializer;';

  @jni$_.internal
  @core$_.override
  RRWebOptionsEvent$Deserializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : RRWebOptionsEvent$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RRWebOptionsEvent$Deserializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($RRWebOptionsEvent$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($RRWebOptionsEvent$Deserializer$NullableType) &&
        other is $RRWebOptionsEvent$Deserializer$NullableType;
  }
}

final class $RRWebOptionsEvent$Deserializer$Type
    extends jni$_.JObjType<RRWebOptionsEvent$Deserializer> {
  @jni$_.internal
  const $RRWebOptionsEvent$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/rrweb/RRWebOptionsEvent$Deserializer;';

  @jni$_.internal
  @core$_.override
  RRWebOptionsEvent$Deserializer fromReference(jni$_.JReference reference) =>
      RRWebOptionsEvent$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RRWebOptionsEvent$Deserializer?> get nullableType =>
      const $RRWebOptionsEvent$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($RRWebOptionsEvent$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RRWebOptionsEvent$Deserializer$Type) &&
        other is $RRWebOptionsEvent$Deserializer$Type;
  }
}

/// from: `io.sentry.rrweb.RRWebOptionsEvent$JsonKeys`
class RRWebOptionsEvent$JsonKeys extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<RRWebOptionsEvent$JsonKeys> $type;

  @jni$_.internal
  RRWebOptionsEvent$JsonKeys.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/rrweb/RRWebOptionsEvent$JsonKeys');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $RRWebOptionsEvent$JsonKeys$NullableType();
  static const type = $RRWebOptionsEvent$JsonKeys$Type();
  static final _id_DATA = _class.staticFieldId(
    r'DATA',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DATA`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DATA =>
      _id_DATA.get(_class, const jni$_.JStringNullableType());

  static final _id_PAYLOAD = _class.staticFieldId(
    r'PAYLOAD',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PAYLOAD`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get PAYLOAD =>
      _id_PAYLOAD.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory RRWebOptionsEvent$JsonKeys() {
    return RRWebOptionsEvent$JsonKeys.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $RRWebOptionsEvent$JsonKeys$NullableType
    extends jni$_.JObjType<RRWebOptionsEvent$JsonKeys?> {
  @jni$_.internal
  const $RRWebOptionsEvent$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/rrweb/RRWebOptionsEvent$JsonKeys;';

  @jni$_.internal
  @core$_.override
  RRWebOptionsEvent$JsonKeys? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : RRWebOptionsEvent$JsonKeys.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RRWebOptionsEvent$JsonKeys?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($RRWebOptionsEvent$JsonKeys$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RRWebOptionsEvent$JsonKeys$NullableType) &&
        other is $RRWebOptionsEvent$JsonKeys$NullableType;
  }
}

final class $RRWebOptionsEvent$JsonKeys$Type
    extends jni$_.JObjType<RRWebOptionsEvent$JsonKeys> {
  @jni$_.internal
  const $RRWebOptionsEvent$JsonKeys$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/rrweb/RRWebOptionsEvent$JsonKeys;';

  @jni$_.internal
  @core$_.override
  RRWebOptionsEvent$JsonKeys fromReference(jni$_.JReference reference) =>
      RRWebOptionsEvent$JsonKeys.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RRWebOptionsEvent$JsonKeys?> get nullableType =>
      const $RRWebOptionsEvent$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($RRWebOptionsEvent$JsonKeys$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RRWebOptionsEvent$JsonKeys$Type) &&
        other is $RRWebOptionsEvent$JsonKeys$Type;
  }
}

/// from: `io.sentry.rrweb.RRWebOptionsEvent`
class RRWebOptionsEvent extends RRWebEvent {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<RRWebOptionsEvent> $type;

  @jni$_.internal
  RRWebOptionsEvent.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/rrweb/RRWebOptionsEvent');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $RRWebOptionsEvent$NullableType();
  static const type = $RRWebOptionsEvent$Type();
  static final _id_EVENT_TAG = _class.staticFieldId(
    r'EVENT_TAG',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EVENT_TAG`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EVENT_TAG =>
      _id_EVENT_TAG.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory RRWebOptionsEvent() {
    return RRWebOptionsEvent.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Lio/sentry/SentryOptions;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(io.sentry.SentryOptions sentryOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  factory RRWebOptionsEvent.new$1(
    SentryOptions sentryOptions,
  ) {
    final _$sentryOptions = sentryOptions.reference;
    return RRWebOptionsEvent.fromReference(_new$1(_class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr, _$sentryOptions.pointer)
        .reference);
  }

  static final _id_getTag = _class.instanceMethodId(
    r'getTag',
    r'()Ljava/lang/String;',
  );

  static final _getTag = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getTag()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getTag() {
    return _getTag(reference.pointer, _id_getTag as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_setTag = _class.instanceMethodId(
    r'setTag',
    r'(Ljava/lang/String;)V',
  );

  static final _setTag = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTag(java.lang.String string)`
  void setTag(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _setTag(reference.pointer, _id_setTag as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getOptionsPayload = _class.instanceMethodId(
    r'getOptionsPayload',
    r'()Ljava/util/Map;',
  );

  static final _getOptionsPayload = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Map<java.lang.String, java.lang.Object> getOptionsPayload()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JObject?> getOptionsPayload() {
    return _getOptionsPayload(
            reference.pointer, _id_getOptionsPayload as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JString?, jni$_.JObject?>(
                jni$_.JStringNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_setOptionsPayload = _class.instanceMethodId(
    r'setOptionsPayload',
    r'(Ljava/util/Map;)V',
  );

  static final _setOptionsPayload = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setOptionsPayload(java.util.Map<java.lang.String, java.lang.Object> map)`
  void setOptionsPayload(
    jni$_.JMap<jni$_.JString?, jni$_.JObject?> map,
  ) {
    final _$map = map.reference;
    _setOptionsPayload(reference.pointer,
            _id_setOptionsPayload as jni$_.JMethodIDPtr, _$map.pointer)
        .check();
  }

  static final _id_getDataUnknown = _class.instanceMethodId(
    r'getDataUnknown',
    r'()Ljava/util/Map;',
  );

  static final _getDataUnknown = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Map<java.lang.String, java.lang.Object> getDataUnknown()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JObject?>? getDataUnknown() {
    return _getDataUnknown(
            reference.pointer, _id_getDataUnknown as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JObject?>(
                jni$_.JStringNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_setDataUnknown = _class.instanceMethodId(
    r'setDataUnknown',
    r'(Ljava/util/Map;)V',
  );

  static final _setDataUnknown = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDataUnknown(java.util.Map<java.lang.String, java.lang.Object> map)`
  void setDataUnknown(
    jni$_.JMap<jni$_.JString?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    _setDataUnknown(reference.pointer, _id_setDataUnknown as jni$_.JMethodIDPtr,
            _$map.pointer)
        .check();
  }

  static final _id_getUnknown = _class.instanceMethodId(
    r'getUnknown',
    r'()Ljava/util/Map;',
  );

  static final _getUnknown = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Map<java.lang.String, java.lang.Object> getUnknown()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JObject?>? getUnknown() {
    return _getUnknown(reference.pointer, _id_getUnknown as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JObject?>(
                jni$_.JStringNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_setUnknown = _class.instanceMethodId(
    r'setUnknown',
    r'(Ljava/util/Map;)V',
  );

  static final _setUnknown = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setUnknown(java.util.Map<java.lang.String, java.lang.Object> map)`
  void setUnknown(
    jni$_.JMap<jni$_.JString?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    _setUnknown(reference.pointer, _id_setUnknown as jni$_.JMethodIDPtr,
            _$map.pointer)
        .check();
  }

  static final _id_serialize = _class.instanceMethodId(
    r'serialize',
    r'(Lio/sentry/ObjectWriter;Lio/sentry/ILogger;)V',
  );

  static final _serialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void serialize(io.sentry.ObjectWriter objectWriter, io.sentry.ILogger iLogger)`
  void serialize(
    jni$_.JObject objectWriter,
    jni$_.JObject iLogger,
  ) {
    final _$objectWriter = objectWriter.reference;
    final _$iLogger = iLogger.reference;
    _serialize(reference.pointer, _id_serialize as jni$_.JMethodIDPtr,
            _$objectWriter.pointer, _$iLogger.pointer)
        .check();
  }
}

final class $RRWebOptionsEvent$NullableType
    extends jni$_.JObjType<RRWebOptionsEvent?> {
  @jni$_.internal
  const $RRWebOptionsEvent$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/rrweb/RRWebOptionsEvent;';

  @jni$_.internal
  @core$_.override
  RRWebOptionsEvent? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : RRWebOptionsEvent.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $RRWebEvent$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RRWebOptionsEvent?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($RRWebOptionsEvent$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RRWebOptionsEvent$NullableType) &&
        other is $RRWebOptionsEvent$NullableType;
  }
}

final class $RRWebOptionsEvent$Type extends jni$_.JObjType<RRWebOptionsEvent> {
  @jni$_.internal
  const $RRWebOptionsEvent$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/rrweb/RRWebOptionsEvent;';

  @jni$_.internal
  @core$_.override
  RRWebOptionsEvent fromReference(jni$_.JReference reference) =>
      RRWebOptionsEvent.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $RRWebEvent$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RRWebOptionsEvent?> get nullableType =>
      const $RRWebOptionsEvent$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($RRWebOptionsEvent$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RRWebOptionsEvent$Type) &&
        other is $RRWebOptionsEvent$Type;
  }
}

/// from: `io.sentry.rrweb.RRWebEvent$Deserializer`
class RRWebEvent$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<RRWebEvent$Deserializer> $type;

  @jni$_.internal
  RRWebEvent$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/rrweb/RRWebEvent$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $RRWebEvent$Deserializer$NullableType();
  static const type = $RRWebEvent$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory RRWebEvent$Deserializer() {
    return RRWebEvent$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserializeValue = _class.instanceMethodId(
    r'deserializeValue',
    r'(Lio/sentry/rrweb/RRWebEvent;Ljava/lang/String;Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Z',
  );

  static final _deserializeValue = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean deserializeValue(io.sentry.rrweb.RRWebEvent rRWebEvent, java.lang.String string, io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  bool deserializeValue(
    RRWebEvent rRWebEvent,
    jni$_.JString string,
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$rRWebEvent = rRWebEvent.reference;
    final _$string = string.reference;
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserializeValue(
            reference.pointer,
            _id_deserializeValue as jni$_.JMethodIDPtr,
            _$rRWebEvent.pointer,
            _$string.pointer,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .boolean;
  }
}

final class $RRWebEvent$Deserializer$NullableType
    extends jni$_.JObjType<RRWebEvent$Deserializer?> {
  @jni$_.internal
  const $RRWebEvent$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/rrweb/RRWebEvent$Deserializer;';

  @jni$_.internal
  @core$_.override
  RRWebEvent$Deserializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : RRWebEvent$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RRWebEvent$Deserializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($RRWebEvent$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RRWebEvent$Deserializer$NullableType) &&
        other is $RRWebEvent$Deserializer$NullableType;
  }
}

final class $RRWebEvent$Deserializer$Type
    extends jni$_.JObjType<RRWebEvent$Deserializer> {
  @jni$_.internal
  const $RRWebEvent$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/rrweb/RRWebEvent$Deserializer;';

  @jni$_.internal
  @core$_.override
  RRWebEvent$Deserializer fromReference(jni$_.JReference reference) =>
      RRWebEvent$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RRWebEvent$Deserializer?> get nullableType =>
      const $RRWebEvent$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($RRWebEvent$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RRWebEvent$Deserializer$Type) &&
        other is $RRWebEvent$Deserializer$Type;
  }
}

/// from: `io.sentry.rrweb.RRWebEvent$JsonKeys`
class RRWebEvent$JsonKeys extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<RRWebEvent$JsonKeys> $type;

  @jni$_.internal
  RRWebEvent$JsonKeys.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/rrweb/RRWebEvent$JsonKeys');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $RRWebEvent$JsonKeys$NullableType();
  static const type = $RRWebEvent$JsonKeys$Type();
  static final _id_TYPE = _class.staticFieldId(
    r'TYPE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TYPE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TYPE =>
      _id_TYPE.get(_class, const jni$_.JStringNullableType());

  static final _id_TIMESTAMP = _class.staticFieldId(
    r'TIMESTAMP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TIMESTAMP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TIMESTAMP =>
      _id_TIMESTAMP.get(_class, const jni$_.JStringNullableType());

  static final _id_TAG = _class.staticFieldId(
    r'TAG',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TAG`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TAG =>
      _id_TAG.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory RRWebEvent$JsonKeys() {
    return RRWebEvent$JsonKeys.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $RRWebEvent$JsonKeys$NullableType
    extends jni$_.JObjType<RRWebEvent$JsonKeys?> {
  @jni$_.internal
  const $RRWebEvent$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/rrweb/RRWebEvent$JsonKeys;';

  @jni$_.internal
  @core$_.override
  RRWebEvent$JsonKeys? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : RRWebEvent$JsonKeys.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RRWebEvent$JsonKeys?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($RRWebEvent$JsonKeys$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RRWebEvent$JsonKeys$NullableType) &&
        other is $RRWebEvent$JsonKeys$NullableType;
  }
}

final class $RRWebEvent$JsonKeys$Type
    extends jni$_.JObjType<RRWebEvent$JsonKeys> {
  @jni$_.internal
  const $RRWebEvent$JsonKeys$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/rrweb/RRWebEvent$JsonKeys;';

  @jni$_.internal
  @core$_.override
  RRWebEvent$JsonKeys fromReference(jni$_.JReference reference) =>
      RRWebEvent$JsonKeys.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RRWebEvent$JsonKeys?> get nullableType =>
      const $RRWebEvent$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($RRWebEvent$JsonKeys$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RRWebEvent$JsonKeys$Type) &&
        other is $RRWebEvent$JsonKeys$Type;
  }
}

/// from: `io.sentry.rrweb.RRWebEvent$Serializer`
class RRWebEvent$Serializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<RRWebEvent$Serializer> $type;

  @jni$_.internal
  RRWebEvent$Serializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/rrweb/RRWebEvent$Serializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $RRWebEvent$Serializer$NullableType();
  static const type = $RRWebEvent$Serializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory RRWebEvent$Serializer() {
    return RRWebEvent$Serializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_serialize = _class.instanceMethodId(
    r'serialize',
    r'(Lio/sentry/rrweb/RRWebEvent;Lio/sentry/ObjectWriter;Lio/sentry/ILogger;)V',
  );

  static final _serialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void serialize(io.sentry.rrweb.RRWebEvent rRWebEvent, io.sentry.ObjectWriter objectWriter, io.sentry.ILogger iLogger)`
  void serialize(
    RRWebEvent rRWebEvent,
    jni$_.JObject objectWriter,
    jni$_.JObject iLogger,
  ) {
    final _$rRWebEvent = rRWebEvent.reference;
    final _$objectWriter = objectWriter.reference;
    final _$iLogger = iLogger.reference;
    _serialize(reference.pointer, _id_serialize as jni$_.JMethodIDPtr,
            _$rRWebEvent.pointer, _$objectWriter.pointer, _$iLogger.pointer)
        .check();
  }
}

final class $RRWebEvent$Serializer$NullableType
    extends jni$_.JObjType<RRWebEvent$Serializer?> {
  @jni$_.internal
  const $RRWebEvent$Serializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/rrweb/RRWebEvent$Serializer;';

  @jni$_.internal
  @core$_.override
  RRWebEvent$Serializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : RRWebEvent$Serializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RRWebEvent$Serializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($RRWebEvent$Serializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RRWebEvent$Serializer$NullableType) &&
        other is $RRWebEvent$Serializer$NullableType;
  }
}

final class $RRWebEvent$Serializer$Type
    extends jni$_.JObjType<RRWebEvent$Serializer> {
  @jni$_.internal
  const $RRWebEvent$Serializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/rrweb/RRWebEvent$Serializer;';

  @jni$_.internal
  @core$_.override
  RRWebEvent$Serializer fromReference(jni$_.JReference reference) =>
      RRWebEvent$Serializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RRWebEvent$Serializer?> get nullableType =>
      const $RRWebEvent$Serializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($RRWebEvent$Serializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RRWebEvent$Serializer$Type) &&
        other is $RRWebEvent$Serializer$Type;
  }
}

/// from: `io.sentry.rrweb.RRWebEvent`
class RRWebEvent extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<RRWebEvent> $type;

  @jni$_.internal
  RRWebEvent.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/rrweb/RRWebEvent');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $RRWebEvent$NullableType();
  static const type = $RRWebEvent$Type();
  static final _id_getType = _class.instanceMethodId(
    r'getType',
    r'()Lio/sentry/rrweb/RRWebEventType;',
  );

  static final _getType = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.rrweb.RRWebEventType getType()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getType() {
    return _getType(reference.pointer, _id_getType as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setType = _class.instanceMethodId(
    r'setType',
    r'(Lio/sentry/rrweb/RRWebEventType;)V',
  );

  static final _setType = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setType(io.sentry.rrweb.RRWebEventType rRWebEventType)`
  void setType(
    jni$_.JObject rRWebEventType,
  ) {
    final _$rRWebEventType = rRWebEventType.reference;
    _setType(reference.pointer, _id_setType as jni$_.JMethodIDPtr,
            _$rRWebEventType.pointer)
        .check();
  }

  static final _id_getTimestamp = _class.instanceMethodId(
    r'getTimestamp',
    r'()J',
  );

  static final _getTimestamp = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long getTimestamp()`
  int getTimestamp() {
    return _getTimestamp(
            reference.pointer, _id_getTimestamp as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_setTimestamp = _class.instanceMethodId(
    r'setTimestamp',
    r'(J)V',
  );

  static final _setTimestamp = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setTimestamp(long j)`
  void setTimestamp(
    int j,
  ) {
    _setTimestamp(reference.pointer, _id_setTimestamp as jni$_.JMethodIDPtr, j)
        .check();
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }
}

final class $RRWebEvent$NullableType extends jni$_.JObjType<RRWebEvent?> {
  @jni$_.internal
  const $RRWebEvent$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/rrweb/RRWebEvent;';

  @jni$_.internal
  @core$_.override
  RRWebEvent? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : RRWebEvent.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RRWebEvent?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($RRWebEvent$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RRWebEvent$NullableType) &&
        other is $RRWebEvent$NullableType;
  }
}

final class $RRWebEvent$Type extends jni$_.JObjType<RRWebEvent> {
  @jni$_.internal
  const $RRWebEvent$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/rrweb/RRWebEvent;';

  @jni$_.internal
  @core$_.override
  RRWebEvent fromReference(jni$_.JReference reference) =>
      RRWebEvent.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RRWebEvent?> get nullableType =>
      const $RRWebEvent$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($RRWebEvent$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RRWebEvent$Type) && other is $RRWebEvent$Type;
  }
}

/// from: `java.net.Proxy$Type`
class Proxy$Type extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Proxy$Type> $type;

  @jni$_.internal
  Proxy$Type.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/Proxy$Type');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Proxy$Type$NullableType();
  static const type = $Proxy$Type$Type();
  static final _id_DIRECT = _class.staticFieldId(
    r'DIRECT',
    r'Ljava/net/Proxy$Type;',
  );

  /// from: `static public final java.net.Proxy$Type DIRECT`
  /// The returned object must be released after use, by calling the [release] method.
  static Proxy$Type get DIRECT =>
      _id_DIRECT.get(_class, const $Proxy$Type$Type());

  static final _id_HTTP = _class.staticFieldId(
    r'HTTP',
    r'Ljava/net/Proxy$Type;',
  );

  /// from: `static public final java.net.Proxy$Type HTTP`
  /// The returned object must be released after use, by calling the [release] method.
  static Proxy$Type get HTTP => _id_HTTP.get(_class, const $Proxy$Type$Type());

  static final _id_SOCKS = _class.staticFieldId(
    r'SOCKS',
    r'Ljava/net/Proxy$Type;',
  );

  /// from: `static public final java.net.Proxy$Type SOCKS`
  /// The returned object must be released after use, by calling the [release] method.
  static Proxy$Type get SOCKS =>
      _id_SOCKS.get(_class, const $Proxy$Type$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Ljava/net/Proxy$Type;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.net.Proxy$Type[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Proxy$Type?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<Proxy$Type?>?>(
            const jni$_.JArrayNullableType<Proxy$Type?>(
                $Proxy$Type$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Ljava/net/Proxy$Type;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.net.Proxy$Type valueOf(java.lang.String synthetic)`
  /// The returned object must be released after use, by calling the [release] method.
  static Proxy$Type? valueOf(
    jni$_.JString? synthetic,
  ) {
    final _$synthetic = synthetic?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$synthetic.pointer)
        .object<Proxy$Type?>(const $Proxy$Type$NullableType());
  }
}

final class $Proxy$Type$NullableType extends jni$_.JObjType<Proxy$Type?> {
  @jni$_.internal
  const $Proxy$Type$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/Proxy$Type;';

  @jni$_.internal
  @core$_.override
  Proxy$Type? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Proxy$Type.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Proxy$Type?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Proxy$Type$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Proxy$Type$NullableType) &&
        other is $Proxy$Type$NullableType;
  }
}

final class $Proxy$Type$Type extends jni$_.JObjType<Proxy$Type> {
  @jni$_.internal
  const $Proxy$Type$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/Proxy$Type;';

  @jni$_.internal
  @core$_.override
  Proxy$Type fromReference(jni$_.JReference reference) =>
      Proxy$Type.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Proxy$Type?> get nullableType =>
      const $Proxy$Type$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Proxy$Type$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Proxy$Type$Type) && other is $Proxy$Type$Type;
  }
}

/// from: `java.net.Proxy`
class Proxy extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Proxy> $type;

  @jni$_.internal
  Proxy.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/Proxy');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Proxy$NullableType();
  static const type = $Proxy$Type();
  static final _id_NO_PROXY = _class.staticFieldId(
    r'NO_PROXY',
    r'Ljava/net/Proxy;',
  );

  /// from: `static public final java.net.Proxy NO_PROXY`
  /// The returned object must be released after use, by calling the [release] method.
  static Proxy? get NO_PROXY =>
      _id_NO_PROXY.get(_class, const $Proxy$NullableType());

  static final _id_new$ = _class.constructorId(
    r'(Ljava/net/Proxy$Type;Ljava/net/SocketAddress;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.net.Proxy$Type type, java.net.SocketAddress socketAddress)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Proxy(
    Proxy$Type? type,
    jni$_.JObject? socketAddress,
  ) {
    final _$type = type?.reference ?? jni$_.jNullReference;
    final _$socketAddress = socketAddress?.reference ?? jni$_.jNullReference;
    return Proxy.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$type.pointer,
            _$socketAddress.pointer)
        .reference);
  }

  static final _id_type$1 = _class.instanceMethodId(
    r'type',
    r'()Ljava/net/Proxy$Type;',
  );

  static final _type$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.net.Proxy$Type type()`
  /// The returned object must be released after use, by calling the [release] method.
  Proxy$Type? type$1() {
    return _type$1(reference.pointer, _id_type$1 as jni$_.JMethodIDPtr)
        .object<Proxy$Type?>(const $Proxy$Type$NullableType());
  }

  static final _id_address = _class.instanceMethodId(
    r'address',
    r'()Ljava/net/SocketAddress;',
  );

  static final _address = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.net.SocketAddress address()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? address() {
    return _address(reference.pointer, _id_address as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }
}

final class $Proxy$NullableType extends jni$_.JObjType<Proxy?> {
  @jni$_.internal
  const $Proxy$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/Proxy;';

  @jni$_.internal
  @core$_.override
  Proxy? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Proxy.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Proxy?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Proxy$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Proxy$NullableType) &&
        other is $Proxy$NullableType;
  }
}

final class $Proxy$Type extends jni$_.JObjType<Proxy> {
  @jni$_.internal
  const $Proxy$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/Proxy;';

  @jni$_.internal
  @core$_.override
  Proxy fromReference(jni$_.JReference reference) => Proxy.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Proxy?> get nullableType => const $Proxy$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Proxy$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Proxy$Type) && other is $Proxy$Type;
  }
}

/// from: `android.graphics.Bitmap$CompressFormat`
class Bitmap$CompressFormat extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Bitmap$CompressFormat> $type;

  @jni$_.internal
  Bitmap$CompressFormat.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'android/graphics/Bitmap$CompressFormat');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Bitmap$CompressFormat$NullableType();
  static const type = $Bitmap$CompressFormat$Type();
  static final _id_JPEG = _class.staticFieldId(
    r'JPEG',
    r'Landroid/graphics/Bitmap$CompressFormat;',
  );

  /// from: `static public final android.graphics.Bitmap$CompressFormat JPEG`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat get JPEG =>
      _id_JPEG.get(_class, const $Bitmap$CompressFormat$Type());

  static final _id_PNG = _class.staticFieldId(
    r'PNG',
    r'Landroid/graphics/Bitmap$CompressFormat;',
  );

  /// from: `static public final android.graphics.Bitmap$CompressFormat PNG`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat get PNG =>
      _id_PNG.get(_class, const $Bitmap$CompressFormat$Type());

  static final _id_WEBP = _class.staticFieldId(
    r'WEBP',
    r'Landroid/graphics/Bitmap$CompressFormat;',
  );

  /// from: `static public final android.graphics.Bitmap$CompressFormat WEBP`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat get WEBP =>
      _id_WEBP.get(_class, const $Bitmap$CompressFormat$Type());

  static final _id_WEBP_LOSSY = _class.staticFieldId(
    r'WEBP_LOSSY',
    r'Landroid/graphics/Bitmap$CompressFormat;',
  );

  /// from: `static public final android.graphics.Bitmap$CompressFormat WEBP_LOSSY`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat get WEBP_LOSSY =>
      _id_WEBP_LOSSY.get(_class, const $Bitmap$CompressFormat$Type());

  static final _id_WEBP_LOSSLESS = _class.staticFieldId(
    r'WEBP_LOSSLESS',
    r'Landroid/graphics/Bitmap$CompressFormat;',
  );

  /// from: `static public final android.graphics.Bitmap$CompressFormat WEBP_LOSSLESS`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat get WEBP_LOSSLESS =>
      _id_WEBP_LOSSLESS.get(_class, const $Bitmap$CompressFormat$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Landroid/graphics/Bitmap$CompressFormat;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public android.graphics.Bitmap$CompressFormat[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Bitmap$CompressFormat?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<Bitmap$CompressFormat?>?>(
            const jni$_.JArrayNullableType<Bitmap$CompressFormat?>(
                $Bitmap$CompressFormat$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Landroid/graphics/Bitmap$CompressFormat;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap$CompressFormat valueOf(java.lang.String synthetic)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat? valueOf(
    jni$_.JString? synthetic,
  ) {
    final _$synthetic = synthetic?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$synthetic.pointer)
        .object<Bitmap$CompressFormat?>(
            const $Bitmap$CompressFormat$NullableType());
  }
}

final class $Bitmap$CompressFormat$NullableType
    extends jni$_.JObjType<Bitmap$CompressFormat?> {
  @jni$_.internal
  const $Bitmap$CompressFormat$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap$CompressFormat;';

  @jni$_.internal
  @core$_.override
  Bitmap$CompressFormat? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Bitmap$CompressFormat.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Bitmap$CompressFormat?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$CompressFormat$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$CompressFormat$NullableType) &&
        other is $Bitmap$CompressFormat$NullableType;
  }
}

final class $Bitmap$CompressFormat$Type
    extends jni$_.JObjType<Bitmap$CompressFormat> {
  @jni$_.internal
  const $Bitmap$CompressFormat$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap$CompressFormat;';

  @jni$_.internal
  @core$_.override
  Bitmap$CompressFormat fromReference(jni$_.JReference reference) =>
      Bitmap$CompressFormat.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Bitmap$CompressFormat?> get nullableType =>
      const $Bitmap$CompressFormat$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$CompressFormat$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$CompressFormat$Type) &&
        other is $Bitmap$CompressFormat$Type;
  }
}

/// from: `android.graphics.Bitmap$Config`
class Bitmap$Config extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Bitmap$Config> $type;

  @jni$_.internal
  Bitmap$Config.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/graphics/Bitmap$Config');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Bitmap$Config$NullableType();
  static const type = $Bitmap$Config$Type();
  static final _id_ALPHA_8 = _class.staticFieldId(
    r'ALPHA_8',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config ALPHA_8`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get ALPHA_8 =>
      _id_ALPHA_8.get(_class, const $Bitmap$Config$Type());

  static final _id_RGB_565 = _class.staticFieldId(
    r'RGB_565',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config RGB_565`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get RGB_565 =>
      _id_RGB_565.get(_class, const $Bitmap$Config$Type());

  static final _id_ARGB_4444 = _class.staticFieldId(
    r'ARGB_4444',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config ARGB_4444`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get ARGB_4444 =>
      _id_ARGB_4444.get(_class, const $Bitmap$Config$Type());

  static final _id_ARGB_8888 = _class.staticFieldId(
    r'ARGB_8888',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config ARGB_8888`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get ARGB_8888 =>
      _id_ARGB_8888.get(_class, const $Bitmap$Config$Type());

  static final _id_RGBA_F16 = _class.staticFieldId(
    r'RGBA_F16',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config RGBA_F16`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get RGBA_F16 =>
      _id_RGBA_F16.get(_class, const $Bitmap$Config$Type());

  static final _id_HARDWARE = _class.staticFieldId(
    r'HARDWARE',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config HARDWARE`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get HARDWARE =>
      _id_HARDWARE.get(_class, const $Bitmap$Config$Type());

  static final _id_RGBA_1010102 = _class.staticFieldId(
    r'RGBA_1010102',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config RGBA_1010102`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get RGBA_1010102 =>
      _id_RGBA_1010102.get(_class, const $Bitmap$Config$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Landroid/graphics/Bitmap$Config;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public android.graphics.Bitmap$Config[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Bitmap$Config?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<Bitmap$Config?>?>(
            const jni$_.JArrayNullableType<Bitmap$Config?>(
                $Bitmap$Config$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Landroid/graphics/Bitmap$Config;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap$Config valueOf(java.lang.String synthetic)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config? valueOf(
    jni$_.JString? synthetic,
  ) {
    final _$synthetic = synthetic?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$synthetic.pointer)
        .object<Bitmap$Config?>(const $Bitmap$Config$NullableType());
  }
}

final class $Bitmap$Config$NullableType extends jni$_.JObjType<Bitmap$Config?> {
  @jni$_.internal
  const $Bitmap$Config$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap$Config;';

  @jni$_.internal
  @core$_.override
  Bitmap$Config? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Bitmap$Config.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Bitmap$Config?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$Config$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$Config$NullableType) &&
        other is $Bitmap$Config$NullableType;
  }
}

final class $Bitmap$Config$Type extends jni$_.JObjType<Bitmap$Config> {
  @jni$_.internal
  const $Bitmap$Config$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap$Config;';

  @jni$_.internal
  @core$_.override
  Bitmap$Config fromReference(jni$_.JReference reference) =>
      Bitmap$Config.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Bitmap$Config?> get nullableType =>
      const $Bitmap$Config$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$Config$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$Config$Type) &&
        other is $Bitmap$Config$Type;
  }
}

/// from: `android.graphics.Bitmap`
class Bitmap extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Bitmap> $type;

  @jni$_.internal
  Bitmap.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/graphics/Bitmap');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Bitmap$NullableType();
  static const type = $Bitmap$Type();
  static final _id_CREATOR = _class.staticFieldId(
    r'CREATOR',
    r'Landroid/os/Parcelable$Creator;',
  );

  /// from: `static public final android.os.Parcelable$Creator<android.graphics.Bitmap> CREATOR`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? get CREATOR =>
      _id_CREATOR.get(_class, const jni$_.JObjectNullableType());

  /// from: `static public final int DENSITY_NONE`
  static const DENSITY_NONE = 0;
  static final _id_getDensity = _class.instanceMethodId(
    r'getDensity',
    r'()I',
  );

  static final _getDensity = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getDensity()`
  int getDensity() {
    return _getDensity(reference.pointer, _id_getDensity as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_setDensity = _class.instanceMethodId(
    r'setDensity',
    r'(I)V',
  );

  static final _setDensity = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setDensity(int i)`
  void setDensity(
    int i,
  ) {
    _setDensity(reference.pointer, _id_setDensity as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_reconfigure = _class.instanceMethodId(
    r'reconfigure',
    r'(IILandroid/graphics/Bitmap$Config;)V',
  );

  static final _reconfigure = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void reconfigure(int i, int i1, android.graphics.Bitmap$Config config)`
  void reconfigure(
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    _reconfigure(reference.pointer, _id_reconfigure as jni$_.JMethodIDPtr, i,
            i1, _$config.pointer)
        .check();
  }

  static final _id_setWidth = _class.instanceMethodId(
    r'setWidth',
    r'(I)V',
  );

  static final _setWidth = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setWidth(int i)`
  void setWidth(
    int i,
  ) {
    _setWidth(reference.pointer, _id_setWidth as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_setHeight = _class.instanceMethodId(
    r'setHeight',
    r'(I)V',
  );

  static final _setHeight = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setHeight(int i)`
  void setHeight(
    int i,
  ) {
    _setHeight(reference.pointer, _id_setHeight as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_setConfig = _class.instanceMethodId(
    r'setConfig',
    r'(Landroid/graphics/Bitmap$Config;)V',
  );

  static final _setConfig = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setConfig(android.graphics.Bitmap$Config config)`
  void setConfig(
    Bitmap$Config? config,
  ) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    _setConfig(reference.pointer, _id_setConfig as jni$_.JMethodIDPtr,
            _$config.pointer)
        .check();
  }

  static final _id_recycle = _class.instanceMethodId(
    r'recycle',
    r'()V',
  );

  static final _recycle = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void recycle()`
  void recycle() {
    _recycle(reference.pointer, _id_recycle as jni$_.JMethodIDPtr).check();
  }

  static final _id_isRecycled = _class.instanceMethodId(
    r'isRecycled',
    r'()Z',
  );

  static final _isRecycled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isRecycled()`
  bool isRecycled() {
    return _isRecycled(reference.pointer, _id_isRecycled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getGenerationId = _class.instanceMethodId(
    r'getGenerationId',
    r'()I',
  );

  static final _getGenerationId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getGenerationId()`
  int getGenerationId() {
    return _getGenerationId(
            reference.pointer, _id_getGenerationId as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_copyPixelsToBuffer = _class.instanceMethodId(
    r'copyPixelsToBuffer',
    r'(Ljava/nio/Buffer;)V',
  );

  static final _copyPixelsToBuffer = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void copyPixelsToBuffer(java.nio.Buffer buffer)`
  void copyPixelsToBuffer(
    jni$_.JBuffer? buffer,
  ) {
    final _$buffer = buffer?.reference ?? jni$_.jNullReference;
    _copyPixelsToBuffer(reference.pointer,
            _id_copyPixelsToBuffer as jni$_.JMethodIDPtr, _$buffer.pointer)
        .check();
  }

  static final _id_copyPixelsFromBuffer = _class.instanceMethodId(
    r'copyPixelsFromBuffer',
    r'(Ljava/nio/Buffer;)V',
  );

  static final _copyPixelsFromBuffer = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void copyPixelsFromBuffer(java.nio.Buffer buffer)`
  void copyPixelsFromBuffer(
    jni$_.JBuffer? buffer,
  ) {
    final _$buffer = buffer?.reference ?? jni$_.jNullReference;
    _copyPixelsFromBuffer(reference.pointer,
            _id_copyPixelsFromBuffer as jni$_.JMethodIDPtr, _$buffer.pointer)
        .check();
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(Landroid/graphics/Bitmap$Config;Z)Landroid/graphics/Bitmap;',
  );

  static final _copy = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public android.graphics.Bitmap copy(android.graphics.Bitmap$Config config, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap? copy(
    Bitmap$Config? config,
    bool z,
  ) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _copy(reference.pointer, _id_copy as jni$_.JMethodIDPtr,
            _$config.pointer, z ? 1 : 0)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_asShared = _class.instanceMethodId(
    r'asShared',
    r'()Landroid/graphics/Bitmap;',
  );

  static final _asShared = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public android.graphics.Bitmap asShared()`
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap? asShared() {
    return _asShared(reference.pointer, _id_asShared as jni$_.JMethodIDPtr)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_wrapHardwareBuffer = _class.staticMethodId(
    r'wrapHardwareBuffer',
    r'(Landroid/hardware/HardwareBuffer;Landroid/graphics/ColorSpace;)Landroid/graphics/Bitmap;',
  );

  static final _wrapHardwareBuffer = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap wrapHardwareBuffer(android.hardware.HardwareBuffer hardwareBuffer, android.graphics.ColorSpace colorSpace)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? wrapHardwareBuffer(
    jni$_.JObject? hardwareBuffer,
    jni$_.JObject? colorSpace,
  ) {
    final _$hardwareBuffer = hardwareBuffer?.reference ?? jni$_.jNullReference;
    final _$colorSpace = colorSpace?.reference ?? jni$_.jNullReference;
    return _wrapHardwareBuffer(
            _class.reference.pointer,
            _id_wrapHardwareBuffer as jni$_.JMethodIDPtr,
            _$hardwareBuffer.pointer,
            _$colorSpace.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createScaledBitmap = _class.staticMethodId(
    r'createScaledBitmap',
    r'(Landroid/graphics/Bitmap;IIZ)Landroid/graphics/Bitmap;',
  );

  static final _createScaledBitmap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int, int, int)>();

  /// from: `static public android.graphics.Bitmap createScaledBitmap(android.graphics.Bitmap bitmap, int i, int i1, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createScaledBitmap(
    Bitmap? bitmap,
    int i,
    int i1,
    bool z,
  ) {
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    return _createScaledBitmap(
            _class.reference.pointer,
            _id_createScaledBitmap as jni$_.JMethodIDPtr,
            _$bitmap.pointer,
            i,
            i1,
            z ? 1 : 0)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/graphics/Bitmap;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.graphics.Bitmap bitmap)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap(
    Bitmap? bitmap,
  ) {
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    return _createBitmap(_class.reference.pointer,
            _id_createBitmap as jni$_.JMethodIDPtr, _$bitmap.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$1 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/graphics/Bitmap;IIII)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.graphics.Bitmap bitmap, int i, int i1, int i2, int i3)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$1(
    Bitmap? bitmap,
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    return _createBitmap$1(
            _class.reference.pointer,
            _id_createBitmap$1 as jni$_.JMethodIDPtr,
            _$bitmap.pointer,
            i,
            i1,
            i2,
            i3)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$2 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/graphics/Bitmap;IIIILandroid/graphics/Matrix;Z)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.graphics.Bitmap bitmap, int i, int i1, int i2, int i3, android.graphics.Matrix matrix, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$2(
    Bitmap? bitmap,
    int i,
    int i1,
    int i2,
    int i3,
    jni$_.JObject? matrix,
    bool z,
  ) {
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    final _$matrix = matrix?.reference ?? jni$_.jNullReference;
    return _createBitmap$2(
            _class.reference.pointer,
            _id_createBitmap$2 as jni$_.JMethodIDPtr,
            _$bitmap.pointer,
            i,
            i1,
            i2,
            i3,
            _$matrix.pointer,
            z ? 1 : 0)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$3 = _class.staticMethodId(
    r'createBitmap',
    r'(IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(int i, int i1, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$3(
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$3(_class.reference.pointer,
            _id_createBitmap$3 as jni$_.JMethodIDPtr, i, i1, _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$4 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/util/DisplayMetrics;IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int i, int i1, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$4(
    jni$_.JObject? displayMetrics,
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$4(
            _class.reference.pointer,
            _id_createBitmap$4 as jni$_.JMethodIDPtr,
            _$displayMetrics.pointer,
            i,
            i1,
            _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$5 = _class.staticMethodId(
    r'createBitmap',
    r'(IILandroid/graphics/Bitmap$Config;Z)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$5 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `static public android.graphics.Bitmap createBitmap(int i, int i1, android.graphics.Bitmap$Config config, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$5(
    int i,
    int i1,
    Bitmap$Config? config,
    bool z,
  ) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$5(
            _class.reference.pointer,
            _id_createBitmap$5 as jni$_.JMethodIDPtr,
            i,
            i1,
            _$config.pointer,
            z ? 1 : 0)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$6 = _class.staticMethodId(
    r'createBitmap',
    r'(IILandroid/graphics/Bitmap$Config;ZLandroid/graphics/ColorSpace;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$6 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(int i, int i1, android.graphics.Bitmap$Config config, boolean z, android.graphics.ColorSpace colorSpace)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$6(
    int i,
    int i1,
    Bitmap$Config? config,
    bool z,
    jni$_.JObject? colorSpace,
  ) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    final _$colorSpace = colorSpace?.reference ?? jni$_.jNullReference;
    return _createBitmap$6(
            _class.reference.pointer,
            _id_createBitmap$6 as jni$_.JMethodIDPtr,
            i,
            i1,
            _$config.pointer,
            z ? 1 : 0,
            _$colorSpace.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$7 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/util/DisplayMetrics;IILandroid/graphics/Bitmap$Config;Z)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$7 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int i, int i1, android.graphics.Bitmap$Config config, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$7(
    jni$_.JObject? displayMetrics,
    int i,
    int i1,
    Bitmap$Config? config,
    bool z,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$7(
            _class.reference.pointer,
            _id_createBitmap$7 as jni$_.JMethodIDPtr,
            _$displayMetrics.pointer,
            i,
            i1,
            _$config.pointer,
            z ? 1 : 0)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$8 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/util/DisplayMetrics;IILandroid/graphics/Bitmap$Config;ZLandroid/graphics/ColorSpace;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$8 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int i, int i1, android.graphics.Bitmap$Config config, boolean z, android.graphics.ColorSpace colorSpace)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$8(
    jni$_.JObject? displayMetrics,
    int i,
    int i1,
    Bitmap$Config? config,
    bool z,
    jni$_.JObject? colorSpace,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    final _$colorSpace = colorSpace?.reference ?? jni$_.jNullReference;
    return _createBitmap$8(
            _class.reference.pointer,
            _id_createBitmap$8 as jni$_.JMethodIDPtr,
            _$displayMetrics.pointer,
            i,
            i1,
            _$config.pointer,
            z ? 1 : 0,
            _$colorSpace.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$9 = _class.staticMethodId(
    r'createBitmap',
    r'([IIIIILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$9 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(int[] is, int i, int i1, int i2, int i3, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$9(
    jni$_.JIntArray? is$,
    int i,
    int i1,
    int i2,
    int i3,
    Bitmap$Config? config,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$9(
            _class.reference.pointer,
            _id_createBitmap$9 as jni$_.JMethodIDPtr,
            _$is$.pointer,
            i,
            i1,
            i2,
            i3,
            _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$10 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/util/DisplayMetrics;[IIIIILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$10 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int[] is, int i, int i1, int i2, int i3, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$10(
    jni$_.JObject? displayMetrics,
    jni$_.JIntArray? is$,
    int i,
    int i1,
    int i2,
    int i3,
    Bitmap$Config? config,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$10(
            _class.reference.pointer,
            _id_createBitmap$10 as jni$_.JMethodIDPtr,
            _$displayMetrics.pointer,
            _$is$.pointer,
            i,
            i1,
            i2,
            i3,
            _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$11 = _class.staticMethodId(
    r'createBitmap',
    r'([IIILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$11 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(int[] is, int i, int i1, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$11(
    jni$_.JIntArray? is$,
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$11(
            _class.reference.pointer,
            _id_createBitmap$11 as jni$_.JMethodIDPtr,
            _$is$.pointer,
            i,
            i1,
            _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$12 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/util/DisplayMetrics;[IIILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$12 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int[] is, int i, int i1, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$12(
    jni$_.JObject? displayMetrics,
    jni$_.JIntArray? is$,
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$12(
            _class.reference.pointer,
            _id_createBitmap$12 as jni$_.JMethodIDPtr,
            _$displayMetrics.pointer,
            _$is$.pointer,
            i,
            i1,
            _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$13 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/graphics/Picture;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$13 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.graphics.Picture picture)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$13(
    jni$_.JObject? picture,
  ) {
    final _$picture = picture?.reference ?? jni$_.jNullReference;
    return _createBitmap$13(_class.reference.pointer,
            _id_createBitmap$13 as jni$_.JMethodIDPtr, _$picture.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$14 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/graphics/Picture;IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$14 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.graphics.Picture picture, int i, int i1, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$14(
    jni$_.JObject? picture,
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$picture = picture?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$14(
            _class.reference.pointer,
            _id_createBitmap$14 as jni$_.JMethodIDPtr,
            _$picture.pointer,
            i,
            i1,
            _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_getNinePatchChunk = _class.instanceMethodId(
    r'getNinePatchChunk',
    r'()[B',
  );

  static final _getNinePatchChunk = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public byte[] getNinePatchChunk()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? getNinePatchChunk() {
    return _getNinePatchChunk(
            reference.pointer, _id_getNinePatchChunk as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_compress = _class.instanceMethodId(
    r'compress',
    r'(Landroid/graphics/Bitmap$CompressFormat;ILjava/io/OutputStream;)Z',
  );

  static final _compress = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean compress(android.graphics.Bitmap$CompressFormat compressFormat, int i, java.io.OutputStream outputStream)`
  bool compress(
    Bitmap$CompressFormat? compressFormat,
    int i,
    jni$_.JObject? outputStream,
  ) {
    final _$compressFormat = compressFormat?.reference ?? jni$_.jNullReference;
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return _compress(reference.pointer, _id_compress as jni$_.JMethodIDPtr,
            _$compressFormat.pointer, i, _$outputStream.pointer)
        .boolean;
  }

  static final _id_isMutable = _class.instanceMethodId(
    r'isMutable',
    r'()Z',
  );

  static final _isMutable = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isMutable()`
  bool isMutable() {
    return _isMutable(reference.pointer, _id_isMutable as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_isPremultiplied = _class.instanceMethodId(
    r'isPremultiplied',
    r'()Z',
  );

  static final _isPremultiplied = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isPremultiplied()`
  bool isPremultiplied() {
    return _isPremultiplied(
            reference.pointer, _id_isPremultiplied as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setPremultiplied = _class.instanceMethodId(
    r'setPremultiplied',
    r'(Z)V',
  );

  static final _setPremultiplied = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setPremultiplied(boolean z)`
  void setPremultiplied(
    bool z,
  ) {
    _setPremultiplied(reference.pointer,
            _id_setPremultiplied as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getWidth = _class.instanceMethodId(
    r'getWidth',
    r'()I',
  );

  static final _getWidth = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getWidth()`
  int getWidth() {
    return _getWidth(reference.pointer, _id_getWidth as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getHeight = _class.instanceMethodId(
    r'getHeight',
    r'()I',
  );

  static final _getHeight = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getHeight()`
  int getHeight() {
    return _getHeight(reference.pointer, _id_getHeight as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getScaledWidth = _class.instanceMethodId(
    r'getScaledWidth',
    r'(Landroid/graphics/Canvas;)I',
  );

  static final _getScaledWidth = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int getScaledWidth(android.graphics.Canvas canvas)`
  int getScaledWidth(
    jni$_.JObject? canvas,
  ) {
    final _$canvas = canvas?.reference ?? jni$_.jNullReference;
    return _getScaledWidth(reference.pointer,
            _id_getScaledWidth as jni$_.JMethodIDPtr, _$canvas.pointer)
        .integer;
  }

  static final _id_getScaledHeight = _class.instanceMethodId(
    r'getScaledHeight',
    r'(Landroid/graphics/Canvas;)I',
  );

  static final _getScaledHeight = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int getScaledHeight(android.graphics.Canvas canvas)`
  int getScaledHeight(
    jni$_.JObject? canvas,
  ) {
    final _$canvas = canvas?.reference ?? jni$_.jNullReference;
    return _getScaledHeight(reference.pointer,
            _id_getScaledHeight as jni$_.JMethodIDPtr, _$canvas.pointer)
        .integer;
  }

  static final _id_getScaledWidth$1 = _class.instanceMethodId(
    r'getScaledWidth',
    r'(Landroid/util/DisplayMetrics;)I',
  );

  static final _getScaledWidth$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int getScaledWidth(android.util.DisplayMetrics displayMetrics)`
  int getScaledWidth$1(
    jni$_.JObject? displayMetrics,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    return _getScaledWidth$1(
            reference.pointer,
            _id_getScaledWidth$1 as jni$_.JMethodIDPtr,
            _$displayMetrics.pointer)
        .integer;
  }

  static final _id_getScaledHeight$1 = _class.instanceMethodId(
    r'getScaledHeight',
    r'(Landroid/util/DisplayMetrics;)I',
  );

  static final _getScaledHeight$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int getScaledHeight(android.util.DisplayMetrics displayMetrics)`
  int getScaledHeight$1(
    jni$_.JObject? displayMetrics,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    return _getScaledHeight$1(
            reference.pointer,
            _id_getScaledHeight$1 as jni$_.JMethodIDPtr,
            _$displayMetrics.pointer)
        .integer;
  }

  static final _id_getScaledWidth$2 = _class.instanceMethodId(
    r'getScaledWidth',
    r'(I)I',
  );

  static final _getScaledWidth$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public int getScaledWidth(int i)`
  int getScaledWidth$2(
    int i,
  ) {
    return _getScaledWidth$2(
            reference.pointer, _id_getScaledWidth$2 as jni$_.JMethodIDPtr, i)
        .integer;
  }

  static final _id_getScaledHeight$2 = _class.instanceMethodId(
    r'getScaledHeight',
    r'(I)I',
  );

  static final _getScaledHeight$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public int getScaledHeight(int i)`
  int getScaledHeight$2(
    int i,
  ) {
    return _getScaledHeight$2(
            reference.pointer, _id_getScaledHeight$2 as jni$_.JMethodIDPtr, i)
        .integer;
  }

  static final _id_getRowBytes = _class.instanceMethodId(
    r'getRowBytes',
    r'()I',
  );

  static final _getRowBytes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getRowBytes()`
  int getRowBytes() {
    return _getRowBytes(
            reference.pointer, _id_getRowBytes as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getByteCount = _class.instanceMethodId(
    r'getByteCount',
    r'()I',
  );

  static final _getByteCount = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getByteCount()`
  int getByteCount() {
    return _getByteCount(
            reference.pointer, _id_getByteCount as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getAllocationByteCount = _class.instanceMethodId(
    r'getAllocationByteCount',
    r'()I',
  );

  static final _getAllocationByteCount = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getAllocationByteCount()`
  int getAllocationByteCount() {
    return _getAllocationByteCount(
            reference.pointer, _id_getAllocationByteCount as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getConfig = _class.instanceMethodId(
    r'getConfig',
    r'()Landroid/graphics/Bitmap$Config;',
  );

  static final _getConfig = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public android.graphics.Bitmap$Config getConfig()`
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap$Config? getConfig() {
    return _getConfig(reference.pointer, _id_getConfig as jni$_.JMethodIDPtr)
        .object<Bitmap$Config?>(const $Bitmap$Config$NullableType());
  }

  static final _id_hasAlpha = _class.instanceMethodId(
    r'hasAlpha',
    r'()Z',
  );

  static final _hasAlpha = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean hasAlpha()`
  bool hasAlpha() {
    return _hasAlpha(reference.pointer, _id_hasAlpha as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setHasAlpha = _class.instanceMethodId(
    r'setHasAlpha',
    r'(Z)V',
  );

  static final _setHasAlpha = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setHasAlpha(boolean z)`
  void setHasAlpha(
    bool z,
  ) {
    _setHasAlpha(
            reference.pointer, _id_setHasAlpha as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_hasMipMap = _class.instanceMethodId(
    r'hasMipMap',
    r'()Z',
  );

  static final _hasMipMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean hasMipMap()`
  bool hasMipMap() {
    return _hasMipMap(reference.pointer, _id_hasMipMap as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setHasMipMap = _class.instanceMethodId(
    r'setHasMipMap',
    r'(Z)V',
  );

  static final _setHasMipMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setHasMipMap(boolean z)`
  void setHasMipMap(
    bool z,
  ) {
    _setHasMipMap(reference.pointer, _id_setHasMipMap as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_getColorSpace = _class.instanceMethodId(
    r'getColorSpace',
    r'()Landroid/graphics/ColorSpace;',
  );

  static final _getColorSpace = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public android.graphics.ColorSpace getColorSpace()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getColorSpace() {
    return _getColorSpace(
            reference.pointer, _id_getColorSpace as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setColorSpace = _class.instanceMethodId(
    r'setColorSpace',
    r'(Landroid/graphics/ColorSpace;)V',
  );

  static final _setColorSpace = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setColorSpace(android.graphics.ColorSpace colorSpace)`
  void setColorSpace(
    jni$_.JObject? colorSpace,
  ) {
    final _$colorSpace = colorSpace?.reference ?? jni$_.jNullReference;
    _setColorSpace(reference.pointer, _id_setColorSpace as jni$_.JMethodIDPtr,
            _$colorSpace.pointer)
        .check();
  }

  static final _id_hasGainmap = _class.instanceMethodId(
    r'hasGainmap',
    r'()Z',
  );

  static final _hasGainmap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean hasGainmap()`
  bool hasGainmap() {
    return _hasGainmap(reference.pointer, _id_hasGainmap as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getGainmap = _class.instanceMethodId(
    r'getGainmap',
    r'()Landroid/graphics/Gainmap;',
  );

  static final _getGainmap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public android.graphics.Gainmap getGainmap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getGainmap() {
    return _getGainmap(reference.pointer, _id_getGainmap as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setGainmap = _class.instanceMethodId(
    r'setGainmap',
    r'(Landroid/graphics/Gainmap;)V',
  );

  static final _setGainmap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setGainmap(android.graphics.Gainmap gainmap)`
  void setGainmap(
    jni$_.JObject? gainmap,
  ) {
    final _$gainmap = gainmap?.reference ?? jni$_.jNullReference;
    _setGainmap(reference.pointer, _id_setGainmap as jni$_.JMethodIDPtr,
            _$gainmap.pointer)
        .check();
  }

  static final _id_eraseColor = _class.instanceMethodId(
    r'eraseColor',
    r'(I)V',
  );

  static final _eraseColor = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void eraseColor(int i)`
  void eraseColor(
    int i,
  ) {
    _eraseColor(reference.pointer, _id_eraseColor as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_eraseColor$1 = _class.instanceMethodId(
    r'eraseColor',
    r'(J)V',
  );

  static final _eraseColor$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void eraseColor(long j)`
  void eraseColor$1(
    int j,
  ) {
    _eraseColor$1(reference.pointer, _id_eraseColor$1 as jni$_.JMethodIDPtr, j)
        .check();
  }

  static final _id_getPixel = _class.instanceMethodId(
    r'getPixel',
    r'(II)I',
  );

  static final _getPixel = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int)>();

  /// from: `public int getPixel(int i, int i1)`
  int getPixel(
    int i,
    int i1,
  ) {
    return _getPixel(
            reference.pointer, _id_getPixel as jni$_.JMethodIDPtr, i, i1)
        .integer;
  }

  static final _id_getColor = _class.instanceMethodId(
    r'getColor',
    r'(II)Landroid/graphics/Color;',
  );

  static final _getColor = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int)>();

  /// from: `public android.graphics.Color getColor(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getColor(
    int i,
    int i1,
  ) {
    return _getColor(
            reference.pointer, _id_getColor as jni$_.JMethodIDPtr, i, i1)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getPixels = _class.instanceMethodId(
    r'getPixels',
    r'([IIIIIII)V',
  );

  static final _getPixels = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              int,
              int)>();

  /// from: `public void getPixels(int[] is, int i, int i1, int i2, int i3, int i4, int i5)`
  void getPixels(
    jni$_.JIntArray? is$,
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    _getPixels(reference.pointer, _id_getPixels as jni$_.JMethodIDPtr,
            _$is$.pointer, i, i1, i2, i3, i4, i5)
        .check();
  }

  static final _id_setPixel = _class.instanceMethodId(
    r'setPixel',
    r'(III)V',
  );

  static final _setPixel = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int, int)>();

  /// from: `public void setPixel(int i, int i1, int i2)`
  void setPixel(
    int i,
    int i1,
    int i2,
  ) {
    _setPixel(reference.pointer, _id_setPixel as jni$_.JMethodIDPtr, i, i1, i2)
        .check();
  }

  static final _id_setPixels = _class.instanceMethodId(
    r'setPixels',
    r'([IIIIIII)V',
  );

  static final _setPixels = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              int,
              int)>();

  /// from: `public void setPixels(int[] is, int i, int i1, int i2, int i3, int i4, int i5)`
  void setPixels(
    jni$_.JIntArray? is$,
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    _setPixels(reference.pointer, _id_setPixels as jni$_.JMethodIDPtr,
            _$is$.pointer, i, i1, i2, i3, i4, i5)
        .check();
  }

  static final _id_describeContents = _class.instanceMethodId(
    r'describeContents',
    r'()I',
  );

  static final _describeContents = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int describeContents()`
  int describeContents() {
    return _describeContents(
            reference.pointer, _id_describeContents as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_writeToParcel = _class.instanceMethodId(
    r'writeToParcel',
    r'(Landroid/os/Parcel;I)V',
  );

  static final _writeToParcel = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public void writeToParcel(android.os.Parcel parcel, int i)`
  void writeToParcel(
    jni$_.JObject? parcel,
    int i,
  ) {
    final _$parcel = parcel?.reference ?? jni$_.jNullReference;
    _writeToParcel(reference.pointer, _id_writeToParcel as jni$_.JMethodIDPtr,
            _$parcel.pointer, i)
        .check();
  }

  static final _id_extractAlpha = _class.instanceMethodId(
    r'extractAlpha',
    r'()Landroid/graphics/Bitmap;',
  );

  static final _extractAlpha = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public android.graphics.Bitmap extractAlpha()`
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap? extractAlpha() {
    return _extractAlpha(
            reference.pointer, _id_extractAlpha as jni$_.JMethodIDPtr)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_extractAlpha$1 = _class.instanceMethodId(
    r'extractAlpha',
    r'(Landroid/graphics/Paint;[I)Landroid/graphics/Bitmap;',
  );

  static final _extractAlpha$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public android.graphics.Bitmap extractAlpha(android.graphics.Paint paint, int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap? extractAlpha$1(
    jni$_.JObject? paint,
    jni$_.JIntArray? is$,
  ) {
    final _$paint = paint?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _extractAlpha$1(
            reference.pointer,
            _id_extractAlpha$1 as jni$_.JMethodIDPtr,
            _$paint.pointer,
            _$is$.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_sameAs = _class.instanceMethodId(
    r'sameAs',
    r'(Landroid/graphics/Bitmap;)Z',
  );

  static final _sameAs = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean sameAs(android.graphics.Bitmap bitmap)`
  bool sameAs(
    Bitmap? bitmap,
  ) {
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    return _sameAs(reference.pointer, _id_sameAs as jni$_.JMethodIDPtr,
            _$bitmap.pointer)
        .boolean;
  }

  static final _id_prepareToDraw = _class.instanceMethodId(
    r'prepareToDraw',
    r'()V',
  );

  static final _prepareToDraw = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void prepareToDraw()`
  void prepareToDraw() {
    _prepareToDraw(reference.pointer, _id_prepareToDraw as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_getHardwareBuffer = _class.instanceMethodId(
    r'getHardwareBuffer',
    r'()Landroid/hardware/HardwareBuffer;',
  );

  static final _getHardwareBuffer = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public android.hardware.HardwareBuffer getHardwareBuffer()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getHardwareBuffer() {
    return _getHardwareBuffer(
            reference.pointer, _id_getHardwareBuffer as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $Bitmap$NullableType extends jni$_.JObjType<Bitmap?> {
  @jni$_.internal
  const $Bitmap$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap;';

  @jni$_.internal
  @core$_.override
  Bitmap? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Bitmap.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Bitmap?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$NullableType) &&
        other is $Bitmap$NullableType;
  }
}

final class $Bitmap$Type extends jni$_.JObjType<Bitmap> {
  @jni$_.internal
  const $Bitmap$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap;';

  @jni$_.internal
  @core$_.override
  Bitmap fromReference(jni$_.JReference reference) => Bitmap.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Bitmap?> get nullableType => const $Bitmap$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$Type) && other is $Bitmap$Type;
  }
}

/// from: `android.content.Context$BindServiceFlags`
class Context$BindServiceFlags extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Context$BindServiceFlags> $type;

  @jni$_.internal
  Context$BindServiceFlags.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'android/content/Context$BindServiceFlags');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Context$BindServiceFlags$NullableType();
  static const type = $Context$BindServiceFlags$Type();
  static final _id_of = _class.staticMethodId(
    r'of',
    r'(J)Landroid/content/Context$BindServiceFlags;',
  );

  static final _of = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public android.content.Context$BindServiceFlags of(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static Context$BindServiceFlags? of(
    int j,
  ) {
    return _of(_class.reference.pointer, _id_of as jni$_.JMethodIDPtr, j)
        .object<Context$BindServiceFlags?>(
            const $Context$BindServiceFlags$NullableType());
  }
}

final class $Context$BindServiceFlags$NullableType
    extends jni$_.JObjType<Context$BindServiceFlags?> {
  @jni$_.internal
  const $Context$BindServiceFlags$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/content/Context$BindServiceFlags;';

  @jni$_.internal
  @core$_.override
  Context$BindServiceFlags? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Context$BindServiceFlags.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Context$BindServiceFlags?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Context$BindServiceFlags$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Context$BindServiceFlags$NullableType) &&
        other is $Context$BindServiceFlags$NullableType;
  }
}

final class $Context$BindServiceFlags$Type
    extends jni$_.JObjType<Context$BindServiceFlags> {
  @jni$_.internal
  const $Context$BindServiceFlags$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/content/Context$BindServiceFlags;';

  @jni$_.internal
  @core$_.override
  Context$BindServiceFlags fromReference(jni$_.JReference reference) =>
      Context$BindServiceFlags.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Context$BindServiceFlags?> get nullableType =>
      const $Context$BindServiceFlags$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Context$BindServiceFlags$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Context$BindServiceFlags$Type) &&
        other is $Context$BindServiceFlags$Type;
  }
}

/// from: `android.content.Context`
class Context extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Context> $type;

  @jni$_.internal
  Context.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/content/Context');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Context$NullableType();
  static const type = $Context$Type();
  static final _id_ACCESSIBILITY_SERVICE = _class.staticFieldId(
    r'ACCESSIBILITY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ACCESSIBILITY_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ACCESSIBILITY_SERVICE =>
      _id_ACCESSIBILITY_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_ACCOUNT_SERVICE = _class.staticFieldId(
    r'ACCOUNT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ACCOUNT_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ACCOUNT_SERVICE =>
      _id_ACCOUNT_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_ACTIVITY_SERVICE = _class.staticFieldId(
    r'ACTIVITY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ACTIVITY_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ACTIVITY_SERVICE =>
      _id_ACTIVITY_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_ALARM_SERVICE = _class.staticFieldId(
    r'ALARM_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ALARM_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ALARM_SERVICE =>
      _id_ALARM_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_APPWIDGET_SERVICE = _class.staticFieldId(
    r'APPWIDGET_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String APPWIDGET_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get APPWIDGET_SERVICE =>
      _id_APPWIDGET_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_APP_OPS_SERVICE = _class.staticFieldId(
    r'APP_OPS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String APP_OPS_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get APP_OPS_SERVICE =>
      _id_APP_OPS_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_APP_SEARCH_SERVICE = _class.staticFieldId(
    r'APP_SEARCH_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String APP_SEARCH_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get APP_SEARCH_SERVICE =>
      _id_APP_SEARCH_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_AUDIO_SERVICE = _class.staticFieldId(
    r'AUDIO_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String AUDIO_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get AUDIO_SERVICE =>
      _id_AUDIO_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_BATTERY_SERVICE = _class.staticFieldId(
    r'BATTERY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BATTERY_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BATTERY_SERVICE =>
      _id_BATTERY_SERVICE.get(_class, const jni$_.JStringNullableType());

  /// from: `static public final int BIND_ABOVE_CLIENT`
  static const BIND_ABOVE_CLIENT = 8;

  /// from: `static public final int BIND_ADJUST_WITH_ACTIVITY`
  static const BIND_ADJUST_WITH_ACTIVITY = 128;

  /// from: `static public final int BIND_ALLOW_ACTIVITY_STARTS`
  static const BIND_ALLOW_ACTIVITY_STARTS = 512;

  /// from: `static public final int BIND_ALLOW_OOM_MANAGEMENT`
  static const BIND_ALLOW_OOM_MANAGEMENT = 16;

  /// from: `static public final int BIND_AUTO_CREATE`
  static const BIND_AUTO_CREATE = 1;

  /// from: `static public final int BIND_DEBUG_UNBIND`
  static const BIND_DEBUG_UNBIND = 2;

  /// from: `static public final int BIND_EXTERNAL_SERVICE`
  static const BIND_EXTERNAL_SERVICE = -2147483648;

  /// from: `static public final long BIND_EXTERNAL_SERVICE_LONG`
  static const BIND_EXTERNAL_SERVICE_LONG = 4611686018427387904;

  /// from: `static public final int BIND_IMPORTANT`
  static const BIND_IMPORTANT = 64;

  /// from: `static public final int BIND_INCLUDE_CAPABILITIES`
  static const BIND_INCLUDE_CAPABILITIES = 4096;

  /// from: `static public final int BIND_NOT_FOREGROUND`
  static const BIND_NOT_FOREGROUND = 4;

  /// from: `static public final int BIND_NOT_PERCEPTIBLE`
  static const BIND_NOT_PERCEPTIBLE = 256;

  /// from: `static public final int BIND_PACKAGE_ISOLATED_PROCESS`
  static const BIND_PACKAGE_ISOLATED_PROCESS = 16384;

  /// from: `static public final int BIND_SHARED_ISOLATED_PROCESS`
  static const BIND_SHARED_ISOLATED_PROCESS = 8192;

  /// from: `static public final int BIND_WAIVE_PRIORITY`
  static const BIND_WAIVE_PRIORITY = 32;
  static final _id_BIOMETRIC_SERVICE = _class.staticFieldId(
    r'BIOMETRIC_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BIOMETRIC_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BIOMETRIC_SERVICE =>
      _id_BIOMETRIC_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_BLOB_STORE_SERVICE = _class.staticFieldId(
    r'BLOB_STORE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BLOB_STORE_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BLOB_STORE_SERVICE =>
      _id_BLOB_STORE_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_BLUETOOTH_SERVICE = _class.staticFieldId(
    r'BLUETOOTH_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BLUETOOTH_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BLUETOOTH_SERVICE =>
      _id_BLUETOOTH_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_BUGREPORT_SERVICE = _class.staticFieldId(
    r'BUGREPORT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BUGREPORT_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BUGREPORT_SERVICE =>
      _id_BUGREPORT_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_CAMERA_SERVICE = _class.staticFieldId(
    r'CAMERA_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CAMERA_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CAMERA_SERVICE =>
      _id_CAMERA_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_CAPTIONING_SERVICE = _class.staticFieldId(
    r'CAPTIONING_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CAPTIONING_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CAPTIONING_SERVICE =>
      _id_CAPTIONING_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_CARRIER_CONFIG_SERVICE = _class.staticFieldId(
    r'CARRIER_CONFIG_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CARRIER_CONFIG_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CARRIER_CONFIG_SERVICE =>
      _id_CARRIER_CONFIG_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_CLIPBOARD_SERVICE = _class.staticFieldId(
    r'CLIPBOARD_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CLIPBOARD_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CLIPBOARD_SERVICE =>
      _id_CLIPBOARD_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_COMPANION_DEVICE_SERVICE = _class.staticFieldId(
    r'COMPANION_DEVICE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String COMPANION_DEVICE_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get COMPANION_DEVICE_SERVICE =>
      _id_COMPANION_DEVICE_SERVICE.get(
          _class, const jni$_.JStringNullableType());

  static final _id_CONNECTIVITY_DIAGNOSTICS_SERVICE = _class.staticFieldId(
    r'CONNECTIVITY_DIAGNOSTICS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CONNECTIVITY_DIAGNOSTICS_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CONNECTIVITY_DIAGNOSTICS_SERVICE =>
      _id_CONNECTIVITY_DIAGNOSTICS_SERVICE.get(
          _class, const jni$_.JStringNullableType());

  static final _id_CONNECTIVITY_SERVICE = _class.staticFieldId(
    r'CONNECTIVITY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CONNECTIVITY_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CONNECTIVITY_SERVICE =>
      _id_CONNECTIVITY_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_CONSUMER_IR_SERVICE = _class.staticFieldId(
    r'CONSUMER_IR_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CONSUMER_IR_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CONSUMER_IR_SERVICE =>
      _id_CONSUMER_IR_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_CONTACT_KEYS_SERVICE = _class.staticFieldId(
    r'CONTACT_KEYS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CONTACT_KEYS_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CONTACT_KEYS_SERVICE =>
      _id_CONTACT_KEYS_SERVICE.get(_class, const jni$_.JStringNullableType());

  /// from: `static public final int CONTEXT_IGNORE_SECURITY`
  static const CONTEXT_IGNORE_SECURITY = 2;

  /// from: `static public final int CONTEXT_INCLUDE_CODE`
  static const CONTEXT_INCLUDE_CODE = 1;

  /// from: `static public final int CONTEXT_RESTRICTED`
  static const CONTEXT_RESTRICTED = 4;
  static final _id_CREDENTIAL_SERVICE = _class.staticFieldId(
    r'CREDENTIAL_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CREDENTIAL_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CREDENTIAL_SERVICE =>
      _id_CREDENTIAL_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_CROSS_PROFILE_APPS_SERVICE = _class.staticFieldId(
    r'CROSS_PROFILE_APPS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CROSS_PROFILE_APPS_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CROSS_PROFILE_APPS_SERVICE =>
      _id_CROSS_PROFILE_APPS_SERVICE.get(
          _class, const jni$_.JStringNullableType());

  /// from: `static public final int DEVICE_ID_DEFAULT`
  static const DEVICE_ID_DEFAULT = 0;

  /// from: `static public final int DEVICE_ID_INVALID`
  static const DEVICE_ID_INVALID = -1;
  static final _id_DEVICE_LOCK_SERVICE = _class.staticFieldId(
    r'DEVICE_LOCK_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DEVICE_LOCK_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DEVICE_LOCK_SERVICE =>
      _id_DEVICE_LOCK_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_DEVICE_POLICY_SERVICE = _class.staticFieldId(
    r'DEVICE_POLICY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DEVICE_POLICY_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DEVICE_POLICY_SERVICE =>
      _id_DEVICE_POLICY_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_DISPLAY_HASH_SERVICE = _class.staticFieldId(
    r'DISPLAY_HASH_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DISPLAY_HASH_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DISPLAY_HASH_SERVICE =>
      _id_DISPLAY_HASH_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_DISPLAY_SERVICE = _class.staticFieldId(
    r'DISPLAY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DISPLAY_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DISPLAY_SERVICE =>
      _id_DISPLAY_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_DOMAIN_VERIFICATION_SERVICE = _class.staticFieldId(
    r'DOMAIN_VERIFICATION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DOMAIN_VERIFICATION_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DOMAIN_VERIFICATION_SERVICE =>
      _id_DOMAIN_VERIFICATION_SERVICE.get(
          _class, const jni$_.JStringNullableType());

  static final _id_DOWNLOAD_SERVICE = _class.staticFieldId(
    r'DOWNLOAD_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DOWNLOAD_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DOWNLOAD_SERVICE =>
      _id_DOWNLOAD_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_DROPBOX_SERVICE = _class.staticFieldId(
    r'DROPBOX_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DROPBOX_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DROPBOX_SERVICE =>
      _id_DROPBOX_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_EUICC_SERVICE = _class.staticFieldId(
    r'EUICC_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EUICC_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EUICC_SERVICE =>
      _id_EUICC_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_FILE_INTEGRITY_SERVICE = _class.staticFieldId(
    r'FILE_INTEGRITY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FILE_INTEGRITY_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get FILE_INTEGRITY_SERVICE =>
      _id_FILE_INTEGRITY_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_FINGERPRINT_SERVICE = _class.staticFieldId(
    r'FINGERPRINT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FINGERPRINT_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get FINGERPRINT_SERVICE =>
      _id_FINGERPRINT_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_GAME_SERVICE = _class.staticFieldId(
    r'GAME_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String GAME_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get GAME_SERVICE =>
      _id_GAME_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_GRAMMATICAL_INFLECTION_SERVICE = _class.staticFieldId(
    r'GRAMMATICAL_INFLECTION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String GRAMMATICAL_INFLECTION_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get GRAMMATICAL_INFLECTION_SERVICE =>
      _id_GRAMMATICAL_INFLECTION_SERVICE.get(
          _class, const jni$_.JStringNullableType());

  static final _id_HARDWARE_PROPERTIES_SERVICE = _class.staticFieldId(
    r'HARDWARE_PROPERTIES_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String HARDWARE_PROPERTIES_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get HARDWARE_PROPERTIES_SERVICE =>
      _id_HARDWARE_PROPERTIES_SERVICE.get(
          _class, const jni$_.JStringNullableType());

  static final _id_HEALTHCONNECT_SERVICE = _class.staticFieldId(
    r'HEALTHCONNECT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String HEALTHCONNECT_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get HEALTHCONNECT_SERVICE =>
      _id_HEALTHCONNECT_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_INPUT_METHOD_SERVICE = _class.staticFieldId(
    r'INPUT_METHOD_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String INPUT_METHOD_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get INPUT_METHOD_SERVICE =>
      _id_INPUT_METHOD_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_INPUT_SERVICE = _class.staticFieldId(
    r'INPUT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String INPUT_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get INPUT_SERVICE =>
      _id_INPUT_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_IPSEC_SERVICE = _class.staticFieldId(
    r'IPSEC_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String IPSEC_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get IPSEC_SERVICE =>
      _id_IPSEC_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_JOB_SCHEDULER_SERVICE = _class.staticFieldId(
    r'JOB_SCHEDULER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String JOB_SCHEDULER_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get JOB_SCHEDULER_SERVICE =>
      _id_JOB_SCHEDULER_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_KEYGUARD_SERVICE = _class.staticFieldId(
    r'KEYGUARD_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String KEYGUARD_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get KEYGUARD_SERVICE =>
      _id_KEYGUARD_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_LAUNCHER_APPS_SERVICE = _class.staticFieldId(
    r'LAUNCHER_APPS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LAUNCHER_APPS_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get LAUNCHER_APPS_SERVICE =>
      _id_LAUNCHER_APPS_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_LAYOUT_INFLATER_SERVICE = _class.staticFieldId(
    r'LAYOUT_INFLATER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LAYOUT_INFLATER_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get LAYOUT_INFLATER_SERVICE =>
      _id_LAYOUT_INFLATER_SERVICE.get(
          _class, const jni$_.JStringNullableType());

  static final _id_LOCALE_SERVICE = _class.staticFieldId(
    r'LOCALE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LOCALE_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get LOCALE_SERVICE =>
      _id_LOCALE_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_LOCATION_SERVICE = _class.staticFieldId(
    r'LOCATION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LOCATION_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get LOCATION_SERVICE =>
      _id_LOCATION_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_MEDIA_COMMUNICATION_SERVICE = _class.staticFieldId(
    r'MEDIA_COMMUNICATION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MEDIA_COMMUNICATION_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get MEDIA_COMMUNICATION_SERVICE =>
      _id_MEDIA_COMMUNICATION_SERVICE.get(
          _class, const jni$_.JStringNullableType());

  static final _id_MEDIA_METRICS_SERVICE = _class.staticFieldId(
    r'MEDIA_METRICS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MEDIA_METRICS_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get MEDIA_METRICS_SERVICE =>
      _id_MEDIA_METRICS_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_MEDIA_PROJECTION_SERVICE = _class.staticFieldId(
    r'MEDIA_PROJECTION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MEDIA_PROJECTION_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get MEDIA_PROJECTION_SERVICE =>
      _id_MEDIA_PROJECTION_SERVICE.get(
          _class, const jni$_.JStringNullableType());

  static final _id_MEDIA_ROUTER_SERVICE = _class.staticFieldId(
    r'MEDIA_ROUTER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MEDIA_ROUTER_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get MEDIA_ROUTER_SERVICE =>
      _id_MEDIA_ROUTER_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_MEDIA_SESSION_SERVICE = _class.staticFieldId(
    r'MEDIA_SESSION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MEDIA_SESSION_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get MEDIA_SESSION_SERVICE =>
      _id_MEDIA_SESSION_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_MIDI_SERVICE = _class.staticFieldId(
    r'MIDI_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MIDI_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get MIDI_SERVICE =>
      _id_MIDI_SERVICE.get(_class, const jni$_.JStringNullableType());

  /// from: `static public final int MODE_APPEND`
  static const MODE_APPEND = 32768;

  /// from: `static public final int MODE_ENABLE_WRITE_AHEAD_LOGGING`
  static const MODE_ENABLE_WRITE_AHEAD_LOGGING = 8;

  /// from: `static public final int MODE_MULTI_PROCESS`
  static const MODE_MULTI_PROCESS = 4;

  /// from: `static public final int MODE_NO_LOCALIZED_COLLATORS`
  static const MODE_NO_LOCALIZED_COLLATORS = 16;

  /// from: `static public final int MODE_PRIVATE`
  static const MODE_PRIVATE = 0;

  /// from: `static public final int MODE_WORLD_READABLE`
  static const MODE_WORLD_READABLE = 1;

  /// from: `static public final int MODE_WORLD_WRITEABLE`
  static const MODE_WORLD_WRITEABLE = 2;
  static final _id_NETWORK_STATS_SERVICE = _class.staticFieldId(
    r'NETWORK_STATS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String NETWORK_STATS_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get NETWORK_STATS_SERVICE =>
      _id_NETWORK_STATS_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_NFC_SERVICE = _class.staticFieldId(
    r'NFC_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String NFC_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get NFC_SERVICE =>
      _id_NFC_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_NOTIFICATION_SERVICE = _class.staticFieldId(
    r'NOTIFICATION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String NOTIFICATION_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get NOTIFICATION_SERVICE =>
      _id_NOTIFICATION_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_NSD_SERVICE = _class.staticFieldId(
    r'NSD_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String NSD_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get NSD_SERVICE =>
      _id_NSD_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_OVERLAY_SERVICE = _class.staticFieldId(
    r'OVERLAY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String OVERLAY_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get OVERLAY_SERVICE =>
      _id_OVERLAY_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_PEOPLE_SERVICE = _class.staticFieldId(
    r'PEOPLE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PEOPLE_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get PEOPLE_SERVICE =>
      _id_PEOPLE_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_PERFORMANCE_HINT_SERVICE = _class.staticFieldId(
    r'PERFORMANCE_HINT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PERFORMANCE_HINT_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get PERFORMANCE_HINT_SERVICE =>
      _id_PERFORMANCE_HINT_SERVICE.get(
          _class, const jni$_.JStringNullableType());

  static final _id_PERSISTENT_DATA_BLOCK_SERVICE = _class.staticFieldId(
    r'PERSISTENT_DATA_BLOCK_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PERSISTENT_DATA_BLOCK_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get PERSISTENT_DATA_BLOCK_SERVICE =>
      _id_PERSISTENT_DATA_BLOCK_SERVICE.get(
          _class, const jni$_.JStringNullableType());

  static final _id_POWER_SERVICE = _class.staticFieldId(
    r'POWER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String POWER_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get POWER_SERVICE =>
      _id_POWER_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_PRINT_SERVICE = _class.staticFieldId(
    r'PRINT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PRINT_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get PRINT_SERVICE =>
      _id_PRINT_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_PROFILING_SERVICE = _class.staticFieldId(
    r'PROFILING_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PROFILING_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get PROFILING_SERVICE =>
      _id_PROFILING_SERVICE.get(_class, const jni$_.JStringNullableType());

  /// from: `static public final int RECEIVER_EXPORTED`
  static const RECEIVER_EXPORTED = 2;

  /// from: `static public final int RECEIVER_NOT_EXPORTED`
  static const RECEIVER_NOT_EXPORTED = 4;

  /// from: `static public final int RECEIVER_VISIBLE_TO_INSTANT_APPS`
  static const RECEIVER_VISIBLE_TO_INSTANT_APPS = 1;
  static final _id_RESTRICTIONS_SERVICE = _class.staticFieldId(
    r'RESTRICTIONS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RESTRICTIONS_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get RESTRICTIONS_SERVICE =>
      _id_RESTRICTIONS_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_ROLE_SERVICE = _class.staticFieldId(
    r'ROLE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ROLE_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ROLE_SERVICE =>
      _id_ROLE_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_SEARCH_SERVICE = _class.staticFieldId(
    r'SEARCH_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SEARCH_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SEARCH_SERVICE =>
      _id_SEARCH_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_SECURITY_STATE_SERVICE = _class.staticFieldId(
    r'SECURITY_STATE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SECURITY_STATE_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SECURITY_STATE_SERVICE =>
      _id_SECURITY_STATE_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_SENSOR_SERVICE = _class.staticFieldId(
    r'SENSOR_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SENSOR_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SENSOR_SERVICE =>
      _id_SENSOR_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_SHORTCUT_SERVICE = _class.staticFieldId(
    r'SHORTCUT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SHORTCUT_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SHORTCUT_SERVICE =>
      _id_SHORTCUT_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_STATUS_BAR_SERVICE = _class.staticFieldId(
    r'STATUS_BAR_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String STATUS_BAR_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get STATUS_BAR_SERVICE =>
      _id_STATUS_BAR_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_STORAGE_SERVICE = _class.staticFieldId(
    r'STORAGE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String STORAGE_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get STORAGE_SERVICE =>
      _id_STORAGE_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_STORAGE_STATS_SERVICE = _class.staticFieldId(
    r'STORAGE_STATS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String STORAGE_STATS_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get STORAGE_STATS_SERVICE =>
      _id_STORAGE_STATS_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_SYSTEM_HEALTH_SERVICE = _class.staticFieldId(
    r'SYSTEM_HEALTH_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYSTEM_HEALTH_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SYSTEM_HEALTH_SERVICE =>
      _id_SYSTEM_HEALTH_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_TELECOM_SERVICE = _class.staticFieldId(
    r'TELECOM_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TELECOM_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TELECOM_SERVICE =>
      _id_TELECOM_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_TELEPHONY_IMS_SERVICE = _class.staticFieldId(
    r'TELEPHONY_IMS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TELEPHONY_IMS_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TELEPHONY_IMS_SERVICE =>
      _id_TELEPHONY_IMS_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_TELEPHONY_SERVICE = _class.staticFieldId(
    r'TELEPHONY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TELEPHONY_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TELEPHONY_SERVICE =>
      _id_TELEPHONY_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_TELEPHONY_SUBSCRIPTION_SERVICE = _class.staticFieldId(
    r'TELEPHONY_SUBSCRIPTION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TELEPHONY_SUBSCRIPTION_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TELEPHONY_SUBSCRIPTION_SERVICE =>
      _id_TELEPHONY_SUBSCRIPTION_SERVICE.get(
          _class, const jni$_.JStringNullableType());

  static final _id_TEXT_CLASSIFICATION_SERVICE = _class.staticFieldId(
    r'TEXT_CLASSIFICATION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_CLASSIFICATION_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_CLASSIFICATION_SERVICE =>
      _id_TEXT_CLASSIFICATION_SERVICE.get(
          _class, const jni$_.JStringNullableType());

  static final _id_TEXT_SERVICES_MANAGER_SERVICE = _class.staticFieldId(
    r'TEXT_SERVICES_MANAGER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_SERVICES_MANAGER_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_SERVICES_MANAGER_SERVICE =>
      _id_TEXT_SERVICES_MANAGER_SERVICE.get(
          _class, const jni$_.JStringNullableType());

  static final _id_TV_INPUT_SERVICE = _class.staticFieldId(
    r'TV_INPUT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TV_INPUT_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TV_INPUT_SERVICE =>
      _id_TV_INPUT_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_TV_INTERACTIVE_APP_SERVICE = _class.staticFieldId(
    r'TV_INTERACTIVE_APP_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TV_INTERACTIVE_APP_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TV_INTERACTIVE_APP_SERVICE =>
      _id_TV_INTERACTIVE_APP_SERVICE.get(
          _class, const jni$_.JStringNullableType());

  static final _id_UI_MODE_SERVICE = _class.staticFieldId(
    r'UI_MODE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String UI_MODE_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get UI_MODE_SERVICE =>
      _id_UI_MODE_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_USAGE_STATS_SERVICE = _class.staticFieldId(
    r'USAGE_STATS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String USAGE_STATS_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get USAGE_STATS_SERVICE =>
      _id_USAGE_STATS_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_USB_SERVICE = _class.staticFieldId(
    r'USB_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String USB_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get USB_SERVICE =>
      _id_USB_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_USER_SERVICE = _class.staticFieldId(
    r'USER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String USER_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get USER_SERVICE =>
      _id_USER_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_VIBRATOR_MANAGER_SERVICE = _class.staticFieldId(
    r'VIBRATOR_MANAGER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String VIBRATOR_MANAGER_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get VIBRATOR_MANAGER_SERVICE =>
      _id_VIBRATOR_MANAGER_SERVICE.get(
          _class, const jni$_.JStringNullableType());

  static final _id_VIBRATOR_SERVICE = _class.staticFieldId(
    r'VIBRATOR_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String VIBRATOR_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get VIBRATOR_SERVICE =>
      _id_VIBRATOR_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_VIRTUAL_DEVICE_SERVICE = _class.staticFieldId(
    r'VIRTUAL_DEVICE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String VIRTUAL_DEVICE_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get VIRTUAL_DEVICE_SERVICE =>
      _id_VIRTUAL_DEVICE_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_VPN_MANAGEMENT_SERVICE = _class.staticFieldId(
    r'VPN_MANAGEMENT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String VPN_MANAGEMENT_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get VPN_MANAGEMENT_SERVICE =>
      _id_VPN_MANAGEMENT_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_WALLPAPER_SERVICE = _class.staticFieldId(
    r'WALLPAPER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String WALLPAPER_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get WALLPAPER_SERVICE =>
      _id_WALLPAPER_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_WIFI_AWARE_SERVICE = _class.staticFieldId(
    r'WIFI_AWARE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String WIFI_AWARE_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get WIFI_AWARE_SERVICE =>
      _id_WIFI_AWARE_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_WIFI_P2P_SERVICE = _class.staticFieldId(
    r'WIFI_P2P_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String WIFI_P2P_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get WIFI_P2P_SERVICE =>
      _id_WIFI_P2P_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_WIFI_RTT_RANGING_SERVICE = _class.staticFieldId(
    r'WIFI_RTT_RANGING_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String WIFI_RTT_RANGING_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get WIFI_RTT_RANGING_SERVICE =>
      _id_WIFI_RTT_RANGING_SERVICE.get(
          _class, const jni$_.JStringNullableType());

  static final _id_WIFI_SERVICE = _class.staticFieldId(
    r'WIFI_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String WIFI_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get WIFI_SERVICE =>
      _id_WIFI_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_WINDOW_SERVICE = _class.staticFieldId(
    r'WINDOW_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String WINDOW_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get WINDOW_SERVICE =>
      _id_WINDOW_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_getAssets = _class.instanceMethodId(
    r'getAssets',
    r'()Landroid/content/res/AssetManager;',
  );

  static final _getAssets = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract android.content.res.AssetManager getAssets()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getAssets() {
    return _getAssets(reference.pointer, _id_getAssets as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getResources = _class.instanceMethodId(
    r'getResources',
    r'()Landroid/content/res/Resources;',
  );

  static final _getResources = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract android.content.res.Resources getResources()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getResources() {
    return _getResources(
            reference.pointer, _id_getResources as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getPackageManager = _class.instanceMethodId(
    r'getPackageManager',
    r'()Landroid/content/pm/PackageManager;',
  );

  static final _getPackageManager = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract android.content.pm.PackageManager getPackageManager()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getPackageManager() {
    return _getPackageManager(
            reference.pointer, _id_getPackageManager as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getContentResolver = _class.instanceMethodId(
    r'getContentResolver',
    r'()Landroid/content/ContentResolver;',
  );

  static final _getContentResolver = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract android.content.ContentResolver getContentResolver()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getContentResolver() {
    return _getContentResolver(
            reference.pointer, _id_getContentResolver as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getMainLooper = _class.instanceMethodId(
    r'getMainLooper',
    r'()Landroid/os/Looper;',
  );

  static final _getMainLooper = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract android.os.Looper getMainLooper()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getMainLooper() {
    return _getMainLooper(
            reference.pointer, _id_getMainLooper as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getMainExecutor = _class.instanceMethodId(
    r'getMainExecutor',
    r'()Ljava/util/concurrent/Executor;',
  );

  static final _getMainExecutor = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.concurrent.Executor getMainExecutor()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getMainExecutor() {
    return _getMainExecutor(
            reference.pointer, _id_getMainExecutor as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getApplicationContext = _class.instanceMethodId(
    r'getApplicationContext',
    r'()Landroid/content/Context;',
  );

  static final _getApplicationContext = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract android.content.Context getApplicationContext()`
  /// The returned object must be released after use, by calling the [release] method.
  Context? getApplicationContext() {
    return _getApplicationContext(
            reference.pointer, _id_getApplicationContext as jni$_.JMethodIDPtr)
        .object<Context?>(const $Context$NullableType());
  }

  static final _id_registerComponentCallbacks = _class.instanceMethodId(
    r'registerComponentCallbacks',
    r'(Landroid/content/ComponentCallbacks;)V',
  );

  static final _registerComponentCallbacks =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void registerComponentCallbacks(android.content.ComponentCallbacks componentCallbacks)`
  void registerComponentCallbacks(
    jni$_.JObject? componentCallbacks,
  ) {
    final _$componentCallbacks =
        componentCallbacks?.reference ?? jni$_.jNullReference;
    _registerComponentCallbacks(
            reference.pointer,
            _id_registerComponentCallbacks as jni$_.JMethodIDPtr,
            _$componentCallbacks.pointer)
        .check();
  }

  static final _id_unregisterComponentCallbacks = _class.instanceMethodId(
    r'unregisterComponentCallbacks',
    r'(Landroid/content/ComponentCallbacks;)V',
  );

  static final _unregisterComponentCallbacks =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void unregisterComponentCallbacks(android.content.ComponentCallbacks componentCallbacks)`
  void unregisterComponentCallbacks(
    jni$_.JObject? componentCallbacks,
  ) {
    final _$componentCallbacks =
        componentCallbacks?.reference ?? jni$_.jNullReference;
    _unregisterComponentCallbacks(
            reference.pointer,
            _id_unregisterComponentCallbacks as jni$_.JMethodIDPtr,
            _$componentCallbacks.pointer)
        .check();
  }

  static final _id_getText = _class.instanceMethodId(
    r'getText',
    r'(I)Ljava/lang/CharSequence;',
  );

  static final _getText = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public final java.lang.CharSequence getText(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getText(
    int i,
  ) {
    return _getText(reference.pointer, _id_getText as jni$_.JMethodIDPtr, i)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getString = _class.instanceMethodId(
    r'getString',
    r'(I)Ljava/lang/String;',
  );

  static final _getString = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public final java.lang.String getString(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getString(
    int i,
  ) {
    return _getString(reference.pointer, _id_getString as jni$_.JMethodIDPtr, i)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getString$1 = _class.instanceMethodId(
    r'getString',
    r'(I[Ljava/lang/Object;)Ljava/lang/String;',
  );

  static final _getString$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final java.lang.String getString(int i, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getString$1(
    int i,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _getString$1(reference.pointer,
            _id_getString$1 as jni$_.JMethodIDPtr, i, _$objects.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getColor = _class.instanceMethodId(
    r'getColor',
    r'(I)I',
  );

  static final _getColor = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public final int getColor(int i)`
  int getColor(
    int i,
  ) {
    return _getColor(reference.pointer, _id_getColor as jni$_.JMethodIDPtr, i)
        .integer;
  }

  static final _id_getDrawable = _class.instanceMethodId(
    r'getDrawable',
    r'(I)Landroid/graphics/drawable/Drawable;',
  );

  static final _getDrawable = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public final android.graphics.drawable.Drawable getDrawable(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getDrawable(
    int i,
  ) {
    return _getDrawable(
            reference.pointer, _id_getDrawable as jni$_.JMethodIDPtr, i)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getColorStateList = _class.instanceMethodId(
    r'getColorStateList',
    r'(I)Landroid/content/res/ColorStateList;',
  );

  static final _getColorStateList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public final android.content.res.ColorStateList getColorStateList(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getColorStateList(
    int i,
  ) {
    return _getColorStateList(
            reference.pointer, _id_getColorStateList as jni$_.JMethodIDPtr, i)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setTheme = _class.instanceMethodId(
    r'setTheme',
    r'(I)V',
  );

  static final _setTheme = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract void setTheme(int i)`
  void setTheme(
    int i,
  ) {
    _setTheme(reference.pointer, _id_setTheme as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_getTheme = _class.instanceMethodId(
    r'getTheme',
    r'()Landroid/content/res/Resources$Theme;',
  );

  static final _getTheme = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract android.content.res.Resources$Theme getTheme()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getTheme() {
    return _getTheme(reference.pointer, _id_getTheme as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_obtainStyledAttributes = _class.instanceMethodId(
    r'obtainStyledAttributes',
    r'([I)Landroid/content/res/TypedArray;',
  );

  static final _obtainStyledAttributes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final android.content.res.TypedArray obtainStyledAttributes(int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? obtainStyledAttributes(
    jni$_.JIntArray? is$,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _obtainStyledAttributes(reference.pointer,
            _id_obtainStyledAttributes as jni$_.JMethodIDPtr, _$is$.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_obtainStyledAttributes$1 = _class.instanceMethodId(
    r'obtainStyledAttributes',
    r'(I[I)Landroid/content/res/TypedArray;',
  );

  static final _obtainStyledAttributes$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final android.content.res.TypedArray obtainStyledAttributes(int i, int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? obtainStyledAttributes$1(
    int i,
    jni$_.JIntArray? is$,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _obtainStyledAttributes$1(
            reference.pointer,
            _id_obtainStyledAttributes$1 as jni$_.JMethodIDPtr,
            i,
            _$is$.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_obtainStyledAttributes$2 = _class.instanceMethodId(
    r'obtainStyledAttributes',
    r'(Landroid/util/AttributeSet;[I)Landroid/content/res/TypedArray;',
  );

  static final _obtainStyledAttributes$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final android.content.res.TypedArray obtainStyledAttributes(android.util.AttributeSet attributeSet, int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? obtainStyledAttributes$2(
    jni$_.JObject? attributeSet,
    jni$_.JIntArray? is$,
  ) {
    final _$attributeSet = attributeSet?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _obtainStyledAttributes$2(
            reference.pointer,
            _id_obtainStyledAttributes$2 as jni$_.JMethodIDPtr,
            _$attributeSet.pointer,
            _$is$.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_obtainStyledAttributes$3 = _class.instanceMethodId(
    r'obtainStyledAttributes',
    r'(Landroid/util/AttributeSet;[III)Landroid/content/res/TypedArray;',
  );

  static final _obtainStyledAttributes$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int)>();

  /// from: `public final android.content.res.TypedArray obtainStyledAttributes(android.util.AttributeSet attributeSet, int[] is, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? obtainStyledAttributes$3(
    jni$_.JObject? attributeSet,
    jni$_.JIntArray? is$,
    int i,
    int i1,
  ) {
    final _$attributeSet = attributeSet?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _obtainStyledAttributes$3(
            reference.pointer,
            _id_obtainStyledAttributes$3 as jni$_.JMethodIDPtr,
            _$attributeSet.pointer,
            _$is$.pointer,
            i,
            i1)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getClassLoader = _class.instanceMethodId(
    r'getClassLoader',
    r'()Ljava/lang/ClassLoader;',
  );

  static final _getClassLoader = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.ClassLoader getClassLoader()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getClassLoader() {
    return _getClassLoader(
            reference.pointer, _id_getClassLoader as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getPackageName = _class.instanceMethodId(
    r'getPackageName',
    r'()Ljava/lang/String;',
  );

  static final _getPackageName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.String getPackageName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getPackageName() {
    return _getPackageName(
            reference.pointer, _id_getPackageName as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getOpPackageName = _class.instanceMethodId(
    r'getOpPackageName',
    r'()Ljava/lang/String;',
  );

  static final _getOpPackageName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getOpPackageName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getOpPackageName() {
    return _getOpPackageName(
            reference.pointer, _id_getOpPackageName as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getAttributionTag = _class.instanceMethodId(
    r'getAttributionTag',
    r'()Ljava/lang/String;',
  );

  static final _getAttributionTag = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getAttributionTag()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getAttributionTag() {
    return _getAttributionTag(
            reference.pointer, _id_getAttributionTag as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getAttributionSource = _class.instanceMethodId(
    r'getAttributionSource',
    r'()Landroid/content/AttributionSource;',
  );

  static final _getAttributionSource = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public android.content.AttributionSource getAttributionSource()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getAttributionSource() {
    return _getAttributionSource(
            reference.pointer, _id_getAttributionSource as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getParams = _class.instanceMethodId(
    r'getParams',
    r'()Landroid/content/ContextParams;',
  );

  static final _getParams = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public android.content.ContextParams getParams()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getParams() {
    return _getParams(reference.pointer, _id_getParams as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getApplicationInfo = _class.instanceMethodId(
    r'getApplicationInfo',
    r'()Landroid/content/pm/ApplicationInfo;',
  );

  static final _getApplicationInfo = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract android.content.pm.ApplicationInfo getApplicationInfo()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getApplicationInfo() {
    return _getApplicationInfo(
            reference.pointer, _id_getApplicationInfo as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getPackageResourcePath = _class.instanceMethodId(
    r'getPackageResourcePath',
    r'()Ljava/lang/String;',
  );

  static final _getPackageResourcePath = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.String getPackageResourcePath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getPackageResourcePath() {
    return _getPackageResourcePath(
            reference.pointer, _id_getPackageResourcePath as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getPackageCodePath = _class.instanceMethodId(
    r'getPackageCodePath',
    r'()Ljava/lang/String;',
  );

  static final _getPackageCodePath = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.String getPackageCodePath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getPackageCodePath() {
    return _getPackageCodePath(
            reference.pointer, _id_getPackageCodePath as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getSharedPreferences = _class.instanceMethodId(
    r'getSharedPreferences',
    r'(Ljava/lang/String;I)Landroid/content/SharedPreferences;',
  );

  static final _getSharedPreferences = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public abstract android.content.SharedPreferences getSharedPreferences(java.lang.String string, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getSharedPreferences(
    jni$_.JString? string,
    int i,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getSharedPreferences(reference.pointer,
            _id_getSharedPreferences as jni$_.JMethodIDPtr, _$string.pointer, i)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_moveSharedPreferencesFrom = _class.instanceMethodId(
    r'moveSharedPreferencesFrom',
    r'(Landroid/content/Context;Ljava/lang/String;)Z',
  );

  static final _moveSharedPreferencesFrom = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract boolean moveSharedPreferencesFrom(android.content.Context context, java.lang.String string)`
  bool moveSharedPreferencesFrom(
    Context? context,
    jni$_.JString? string,
  ) {
    final _$context = context?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _moveSharedPreferencesFrom(
            reference.pointer,
            _id_moveSharedPreferencesFrom as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$string.pointer)
        .boolean;
  }

  static final _id_deleteSharedPreferences = _class.instanceMethodId(
    r'deleteSharedPreferences',
    r'(Ljava/lang/String;)Z',
  );

  static final _deleteSharedPreferences = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract boolean deleteSharedPreferences(java.lang.String string)`
  bool deleteSharedPreferences(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _deleteSharedPreferences(reference.pointer,
            _id_deleteSharedPreferences as jni$_.JMethodIDPtr, _$string.pointer)
        .boolean;
  }

  static final _id_openFileInput = _class.instanceMethodId(
    r'openFileInput',
    r'(Ljava/lang/String;)Ljava/io/FileInputStream;',
  );

  static final _openFileInput = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.io.FileInputStream openFileInput(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? openFileInput(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _openFileInput(reference.pointer,
            _id_openFileInput as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_openFileOutput = _class.instanceMethodId(
    r'openFileOutput',
    r'(Ljava/lang/String;I)Ljava/io/FileOutputStream;',
  );

  static final _openFileOutput = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public abstract java.io.FileOutputStream openFileOutput(java.lang.String string, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? openFileOutput(
    jni$_.JString? string,
    int i,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _openFileOutput(reference.pointer,
            _id_openFileOutput as jni$_.JMethodIDPtr, _$string.pointer, i)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_deleteFile = _class.instanceMethodId(
    r'deleteFile',
    r'(Ljava/lang/String;)Z',
  );

  static final _deleteFile = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract boolean deleteFile(java.lang.String string)`
  bool deleteFile(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _deleteFile(reference.pointer, _id_deleteFile as jni$_.JMethodIDPtr,
            _$string.pointer)
        .boolean;
  }

  static final _id_getFileStreamPath = _class.instanceMethodId(
    r'getFileStreamPath',
    r'(Ljava/lang/String;)Ljava/io/File;',
  );

  static final _getFileStreamPath = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.io.File getFileStreamPath(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getFileStreamPath(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getFileStreamPath(reference.pointer,
            _id_getFileStreamPath as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getDataDir = _class.instanceMethodId(
    r'getDataDir',
    r'()Ljava/io/File;',
  );

  static final _getDataDir = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.io.File getDataDir()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getDataDir() {
    return _getDataDir(reference.pointer, _id_getDataDir as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getFilesDir = _class.instanceMethodId(
    r'getFilesDir',
    r'()Ljava/io/File;',
  );

  static final _getFilesDir = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.io.File getFilesDir()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getFilesDir() {
    return _getFilesDir(
            reference.pointer, _id_getFilesDir as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getNoBackupFilesDir = _class.instanceMethodId(
    r'getNoBackupFilesDir',
    r'()Ljava/io/File;',
  );

  static final _getNoBackupFilesDir = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.io.File getNoBackupFilesDir()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getNoBackupFilesDir() {
    return _getNoBackupFilesDir(
            reference.pointer, _id_getNoBackupFilesDir as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getExternalFilesDir = _class.instanceMethodId(
    r'getExternalFilesDir',
    r'(Ljava/lang/String;)Ljava/io/File;',
  );

  static final _getExternalFilesDir = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.io.File getExternalFilesDir(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getExternalFilesDir(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getExternalFilesDir(reference.pointer,
            _id_getExternalFilesDir as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getExternalFilesDirs = _class.instanceMethodId(
    r'getExternalFilesDirs',
    r'(Ljava/lang/String;)[Ljava/io/File;',
  );

  static final _getExternalFilesDirs = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.io.File[] getExternalFilesDirs(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JObject?>? getExternalFilesDirs(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getExternalFilesDirs(reference.pointer,
            _id_getExternalFilesDirs as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JArray<jni$_.JObject?>?>(
            const jni$_.JArrayNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_getObbDir = _class.instanceMethodId(
    r'getObbDir',
    r'()Ljava/io/File;',
  );

  static final _getObbDir = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.io.File getObbDir()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getObbDir() {
    return _getObbDir(reference.pointer, _id_getObbDir as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getObbDirs = _class.instanceMethodId(
    r'getObbDirs',
    r'()[Ljava/io/File;',
  );

  static final _getObbDirs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.io.File[] getObbDirs()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JObject?>? getObbDirs() {
    return _getObbDirs(reference.pointer, _id_getObbDirs as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<jni$_.JObject?>?>(
            const jni$_.JArrayNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_getCacheDir = _class.instanceMethodId(
    r'getCacheDir',
    r'()Ljava/io/File;',
  );

  static final _getCacheDir = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.io.File getCacheDir()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getCacheDir() {
    return _getCacheDir(
            reference.pointer, _id_getCacheDir as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getCodeCacheDir = _class.instanceMethodId(
    r'getCodeCacheDir',
    r'()Ljava/io/File;',
  );

  static final _getCodeCacheDir = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.io.File getCodeCacheDir()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getCodeCacheDir() {
    return _getCodeCacheDir(
            reference.pointer, _id_getCodeCacheDir as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getExternalCacheDir = _class.instanceMethodId(
    r'getExternalCacheDir',
    r'()Ljava/io/File;',
  );

  static final _getExternalCacheDir = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.io.File getExternalCacheDir()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getExternalCacheDir() {
    return _getExternalCacheDir(
            reference.pointer, _id_getExternalCacheDir as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getExternalCacheDirs = _class.instanceMethodId(
    r'getExternalCacheDirs',
    r'()[Ljava/io/File;',
  );

  static final _getExternalCacheDirs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.io.File[] getExternalCacheDirs()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JObject?>? getExternalCacheDirs() {
    return _getExternalCacheDirs(
            reference.pointer, _id_getExternalCacheDirs as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<jni$_.JObject?>?>(
            const jni$_.JArrayNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_getExternalMediaDirs = _class.instanceMethodId(
    r'getExternalMediaDirs',
    r'()[Ljava/io/File;',
  );

  static final _getExternalMediaDirs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.io.File[] getExternalMediaDirs()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JObject?>? getExternalMediaDirs() {
    return _getExternalMediaDirs(
            reference.pointer, _id_getExternalMediaDirs as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<jni$_.JObject?>?>(
            const jni$_.JArrayNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_fileList = _class.instanceMethodId(
    r'fileList',
    r'()[Ljava/lang/String;',
  );

  static final _fileList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.String[] fileList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?>? fileList() {
    return _fileList(reference.pointer, _id_fileList as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<jni$_.JString?>?>(
            const jni$_.JArrayNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_getDir = _class.instanceMethodId(
    r'getDir',
    r'(Ljava/lang/String;I)Ljava/io/File;',
  );

  static final _getDir = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public abstract java.io.File getDir(java.lang.String string, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getDir(
    jni$_.JString? string,
    int i,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getDir(reference.pointer, _id_getDir as jni$_.JMethodIDPtr,
            _$string.pointer, i)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_openOrCreateDatabase = _class.instanceMethodId(
    r'openOrCreateDatabase',
    r'(Ljava/lang/String;ILandroid/database/sqlite/SQLiteDatabase$CursorFactory;)Landroid/database/sqlite/SQLiteDatabase;',
  );

  static final _openOrCreateDatabase = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract android.database.sqlite.SQLiteDatabase openOrCreateDatabase(java.lang.String string, int i, android.database.sqlite.SQLiteDatabase$CursorFactory cursorFactory)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? openOrCreateDatabase(
    jni$_.JString? string,
    int i,
    jni$_.JObject? cursorFactory,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$cursorFactory = cursorFactory?.reference ?? jni$_.jNullReference;
    return _openOrCreateDatabase(
            reference.pointer,
            _id_openOrCreateDatabase as jni$_.JMethodIDPtr,
            _$string.pointer,
            i,
            _$cursorFactory.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_openOrCreateDatabase$1 = _class.instanceMethodId(
    r'openOrCreateDatabase',
    r'(Ljava/lang/String;ILandroid/database/sqlite/SQLiteDatabase$CursorFactory;Landroid/database/DatabaseErrorHandler;)Landroid/database/sqlite/SQLiteDatabase;',
  );

  static final _openOrCreateDatabase$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract android.database.sqlite.SQLiteDatabase openOrCreateDatabase(java.lang.String string, int i, android.database.sqlite.SQLiteDatabase$CursorFactory cursorFactory, android.database.DatabaseErrorHandler databaseErrorHandler)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? openOrCreateDatabase$1(
    jni$_.JString? string,
    int i,
    jni$_.JObject? cursorFactory,
    jni$_.JObject? databaseErrorHandler,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$cursorFactory = cursorFactory?.reference ?? jni$_.jNullReference;
    final _$databaseErrorHandler =
        databaseErrorHandler?.reference ?? jni$_.jNullReference;
    return _openOrCreateDatabase$1(
            reference.pointer,
            _id_openOrCreateDatabase$1 as jni$_.JMethodIDPtr,
            _$string.pointer,
            i,
            _$cursorFactory.pointer,
            _$databaseErrorHandler.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_moveDatabaseFrom = _class.instanceMethodId(
    r'moveDatabaseFrom',
    r'(Landroid/content/Context;Ljava/lang/String;)Z',
  );

  static final _moveDatabaseFrom = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract boolean moveDatabaseFrom(android.content.Context context, java.lang.String string)`
  bool moveDatabaseFrom(
    Context? context,
    jni$_.JString? string,
  ) {
    final _$context = context?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _moveDatabaseFrom(
            reference.pointer,
            _id_moveDatabaseFrom as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$string.pointer)
        .boolean;
  }

  static final _id_deleteDatabase = _class.instanceMethodId(
    r'deleteDatabase',
    r'(Ljava/lang/String;)Z',
  );

  static final _deleteDatabase = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract boolean deleteDatabase(java.lang.String string)`
  bool deleteDatabase(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _deleteDatabase(reference.pointer,
            _id_deleteDatabase as jni$_.JMethodIDPtr, _$string.pointer)
        .boolean;
  }

  static final _id_getDatabasePath = _class.instanceMethodId(
    r'getDatabasePath',
    r'(Ljava/lang/String;)Ljava/io/File;',
  );

  static final _getDatabasePath = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.io.File getDatabasePath(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getDatabasePath(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getDatabasePath(reference.pointer,
            _id_getDatabasePath as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_databaseList = _class.instanceMethodId(
    r'databaseList',
    r'()[Ljava/lang/String;',
  );

  static final _databaseList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.String[] databaseList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?>? databaseList() {
    return _databaseList(
            reference.pointer, _id_databaseList as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<jni$_.JString?>?>(
            const jni$_.JArrayNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_getWallpaper = _class.instanceMethodId(
    r'getWallpaper',
    r'()Landroid/graphics/drawable/Drawable;',
  );

  static final _getWallpaper = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract android.graphics.drawable.Drawable getWallpaper()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getWallpaper() {
    return _getWallpaper(
            reference.pointer, _id_getWallpaper as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_peekWallpaper = _class.instanceMethodId(
    r'peekWallpaper',
    r'()Landroid/graphics/drawable/Drawable;',
  );

  static final _peekWallpaper = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract android.graphics.drawable.Drawable peekWallpaper()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? peekWallpaper() {
    return _peekWallpaper(
            reference.pointer, _id_peekWallpaper as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getWallpaperDesiredMinimumWidth = _class.instanceMethodId(
    r'getWallpaperDesiredMinimumWidth',
    r'()I',
  );

  static final _getWallpaperDesiredMinimumWidth =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallIntMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public abstract int getWallpaperDesiredMinimumWidth()`
  int getWallpaperDesiredMinimumWidth() {
    return _getWallpaperDesiredMinimumWidth(reference.pointer,
            _id_getWallpaperDesiredMinimumWidth as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getWallpaperDesiredMinimumHeight = _class.instanceMethodId(
    r'getWallpaperDesiredMinimumHeight',
    r'()I',
  );

  static final _getWallpaperDesiredMinimumHeight =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallIntMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public abstract int getWallpaperDesiredMinimumHeight()`
  int getWallpaperDesiredMinimumHeight() {
    return _getWallpaperDesiredMinimumHeight(reference.pointer,
            _id_getWallpaperDesiredMinimumHeight as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_setWallpaper = _class.instanceMethodId(
    r'setWallpaper',
    r'(Landroid/graphics/Bitmap;)V',
  );

  static final _setWallpaper = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void setWallpaper(android.graphics.Bitmap bitmap)`
  void setWallpaper(
    Bitmap? bitmap,
  ) {
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    _setWallpaper(reference.pointer, _id_setWallpaper as jni$_.JMethodIDPtr,
            _$bitmap.pointer)
        .check();
  }

  static final _id_setWallpaper$1 = _class.instanceMethodId(
    r'setWallpaper',
    r'(Ljava/io/InputStream;)V',
  );

  static final _setWallpaper$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void setWallpaper(java.io.InputStream inputStream)`
  void setWallpaper$1(
    jni$_.JObject? inputStream,
  ) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    _setWallpaper$1(reference.pointer, _id_setWallpaper$1 as jni$_.JMethodIDPtr,
            _$inputStream.pointer)
        .check();
  }

  static final _id_clearWallpaper = _class.instanceMethodId(
    r'clearWallpaper',
    r'()V',
  );

  static final _clearWallpaper = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void clearWallpaper()`
  void clearWallpaper() {
    _clearWallpaper(reference.pointer, _id_clearWallpaper as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_startActivity = _class.instanceMethodId(
    r'startActivity',
    r'(Landroid/content/Intent;)V',
  );

  static final _startActivity = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void startActivity(android.content.Intent intent)`
  void startActivity(
    jni$_.JObject? intent,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    _startActivity(reference.pointer, _id_startActivity as jni$_.JMethodIDPtr,
            _$intent.pointer)
        .check();
  }

  static final _id_startActivity$1 = _class.instanceMethodId(
    r'startActivity',
    r'(Landroid/content/Intent;Landroid/os/Bundle;)V',
  );

  static final _startActivity$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void startActivity(android.content.Intent intent, android.os.Bundle bundle)`
  void startActivity$1(
    jni$_.JObject? intent,
    jni$_.JObject? bundle,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _startActivity$1(
            reference.pointer,
            _id_startActivity$1 as jni$_.JMethodIDPtr,
            _$intent.pointer,
            _$bundle.pointer)
        .check();
  }

  static final _id_startActivities = _class.instanceMethodId(
    r'startActivities',
    r'([Landroid/content/Intent;)V',
  );

  static final _startActivities = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void startActivities(android.content.Intent[] intents)`
  void startActivities(
    jni$_.JArray<jni$_.JObject?>? intents,
  ) {
    final _$intents = intents?.reference ?? jni$_.jNullReference;
    _startActivities(reference.pointer,
            _id_startActivities as jni$_.JMethodIDPtr, _$intents.pointer)
        .check();
  }

  static final _id_startActivities$1 = _class.instanceMethodId(
    r'startActivities',
    r'([Landroid/content/Intent;Landroid/os/Bundle;)V',
  );

  static final _startActivities$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void startActivities(android.content.Intent[] intents, android.os.Bundle bundle)`
  void startActivities$1(
    jni$_.JArray<jni$_.JObject?>? intents,
    jni$_.JObject? bundle,
  ) {
    final _$intents = intents?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _startActivities$1(
            reference.pointer,
            _id_startActivities$1 as jni$_.JMethodIDPtr,
            _$intents.pointer,
            _$bundle.pointer)
        .check();
  }

  static final _id_startIntentSender = _class.instanceMethodId(
    r'startIntentSender',
    r'(Landroid/content/IntentSender;Landroid/content/Intent;III)V',
  );

  static final _startIntentSender = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int)>();

  /// from: `public abstract void startIntentSender(android.content.IntentSender intentSender, android.content.Intent intent, int i, int i1, int i2)`
  void startIntentSender(
    jni$_.JObject? intentSender,
    jni$_.JObject? intent,
    int i,
    int i1,
    int i2,
  ) {
    final _$intentSender = intentSender?.reference ?? jni$_.jNullReference;
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    _startIntentSender(
            reference.pointer,
            _id_startIntentSender as jni$_.JMethodIDPtr,
            _$intentSender.pointer,
            _$intent.pointer,
            i,
            i1,
            i2)
        .check();
  }

  static final _id_startIntentSender$1 = _class.instanceMethodId(
    r'startIntentSender',
    r'(Landroid/content/IntentSender;Landroid/content/Intent;IIILandroid/os/Bundle;)V',
  );

  static final _startIntentSender$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void startIntentSender(android.content.IntentSender intentSender, android.content.Intent intent, int i, int i1, int i2, android.os.Bundle bundle)`
  void startIntentSender$1(
    jni$_.JObject? intentSender,
    jni$_.JObject? intent,
    int i,
    int i1,
    int i2,
    jni$_.JObject? bundle,
  ) {
    final _$intentSender = intentSender?.reference ?? jni$_.jNullReference;
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _startIntentSender$1(
            reference.pointer,
            _id_startIntentSender$1 as jni$_.JMethodIDPtr,
            _$intentSender.pointer,
            _$intent.pointer,
            i,
            i1,
            i2,
            _$bundle.pointer)
        .check();
  }

  static final _id_sendBroadcast = _class.instanceMethodId(
    r'sendBroadcast',
    r'(Landroid/content/Intent;)V',
  );

  static final _sendBroadcast = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void sendBroadcast(android.content.Intent intent)`
  void sendBroadcast(
    jni$_.JObject? intent,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    _sendBroadcast(reference.pointer, _id_sendBroadcast as jni$_.JMethodIDPtr,
            _$intent.pointer)
        .check();
  }

  static final _id_sendBroadcast$1 = _class.instanceMethodId(
    r'sendBroadcast',
    r'(Landroid/content/Intent;Ljava/lang/String;)V',
  );

  static final _sendBroadcast$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void sendBroadcast(android.content.Intent intent, java.lang.String string)`
  void sendBroadcast$1(
    jni$_.JObject? intent,
    jni$_.JString? string,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    _sendBroadcast$1(
            reference.pointer,
            _id_sendBroadcast$1 as jni$_.JMethodIDPtr,
            _$intent.pointer,
            _$string.pointer)
        .check();
  }

  static final _id_sendBroadcastWithMultiplePermissions =
      _class.instanceMethodId(
    r'sendBroadcastWithMultiplePermissions',
    r'(Landroid/content/Intent;[Ljava/lang/String;)V',
  );

  static final _sendBroadcastWithMultiplePermissions =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void sendBroadcastWithMultiplePermissions(android.content.Intent intent, java.lang.String[] strings)`
  void sendBroadcastWithMultiplePermissions(
    jni$_.JObject? intent,
    jni$_.JArray<jni$_.JString?>? strings,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$strings = strings?.reference ?? jni$_.jNullReference;
    _sendBroadcastWithMultiplePermissions(
            reference.pointer,
            _id_sendBroadcastWithMultiplePermissions as jni$_.JMethodIDPtr,
            _$intent.pointer,
            _$strings.pointer)
        .check();
  }

  static final _id_sendBroadcast$2 = _class.instanceMethodId(
    r'sendBroadcast',
    r'(Landroid/content/Intent;Ljava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _sendBroadcast$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void sendBroadcast(android.content.Intent intent, java.lang.String string, android.os.Bundle bundle)`
  void sendBroadcast$2(
    jni$_.JObject? intent,
    jni$_.JString? string,
    jni$_.JObject? bundle,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _sendBroadcast$2(
            reference.pointer,
            _id_sendBroadcast$2 as jni$_.JMethodIDPtr,
            _$intent.pointer,
            _$string.pointer,
            _$bundle.pointer)
        .check();
  }

  static final _id_sendOrderedBroadcast = _class.instanceMethodId(
    r'sendOrderedBroadcast',
    r'(Landroid/content/Intent;Ljava/lang/String;)V',
  );

  static final _sendOrderedBroadcast = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void sendOrderedBroadcast(android.content.Intent intent, java.lang.String string)`
  void sendOrderedBroadcast(
    jni$_.JObject? intent,
    jni$_.JString? string,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    _sendOrderedBroadcast(
            reference.pointer,
            _id_sendOrderedBroadcast as jni$_.JMethodIDPtr,
            _$intent.pointer,
            _$string.pointer)
        .check();
  }

  static final _id_sendOrderedBroadcast$1 = _class.instanceMethodId(
    r'sendOrderedBroadcast',
    r'(Landroid/content/Intent;Ljava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _sendOrderedBroadcast$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void sendOrderedBroadcast(android.content.Intent intent, java.lang.String string, android.os.Bundle bundle)`
  void sendOrderedBroadcast$1(
    jni$_.JObject? intent,
    jni$_.JString? string,
    jni$_.JObject? bundle,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _sendOrderedBroadcast$1(
            reference.pointer,
            _id_sendOrderedBroadcast$1 as jni$_.JMethodIDPtr,
            _$intent.pointer,
            _$string.pointer,
            _$bundle.pointer)
        .check();
  }

  static final _id_sendOrderedBroadcast$2 = _class.instanceMethodId(
    r'sendOrderedBroadcast',
    r'(Landroid/content/Intent;Ljava/lang/String;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _sendOrderedBroadcast$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void sendOrderedBroadcast(android.content.Intent intent, java.lang.String string, android.content.BroadcastReceiver broadcastReceiver, android.os.Handler handler, int i, java.lang.String string1, android.os.Bundle bundle)`
  void sendOrderedBroadcast$2(
    jni$_.JObject? intent,
    jni$_.JString? string,
    jni$_.JObject? broadcastReceiver,
    jni$_.JObject? handler,
    int i,
    jni$_.JString? string1,
    jni$_.JObject? bundle,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$broadcastReceiver =
        broadcastReceiver?.reference ?? jni$_.jNullReference;
    final _$handler = handler?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _sendOrderedBroadcast$2(
            reference.pointer,
            _id_sendOrderedBroadcast$2 as jni$_.JMethodIDPtr,
            _$intent.pointer,
            _$string.pointer,
            _$broadcastReceiver.pointer,
            _$handler.pointer,
            i,
            _$string1.pointer,
            _$bundle.pointer)
        .check();
  }

  static final _id_sendOrderedBroadcast$3 = _class.instanceMethodId(
    r'sendOrderedBroadcast',
    r'(Landroid/content/Intent;Ljava/lang/String;Landroid/os/Bundle;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _sendOrderedBroadcast$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void sendOrderedBroadcast(android.content.Intent intent, java.lang.String string, android.os.Bundle bundle, android.content.BroadcastReceiver broadcastReceiver, android.os.Handler handler, int i, java.lang.String string1, android.os.Bundle bundle1)`
  void sendOrderedBroadcast$3(
    jni$_.JObject? intent,
    jni$_.JString? string,
    jni$_.JObject? bundle,
    jni$_.JObject? broadcastReceiver,
    jni$_.JObject? handler,
    int i,
    jni$_.JString? string1,
    jni$_.JObject? bundle1,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    final _$broadcastReceiver =
        broadcastReceiver?.reference ?? jni$_.jNullReference;
    final _$handler = handler?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$bundle1 = bundle1?.reference ?? jni$_.jNullReference;
    _sendOrderedBroadcast$3(
            reference.pointer,
            _id_sendOrderedBroadcast$3 as jni$_.JMethodIDPtr,
            _$intent.pointer,
            _$string.pointer,
            _$bundle.pointer,
            _$broadcastReceiver.pointer,
            _$handler.pointer,
            i,
            _$string1.pointer,
            _$bundle1.pointer)
        .check();
  }

  static final _id_sendBroadcastAsUser = _class.instanceMethodId(
    r'sendBroadcastAsUser',
    r'(Landroid/content/Intent;Landroid/os/UserHandle;)V',
  );

  static final _sendBroadcastAsUser = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void sendBroadcastAsUser(android.content.Intent intent, android.os.UserHandle userHandle)`
  void sendBroadcastAsUser(
    jni$_.JObject? intent,
    jni$_.JObject? userHandle,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$userHandle = userHandle?.reference ?? jni$_.jNullReference;
    _sendBroadcastAsUser(
            reference.pointer,
            _id_sendBroadcastAsUser as jni$_.JMethodIDPtr,
            _$intent.pointer,
            _$userHandle.pointer)
        .check();
  }

  static final _id_sendBroadcastAsUser$1 = _class.instanceMethodId(
    r'sendBroadcastAsUser',
    r'(Landroid/content/Intent;Landroid/os/UserHandle;Ljava/lang/String;)V',
  );

  static final _sendBroadcastAsUser$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void sendBroadcastAsUser(android.content.Intent intent, android.os.UserHandle userHandle, java.lang.String string)`
  void sendBroadcastAsUser$1(
    jni$_.JObject? intent,
    jni$_.JObject? userHandle,
    jni$_.JString? string,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$userHandle = userHandle?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    _sendBroadcastAsUser$1(
            reference.pointer,
            _id_sendBroadcastAsUser$1 as jni$_.JMethodIDPtr,
            _$intent.pointer,
            _$userHandle.pointer,
            _$string.pointer)
        .check();
  }

  static final _id_sendOrderedBroadcastAsUser = _class.instanceMethodId(
    r'sendOrderedBroadcastAsUser',
    r'(Landroid/content/Intent;Landroid/os/UserHandle;Ljava/lang/String;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _sendOrderedBroadcastAsUser =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  int,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void sendOrderedBroadcastAsUser(android.content.Intent intent, android.os.UserHandle userHandle, java.lang.String string, android.content.BroadcastReceiver broadcastReceiver, android.os.Handler handler, int i, java.lang.String string1, android.os.Bundle bundle)`
  void sendOrderedBroadcastAsUser(
    jni$_.JObject? intent,
    jni$_.JObject? userHandle,
    jni$_.JString? string,
    jni$_.JObject? broadcastReceiver,
    jni$_.JObject? handler,
    int i,
    jni$_.JString? string1,
    jni$_.JObject? bundle,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$userHandle = userHandle?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$broadcastReceiver =
        broadcastReceiver?.reference ?? jni$_.jNullReference;
    final _$handler = handler?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _sendOrderedBroadcastAsUser(
            reference.pointer,
            _id_sendOrderedBroadcastAsUser as jni$_.JMethodIDPtr,
            _$intent.pointer,
            _$userHandle.pointer,
            _$string.pointer,
            _$broadcastReceiver.pointer,
            _$handler.pointer,
            i,
            _$string1.pointer,
            _$bundle.pointer)
        .check();
  }

  static final _id_sendOrderedBroadcast$4 = _class.instanceMethodId(
    r'sendOrderedBroadcast',
    r'(Landroid/content/Intent;Ljava/lang/String;Ljava/lang/String;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _sendOrderedBroadcast$4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void sendOrderedBroadcast(android.content.Intent intent, java.lang.String string, java.lang.String string1, android.content.BroadcastReceiver broadcastReceiver, android.os.Handler handler, int i, java.lang.String string2, android.os.Bundle bundle)`
  void sendOrderedBroadcast$4(
    jni$_.JObject? intent,
    jni$_.JString? string,
    jni$_.JString? string1,
    jni$_.JObject? broadcastReceiver,
    jni$_.JObject? handler,
    int i,
    jni$_.JString? string2,
    jni$_.JObject? bundle,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$broadcastReceiver =
        broadcastReceiver?.reference ?? jni$_.jNullReference;
    final _$handler = handler?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _sendOrderedBroadcast$4(
            reference.pointer,
            _id_sendOrderedBroadcast$4 as jni$_.JMethodIDPtr,
            _$intent.pointer,
            _$string.pointer,
            _$string1.pointer,
            _$broadcastReceiver.pointer,
            _$handler.pointer,
            i,
            _$string2.pointer,
            _$bundle.pointer)
        .check();
  }

  static final _id_sendStickyBroadcast = _class.instanceMethodId(
    r'sendStickyBroadcast',
    r'(Landroid/content/Intent;)V',
  );

  static final _sendStickyBroadcast = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void sendStickyBroadcast(android.content.Intent intent)`
  void sendStickyBroadcast(
    jni$_.JObject? intent,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    _sendStickyBroadcast(reference.pointer,
            _id_sendStickyBroadcast as jni$_.JMethodIDPtr, _$intent.pointer)
        .check();
  }

  static final _id_sendStickyBroadcast$1 = _class.instanceMethodId(
    r'sendStickyBroadcast',
    r'(Landroid/content/Intent;Landroid/os/Bundle;)V',
  );

  static final _sendStickyBroadcast$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void sendStickyBroadcast(android.content.Intent intent, android.os.Bundle bundle)`
  void sendStickyBroadcast$1(
    jni$_.JObject? intent,
    jni$_.JObject? bundle,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _sendStickyBroadcast$1(
            reference.pointer,
            _id_sendStickyBroadcast$1 as jni$_.JMethodIDPtr,
            _$intent.pointer,
            _$bundle.pointer)
        .check();
  }

  static final _id_sendStickyOrderedBroadcast = _class.instanceMethodId(
    r'sendStickyOrderedBroadcast',
    r'(Landroid/content/Intent;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _sendStickyOrderedBroadcast =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  int,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void sendStickyOrderedBroadcast(android.content.Intent intent, android.content.BroadcastReceiver broadcastReceiver, android.os.Handler handler, int i, java.lang.String string, android.os.Bundle bundle)`
  void sendStickyOrderedBroadcast(
    jni$_.JObject? intent,
    jni$_.JObject? broadcastReceiver,
    jni$_.JObject? handler,
    int i,
    jni$_.JString? string,
    jni$_.JObject? bundle,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$broadcastReceiver =
        broadcastReceiver?.reference ?? jni$_.jNullReference;
    final _$handler = handler?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _sendStickyOrderedBroadcast(
            reference.pointer,
            _id_sendStickyOrderedBroadcast as jni$_.JMethodIDPtr,
            _$intent.pointer,
            _$broadcastReceiver.pointer,
            _$handler.pointer,
            i,
            _$string.pointer,
            _$bundle.pointer)
        .check();
  }

  static final _id_removeStickyBroadcast = _class.instanceMethodId(
    r'removeStickyBroadcast',
    r'(Landroid/content/Intent;)V',
  );

  static final _removeStickyBroadcast = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void removeStickyBroadcast(android.content.Intent intent)`
  void removeStickyBroadcast(
    jni$_.JObject? intent,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    _removeStickyBroadcast(reference.pointer,
            _id_removeStickyBroadcast as jni$_.JMethodIDPtr, _$intent.pointer)
        .check();
  }

  static final _id_sendStickyBroadcastAsUser = _class.instanceMethodId(
    r'sendStickyBroadcastAsUser',
    r'(Landroid/content/Intent;Landroid/os/UserHandle;)V',
  );

  static final _sendStickyBroadcastAsUser = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void sendStickyBroadcastAsUser(android.content.Intent intent, android.os.UserHandle userHandle)`
  void sendStickyBroadcastAsUser(
    jni$_.JObject? intent,
    jni$_.JObject? userHandle,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$userHandle = userHandle?.reference ?? jni$_.jNullReference;
    _sendStickyBroadcastAsUser(
            reference.pointer,
            _id_sendStickyBroadcastAsUser as jni$_.JMethodIDPtr,
            _$intent.pointer,
            _$userHandle.pointer)
        .check();
  }

  static final _id_sendStickyOrderedBroadcastAsUser = _class.instanceMethodId(
    r'sendStickyOrderedBroadcastAsUser',
    r'(Landroid/content/Intent;Landroid/os/UserHandle;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _sendStickyOrderedBroadcastAsUser =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  int,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void sendStickyOrderedBroadcastAsUser(android.content.Intent intent, android.os.UserHandle userHandle, android.content.BroadcastReceiver broadcastReceiver, android.os.Handler handler, int i, java.lang.String string, android.os.Bundle bundle)`
  void sendStickyOrderedBroadcastAsUser(
    jni$_.JObject? intent,
    jni$_.JObject? userHandle,
    jni$_.JObject? broadcastReceiver,
    jni$_.JObject? handler,
    int i,
    jni$_.JString? string,
    jni$_.JObject? bundle,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$userHandle = userHandle?.reference ?? jni$_.jNullReference;
    final _$broadcastReceiver =
        broadcastReceiver?.reference ?? jni$_.jNullReference;
    final _$handler = handler?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _sendStickyOrderedBroadcastAsUser(
            reference.pointer,
            _id_sendStickyOrderedBroadcastAsUser as jni$_.JMethodIDPtr,
            _$intent.pointer,
            _$userHandle.pointer,
            _$broadcastReceiver.pointer,
            _$handler.pointer,
            i,
            _$string.pointer,
            _$bundle.pointer)
        .check();
  }

  static final _id_removeStickyBroadcastAsUser = _class.instanceMethodId(
    r'removeStickyBroadcastAsUser',
    r'(Landroid/content/Intent;Landroid/os/UserHandle;)V',
  );

  static final _removeStickyBroadcastAsUser =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void removeStickyBroadcastAsUser(android.content.Intent intent, android.os.UserHandle userHandle)`
  void removeStickyBroadcastAsUser(
    jni$_.JObject? intent,
    jni$_.JObject? userHandle,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$userHandle = userHandle?.reference ?? jni$_.jNullReference;
    _removeStickyBroadcastAsUser(
            reference.pointer,
            _id_removeStickyBroadcastAsUser as jni$_.JMethodIDPtr,
            _$intent.pointer,
            _$userHandle.pointer)
        .check();
  }

  static final _id_registerReceiver = _class.instanceMethodId(
    r'registerReceiver',
    r'(Landroid/content/BroadcastReceiver;Landroid/content/IntentFilter;)Landroid/content/Intent;',
  );

  static final _registerReceiver = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract android.content.Intent registerReceiver(android.content.BroadcastReceiver broadcastReceiver, android.content.IntentFilter intentFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? registerReceiver(
    jni$_.JObject? broadcastReceiver,
    jni$_.JObject? intentFilter,
  ) {
    final _$broadcastReceiver =
        broadcastReceiver?.reference ?? jni$_.jNullReference;
    final _$intentFilter = intentFilter?.reference ?? jni$_.jNullReference;
    return _registerReceiver(
            reference.pointer,
            _id_registerReceiver as jni$_.JMethodIDPtr,
            _$broadcastReceiver.pointer,
            _$intentFilter.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_registerReceiver$1 = _class.instanceMethodId(
    r'registerReceiver',
    r'(Landroid/content/BroadcastReceiver;Landroid/content/IntentFilter;I)Landroid/content/Intent;',
  );

  static final _registerReceiver$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `public abstract android.content.Intent registerReceiver(android.content.BroadcastReceiver broadcastReceiver, android.content.IntentFilter intentFilter, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? registerReceiver$1(
    jni$_.JObject? broadcastReceiver,
    jni$_.JObject? intentFilter,
    int i,
  ) {
    final _$broadcastReceiver =
        broadcastReceiver?.reference ?? jni$_.jNullReference;
    final _$intentFilter = intentFilter?.reference ?? jni$_.jNullReference;
    return _registerReceiver$1(
            reference.pointer,
            _id_registerReceiver$1 as jni$_.JMethodIDPtr,
            _$broadcastReceiver.pointer,
            _$intentFilter.pointer,
            i)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_registerReceiver$2 = _class.instanceMethodId(
    r'registerReceiver',
    r'(Landroid/content/BroadcastReceiver;Landroid/content/IntentFilter;Ljava/lang/String;Landroid/os/Handler;)Landroid/content/Intent;',
  );

  static final _registerReceiver$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract android.content.Intent registerReceiver(android.content.BroadcastReceiver broadcastReceiver, android.content.IntentFilter intentFilter, java.lang.String string, android.os.Handler handler)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? registerReceiver$2(
    jni$_.JObject? broadcastReceiver,
    jni$_.JObject? intentFilter,
    jni$_.JString? string,
    jni$_.JObject? handler,
  ) {
    final _$broadcastReceiver =
        broadcastReceiver?.reference ?? jni$_.jNullReference;
    final _$intentFilter = intentFilter?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$handler = handler?.reference ?? jni$_.jNullReference;
    return _registerReceiver$2(
            reference.pointer,
            _id_registerReceiver$2 as jni$_.JMethodIDPtr,
            _$broadcastReceiver.pointer,
            _$intentFilter.pointer,
            _$string.pointer,
            _$handler.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_registerReceiver$3 = _class.instanceMethodId(
    r'registerReceiver',
    r'(Landroid/content/BroadcastReceiver;Landroid/content/IntentFilter;Ljava/lang/String;Landroid/os/Handler;I)Landroid/content/Intent;',
  );

  static final _registerReceiver$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `public abstract android.content.Intent registerReceiver(android.content.BroadcastReceiver broadcastReceiver, android.content.IntentFilter intentFilter, java.lang.String string, android.os.Handler handler, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? registerReceiver$3(
    jni$_.JObject? broadcastReceiver,
    jni$_.JObject? intentFilter,
    jni$_.JString? string,
    jni$_.JObject? handler,
    int i,
  ) {
    final _$broadcastReceiver =
        broadcastReceiver?.reference ?? jni$_.jNullReference;
    final _$intentFilter = intentFilter?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$handler = handler?.reference ?? jni$_.jNullReference;
    return _registerReceiver$3(
            reference.pointer,
            _id_registerReceiver$3 as jni$_.JMethodIDPtr,
            _$broadcastReceiver.pointer,
            _$intentFilter.pointer,
            _$string.pointer,
            _$handler.pointer,
            i)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_unregisterReceiver = _class.instanceMethodId(
    r'unregisterReceiver',
    r'(Landroid/content/BroadcastReceiver;)V',
  );

  static final _unregisterReceiver = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void unregisterReceiver(android.content.BroadcastReceiver broadcastReceiver)`
  void unregisterReceiver(
    jni$_.JObject? broadcastReceiver,
  ) {
    final _$broadcastReceiver =
        broadcastReceiver?.reference ?? jni$_.jNullReference;
    _unregisterReceiver(
            reference.pointer,
            _id_unregisterReceiver as jni$_.JMethodIDPtr,
            _$broadcastReceiver.pointer)
        .check();
  }

  static final _id_startService = _class.instanceMethodId(
    r'startService',
    r'(Landroid/content/Intent;)Landroid/content/ComponentName;',
  );

  static final _startService = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract android.content.ComponentName startService(android.content.Intent intent)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? startService(
    jni$_.JObject? intent,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    return _startService(reference.pointer,
            _id_startService as jni$_.JMethodIDPtr, _$intent.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_startForegroundService = _class.instanceMethodId(
    r'startForegroundService',
    r'(Landroid/content/Intent;)Landroid/content/ComponentName;',
  );

  static final _startForegroundService = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract android.content.ComponentName startForegroundService(android.content.Intent intent)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? startForegroundService(
    jni$_.JObject? intent,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    return _startForegroundService(reference.pointer,
            _id_startForegroundService as jni$_.JMethodIDPtr, _$intent.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_stopService = _class.instanceMethodId(
    r'stopService',
    r'(Landroid/content/Intent;)Z',
  );

  static final _stopService = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract boolean stopService(android.content.Intent intent)`
  bool stopService(
    jni$_.JObject? intent,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    return _stopService(reference.pointer,
            _id_stopService as jni$_.JMethodIDPtr, _$intent.pointer)
        .boolean;
  }

  static final _id_bindService = _class.instanceMethodId(
    r'bindService',
    r'(Landroid/content/Intent;Landroid/content/ServiceConnection;I)Z',
  );

  static final _bindService = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `public abstract boolean bindService(android.content.Intent intent, android.content.ServiceConnection serviceConnection, int i)`
  bool bindService(
    jni$_.JObject? intent,
    jni$_.JObject? serviceConnection,
    int i,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$serviceConnection =
        serviceConnection?.reference ?? jni$_.jNullReference;
    return _bindService(
            reference.pointer,
            _id_bindService as jni$_.JMethodIDPtr,
            _$intent.pointer,
            _$serviceConnection.pointer,
            i)
        .boolean;
  }

  static final _id_bindService$1 = _class.instanceMethodId(
    r'bindService',
    r'(Landroid/content/Intent;Landroid/content/ServiceConnection;Landroid/content/Context$BindServiceFlags;)Z',
  );

  static final _bindService$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean bindService(android.content.Intent intent, android.content.ServiceConnection serviceConnection, android.content.Context$BindServiceFlags bindServiceFlags)`
  bool bindService$1(
    jni$_.JObject? intent,
    jni$_.JObject? serviceConnection,
    Context$BindServiceFlags? bindServiceFlags,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$serviceConnection =
        serviceConnection?.reference ?? jni$_.jNullReference;
    final _$bindServiceFlags =
        bindServiceFlags?.reference ?? jni$_.jNullReference;
    return _bindService$1(
            reference.pointer,
            _id_bindService$1 as jni$_.JMethodIDPtr,
            _$intent.pointer,
            _$serviceConnection.pointer,
            _$bindServiceFlags.pointer)
        .boolean;
  }

  static final _id_bindService$2 = _class.instanceMethodId(
    r'bindService',
    r'(Landroid/content/Intent;ILjava/util/concurrent/Executor;Landroid/content/ServiceConnection;)Z',
  );

  static final _bindService$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean bindService(android.content.Intent intent, int i, java.util.concurrent.Executor executor, android.content.ServiceConnection serviceConnection)`
  bool bindService$2(
    jni$_.JObject? intent,
    int i,
    jni$_.JObject? executor,
    jni$_.JObject? serviceConnection,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$executor = executor?.reference ?? jni$_.jNullReference;
    final _$serviceConnection =
        serviceConnection?.reference ?? jni$_.jNullReference;
    return _bindService$2(
            reference.pointer,
            _id_bindService$2 as jni$_.JMethodIDPtr,
            _$intent.pointer,
            i,
            _$executor.pointer,
            _$serviceConnection.pointer)
        .boolean;
  }

  static final _id_bindService$3 = _class.instanceMethodId(
    r'bindService',
    r'(Landroid/content/Intent;Landroid/content/Context$BindServiceFlags;Ljava/util/concurrent/Executor;Landroid/content/ServiceConnection;)Z',
  );

  static final _bindService$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean bindService(android.content.Intent intent, android.content.Context$BindServiceFlags bindServiceFlags, java.util.concurrent.Executor executor, android.content.ServiceConnection serviceConnection)`
  bool bindService$3(
    jni$_.JObject? intent,
    Context$BindServiceFlags? bindServiceFlags,
    jni$_.JObject? executor,
    jni$_.JObject? serviceConnection,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$bindServiceFlags =
        bindServiceFlags?.reference ?? jni$_.jNullReference;
    final _$executor = executor?.reference ?? jni$_.jNullReference;
    final _$serviceConnection =
        serviceConnection?.reference ?? jni$_.jNullReference;
    return _bindService$3(
            reference.pointer,
            _id_bindService$3 as jni$_.JMethodIDPtr,
            _$intent.pointer,
            _$bindServiceFlags.pointer,
            _$executor.pointer,
            _$serviceConnection.pointer)
        .boolean;
  }

  static final _id_bindIsolatedService = _class.instanceMethodId(
    r'bindIsolatedService',
    r'(Landroid/content/Intent;ILjava/lang/String;Ljava/util/concurrent/Executor;Landroid/content/ServiceConnection;)Z',
  );

  static final _bindIsolatedService = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean bindIsolatedService(android.content.Intent intent, int i, java.lang.String string, java.util.concurrent.Executor executor, android.content.ServiceConnection serviceConnection)`
  bool bindIsolatedService(
    jni$_.JObject? intent,
    int i,
    jni$_.JString? string,
    jni$_.JObject? executor,
    jni$_.JObject? serviceConnection,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$executor = executor?.reference ?? jni$_.jNullReference;
    final _$serviceConnection =
        serviceConnection?.reference ?? jni$_.jNullReference;
    return _bindIsolatedService(
            reference.pointer,
            _id_bindIsolatedService as jni$_.JMethodIDPtr,
            _$intent.pointer,
            i,
            _$string.pointer,
            _$executor.pointer,
            _$serviceConnection.pointer)
        .boolean;
  }

  static final _id_bindIsolatedService$1 = _class.instanceMethodId(
    r'bindIsolatedService',
    r'(Landroid/content/Intent;Landroid/content/Context$BindServiceFlags;Ljava/lang/String;Ljava/util/concurrent/Executor;Landroid/content/ServiceConnection;)Z',
  );

  static final _bindIsolatedService$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean bindIsolatedService(android.content.Intent intent, android.content.Context$BindServiceFlags bindServiceFlags, java.lang.String string, java.util.concurrent.Executor executor, android.content.ServiceConnection serviceConnection)`
  bool bindIsolatedService$1(
    jni$_.JObject? intent,
    Context$BindServiceFlags? bindServiceFlags,
    jni$_.JString? string,
    jni$_.JObject? executor,
    jni$_.JObject? serviceConnection,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$bindServiceFlags =
        bindServiceFlags?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$executor = executor?.reference ?? jni$_.jNullReference;
    final _$serviceConnection =
        serviceConnection?.reference ?? jni$_.jNullReference;
    return _bindIsolatedService$1(
            reference.pointer,
            _id_bindIsolatedService$1 as jni$_.JMethodIDPtr,
            _$intent.pointer,
            _$bindServiceFlags.pointer,
            _$string.pointer,
            _$executor.pointer,
            _$serviceConnection.pointer)
        .boolean;
  }

  static final _id_bindServiceAsUser = _class.instanceMethodId(
    r'bindServiceAsUser',
    r'(Landroid/content/Intent;Landroid/content/ServiceConnection;ILandroid/os/UserHandle;)Z',
  );

  static final _bindServiceAsUser = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean bindServiceAsUser(android.content.Intent intent, android.content.ServiceConnection serviceConnection, int i, android.os.UserHandle userHandle)`
  bool bindServiceAsUser(
    jni$_.JObject? intent,
    jni$_.JObject? serviceConnection,
    int i,
    jni$_.JObject? userHandle,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$serviceConnection =
        serviceConnection?.reference ?? jni$_.jNullReference;
    final _$userHandle = userHandle?.reference ?? jni$_.jNullReference;
    return _bindServiceAsUser(
            reference.pointer,
            _id_bindServiceAsUser as jni$_.JMethodIDPtr,
            _$intent.pointer,
            _$serviceConnection.pointer,
            i,
            _$userHandle.pointer)
        .boolean;
  }

  static final _id_bindServiceAsUser$1 = _class.instanceMethodId(
    r'bindServiceAsUser',
    r'(Landroid/content/Intent;Landroid/content/ServiceConnection;Landroid/content/Context$BindServiceFlags;Landroid/os/UserHandle;)Z',
  );

  static final _bindServiceAsUser$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean bindServiceAsUser(android.content.Intent intent, android.content.ServiceConnection serviceConnection, android.content.Context$BindServiceFlags bindServiceFlags, android.os.UserHandle userHandle)`
  bool bindServiceAsUser$1(
    jni$_.JObject? intent,
    jni$_.JObject? serviceConnection,
    Context$BindServiceFlags? bindServiceFlags,
    jni$_.JObject? userHandle,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$serviceConnection =
        serviceConnection?.reference ?? jni$_.jNullReference;
    final _$bindServiceFlags =
        bindServiceFlags?.reference ?? jni$_.jNullReference;
    final _$userHandle = userHandle?.reference ?? jni$_.jNullReference;
    return _bindServiceAsUser$1(
            reference.pointer,
            _id_bindServiceAsUser$1 as jni$_.JMethodIDPtr,
            _$intent.pointer,
            _$serviceConnection.pointer,
            _$bindServiceFlags.pointer,
            _$userHandle.pointer)
        .boolean;
  }

  static final _id_updateServiceGroup = _class.instanceMethodId(
    r'updateServiceGroup',
    r'(Landroid/content/ServiceConnection;II)V',
  );

  static final _updateServiceGroup = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int, int)>();

  /// from: `public void updateServiceGroup(android.content.ServiceConnection serviceConnection, int i, int i1)`
  void updateServiceGroup(
    jni$_.JObject? serviceConnection,
    int i,
    int i1,
  ) {
    final _$serviceConnection =
        serviceConnection?.reference ?? jni$_.jNullReference;
    _updateServiceGroup(
            reference.pointer,
            _id_updateServiceGroup as jni$_.JMethodIDPtr,
            _$serviceConnection.pointer,
            i,
            i1)
        .check();
  }

  static final _id_unbindService = _class.instanceMethodId(
    r'unbindService',
    r'(Landroid/content/ServiceConnection;)V',
  );

  static final _unbindService = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void unbindService(android.content.ServiceConnection serviceConnection)`
  void unbindService(
    jni$_.JObject? serviceConnection,
  ) {
    final _$serviceConnection =
        serviceConnection?.reference ?? jni$_.jNullReference;
    _unbindService(reference.pointer, _id_unbindService as jni$_.JMethodIDPtr,
            _$serviceConnection.pointer)
        .check();
  }

  static final _id_startInstrumentation = _class.instanceMethodId(
    r'startInstrumentation',
    r'(Landroid/content/ComponentName;Ljava/lang/String;Landroid/os/Bundle;)Z',
  );

  static final _startInstrumentation = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract boolean startInstrumentation(android.content.ComponentName componentName, java.lang.String string, android.os.Bundle bundle)`
  bool startInstrumentation(
    jni$_.JObject? componentName,
    jni$_.JString? string,
    jni$_.JObject? bundle,
  ) {
    final _$componentName = componentName?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    return _startInstrumentation(
            reference.pointer,
            _id_startInstrumentation as jni$_.JMethodIDPtr,
            _$componentName.pointer,
            _$string.pointer,
            _$bundle.pointer)
        .boolean;
  }

  static final _id_getSystemService = _class.instanceMethodId(
    r'getSystemService',
    r'(Ljava/lang/String;)Ljava/lang/Object;',
  );

  static final _getSystemService = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object getSystemService(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getSystemService(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getSystemService(reference.pointer,
            _id_getSystemService as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getSystemService$1 = _class.instanceMethodId(
    r'getSystemService',
    r'(Ljava/lang/Class;)Ljava/lang/Object;',
  );

  static final _getSystemService$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final T getSystemService(java.lang.Class<T> class)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? getSystemService$1<$T extends jni$_.JObject?>(
    jni$_.JObject? class$, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$class$ = class$?.reference ?? jni$_.jNullReference;
    return _getSystemService$1(reference.pointer,
            _id_getSystemService$1 as jni$_.JMethodIDPtr, _$class$.pointer)
        .object<$T?>(T.nullableType);
  }

  static final _id_getSystemServiceName = _class.instanceMethodId(
    r'getSystemServiceName',
    r'(Ljava/lang/Class;)Ljava/lang/String;',
  );

  static final _getSystemServiceName = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String getSystemServiceName(java.lang.Class<?> class)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getSystemServiceName(
    jni$_.JObject? class$,
  ) {
    final _$class$ = class$?.reference ?? jni$_.jNullReference;
    return _getSystemServiceName(reference.pointer,
            _id_getSystemServiceName as jni$_.JMethodIDPtr, _$class$.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_checkPermission = _class.instanceMethodId(
    r'checkPermission',
    r'(Ljava/lang/String;II)I',
  );

  static final _checkPermission = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int, int)>();

  /// from: `public abstract int checkPermission(java.lang.String string, int i, int i1)`
  int checkPermission(
    jni$_.JString? string,
    int i,
    int i1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _checkPermission(reference.pointer,
            _id_checkPermission as jni$_.JMethodIDPtr, _$string.pointer, i, i1)
        .integer;
  }

  static final _id_checkCallingPermission = _class.instanceMethodId(
    r'checkCallingPermission',
    r'(Ljava/lang/String;)I',
  );

  static final _checkCallingPermission = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract int checkCallingPermission(java.lang.String string)`
  int checkCallingPermission(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _checkCallingPermission(reference.pointer,
            _id_checkCallingPermission as jni$_.JMethodIDPtr, _$string.pointer)
        .integer;
  }

  static final _id_checkCallingOrSelfPermission = _class.instanceMethodId(
    r'checkCallingOrSelfPermission',
    r'(Ljava/lang/String;)I',
  );

  static final _checkCallingOrSelfPermission =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallIntMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract int checkCallingOrSelfPermission(java.lang.String string)`
  int checkCallingOrSelfPermission(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _checkCallingOrSelfPermission(
            reference.pointer,
            _id_checkCallingOrSelfPermission as jni$_.JMethodIDPtr,
            _$string.pointer)
        .integer;
  }

  static final _id_checkSelfPermission = _class.instanceMethodId(
    r'checkSelfPermission',
    r'(Ljava/lang/String;)I',
  );

  static final _checkSelfPermission = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract int checkSelfPermission(java.lang.String string)`
  int checkSelfPermission(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _checkSelfPermission(reference.pointer,
            _id_checkSelfPermission as jni$_.JMethodIDPtr, _$string.pointer)
        .integer;
  }

  static final _id_enforcePermission = _class.instanceMethodId(
    r'enforcePermission',
    r'(Ljava/lang/String;IILjava/lang/String;)V',
  );

  static final _enforcePermission = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void enforcePermission(java.lang.String string, int i, int i1, java.lang.String string1)`
  void enforcePermission(
    jni$_.JString? string,
    int i,
    int i1,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _enforcePermission(
            reference.pointer,
            _id_enforcePermission as jni$_.JMethodIDPtr,
            _$string.pointer,
            i,
            i1,
            _$string1.pointer)
        .check();
  }

  static final _id_enforceCallingPermission = _class.instanceMethodId(
    r'enforceCallingPermission',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _enforceCallingPermission = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void enforceCallingPermission(java.lang.String string, java.lang.String string1)`
  void enforceCallingPermission(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _enforceCallingPermission(
            reference.pointer,
            _id_enforceCallingPermission as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer)
        .check();
  }

  static final _id_enforceCallingOrSelfPermission = _class.instanceMethodId(
    r'enforceCallingOrSelfPermission',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _enforceCallingOrSelfPermission =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void enforceCallingOrSelfPermission(java.lang.String string, java.lang.String string1)`
  void enforceCallingOrSelfPermission(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _enforceCallingOrSelfPermission(
            reference.pointer,
            _id_enforceCallingOrSelfPermission as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer)
        .check();
  }

  static final _id_grantUriPermission = _class.instanceMethodId(
    r'grantUriPermission',
    r'(Ljava/lang/String;Landroid/net/Uri;I)V',
  );

  static final _grantUriPermission = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `public abstract void grantUriPermission(java.lang.String string, android.net.Uri uri, int i)`
  void grantUriPermission(
    jni$_.JString? string,
    jni$_.JObject? uri,
    int i,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    _grantUriPermission(
            reference.pointer,
            _id_grantUriPermission as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$uri.pointer,
            i)
        .check();
  }

  static final _id_revokeUriPermission = _class.instanceMethodId(
    r'revokeUriPermission',
    r'(Landroid/net/Uri;I)V',
  );

  static final _revokeUriPermission = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public abstract void revokeUriPermission(android.net.Uri uri, int i)`
  void revokeUriPermission(
    jni$_.JObject? uri,
    int i,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    _revokeUriPermission(reference.pointer,
            _id_revokeUriPermission as jni$_.JMethodIDPtr, _$uri.pointer, i)
        .check();
  }

  static final _id_revokeUriPermission$1 = _class.instanceMethodId(
    r'revokeUriPermission',
    r'(Ljava/lang/String;Landroid/net/Uri;I)V',
  );

  static final _revokeUriPermission$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `public abstract void revokeUriPermission(java.lang.String string, android.net.Uri uri, int i)`
  void revokeUriPermission$1(
    jni$_.JString? string,
    jni$_.JObject? uri,
    int i,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    _revokeUriPermission$1(
            reference.pointer,
            _id_revokeUriPermission$1 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$uri.pointer,
            i)
        .check();
  }

  static final _id_checkUriPermission = _class.instanceMethodId(
    r'checkUriPermission',
    r'(Landroid/net/Uri;III)I',
  );

  static final _checkUriPermission = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int, int, int)>();

  /// from: `public abstract int checkUriPermission(android.net.Uri uri, int i, int i1, int i2)`
  int checkUriPermission(
    jni$_.JObject? uri,
    int i,
    int i1,
    int i2,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    return _checkUriPermission(
            reference.pointer,
            _id_checkUriPermission as jni$_.JMethodIDPtr,
            _$uri.pointer,
            i,
            i1,
            i2)
        .integer;
  }

  static final _id_checkContentUriPermissionFull = _class.instanceMethodId(
    r'checkContentUriPermissionFull',
    r'(Landroid/net/Uri;III)I',
  );

  static final _checkContentUriPermissionFull =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32,
                            jni$_.Int32,
                            jni$_.Int32
                          )>)>>('globalEnv_CallIntMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  int,
                  int,
                  int)>();

  /// from: `public int checkContentUriPermissionFull(android.net.Uri uri, int i, int i1, int i2)`
  int checkContentUriPermissionFull(
    jni$_.JObject? uri,
    int i,
    int i1,
    int i2,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    return _checkContentUriPermissionFull(
            reference.pointer,
            _id_checkContentUriPermissionFull as jni$_.JMethodIDPtr,
            _$uri.pointer,
            i,
            i1,
            i2)
        .integer;
  }

  static final _id_checkUriPermissions = _class.instanceMethodId(
    r'checkUriPermissions',
    r'(Ljava/util/List;III)[I',
  );

  static final _checkUriPermissions = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int, int, int)>();

  /// from: `public int[] checkUriPermissions(java.util.List<android.net.Uri> list, int i, int i1, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? checkUriPermissions(
    jni$_.JList<jni$_.JObject?>? list,
    int i,
    int i1,
    int i2,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _checkUriPermissions(
            reference.pointer,
            _id_checkUriPermissions as jni$_.JMethodIDPtr,
            _$list.pointer,
            i,
            i1,
            i2)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_checkCallingUriPermission = _class.instanceMethodId(
    r'checkCallingUriPermission',
    r'(Landroid/net/Uri;I)I',
  );

  static final _checkCallingUriPermission = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public abstract int checkCallingUriPermission(android.net.Uri uri, int i)`
  int checkCallingUriPermission(
    jni$_.JObject? uri,
    int i,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    return _checkCallingUriPermission(
            reference.pointer,
            _id_checkCallingUriPermission as jni$_.JMethodIDPtr,
            _$uri.pointer,
            i)
        .integer;
  }

  static final _id_checkCallingUriPermissions = _class.instanceMethodId(
    r'checkCallingUriPermissions',
    r'(Ljava/util/List;I)[I',
  );

  static final _checkCallingUriPermissions =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public int[] checkCallingUriPermissions(java.util.List<android.net.Uri> list, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? checkCallingUriPermissions(
    jni$_.JList<jni$_.JObject?>? list,
    int i,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _checkCallingUriPermissions(
            reference.pointer,
            _id_checkCallingUriPermissions as jni$_.JMethodIDPtr,
            _$list.pointer,
            i)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_checkCallingOrSelfUriPermission = _class.instanceMethodId(
    r'checkCallingOrSelfUriPermission',
    r'(Landroid/net/Uri;I)I',
  );

  static final _checkCallingOrSelfUriPermission =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32
                          )>)>>('globalEnv_CallIntMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public abstract int checkCallingOrSelfUriPermission(android.net.Uri uri, int i)`
  int checkCallingOrSelfUriPermission(
    jni$_.JObject? uri,
    int i,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    return _checkCallingOrSelfUriPermission(
            reference.pointer,
            _id_checkCallingOrSelfUriPermission as jni$_.JMethodIDPtr,
            _$uri.pointer,
            i)
        .integer;
  }

  static final _id_checkCallingOrSelfUriPermissions = _class.instanceMethodId(
    r'checkCallingOrSelfUriPermissions',
    r'(Ljava/util/List;I)[I',
  );

  static final _checkCallingOrSelfUriPermissions =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public int[] checkCallingOrSelfUriPermissions(java.util.List<android.net.Uri> list, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? checkCallingOrSelfUriPermissions(
    jni$_.JList<jni$_.JObject?>? list,
    int i,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _checkCallingOrSelfUriPermissions(
            reference.pointer,
            _id_checkCallingOrSelfUriPermissions as jni$_.JMethodIDPtr,
            _$list.pointer,
            i)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_checkUriPermission$1 = _class.instanceMethodId(
    r'checkUriPermission',
    r'(Landroid/net/Uri;Ljava/lang/String;Ljava/lang/String;III)I',
  );

  static final _checkUriPermission$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int)>();

  /// from: `public abstract int checkUriPermission(android.net.Uri uri, java.lang.String string, java.lang.String string1, int i, int i1, int i2)`
  int checkUriPermission$1(
    jni$_.JObject? uri,
    jni$_.JString? string,
    jni$_.JString? string1,
    int i,
    int i1,
    int i2,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return _checkUriPermission$1(
            reference.pointer,
            _id_checkUriPermission$1 as jni$_.JMethodIDPtr,
            _$uri.pointer,
            _$string.pointer,
            _$string1.pointer,
            i,
            i1,
            i2)
        .integer;
  }

  static final _id_enforceUriPermission = _class.instanceMethodId(
    r'enforceUriPermission',
    r'(Landroid/net/Uri;IIILjava/lang/String;)V',
  );

  static final _enforceUriPermission = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void enforceUriPermission(android.net.Uri uri, int i, int i1, int i2, java.lang.String string)`
  void enforceUriPermission(
    jni$_.JObject? uri,
    int i,
    int i1,
    int i2,
    jni$_.JString? string,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    _enforceUriPermission(
            reference.pointer,
            _id_enforceUriPermission as jni$_.JMethodIDPtr,
            _$uri.pointer,
            i,
            i1,
            i2,
            _$string.pointer)
        .check();
  }

  static final _id_enforceCallingUriPermission = _class.instanceMethodId(
    r'enforceCallingUriPermission',
    r'(Landroid/net/Uri;ILjava/lang/String;)V',
  );

  static final _enforceCallingUriPermission =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  int,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void enforceCallingUriPermission(android.net.Uri uri, int i, java.lang.String string)`
  void enforceCallingUriPermission(
    jni$_.JObject? uri,
    int i,
    jni$_.JString? string,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    _enforceCallingUriPermission(
            reference.pointer,
            _id_enforceCallingUriPermission as jni$_.JMethodIDPtr,
            _$uri.pointer,
            i,
            _$string.pointer)
        .check();
  }

  static final _id_enforceCallingOrSelfUriPermission = _class.instanceMethodId(
    r'enforceCallingOrSelfUriPermission',
    r'(Landroid/net/Uri;ILjava/lang/String;)V',
  );

  static final _enforceCallingOrSelfUriPermission =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  int,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void enforceCallingOrSelfUriPermission(android.net.Uri uri, int i, java.lang.String string)`
  void enforceCallingOrSelfUriPermission(
    jni$_.JObject? uri,
    int i,
    jni$_.JString? string,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    _enforceCallingOrSelfUriPermission(
            reference.pointer,
            _id_enforceCallingOrSelfUriPermission as jni$_.JMethodIDPtr,
            _$uri.pointer,
            i,
            _$string.pointer)
        .check();
  }

  static final _id_enforceUriPermission$1 = _class.instanceMethodId(
    r'enforceUriPermission',
    r'(Landroid/net/Uri;Ljava/lang/String;Ljava/lang/String;IIILjava/lang/String;)V',
  );

  static final _enforceUriPermission$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void enforceUriPermission(android.net.Uri uri, java.lang.String string, java.lang.String string1, int i, int i1, int i2, java.lang.String string2)`
  void enforceUriPermission$1(
    jni$_.JObject? uri,
    jni$_.JString? string,
    jni$_.JString? string1,
    int i,
    int i1,
    int i2,
    jni$_.JString? string2,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    _enforceUriPermission$1(
            reference.pointer,
            _id_enforceUriPermission$1 as jni$_.JMethodIDPtr,
            _$uri.pointer,
            _$string.pointer,
            _$string1.pointer,
            i,
            i1,
            i2,
            _$string2.pointer)
        .check();
  }

  static final _id_revokeSelfPermissionOnKill = _class.instanceMethodId(
    r'revokeSelfPermissionOnKill',
    r'(Ljava/lang/String;)V',
  );

  static final _revokeSelfPermissionOnKill =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void revokeSelfPermissionOnKill(java.lang.String string)`
  void revokeSelfPermissionOnKill(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _revokeSelfPermissionOnKill(
            reference.pointer,
            _id_revokeSelfPermissionOnKill as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_revokeSelfPermissionsOnKill = _class.instanceMethodId(
    r'revokeSelfPermissionsOnKill',
    r'(Ljava/util/Collection;)V',
  );

  static final _revokeSelfPermissionsOnKill =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void revokeSelfPermissionsOnKill(java.util.Collection<java.lang.String> collection)`
  void revokeSelfPermissionsOnKill(
    jni$_.JObject? collection,
  ) {
    final _$collection = collection?.reference ?? jni$_.jNullReference;
    _revokeSelfPermissionsOnKill(
            reference.pointer,
            _id_revokeSelfPermissionsOnKill as jni$_.JMethodIDPtr,
            _$collection.pointer)
        .check();
  }

  static final _id_createPackageContext = _class.instanceMethodId(
    r'createPackageContext',
    r'(Ljava/lang/String;I)Landroid/content/Context;',
  );

  static final _createPackageContext = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public abstract android.content.Context createPackageContext(java.lang.String string, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  Context? createPackageContext(
    jni$_.JString? string,
    int i,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _createPackageContext(reference.pointer,
            _id_createPackageContext as jni$_.JMethodIDPtr, _$string.pointer, i)
        .object<Context?>(const $Context$NullableType());
  }

  static final _id_createContextForSplit = _class.instanceMethodId(
    r'createContextForSplit',
    r'(Ljava/lang/String;)Landroid/content/Context;',
  );

  static final _createContextForSplit = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract android.content.Context createContextForSplit(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  Context? createContextForSplit(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _createContextForSplit(reference.pointer,
            _id_createContextForSplit as jni$_.JMethodIDPtr, _$string.pointer)
        .object<Context?>(const $Context$NullableType());
  }

  static final _id_createConfigurationContext = _class.instanceMethodId(
    r'createConfigurationContext',
    r'(Landroid/content/res/Configuration;)Landroid/content/Context;',
  );

  static final _createConfigurationContext =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract android.content.Context createConfigurationContext(android.content.res.Configuration configuration)`
  /// The returned object must be released after use, by calling the [release] method.
  Context? createConfigurationContext(
    jni$_.JObject? configuration,
  ) {
    final _$configuration = configuration?.reference ?? jni$_.jNullReference;
    return _createConfigurationContext(
            reference.pointer,
            _id_createConfigurationContext as jni$_.JMethodIDPtr,
            _$configuration.pointer)
        .object<Context?>(const $Context$NullableType());
  }

  static final _id_createDisplayContext = _class.instanceMethodId(
    r'createDisplayContext',
    r'(Landroid/view/Display;)Landroid/content/Context;',
  );

  static final _createDisplayContext = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract android.content.Context createDisplayContext(android.view.Display display)`
  /// The returned object must be released after use, by calling the [release] method.
  Context? createDisplayContext(
    jni$_.JObject? display,
  ) {
    final _$display = display?.reference ?? jni$_.jNullReference;
    return _createDisplayContext(reference.pointer,
            _id_createDisplayContext as jni$_.JMethodIDPtr, _$display.pointer)
        .object<Context?>(const $Context$NullableType());
  }

  static final _id_createDeviceContext = _class.instanceMethodId(
    r'createDeviceContext',
    r'(I)Landroid/content/Context;',
  );

  static final _createDeviceContext = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public android.content.Context createDeviceContext(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  Context? createDeviceContext(
    int i,
  ) {
    return _createDeviceContext(
            reference.pointer, _id_createDeviceContext as jni$_.JMethodIDPtr, i)
        .object<Context?>(const $Context$NullableType());
  }

  static final _id_createWindowContext = _class.instanceMethodId(
    r'createWindowContext',
    r'(ILandroid/os/Bundle;)Landroid/content/Context;',
  );

  static final _createWindowContext = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public android.content.Context createWindowContext(int i, android.os.Bundle bundle)`
  /// The returned object must be released after use, by calling the [release] method.
  Context? createWindowContext(
    int i,
    jni$_.JObject? bundle,
  ) {
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    return _createWindowContext(reference.pointer,
            _id_createWindowContext as jni$_.JMethodIDPtr, i, _$bundle.pointer)
        .object<Context?>(const $Context$NullableType());
  }

  static final _id_createWindowContext$1 = _class.instanceMethodId(
    r'createWindowContext',
    r'(Landroid/view/Display;ILandroid/os/Bundle;)Landroid/content/Context;',
  );

  static final _createWindowContext$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public android.content.Context createWindowContext(android.view.Display display, int i, android.os.Bundle bundle)`
  /// The returned object must be released after use, by calling the [release] method.
  Context? createWindowContext$1(
    jni$_.JObject? display,
    int i,
    jni$_.JObject? bundle,
  ) {
    final _$display = display?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    return _createWindowContext$1(
            reference.pointer,
            _id_createWindowContext$1 as jni$_.JMethodIDPtr,
            _$display.pointer,
            i,
            _$bundle.pointer)
        .object<Context?>(const $Context$NullableType());
  }

  static final _id_createContext = _class.instanceMethodId(
    r'createContext',
    r'(Landroid/content/ContextParams;)Landroid/content/Context;',
  );

  static final _createContext = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public android.content.Context createContext(android.content.ContextParams contextParams)`
  /// The returned object must be released after use, by calling the [release] method.
  Context? createContext(
    jni$_.JObject? contextParams,
  ) {
    final _$contextParams = contextParams?.reference ?? jni$_.jNullReference;
    return _createContext(reference.pointer,
            _id_createContext as jni$_.JMethodIDPtr, _$contextParams.pointer)
        .object<Context?>(const $Context$NullableType());
  }

  static final _id_createAttributionContext = _class.instanceMethodId(
    r'createAttributionContext',
    r'(Ljava/lang/String;)Landroid/content/Context;',
  );

  static final _createAttributionContext = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public android.content.Context createAttributionContext(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  Context? createAttributionContext(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _createAttributionContext(
            reference.pointer,
            _id_createAttributionContext as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<Context?>(const $Context$NullableType());
  }

  static final _id_createDeviceProtectedStorageContext =
      _class.instanceMethodId(
    r'createDeviceProtectedStorageContext',
    r'()Landroid/content/Context;',
  );

  static final _createDeviceProtectedStorageContext =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public abstract android.content.Context createDeviceProtectedStorageContext()`
  /// The returned object must be released after use, by calling the [release] method.
  Context? createDeviceProtectedStorageContext() {
    return _createDeviceProtectedStorageContext(reference.pointer,
            _id_createDeviceProtectedStorageContext as jni$_.JMethodIDPtr)
        .object<Context?>(const $Context$NullableType());
  }

  static final _id_getDisplay = _class.instanceMethodId(
    r'getDisplay',
    r'()Landroid/view/Display;',
  );

  static final _getDisplay = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public android.view.Display getDisplay()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getDisplay() {
    return _getDisplay(reference.pointer, _id_getDisplay as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getDeviceId = _class.instanceMethodId(
    r'getDeviceId',
    r'()I',
  );

  static final _getDeviceId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getDeviceId()`
  int getDeviceId() {
    return _getDeviceId(
            reference.pointer, _id_getDeviceId as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_registerDeviceIdChangeListener = _class.instanceMethodId(
    r'registerDeviceIdChangeListener',
    r'(Ljava/util/concurrent/Executor;Ljava/util/function/IntConsumer;)V',
  );

  static final _registerDeviceIdChangeListener =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void registerDeviceIdChangeListener(java.util.concurrent.Executor executor, java.util.function.IntConsumer intConsumer)`
  void registerDeviceIdChangeListener(
    jni$_.JObject? executor,
    jni$_.JObject? intConsumer,
  ) {
    final _$executor = executor?.reference ?? jni$_.jNullReference;
    final _$intConsumer = intConsumer?.reference ?? jni$_.jNullReference;
    _registerDeviceIdChangeListener(
            reference.pointer,
            _id_registerDeviceIdChangeListener as jni$_.JMethodIDPtr,
            _$executor.pointer,
            _$intConsumer.pointer)
        .check();
  }

  static final _id_unregisterDeviceIdChangeListener = _class.instanceMethodId(
    r'unregisterDeviceIdChangeListener',
    r'(Ljava/util/function/IntConsumer;)V',
  );

  static final _unregisterDeviceIdChangeListener =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void unregisterDeviceIdChangeListener(java.util.function.IntConsumer intConsumer)`
  void unregisterDeviceIdChangeListener(
    jni$_.JObject? intConsumer,
  ) {
    final _$intConsumer = intConsumer?.reference ?? jni$_.jNullReference;
    _unregisterDeviceIdChangeListener(
            reference.pointer,
            _id_unregisterDeviceIdChangeListener as jni$_.JMethodIDPtr,
            _$intConsumer.pointer)
        .check();
  }

  static final _id_isRestricted = _class.instanceMethodId(
    r'isRestricted',
    r'()Z',
  );

  static final _isRestricted = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isRestricted()`
  bool isRestricted() {
    return _isRestricted(
            reference.pointer, _id_isRestricted as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_isDeviceProtectedStorage = _class.instanceMethodId(
    r'isDeviceProtectedStorage',
    r'()Z',
  );

  static final _isDeviceProtectedStorage = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract boolean isDeviceProtectedStorage()`
  bool isDeviceProtectedStorage() {
    return _isDeviceProtectedStorage(reference.pointer,
            _id_isDeviceProtectedStorage as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_isUiContext = _class.instanceMethodId(
    r'isUiContext',
    r'()Z',
  );

  static final _isUiContext = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isUiContext()`
  bool isUiContext() {
    return _isUiContext(
            reference.pointer, _id_isUiContext as jni$_.JMethodIDPtr)
        .boolean;
  }
}

final class $Context$NullableType extends jni$_.JObjType<Context?> {
  @jni$_.internal
  const $Context$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/content/Context;';

  @jni$_.internal
  @core$_.override
  Context? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Context.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Context?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Context$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Context$NullableType) &&
        other is $Context$NullableType;
  }
}

final class $Context$Type extends jni$_.JObjType<Context> {
  @jni$_.internal
  const $Context$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/content/Context;';

  @jni$_.internal
  @core$_.override
  Context fromReference(jni$_.JReference reference) => Context.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Context?> get nullableType => const $Context$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Context$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Context$Type) && other is $Context$Type;
  }
}
