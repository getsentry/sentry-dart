// AUTO GENERATED BY JNIGEN 0.14.2. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `io.sentry.android.core.InternalSentrySdk`
class InternalSentrySdk extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<InternalSentrySdk> $type;

  @jni$_.internal
  InternalSentrySdk.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/android/core/InternalSentrySdk');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $InternalSentrySdk$NullableType();
  static const type = $InternalSentrySdk$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory InternalSentrySdk() {
    return InternalSentrySdk.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_getCurrentScope = _class.staticMethodId(
    r'getCurrentScope',
    r'()Lio/sentry/IScope;',
  );

  static final _getCurrentScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.IScope getCurrentScope()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? getCurrentScope() {
    return _getCurrentScope(
            _class.reference.pointer, _id_getCurrentScope as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_serializeScope = _class.staticMethodId(
    r'serializeScope',
    r'(Landroid/content/Context;Lio/sentry/android/core/SentryAndroidOptions;Lio/sentry/IScope;)Ljava/util/Map;',
  );

  static final _serializeScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.Map<java.lang.String, java.lang.Object> serializeScope(android.content.Context context, io.sentry.android.core.SentryAndroidOptions sentryAndroidOptions, io.sentry.IScope iScope)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JMap<jni$_.JString?, jni$_.JObject?> serializeScope(
    jni$_.JObject context,
    jni$_.JObject sentryAndroidOptions,
    jni$_.JObject? iScope,
  ) {
    final _$context = context.reference;
    final _$sentryAndroidOptions = sentryAndroidOptions.reference;
    final _$iScope = iScope?.reference ?? jni$_.jNullReference;
    return _serializeScope(
            _class.reference.pointer,
            _id_serializeScope as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$sentryAndroidOptions.pointer,
            _$iScope.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JString?, jni$_.JObject?>(
                jni$_.JStringNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_captureEnvelope = _class.staticMethodId(
    r'captureEnvelope',
    r'([BZ)Lio/sentry/protocol/SentryId;',
  );

  static final _captureEnvelope = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `static public io.sentry.protocol.SentryId captureEnvelope(byte[] bs, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? captureEnvelope(
    jni$_.JByteArray bs,
    bool z,
  ) {
    final _$bs = bs.reference;
    return _captureEnvelope(_class.reference.pointer,
            _id_captureEnvelope as jni$_.JMethodIDPtr, _$bs.pointer, z ? 1 : 0)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getAppStartMeasurement = _class.staticMethodId(
    r'getAppStartMeasurement',
    r'()Ljava/util/Map;',
  );

  static final _getAppStartMeasurement = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.util.Map<java.lang.String, java.lang.Object> getAppStartMeasurement()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JMap<jni$_.JString?, jni$_.JObject?>? getAppStartMeasurement() {
    return _getAppStartMeasurement(_class.reference.pointer,
            _id_getAppStartMeasurement as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JObject?>(
                jni$_.JStringNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_setTrace = _class.staticMethodId(
    r'setTrace',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/Double;Ljava/lang/Double;)V',
  );

  static final _setTrace = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void setTrace(java.lang.String string, java.lang.String string1, java.lang.Double double, java.lang.Double double1)`
  static void setTrace(
    jni$_.JString string,
    jni$_.JString string1,
    jni$_.JDouble? double,
    jni$_.JDouble? double1,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$double1 = double1?.reference ?? jni$_.jNullReference;
    _setTrace(
            _class.reference.pointer,
            _id_setTrace as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$double.pointer,
            _$double1.pointer)
        .check();
  }
}

final class $InternalSentrySdk$NullableType
    extends jni$_.JObjType<InternalSentrySdk?> {
  @jni$_.internal
  const $InternalSentrySdk$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/core/InternalSentrySdk;';

  @jni$_.internal
  @core$_.override
  InternalSentrySdk? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : InternalSentrySdk.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InternalSentrySdk?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InternalSentrySdk$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InternalSentrySdk$NullableType) &&
        other is $InternalSentrySdk$NullableType;
  }
}

final class $InternalSentrySdk$Type extends jni$_.JObjType<InternalSentrySdk> {
  @jni$_.internal
  const $InternalSentrySdk$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/core/InternalSentrySdk;';

  @jni$_.internal
  @core$_.override
  InternalSentrySdk fromReference(jni$_.JReference reference) =>
      InternalSentrySdk.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InternalSentrySdk?> get nullableType =>
      const $InternalSentrySdk$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InternalSentrySdk$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InternalSentrySdk$Type) &&
        other is $InternalSentrySdk$Type;
  }
}

/// from: `io.sentry.android.replay.ReplayIntegration`
class ReplayIntegration extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ReplayIntegration> $type;

  @jni$_.internal
  ReplayIntegration.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/android/replay/ReplayIntegration');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ReplayIntegration$NullableType();
  static const type = $ReplayIntegration$Type();
  static final _id_new$ = _class.constructorId(
    r'(Landroid/content/Context;Lio/sentry/transport/ICurrentDateProvider;Lkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(android.content.Context context, io.sentry.transport.ICurrentDateProvider iCurrentDateProvider, kotlin.jvm.functions.Function0<? extends io.sentry.android.replay.Recorder> function0, kotlin.jvm.functions.Function1<? super io.sentry.protocol.SentryId, io.sentry.android.replay.ReplayCache> function1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ReplayIntegration(
    jni$_.JObject context,
    jni$_.JObject iCurrentDateProvider,
    jni$_.JObject? function0,
    jni$_.JObject? function1,
  ) {
    final _$context = context.reference;
    final _$iCurrentDateProvider = iCurrentDateProvider.reference;
    final _$function0 = function0?.reference ?? jni$_.jNullReference;
    final _$function1 = function1?.reference ?? jni$_.jNullReference;
    return ReplayIntegration.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$iCurrentDateProvider.pointer,
            _$function0.pointer,
            _$function1.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Landroid/content/Context;Lio/sentry/transport/ICurrentDateProvider;Lkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(android.content.Context context, io.sentry.transport.ICurrentDateProvider iCurrentDateProvider, kotlin.jvm.functions.Function0 function0, kotlin.jvm.functions.Function1 function1, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ReplayIntegration.new$1(
    jni$_.JObject? context,
    jni$_.JObject? iCurrentDateProvider,
    jni$_.JObject? function0,
    jni$_.JObject? function1,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$context = context?.reference ?? jni$_.jNullReference;
    final _$iCurrentDateProvider =
        iCurrentDateProvider?.reference ?? jni$_.jNullReference;
    final _$function0 = function0?.reference ?? jni$_.jNullReference;
    final _$function1 = function1?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return ReplayIntegration.fromReference(_new$1(
            _class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$iCurrentDateProvider.pointer,
            _$function0.pointer,
            _$function1.pointer,
            i,
            _$defaultConstructorMarker.pointer)
        .reference);
  }

  static final _id_new$2 = _class.constructorId(
    r'(Landroid/content/Context;Lio/sentry/transport/ICurrentDateProvider;)V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(android.content.Context context, io.sentry.transport.ICurrentDateProvider iCurrentDateProvider)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ReplayIntegration.new$2(
    jni$_.JObject context,
    jni$_.JObject iCurrentDateProvider,
  ) {
    final _$context = context.reference;
    final _$iCurrentDateProvider = iCurrentDateProvider.reference;
    return ReplayIntegration.fromReference(_new$2(
            _class.reference.pointer,
            _id_new$2 as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$iCurrentDateProvider.pointer)
        .reference);
  }

  static final _id_new$3 = _class.constructorId(
    r'(Landroid/content/Context;Lio/sentry/transport/ICurrentDateProvider;Lkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;Lio/sentry/android/replay/util/MainLooperHandler;Lkotlin/jvm/functions/Function0;)V',
  );

  static final _new$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(android.content.Context context, io.sentry.transport.ICurrentDateProvider iCurrentDateProvider, kotlin.jvm.functions.Function0<? extends io.sentry.android.replay.Recorder> function0, kotlin.jvm.functions.Function1<? super io.sentry.protocol.SentryId, io.sentry.android.replay.ReplayCache> function1, kotlin.jvm.functions.Function1<? super java.lang.Boolean, ? extends io.sentry.android.replay.capture.CaptureStrategy> function11, io.sentry.android.replay.util.MainLooperHandler mainLooperHandler, kotlin.jvm.functions.Function0<io.sentry.android.replay.gestures.GestureRecorder> function01)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ReplayIntegration.new$3(
    jni$_.JObject context,
    jni$_.JObject iCurrentDateProvider,
    jni$_.JObject? function0,
    jni$_.JObject? function1,
    jni$_.JObject? function11,
    jni$_.JObject? mainLooperHandler,
    jni$_.JObject? function01,
  ) {
    final _$context = context.reference;
    final _$iCurrentDateProvider = iCurrentDateProvider.reference;
    final _$function0 = function0?.reference ?? jni$_.jNullReference;
    final _$function1 = function1?.reference ?? jni$_.jNullReference;
    final _$function11 = function11?.reference ?? jni$_.jNullReference;
    final _$mainLooperHandler =
        mainLooperHandler?.reference ?? jni$_.jNullReference;
    final _$function01 = function01?.reference ?? jni$_.jNullReference;
    return ReplayIntegration.fromReference(_new$3(
            _class.reference.pointer,
            _id_new$3 as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$iCurrentDateProvider.pointer,
            _$function0.pointer,
            _$function1.pointer,
            _$function11.pointer,
            _$mainLooperHandler.pointer,
            _$function01.pointer)
        .reference);
  }

  static final _id_new$4 = _class.constructorId(
    r'(Landroid/content/Context;Lio/sentry/transport/ICurrentDateProvider;Lkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;Lio/sentry/android/replay/util/MainLooperHandler;Lkotlin/jvm/functions/Function0;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(android.content.Context context, io.sentry.transport.ICurrentDateProvider iCurrentDateProvider, kotlin.jvm.functions.Function0 function0, kotlin.jvm.functions.Function1 function1, kotlin.jvm.functions.Function1 function11, io.sentry.android.replay.util.MainLooperHandler mainLooperHandler, kotlin.jvm.functions.Function0 function01, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ReplayIntegration.new$4(
    jni$_.JObject? context,
    jni$_.JObject? iCurrentDateProvider,
    jni$_.JObject? function0,
    jni$_.JObject? function1,
    jni$_.JObject? function11,
    jni$_.JObject? mainLooperHandler,
    jni$_.JObject? function01,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$context = context?.reference ?? jni$_.jNullReference;
    final _$iCurrentDateProvider =
        iCurrentDateProvider?.reference ?? jni$_.jNullReference;
    final _$function0 = function0?.reference ?? jni$_.jNullReference;
    final _$function1 = function1?.reference ?? jni$_.jNullReference;
    final _$function11 = function11?.reference ?? jni$_.jNullReference;
    final _$mainLooperHandler =
        mainLooperHandler?.reference ?? jni$_.jNullReference;
    final _$function01 = function01?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return ReplayIntegration.fromReference(_new$4(
            _class.reference.pointer,
            _id_new$4 as jni$_.JMethodIDPtr,
            _$context.pointer,
            _$iCurrentDateProvider.pointer,
            _$function0.pointer,
            _$function1.pointer,
            _$function11.pointer,
            _$mainLooperHandler.pointer,
            _$function01.pointer,
            i,
            _$defaultConstructorMarker.pointer)
        .reference);
  }

  static final _id_getReplayCacheDir = _class.instanceMethodId(
    r'getReplayCacheDir',
    r'()Ljava/io/File;',
  );

  static final _getReplayCacheDir = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.io.File getReplayCacheDir()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getReplayCacheDir() {
    return _getReplayCacheDir(
            reference.pointer, _id_getReplayCacheDir as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_register = _class.instanceMethodId(
    r'register',
    r'(Lio/sentry/IScopes;Lio/sentry/SentryOptions;)V',
  );

  static final _register = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void register(io.sentry.IScopes iScopes, io.sentry.SentryOptions sentryOptions)`
  void register(
    jni$_.JObject iScopes,
    jni$_.JObject sentryOptions,
  ) {
    final _$iScopes = iScopes.reference;
    final _$sentryOptions = sentryOptions.reference;
    _register(reference.pointer, _id_register as jni$_.JMethodIDPtr,
            _$iScopes.pointer, _$sentryOptions.pointer)
        .check();
  }

  static final _id_isRecording = _class.instanceMethodId(
    r'isRecording',
    r'()Z',
  );

  static final _isRecording = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isRecording()`
  bool isRecording() {
    return _isRecording(
            reference.pointer, _id_isRecording as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_start = _class.instanceMethodId(
    r'start',
    r'()V',
  );

  static final _start = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void start()`
  void start() {
    _start(reference.pointer, _id_start as jni$_.JMethodIDPtr).check();
  }

  static final _id_resume = _class.instanceMethodId(
    r'resume',
    r'()V',
  );

  static final _resume = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void resume()`
  void resume() {
    _resume(reference.pointer, _id_resume as jni$_.JMethodIDPtr).check();
  }

  static final _id_captureReplay = _class.instanceMethodId(
    r'captureReplay',
    r'(Ljava/lang/Boolean;)V',
  );

  static final _captureReplay = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void captureReplay(java.lang.Boolean boolean)`
  void captureReplay(
    jni$_.JBoolean? boolean,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    _captureReplay(reference.pointer, _id_captureReplay as jni$_.JMethodIDPtr,
            _$boolean.pointer)
        .check();
  }

  static final _id_getReplayId = _class.instanceMethodId(
    r'getReplayId',
    r'()Lio/sentry/protocol/SentryId;',
  );

  static final _getReplayId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.SentryId getReplayId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getReplayId() {
    return _getReplayId(
            reference.pointer, _id_getReplayId as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setBreadcrumbConverter = _class.instanceMethodId(
    r'setBreadcrumbConverter',
    r'(Lio/sentry/ReplayBreadcrumbConverter;)V',
  );

  static final _setBreadcrumbConverter = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setBreadcrumbConverter(io.sentry.ReplayBreadcrumbConverter replayBreadcrumbConverter)`
  void setBreadcrumbConverter(
    jni$_.JObject replayBreadcrumbConverter,
  ) {
    final _$replayBreadcrumbConverter = replayBreadcrumbConverter.reference;
    _setBreadcrumbConverter(
            reference.pointer,
            _id_setBreadcrumbConverter as jni$_.JMethodIDPtr,
            _$replayBreadcrumbConverter.pointer)
        .check();
  }

  static final _id_getBreadcrumbConverter = _class.instanceMethodId(
    r'getBreadcrumbConverter',
    r'()Lio/sentry/ReplayBreadcrumbConverter;',
  );

  static final _getBreadcrumbConverter = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ReplayBreadcrumbConverter getBreadcrumbConverter()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getBreadcrumbConverter() {
    return _getBreadcrumbConverter(
            reference.pointer, _id_getBreadcrumbConverter as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_pause = _class.instanceMethodId(
    r'pause',
    r'()V',
  );

  static final _pause = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void pause()`
  void pause() {
    _pause(reference.pointer, _id_pause as jni$_.JMethodIDPtr).check();
  }

  static final _id_enableDebugMaskingOverlay = _class.instanceMethodId(
    r'enableDebugMaskingOverlay',
    r'()V',
  );

  static final _enableDebugMaskingOverlay = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void enableDebugMaskingOverlay()`
  void enableDebugMaskingOverlay() {
    _enableDebugMaskingOverlay(reference.pointer,
            _id_enableDebugMaskingOverlay as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_disableDebugMaskingOverlay = _class.instanceMethodId(
    r'disableDebugMaskingOverlay',
    r'()V',
  );

  static final _disableDebugMaskingOverlay =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public void disableDebugMaskingOverlay()`
  void disableDebugMaskingOverlay() {
    _disableDebugMaskingOverlay(reference.pointer,
            _id_disableDebugMaskingOverlay as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_isDebugMaskingOverlayEnabled = _class.instanceMethodId(
    r'isDebugMaskingOverlayEnabled',
    r'()Z',
  );

  static final _isDebugMaskingOverlayEnabled =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isDebugMaskingOverlayEnabled()`
  bool isDebugMaskingOverlayEnabled() {
    return _isDebugMaskingOverlayEnabled(reference.pointer,
            _id_isDebugMaskingOverlayEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_stop = _class.instanceMethodId(
    r'stop',
    r'()V',
  );

  static final _stop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void stop()`
  void stop() {
    _stop(reference.pointer, _id_stop as jni$_.JMethodIDPtr).check();
  }

  static final _id_onScreenshotRecorded = _class.instanceMethodId(
    r'onScreenshotRecorded',
    r'(Landroid/graphics/Bitmap;)V',
  );

  static final _onScreenshotRecorded = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onScreenshotRecorded(android.graphics.Bitmap bitmap)`
  void onScreenshotRecorded(
    Bitmap bitmap,
  ) {
    final _$bitmap = bitmap.reference;
    _onScreenshotRecorded(reference.pointer,
            _id_onScreenshotRecorded as jni$_.JMethodIDPtr, _$bitmap.pointer)
        .check();
  }

  static final _id_onScreenshotRecorded$1 = _class.instanceMethodId(
    r'onScreenshotRecorded',
    r'(Ljava/io/File;J)V',
  );

  static final _onScreenshotRecorded$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public void onScreenshotRecorded(java.io.File file, long j)`
  void onScreenshotRecorded$1(
    jni$_.JObject file,
    int j,
  ) {
    final _$file = file.reference;
    _onScreenshotRecorded$1(reference.pointer,
            _id_onScreenshotRecorded$1 as jni$_.JMethodIDPtr, _$file.pointer, j)
        .check();
  }

  static final _id_close = _class.instanceMethodId(
    r'close',
    r'()V',
  );

  static final _close = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_onConnectionStatusChanged = _class.instanceMethodId(
    r'onConnectionStatusChanged',
    r'(Lio/sentry/IConnectionStatusProvider$ConnectionStatus;)V',
  );

  static final _onConnectionStatusChanged = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onConnectionStatusChanged(io.sentry.IConnectionStatusProvider$ConnectionStatus connectionStatus)`
  void onConnectionStatusChanged(
    jni$_.JObject connectionStatus,
  ) {
    final _$connectionStatus = connectionStatus.reference;
    _onConnectionStatusChanged(
            reference.pointer,
            _id_onConnectionStatusChanged as jni$_.JMethodIDPtr,
            _$connectionStatus.pointer)
        .check();
  }

  static final _id_onRateLimitChanged = _class.instanceMethodId(
    r'onRateLimitChanged',
    r'(Lio/sentry/transport/RateLimiter;)V',
  );

  static final _onRateLimitChanged = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onRateLimitChanged(io.sentry.transport.RateLimiter rateLimiter)`
  void onRateLimitChanged(
    jni$_.JObject rateLimiter,
  ) {
    final _$rateLimiter = rateLimiter.reference;
    _onRateLimitChanged(reference.pointer,
            _id_onRateLimitChanged as jni$_.JMethodIDPtr, _$rateLimiter.pointer)
        .check();
  }

  static final _id_onTouchEvent = _class.instanceMethodId(
    r'onTouchEvent',
    r'(Landroid/view/MotionEvent;)V',
  );

  static final _onTouchEvent = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onTouchEvent(android.view.MotionEvent motionEvent)`
  void onTouchEvent(
    jni$_.JObject motionEvent,
  ) {
    final _$motionEvent = motionEvent.reference;
    _onTouchEvent(reference.pointer, _id_onTouchEvent as jni$_.JMethodIDPtr,
            _$motionEvent.pointer)
        .check();
  }

  static final _id_onWindowSizeChanged = _class.instanceMethodId(
    r'onWindowSizeChanged',
    r'(II)V',
  );

  static final _onWindowSizeChanged = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int)>();

  /// from: `public void onWindowSizeChanged(int i, int i1)`
  void onWindowSizeChanged(
    int i,
    int i1,
  ) {
    _onWindowSizeChanged(reference.pointer,
            _id_onWindowSizeChanged as jni$_.JMethodIDPtr, i, i1)
        .check();
  }

  static final _id_onConfigurationChanged = _class.instanceMethodId(
    r'onConfigurationChanged',
    r'(Lio/sentry/android/replay/ScreenshotRecorderConfig;)V',
  );

  static final _onConfigurationChanged = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void onConfigurationChanged(io.sentry.android.replay.ScreenshotRecorderConfig screenshotRecorderConfig)`
  void onConfigurationChanged(
    jni$_.JObject screenshotRecorderConfig,
  ) {
    final _$screenshotRecorderConfig = screenshotRecorderConfig.reference;
    _onConfigurationChanged(
            reference.pointer,
            _id_onConfigurationChanged as jni$_.JMethodIDPtr,
            _$screenshotRecorderConfig.pointer)
        .check();
  }
}

final class $ReplayIntegration$NullableType
    extends jni$_.JObjType<ReplayIntegration?> {
  @jni$_.internal
  const $ReplayIntegration$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/replay/ReplayIntegration;';

  @jni$_.internal
  @core$_.override
  ReplayIntegration? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ReplayIntegration.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ReplayIntegration?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ReplayIntegration$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ReplayIntegration$NullableType) &&
        other is $ReplayIntegration$NullableType;
  }
}

final class $ReplayIntegration$Type extends jni$_.JObjType<ReplayIntegration> {
  @jni$_.internal
  const $ReplayIntegration$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/android/replay/ReplayIntegration;';

  @jni$_.internal
  @core$_.override
  ReplayIntegration fromReference(jni$_.JReference reference) =>
      ReplayIntegration.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ReplayIntegration?> get nullableType =>
      const $ReplayIntegration$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ReplayIntegration$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ReplayIntegration$Type) &&
        other is $ReplayIntegration$Type;
  }
}

/// from: `io.sentry.flutter.SentryFlutterPlugin$Companion`
class SentryFlutterPlugin$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryFlutterPlugin$Companion> $type;

  @jni$_.internal
  SentryFlutterPlugin$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/flutter/SentryFlutterPlugin$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryFlutterPlugin$Companion$NullableType();
  static const type = $SentryFlutterPlugin$Companion$Type();
  static final _id_privateSentryGetReplayIntegration = _class.instanceMethodId(
    r'privateSentryGetReplayIntegration',
    r'()Lio/sentry/android/replay/ReplayIntegration;',
  );

  static final _privateSentryGetReplayIntegration =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public final io.sentry.android.replay.ReplayIntegration privateSentryGetReplayIntegration()`
  /// The returned object must be released after use, by calling the [release] method.
  ReplayIntegration? privateSentryGetReplayIntegration() {
    return _privateSentryGetReplayIntegration(reference.pointer,
            _id_privateSentryGetReplayIntegration as jni$_.JMethodIDPtr)
        .object<ReplayIntegration?>(const $ReplayIntegration$NullableType());
  }

  static final _id_crash = _class.instanceMethodId(
    r'crash',
    r'()V',
  );

  static final _crash = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final void crash()`
  void crash() {
    _crash(reference.pointer, _id_crash as jni$_.JMethodIDPtr).check();
  }

  static final _id_getDisplayRefreshRate = _class.instanceMethodId(
    r'getDisplayRefreshRate',
    r'()Ljava/lang/Integer;',
  );

  static final _getDisplayRefreshRate = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Integer getDisplayRefreshRate()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JInteger? getDisplayRefreshRate() {
    return _getDisplayRefreshRate(
            reference.pointer, _id_getDisplayRefreshRate as jni$_.JMethodIDPtr)
        .object<jni$_.JInteger?>(const jni$_.JIntegerNullableType());
  }

  static final _id_fetchNativeAppStartAsBytes = _class.instanceMethodId(
    r'fetchNativeAppStartAsBytes',
    r'()[B',
  );

  static final _fetchNativeAppStartAsBytes =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public final byte[] fetchNativeAppStartAsBytes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? fetchNativeAppStartAsBytes() {
    return _fetchNativeAppStartAsBytes(reference.pointer,
            _id_fetchNativeAppStartAsBytes as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_getApplicationContext = _class.instanceMethodId(
    r'getApplicationContext',
    r'()Landroid/content/Context;',
  );

  static final _getApplicationContext = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final android.content.Context getApplicationContext()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getApplicationContext() {
    return _getApplicationContext(
            reference.pointer, _id_getApplicationContext as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_loadContextsAsBytes = _class.instanceMethodId(
    r'loadContextsAsBytes',
    r'()[B',
  );

  static final _loadContextsAsBytes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final byte[] loadContextsAsBytes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? loadContextsAsBytes() {
    return _loadContextsAsBytes(
            reference.pointer, _id_loadContextsAsBytes as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_loadDebugImagesAsBytes = _class.instanceMethodId(
    r'loadDebugImagesAsBytes',
    r'(Ljava/util/Set;)[B',
  );

  static final _loadDebugImagesAsBytes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final byte[] loadDebugImagesAsBytes(java.util.Set<java.lang.String> set)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? loadDebugImagesAsBytes(
    jni$_.JSet<jni$_.JString> set,
  ) {
    final _$set = set.reference;
    return _loadDebugImagesAsBytes(reference.pointer,
            _id_loadDebugImagesAsBytes as jni$_.JMethodIDPtr, _$set.pointer)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryFlutterPlugin$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return SentryFlutterPlugin$Companion.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $SentryFlutterPlugin$Companion$NullableType
    extends jni$_.JObjType<SentryFlutterPlugin$Companion?> {
  @jni$_.internal
  const $SentryFlutterPlugin$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/flutter/SentryFlutterPlugin$Companion;';

  @jni$_.internal
  @core$_.override
  SentryFlutterPlugin$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryFlutterPlugin$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryFlutterPlugin$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryFlutterPlugin$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryFlutterPlugin$Companion$NullableType) &&
        other is $SentryFlutterPlugin$Companion$NullableType;
  }
}

final class $SentryFlutterPlugin$Companion$Type
    extends jni$_.JObjType<SentryFlutterPlugin$Companion> {
  @jni$_.internal
  const $SentryFlutterPlugin$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/flutter/SentryFlutterPlugin$Companion;';

  @jni$_.internal
  @core$_.override
  SentryFlutterPlugin$Companion fromReference(jni$_.JReference reference) =>
      SentryFlutterPlugin$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryFlutterPlugin$Companion?> get nullableType =>
      const $SentryFlutterPlugin$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryFlutterPlugin$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryFlutterPlugin$Companion$Type) &&
        other is $SentryFlutterPlugin$Companion$Type;
  }
}

/// from: `io.sentry.flutter.SentryFlutterPlugin`
class SentryFlutterPlugin extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SentryFlutterPlugin> $type;

  @jni$_.internal
  SentryFlutterPlugin.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/flutter/SentryFlutterPlugin');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SentryFlutterPlugin$NullableType();
  static const type = $SentryFlutterPlugin$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Lio/sentry/flutter/SentryFlutterPlugin$Companion;',
  );

  /// from: `static public final io.sentry.flutter.SentryFlutterPlugin$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static SentryFlutterPlugin$Companion get Companion =>
      _id_Companion.get(_class, const $SentryFlutterPlugin$Companion$Type());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SentryFlutterPlugin() {
    return SentryFlutterPlugin.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_onAttachedToEngine = _class.instanceMethodId(
    r'onAttachedToEngine',
    r'(Lio/flutter/embedding/engine/plugins/FlutterPlugin$FlutterPluginBinding;)V',
  );

  static final _onAttachedToEngine = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onAttachedToEngine(io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding flutterPluginBinding)`
  void onAttachedToEngine(
    jni$_.JObject flutterPluginBinding,
  ) {
    final _$flutterPluginBinding = flutterPluginBinding.reference;
    _onAttachedToEngine(
            reference.pointer,
            _id_onAttachedToEngine as jni$_.JMethodIDPtr,
            _$flutterPluginBinding.pointer)
        .check();
  }

  static final _id_onMethodCall = _class.instanceMethodId(
    r'onMethodCall',
    r'(Lio/flutter/plugin/common/MethodCall;Lio/flutter/plugin/common/MethodChannel$Result;)V',
  );

  static final _onMethodCall = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onMethodCall(io.flutter.plugin.common.MethodCall methodCall, io.flutter.plugin.common.MethodChannel$Result result)`
  void onMethodCall(
    jni$_.JObject methodCall,
    jni$_.JObject result,
  ) {
    final _$methodCall = methodCall.reference;
    final _$result = result.reference;
    _onMethodCall(reference.pointer, _id_onMethodCall as jni$_.JMethodIDPtr,
            _$methodCall.pointer, _$result.pointer)
        .check();
  }

  static final _id_onDetachedFromEngine = _class.instanceMethodId(
    r'onDetachedFromEngine',
    r'(Lio/flutter/embedding/engine/plugins/FlutterPlugin$FlutterPluginBinding;)V',
  );

  static final _onDetachedFromEngine = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onDetachedFromEngine(io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding flutterPluginBinding)`
  void onDetachedFromEngine(
    jni$_.JObject flutterPluginBinding,
  ) {
    final _$flutterPluginBinding = flutterPluginBinding.reference;
    _onDetachedFromEngine(
            reference.pointer,
            _id_onDetachedFromEngine as jni$_.JMethodIDPtr,
            _$flutterPluginBinding.pointer)
        .check();
  }

  static final _id_onAttachedToActivity = _class.instanceMethodId(
    r'onAttachedToActivity',
    r'(Lio/flutter/embedding/engine/plugins/activity/ActivityPluginBinding;)V',
  );

  static final _onAttachedToActivity = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onAttachedToActivity(io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding activityPluginBinding)`
  void onAttachedToActivity(
    jni$_.JObject activityPluginBinding,
  ) {
    final _$activityPluginBinding = activityPluginBinding.reference;
    _onAttachedToActivity(
            reference.pointer,
            _id_onAttachedToActivity as jni$_.JMethodIDPtr,
            _$activityPluginBinding.pointer)
        .check();
  }

  static final _id_onDetachedFromActivity = _class.instanceMethodId(
    r'onDetachedFromActivity',
    r'()V',
  );

  static final _onDetachedFromActivity = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void onDetachedFromActivity()`
  void onDetachedFromActivity() {
    _onDetachedFromActivity(
            reference.pointer, _id_onDetachedFromActivity as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_onReattachedToActivityForConfigChanges =
      _class.instanceMethodId(
    r'onReattachedToActivityForConfigChanges',
    r'(Lio/flutter/embedding/engine/plugins/activity/ActivityPluginBinding;)V',
  );

  static final _onReattachedToActivityForConfigChanges =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onReattachedToActivityForConfigChanges(io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding activityPluginBinding)`
  void onReattachedToActivityForConfigChanges(
    jni$_.JObject activityPluginBinding,
  ) {
    final _$activityPluginBinding = activityPluginBinding.reference;
    _onReattachedToActivityForConfigChanges(
            reference.pointer,
            _id_onReattachedToActivityForConfigChanges as jni$_.JMethodIDPtr,
            _$activityPluginBinding.pointer)
        .check();
  }

  static final _id_onDetachedFromActivityForConfigChanges =
      _class.instanceMethodId(
    r'onDetachedFromActivityForConfigChanges',
    r'()V',
  );

  static final _onDetachedFromActivityForConfigChanges =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public void onDetachedFromActivityForConfigChanges()`
  void onDetachedFromActivityForConfigChanges() {
    _onDetachedFromActivityForConfigChanges(reference.pointer,
            _id_onDetachedFromActivityForConfigChanges as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_privateSentryGetReplayIntegration = _class.staticMethodId(
    r'privateSentryGetReplayIntegration',
    r'()Lio/sentry/android/replay/ReplayIntegration;',
  );

  static final _privateSentryGetReplayIntegration =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `static public final io.sentry.android.replay.ReplayIntegration privateSentryGetReplayIntegration()`
  /// The returned object must be released after use, by calling the [release] method.
  static ReplayIntegration? privateSentryGetReplayIntegration() {
    return _privateSentryGetReplayIntegration(_class.reference.pointer,
            _id_privateSentryGetReplayIntegration as jni$_.JMethodIDPtr)
        .object<ReplayIntegration?>(const $ReplayIntegration$NullableType());
  }

  static final _id_crash = _class.staticMethodId(
    r'crash',
    r'()V',
  );

  static final _crash = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public final void crash()`
  static void crash() {
    _crash(_class.reference.pointer, _id_crash as jni$_.JMethodIDPtr).check();
  }

  static final _id_getDisplayRefreshRate = _class.staticMethodId(
    r'getDisplayRefreshRate',
    r'()Ljava/lang/Integer;',
  );

  static final _getDisplayRefreshRate = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public final java.lang.Integer getDisplayRefreshRate()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JInteger? getDisplayRefreshRate() {
    return _getDisplayRefreshRate(_class.reference.pointer,
            _id_getDisplayRefreshRate as jni$_.JMethodIDPtr)
        .object<jni$_.JInteger?>(const jni$_.JIntegerNullableType());
  }

  static final _id_fetchNativeAppStartAsBytes = _class.staticMethodId(
    r'fetchNativeAppStartAsBytes',
    r'()[B',
  );

  static final _fetchNativeAppStartAsBytes =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `static public final byte[] fetchNativeAppStartAsBytes()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JByteArray? fetchNativeAppStartAsBytes() {
    return _fetchNativeAppStartAsBytes(_class.reference.pointer,
            _id_fetchNativeAppStartAsBytes as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_getApplicationContext = _class.staticMethodId(
    r'getApplicationContext',
    r'()Landroid/content/Context;',
  );

  static final _getApplicationContext = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public final android.content.Context getApplicationContext()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? getApplicationContext() {
    return _getApplicationContext(_class.reference.pointer,
            _id_getApplicationContext as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_loadContextsAsBytes = _class.staticMethodId(
    r'loadContextsAsBytes',
    r'()[B',
  );

  static final _loadContextsAsBytes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public final byte[] loadContextsAsBytes()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JByteArray? loadContextsAsBytes() {
    return _loadContextsAsBytes(_class.reference.pointer,
            _id_loadContextsAsBytes as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_loadDebugImagesAsBytes = _class.staticMethodId(
    r'loadDebugImagesAsBytes',
    r'(Ljava/util/Set;)[B',
  );

  static final _loadDebugImagesAsBytes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public final byte[] loadDebugImagesAsBytes(java.util.Set<java.lang.String> set)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JByteArray? loadDebugImagesAsBytes(
    jni$_.JSet<jni$_.JString?> set,
  ) {
    final _$set = set.reference;
    return _loadDebugImagesAsBytes(_class.reference.pointer,
            _id_loadDebugImagesAsBytes as jni$_.JMethodIDPtr, _$set.pointer)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }
}

final class $SentryFlutterPlugin$NullableType
    extends jni$_.JObjType<SentryFlutterPlugin?> {
  @jni$_.internal
  const $SentryFlutterPlugin$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/flutter/SentryFlutterPlugin;';

  @jni$_.internal
  @core$_.override
  SentryFlutterPlugin? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SentryFlutterPlugin.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryFlutterPlugin?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryFlutterPlugin$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryFlutterPlugin$NullableType) &&
        other is $SentryFlutterPlugin$NullableType;
  }
}

final class $SentryFlutterPlugin$Type
    extends jni$_.JObjType<SentryFlutterPlugin> {
  @jni$_.internal
  const $SentryFlutterPlugin$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/flutter/SentryFlutterPlugin;';

  @jni$_.internal
  @core$_.override
  SentryFlutterPlugin fromReference(jni$_.JReference reference) =>
      SentryFlutterPlugin.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SentryFlutterPlugin?> get nullableType =>
      const $SentryFlutterPlugin$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SentryFlutterPlugin$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SentryFlutterPlugin$Type) &&
        other is $SentryFlutterPlugin$Type;
  }
}

/// from: `io.sentry.Sentry$OptionsConfiguration`
class Sentry$OptionsConfiguration<$T extends jni$_.JObject?>
    extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Sentry$OptionsConfiguration<$T>> $type;

  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  Sentry$OptionsConfiguration.fromReference(
    this.T,
    jni$_.JReference reference,
  )   : $type = type<$T>(T),
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/Sentry$OptionsConfiguration');

  /// The type which includes information such as the signature of this class.
  static $Sentry$OptionsConfiguration$NullableType<$T>
      nullableType<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) {
    return $Sentry$OptionsConfiguration$NullableType<$T>(
      T,
    );
  }

  static $Sentry$OptionsConfiguration$Type<$T> type<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) {
    return $Sentry$OptionsConfiguration$Type<$T>(
      T,
    );
  }

  static final _id_configure = _class.instanceMethodId(
    r'configure',
    r'(Lio/sentry/SentryOptions;)V',
  );

  static final _configure = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void configure(T sentryOptions)`
  void configure(
    $T sentryOptions,
  ) {
    final _$sentryOptions = sentryOptions?.reference ?? jni$_.jNullReference;
    _configure(reference.pointer, _id_configure as jni$_.JMethodIDPtr,
            _$sentryOptions.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Sentry$OptionsConfiguration> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'configure(Lio/sentry/SentryOptions;)V') {
        _$impls[$p]!.configure(
          $a![0]?.as(_$impls[$p]!.T, releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn<$T extends jni$_.JObject?>(
    jni$_.JImplementer implementer,
    $Sentry$OptionsConfiguration<$T> $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.Sentry$OptionsConfiguration',
      $p,
      _$invokePointer,
      [
        if ($impl.configure$async) r'configure(Lio/sentry/SentryOptions;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Sentry$OptionsConfiguration.implement(
    $Sentry$OptionsConfiguration<$T> $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Sentry$OptionsConfiguration<$T>.fromReference(
      $impl.T,
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Sentry$OptionsConfiguration<
    $T extends jni$_.JObject?> {
  factory $Sentry$OptionsConfiguration({
    required jni$_.JObjType<$T> T,
    required void Function($T sentryOptions) configure,
    bool configure$async,
  }) = _$Sentry$OptionsConfiguration<$T>;

  jni$_.JObjType<$T> get T;

  void configure($T sentryOptions);
  bool get configure$async => false;
}

final class _$Sentry$OptionsConfiguration<$T extends jni$_.JObject?>
    with $Sentry$OptionsConfiguration<$T> {
  _$Sentry$OptionsConfiguration({
    required this.T,
    required void Function($T sentryOptions) configure,
    this.configure$async = false,
  }) : _configure = configure;

  @core$_.override
  final jni$_.JObjType<$T> T;

  final void Function($T sentryOptions) _configure;
  final bool configure$async;

  void configure($T sentryOptions) {
    return _configure(sentryOptions);
  }
}

final class $Sentry$OptionsConfiguration$NullableType<$T extends jni$_.JObject?>
    extends jni$_.JObjType<Sentry$OptionsConfiguration<$T>?> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $Sentry$OptionsConfiguration$NullableType(
    this.T,
  );

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Sentry$OptionsConfiguration;';

  @jni$_.internal
  @core$_.override
  Sentry$OptionsConfiguration<$T>? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Sentry$OptionsConfiguration<$T>.fromReference(
              T,
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Sentry$OptionsConfiguration<$T>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($Sentry$OptionsConfiguration$NullableType, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($Sentry$OptionsConfiguration$NullableType<$T>) &&
        other is $Sentry$OptionsConfiguration$NullableType<$T> &&
        T == other.T;
  }
}

final class $Sentry$OptionsConfiguration$Type<$T extends jni$_.JObject?>
    extends jni$_.JObjType<Sentry$OptionsConfiguration<$T>> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $Sentry$OptionsConfiguration$Type(
    this.T,
  );

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Sentry$OptionsConfiguration;';

  @jni$_.internal
  @core$_.override
  Sentry$OptionsConfiguration<$T> fromReference(jni$_.JReference reference) =>
      Sentry$OptionsConfiguration<$T>.fromReference(
        T,
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Sentry$OptionsConfiguration<$T>?> get nullableType =>
      $Sentry$OptionsConfiguration$NullableType<$T>(T);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($Sentry$OptionsConfiguration$Type, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Sentry$OptionsConfiguration$Type<$T>) &&
        other is $Sentry$OptionsConfiguration$Type<$T> &&
        T == other.T;
  }
}

/// from: `io.sentry.Sentry`
class Sentry extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Sentry> $type;

  @jni$_.internal
  Sentry.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/Sentry');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Sentry$NullableType();
  static const type = $Sentry$Type();
  static final _id_APP_START_PROFILING_CONFIG_FILE_NAME = _class.staticFieldId(
    r'APP_START_PROFILING_CONFIG_FILE_NAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String APP_START_PROFILING_CONFIG_FILE_NAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString get APP_START_PROFILING_CONFIG_FILE_NAME =>
      _id_APP_START_PROFILING_CONFIG_FILE_NAME.get(
          _class, const jni$_.JStringType());

  static final _id_getCurrentHub = _class.staticMethodId(
    r'getCurrentHub',
    r'()Lio/sentry/IHub;',
  );

  static final _getCurrentHub = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.IHub getCurrentHub()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getCurrentHub() {
    return _getCurrentHub(
            _class.reference.pointer, _id_getCurrentHub as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getCurrentScopes = _class.staticMethodId(
    r'getCurrentScopes',
    r'()Lio/sentry/IScopes;',
  );

  static final _getCurrentScopes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.IScopes getCurrentScopes()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getCurrentScopes() {
    return _getCurrentScopes(_class.reference.pointer,
            _id_getCurrentScopes as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_forkedRootScopes = _class.staticMethodId(
    r'forkedRootScopes',
    r'(Ljava/lang/String;)Lio/sentry/IScopes;',
  );

  static final _forkedRootScopes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.IScopes forkedRootScopes(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject forkedRootScopes(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _forkedRootScopes(_class.reference.pointer,
            _id_forkedRootScopes as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_forkedScopes = _class.staticMethodId(
    r'forkedScopes',
    r'(Ljava/lang/String;)Lio/sentry/IScopes;',
  );

  static final _forkedScopes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.IScopes forkedScopes(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject forkedScopes(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _forkedScopes(_class.reference.pointer,
            _id_forkedScopes as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_forkedCurrentScope = _class.staticMethodId(
    r'forkedCurrentScope',
    r'(Ljava/lang/String;)Lio/sentry/IScopes;',
  );

  static final _forkedCurrentScope = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.IScopes forkedCurrentScope(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject forkedCurrentScope(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _forkedCurrentScope(_class.reference.pointer,
            _id_forkedCurrentScope as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setCurrentHub = _class.staticMethodId(
    r'setCurrentHub',
    r'(Lio/sentry/IHub;)Lio/sentry/ISentryLifecycleToken;',
  );

  static final _setCurrentHub = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.ISentryLifecycleToken setCurrentHub(io.sentry.IHub iHub)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject setCurrentHub(
    jni$_.JObject iHub,
  ) {
    final _$iHub = iHub.reference;
    return _setCurrentHub(_class.reference.pointer,
            _id_setCurrentHub as jni$_.JMethodIDPtr, _$iHub.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setCurrentScopes = _class.staticMethodId(
    r'setCurrentScopes',
    r'(Lio/sentry/IScopes;)Lio/sentry/ISentryLifecycleToken;',
  );

  static final _setCurrentScopes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.ISentryLifecycleToken setCurrentScopes(io.sentry.IScopes iScopes)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject setCurrentScopes(
    jni$_.JObject iScopes,
  ) {
    final _$iScopes = iScopes.reference;
    return _setCurrentScopes(_class.reference.pointer,
            _id_setCurrentScopes as jni$_.JMethodIDPtr, _$iScopes.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getGlobalScope = _class.staticMethodId(
    r'getGlobalScope',
    r'()Lio/sentry/IScope;',
  );

  static final _getGlobalScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.IScope getGlobalScope()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getGlobalScope() {
    return _getGlobalScope(
            _class.reference.pointer, _id_getGlobalScope as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_isEnabled = _class.staticMethodId(
    r'isEnabled',
    r'()Z',
  );

  static final _isEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public boolean isEnabled()`
  static bool isEnabled() {
    return _isEnabled(
            _class.reference.pointer, _id_isEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_init = _class.staticMethodId(
    r'init',
    r'()V',
  );

  static final _init = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public void init()`
  static void init() {
    _init(_class.reference.pointer, _id_init as jni$_.JMethodIDPtr).check();
  }

  static final _id_init$1 = _class.staticMethodId(
    r'init',
    r'(Ljava/lang/String;)V',
  );

  static final _init$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void init(java.lang.String string)`
  static void init$1(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _init$1(_class.reference.pointer, _id_init$1 as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_init$2 = _class.staticMethodId(
    r'init',
    r'(Lio/sentry/OptionsContainer;Lio/sentry/Sentry$OptionsConfiguration;)V',
  );

  static final _init$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void init(io.sentry.OptionsContainer<T> optionsContainer, io.sentry.Sentry$OptionsConfiguration<T> optionsConfiguration)`
  static void init$2<$T extends jni$_.JObject?>(
    jni$_.JObject optionsContainer,
    Sentry$OptionsConfiguration<$T?> optionsConfiguration, {
    jni$_.JObjType<$T>? T,
  }) {
    T ??= jni$_.lowestCommonSuperType([
      (optionsConfiguration.$type
              as $Sentry$OptionsConfiguration$Type<core$_.dynamic>)
          .T,
    ]) as jni$_.JObjType<$T>;
    final _$optionsContainer = optionsContainer.reference;
    final _$optionsConfiguration = optionsConfiguration.reference;
    _init$2(_class.reference.pointer, _id_init$2 as jni$_.JMethodIDPtr,
            _$optionsContainer.pointer, _$optionsConfiguration.pointer)
        .check();
  }

  static final _id_init$3 = _class.staticMethodId(
    r'init',
    r'(Lio/sentry/OptionsContainer;Lio/sentry/Sentry$OptionsConfiguration;Z)V',
  );

  static final _init$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `static public void init(io.sentry.OptionsContainer<T> optionsContainer, io.sentry.Sentry$OptionsConfiguration<T> optionsConfiguration, boolean z)`
  static void init$3<$T extends jni$_.JObject?>(
    jni$_.JObject optionsContainer,
    Sentry$OptionsConfiguration<$T?> optionsConfiguration,
    bool z, {
    jni$_.JObjType<$T>? T,
  }) {
    T ??= jni$_.lowestCommonSuperType([
      (optionsConfiguration.$type
              as $Sentry$OptionsConfiguration$Type<core$_.dynamic>)
          .T,
    ]) as jni$_.JObjType<$T>;
    final _$optionsContainer = optionsContainer.reference;
    final _$optionsConfiguration = optionsConfiguration.reference;
    _init$3(
            _class.reference.pointer,
            _id_init$3 as jni$_.JMethodIDPtr,
            _$optionsContainer.pointer,
            _$optionsConfiguration.pointer,
            z ? 1 : 0)
        .check();
  }

  static final _id_init$4 = _class.staticMethodId(
    r'init',
    r'(Lio/sentry/Sentry$OptionsConfiguration;)V',
  );

  static final _init$4 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void init(io.sentry.Sentry$OptionsConfiguration<io.sentry.SentryOptions> optionsConfiguration)`
  static void init$4(
    Sentry$OptionsConfiguration<jni$_.JObject?> optionsConfiguration,
  ) {
    final _$optionsConfiguration = optionsConfiguration.reference;
    _init$4(_class.reference.pointer, _id_init$4 as jni$_.JMethodIDPtr,
            _$optionsConfiguration.pointer)
        .check();
  }

  static final _id_init$5 = _class.staticMethodId(
    r'init',
    r'(Lio/sentry/Sentry$OptionsConfiguration;Z)V',
  );

  static final _init$5 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `static public void init(io.sentry.Sentry$OptionsConfiguration<io.sentry.SentryOptions> optionsConfiguration, boolean z)`
  static void init$5(
    Sentry$OptionsConfiguration<jni$_.JObject?> optionsConfiguration,
    bool z,
  ) {
    final _$optionsConfiguration = optionsConfiguration.reference;
    _init$5(_class.reference.pointer, _id_init$5 as jni$_.JMethodIDPtr,
            _$optionsConfiguration.pointer, z ? 1 : 0)
        .check();
  }

  static final _id_init$6 = _class.staticMethodId(
    r'init',
    r'(Lio/sentry/SentryOptions;)V',
  );

  static final _init$6 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void init(io.sentry.SentryOptions sentryOptions)`
  static void init$6(
    jni$_.JObject sentryOptions,
  ) {
    final _$sentryOptions = sentryOptions.reference;
    _init$6(_class.reference.pointer, _id_init$6 as jni$_.JMethodIDPtr,
            _$sentryOptions.pointer)
        .check();
  }

  static final _id_close = _class.staticMethodId(
    r'close',
    r'()V',
  );

  static final _close = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public void close()`
  static void close() {
    _close(_class.reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_captureEvent = _class.staticMethodId(
    r'captureEvent',
    r'(Lio/sentry/SentryEvent;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureEvent = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureEvent(io.sentry.SentryEvent sentryEvent)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject captureEvent(
    jni$_.JObject sentryEvent,
  ) {
    final _$sentryEvent = sentryEvent.reference;
    return _captureEvent(_class.reference.pointer,
            _id_captureEvent as jni$_.JMethodIDPtr, _$sentryEvent.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureEvent$1 = _class.staticMethodId(
    r'captureEvent',
    r'(Lio/sentry/SentryEvent;Lio/sentry/ScopeCallback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureEvent$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureEvent(io.sentry.SentryEvent sentryEvent, io.sentry.ScopeCallback scopeCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject captureEvent$1(
    jni$_.JObject sentryEvent,
    ScopeCallback scopeCallback,
  ) {
    final _$sentryEvent = sentryEvent.reference;
    final _$scopeCallback = scopeCallback.reference;
    return _captureEvent$1(
            _class.reference.pointer,
            _id_captureEvent$1 as jni$_.JMethodIDPtr,
            _$sentryEvent.pointer,
            _$scopeCallback.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureEvent$2 = _class.staticMethodId(
    r'captureEvent',
    r'(Lio/sentry/SentryEvent;Lio/sentry/Hint;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureEvent$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureEvent(io.sentry.SentryEvent sentryEvent, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject captureEvent$2(
    jni$_.JObject sentryEvent,
    jni$_.JObject? hint,
  ) {
    final _$sentryEvent = sentryEvent.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    return _captureEvent$2(
            _class.reference.pointer,
            _id_captureEvent$2 as jni$_.JMethodIDPtr,
            _$sentryEvent.pointer,
            _$hint.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureEvent$3 = _class.staticMethodId(
    r'captureEvent',
    r'(Lio/sentry/SentryEvent;Lio/sentry/Hint;Lio/sentry/ScopeCallback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureEvent$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureEvent(io.sentry.SentryEvent sentryEvent, io.sentry.Hint hint, io.sentry.ScopeCallback scopeCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject captureEvent$3(
    jni$_.JObject sentryEvent,
    jni$_.JObject? hint,
    ScopeCallback scopeCallback,
  ) {
    final _$sentryEvent = sentryEvent.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    final _$scopeCallback = scopeCallback.reference;
    return _captureEvent$3(
            _class.reference.pointer,
            _id_captureEvent$3 as jni$_.JMethodIDPtr,
            _$sentryEvent.pointer,
            _$hint.pointer,
            _$scopeCallback.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureMessage = _class.staticMethodId(
    r'captureMessage',
    r'(Ljava/lang/String;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureMessage = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureMessage(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject captureMessage(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _captureMessage(_class.reference.pointer,
            _id_captureMessage as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureMessage$1 = _class.staticMethodId(
    r'captureMessage',
    r'(Ljava/lang/String;Lio/sentry/ScopeCallback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureMessage$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureMessage(java.lang.String string, io.sentry.ScopeCallback scopeCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject captureMessage$1(
    jni$_.JString string,
    ScopeCallback scopeCallback,
  ) {
    final _$string = string.reference;
    final _$scopeCallback = scopeCallback.reference;
    return _captureMessage$1(
            _class.reference.pointer,
            _id_captureMessage$1 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$scopeCallback.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureMessage$2 = _class.staticMethodId(
    r'captureMessage',
    r'(Ljava/lang/String;Lio/sentry/SentryLevel;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureMessage$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureMessage(java.lang.String string, io.sentry.SentryLevel sentryLevel)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject captureMessage$2(
    jni$_.JString string,
    jni$_.JObject sentryLevel,
  ) {
    final _$string = string.reference;
    final _$sentryLevel = sentryLevel.reference;
    return _captureMessage$2(
            _class.reference.pointer,
            _id_captureMessage$2 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$sentryLevel.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureMessage$3 = _class.staticMethodId(
    r'captureMessage',
    r'(Ljava/lang/String;Lio/sentry/SentryLevel;Lio/sentry/ScopeCallback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureMessage$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureMessage(java.lang.String string, io.sentry.SentryLevel sentryLevel, io.sentry.ScopeCallback scopeCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject captureMessage$3(
    jni$_.JString string,
    jni$_.JObject sentryLevel,
    ScopeCallback scopeCallback,
  ) {
    final _$string = string.reference;
    final _$sentryLevel = sentryLevel.reference;
    final _$scopeCallback = scopeCallback.reference;
    return _captureMessage$3(
            _class.reference.pointer,
            _id_captureMessage$3 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$sentryLevel.pointer,
            _$scopeCallback.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureFeedback = _class.staticMethodId(
    r'captureFeedback',
    r'(Lio/sentry/protocol/Feedback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureFeedback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureFeedback(io.sentry.protocol.Feedback feedback)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject captureFeedback(
    jni$_.JObject feedback,
  ) {
    final _$feedback = feedback.reference;
    return _captureFeedback(_class.reference.pointer,
            _id_captureFeedback as jni$_.JMethodIDPtr, _$feedback.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureFeedback$1 = _class.staticMethodId(
    r'captureFeedback',
    r'(Lio/sentry/protocol/Feedback;Lio/sentry/Hint;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureFeedback$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureFeedback(io.sentry.protocol.Feedback feedback, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject captureFeedback$1(
    jni$_.JObject feedback,
    jni$_.JObject? hint,
  ) {
    final _$feedback = feedback.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    return _captureFeedback$1(
            _class.reference.pointer,
            _id_captureFeedback$1 as jni$_.JMethodIDPtr,
            _$feedback.pointer,
            _$hint.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureFeedback$2 = _class.staticMethodId(
    r'captureFeedback',
    r'(Lio/sentry/protocol/Feedback;Lio/sentry/Hint;Lio/sentry/ScopeCallback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureFeedback$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureFeedback(io.sentry.protocol.Feedback feedback, io.sentry.Hint hint, io.sentry.ScopeCallback scopeCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject captureFeedback$2(
    jni$_.JObject feedback,
    jni$_.JObject? hint,
    ScopeCallback? scopeCallback,
  ) {
    final _$feedback = feedback.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    final _$scopeCallback = scopeCallback?.reference ?? jni$_.jNullReference;
    return _captureFeedback$2(
            _class.reference.pointer,
            _id_captureFeedback$2 as jni$_.JMethodIDPtr,
            _$feedback.pointer,
            _$hint.pointer,
            _$scopeCallback.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureException = _class.staticMethodId(
    r'captureException',
    r'(Ljava/lang/Throwable;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureException = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureException(java.lang.Throwable throwable)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject captureException(
    jni$_.JObject throwable,
  ) {
    final _$throwable = throwable.reference;
    return _captureException(_class.reference.pointer,
            _id_captureException as jni$_.JMethodIDPtr, _$throwable.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureException$1 = _class.staticMethodId(
    r'captureException',
    r'(Ljava/lang/Throwable;Lio/sentry/ScopeCallback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureException$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureException(java.lang.Throwable throwable, io.sentry.ScopeCallback scopeCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject captureException$1(
    jni$_.JObject throwable,
    ScopeCallback scopeCallback,
  ) {
    final _$throwable = throwable.reference;
    final _$scopeCallback = scopeCallback.reference;
    return _captureException$1(
            _class.reference.pointer,
            _id_captureException$1 as jni$_.JMethodIDPtr,
            _$throwable.pointer,
            _$scopeCallback.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureException$2 = _class.staticMethodId(
    r'captureException',
    r'(Ljava/lang/Throwable;Lio/sentry/Hint;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureException$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureException(java.lang.Throwable throwable, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject captureException$2(
    jni$_.JObject throwable,
    jni$_.JObject? hint,
  ) {
    final _$throwable = throwable.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    return _captureException$2(
            _class.reference.pointer,
            _id_captureException$2 as jni$_.JMethodIDPtr,
            _$throwable.pointer,
            _$hint.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureException$3 = _class.staticMethodId(
    r'captureException',
    r'(Ljava/lang/Throwable;Lio/sentry/Hint;Lio/sentry/ScopeCallback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureException$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureException(java.lang.Throwable throwable, io.sentry.Hint hint, io.sentry.ScopeCallback scopeCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject captureException$3(
    jni$_.JObject throwable,
    jni$_.JObject? hint,
    ScopeCallback scopeCallback,
  ) {
    final _$throwable = throwable.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    final _$scopeCallback = scopeCallback.reference;
    return _captureException$3(
            _class.reference.pointer,
            _id_captureException$3 as jni$_.JMethodIDPtr,
            _$throwable.pointer,
            _$hint.pointer,
            _$scopeCallback.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureUserFeedback = _class.staticMethodId(
    r'captureUserFeedback',
    r'(Lio/sentry/UserFeedback;)V',
  );

  static final _captureUserFeedback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void captureUserFeedback(io.sentry.UserFeedback userFeedback)`
  static void captureUserFeedback(
    jni$_.JObject userFeedback,
  ) {
    final _$userFeedback = userFeedback.reference;
    _captureUserFeedback(
            _class.reference.pointer,
            _id_captureUserFeedback as jni$_.JMethodIDPtr,
            _$userFeedback.pointer)
        .check();
  }

  static final _id_addBreadcrumb = _class.staticMethodId(
    r'addBreadcrumb',
    r'(Lio/sentry/Breadcrumb;Lio/sentry/Hint;)V',
  );

  static final _addBreadcrumb = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void addBreadcrumb(io.sentry.Breadcrumb breadcrumb, io.sentry.Hint hint)`
  static void addBreadcrumb(
    Breadcrumb breadcrumb,
    jni$_.JObject? hint,
  ) {
    final _$breadcrumb = breadcrumb.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    _addBreadcrumb(
            _class.reference.pointer,
            _id_addBreadcrumb as jni$_.JMethodIDPtr,
            _$breadcrumb.pointer,
            _$hint.pointer)
        .check();
  }

  static final _id_addBreadcrumb$1 = _class.staticMethodId(
    r'addBreadcrumb',
    r'(Lio/sentry/Breadcrumb;)V',
  );

  static final _addBreadcrumb$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void addBreadcrumb(io.sentry.Breadcrumb breadcrumb)`
  static void addBreadcrumb$1(
    Breadcrumb breadcrumb,
  ) {
    final _$breadcrumb = breadcrumb.reference;
    _addBreadcrumb$1(_class.reference.pointer,
            _id_addBreadcrumb$1 as jni$_.JMethodIDPtr, _$breadcrumb.pointer)
        .check();
  }

  static final _id_addBreadcrumb$2 = _class.staticMethodId(
    r'addBreadcrumb',
    r'(Ljava/lang/String;)V',
  );

  static final _addBreadcrumb$2 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void addBreadcrumb(java.lang.String string)`
  static void addBreadcrumb$2(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _addBreadcrumb$2(_class.reference.pointer,
            _id_addBreadcrumb$2 as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_addBreadcrumb$3 = _class.staticMethodId(
    r'addBreadcrumb',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _addBreadcrumb$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void addBreadcrumb(java.lang.String string, java.lang.String string1)`
  static void addBreadcrumb$3(
    jni$_.JString string,
    jni$_.JString string1,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    _addBreadcrumb$3(
            _class.reference.pointer,
            _id_addBreadcrumb$3 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer)
        .check();
  }

  static final _id_setLevel = _class.staticMethodId(
    r'setLevel',
    r'(Lio/sentry/SentryLevel;)V',
  );

  static final _setLevel = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void setLevel(io.sentry.SentryLevel sentryLevel)`
  static void setLevel(
    jni$_.JObject? sentryLevel,
  ) {
    final _$sentryLevel = sentryLevel?.reference ?? jni$_.jNullReference;
    _setLevel(_class.reference.pointer, _id_setLevel as jni$_.JMethodIDPtr,
            _$sentryLevel.pointer)
        .check();
  }

  static final _id_setTransaction = _class.staticMethodId(
    r'setTransaction',
    r'(Ljava/lang/String;)V',
  );

  static final _setTransaction = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void setTransaction(java.lang.String string)`
  static void setTransaction(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setTransaction(_class.reference.pointer,
            _id_setTransaction as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_setUser = _class.staticMethodId(
    r'setUser',
    r'(Lio/sentry/protocol/User;)V',
  );

  static final _setUser = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void setUser(io.sentry.protocol.User user)`
  static void setUser(
    User? user,
  ) {
    final _$user = user?.reference ?? jni$_.jNullReference;
    _setUser(_class.reference.pointer, _id_setUser as jni$_.JMethodIDPtr,
            _$user.pointer)
        .check();
  }

  static final _id_setFingerprint = _class.staticMethodId(
    r'setFingerprint',
    r'(Ljava/util/List;)V',
  );

  static final _setFingerprint = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void setFingerprint(java.util.List<java.lang.String> list)`
  static void setFingerprint(
    jni$_.JList<jni$_.JString?> list,
  ) {
    final _$list = list.reference;
    _setFingerprint(_class.reference.pointer,
            _id_setFingerprint as jni$_.JMethodIDPtr, _$list.pointer)
        .check();
  }

  static final _id_clearBreadcrumbs = _class.staticMethodId(
    r'clearBreadcrumbs',
    r'()V',
  );

  static final _clearBreadcrumbs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public void clearBreadcrumbs()`
  static void clearBreadcrumbs() {
    _clearBreadcrumbs(_class.reference.pointer,
            _id_clearBreadcrumbs as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_setTag = _class.staticMethodId(
    r'setTag',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setTag = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void setTag(java.lang.String string, java.lang.String string1)`
  static void setTag(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setTag(_class.reference.pointer, _id_setTag as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  static final _id_removeTag = _class.staticMethodId(
    r'removeTag',
    r'(Ljava/lang/String;)V',
  );

  static final _removeTag = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void removeTag(java.lang.String string)`
  static void removeTag(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _removeTag(_class.reference.pointer, _id_removeTag as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_setExtra = _class.staticMethodId(
    r'setExtra',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setExtra = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void setExtra(java.lang.String string, java.lang.String string1)`
  static void setExtra(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setExtra(_class.reference.pointer, _id_setExtra as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  static final _id_removeExtra = _class.staticMethodId(
    r'removeExtra',
    r'(Ljava/lang/String;)V',
  );

  static final _removeExtra = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void removeExtra(java.lang.String string)`
  static void removeExtra(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _removeExtra(_class.reference.pointer,
            _id_removeExtra as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_getLastEventId = _class.staticMethodId(
    r'getLastEventId',
    r'()Lio/sentry/protocol/SentryId;',
  );

  static final _getLastEventId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.protocol.SentryId getLastEventId()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getLastEventId() {
    return _getLastEventId(
            _class.reference.pointer, _id_getLastEventId as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_pushScope = _class.staticMethodId(
    r'pushScope',
    r'()Lio/sentry/ISentryLifecycleToken;',
  );

  static final _pushScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.ISentryLifecycleToken pushScope()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject pushScope() {
    return _pushScope(
            _class.reference.pointer, _id_pushScope as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_pushIsolationScope = _class.staticMethodId(
    r'pushIsolationScope',
    r'()Lio/sentry/ISentryLifecycleToken;',
  );

  static final _pushIsolationScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.ISentryLifecycleToken pushIsolationScope()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject pushIsolationScope() {
    return _pushIsolationScope(_class.reference.pointer,
            _id_pushIsolationScope as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_popScope = _class.staticMethodId(
    r'popScope',
    r'()V',
  );

  static final _popScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public void popScope()`
  static void popScope() {
    _popScope(_class.reference.pointer, _id_popScope as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_withScope = _class.staticMethodId(
    r'withScope',
    r'(Lio/sentry/ScopeCallback;)V',
  );

  static final _withScope = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void withScope(io.sentry.ScopeCallback scopeCallback)`
  static void withScope(
    ScopeCallback scopeCallback,
  ) {
    final _$scopeCallback = scopeCallback.reference;
    _withScope(_class.reference.pointer, _id_withScope as jni$_.JMethodIDPtr,
            _$scopeCallback.pointer)
        .check();
  }

  static final _id_withIsolationScope = _class.staticMethodId(
    r'withIsolationScope',
    r'(Lio/sentry/ScopeCallback;)V',
  );

  static final _withIsolationScope = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void withIsolationScope(io.sentry.ScopeCallback scopeCallback)`
  static void withIsolationScope(
    ScopeCallback scopeCallback,
  ) {
    final _$scopeCallback = scopeCallback.reference;
    _withIsolationScope(
            _class.reference.pointer,
            _id_withIsolationScope as jni$_.JMethodIDPtr,
            _$scopeCallback.pointer)
        .check();
  }

  static final _id_configureScope = _class.staticMethodId(
    r'configureScope',
    r'(Lio/sentry/ScopeCallback;)V',
  );

  static final _configureScope = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void configureScope(io.sentry.ScopeCallback scopeCallback)`
  static void configureScope(
    ScopeCallback scopeCallback,
  ) {
    final _$scopeCallback = scopeCallback.reference;
    _configureScope(_class.reference.pointer,
            _id_configureScope as jni$_.JMethodIDPtr, _$scopeCallback.pointer)
        .check();
  }

  static final _id_configureScope$1 = _class.staticMethodId(
    r'configureScope',
    r'(Lio/sentry/ScopeType;Lio/sentry/ScopeCallback;)V',
  );

  static final _configureScope$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void configureScope(io.sentry.ScopeType scopeType, io.sentry.ScopeCallback scopeCallback)`
  static void configureScope$1(
    jni$_.JObject? scopeType,
    ScopeCallback scopeCallback,
  ) {
    final _$scopeType = scopeType?.reference ?? jni$_.jNullReference;
    final _$scopeCallback = scopeCallback.reference;
    _configureScope$1(
            _class.reference.pointer,
            _id_configureScope$1 as jni$_.JMethodIDPtr,
            _$scopeType.pointer,
            _$scopeCallback.pointer)
        .check();
  }

  static final _id_bindClient = _class.staticMethodId(
    r'bindClient',
    r'(Lio/sentry/ISentryClient;)V',
  );

  static final _bindClient = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void bindClient(io.sentry.ISentryClient iSentryClient)`
  static void bindClient(
    jni$_.JObject iSentryClient,
  ) {
    final _$iSentryClient = iSentryClient.reference;
    _bindClient(_class.reference.pointer, _id_bindClient as jni$_.JMethodIDPtr,
            _$iSentryClient.pointer)
        .check();
  }

  static final _id_isHealthy = _class.staticMethodId(
    r'isHealthy',
    r'()Z',
  );

  static final _isHealthy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public boolean isHealthy()`
  static bool isHealthy() {
    return _isHealthy(
            _class.reference.pointer, _id_isHealthy as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_flush = _class.staticMethodId(
    r'flush',
    r'(J)V',
  );

  static final _flush = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public void flush(long j)`
  static void flush(
    int j,
  ) {
    _flush(_class.reference.pointer, _id_flush as jni$_.JMethodIDPtr, j)
        .check();
  }

  static final _id_startSession = _class.staticMethodId(
    r'startSession',
    r'()V',
  );

  static final _startSession = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public void startSession()`
  static void startSession() {
    _startSession(
            _class.reference.pointer, _id_startSession as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_endSession = _class.staticMethodId(
    r'endSession',
    r'()V',
  );

  static final _endSession = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public void endSession()`
  static void endSession() {
    _endSession(_class.reference.pointer, _id_endSession as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_startTransaction = _class.staticMethodId(
    r'startTransaction',
    r'(Ljava/lang/String;Ljava/lang/String;)Lio/sentry/ITransaction;',
  );

  static final _startTransaction = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.ITransaction startTransaction(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject startTransaction(
    jni$_.JString string,
    jni$_.JString string1,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    return _startTransaction(
            _class.reference.pointer,
            _id_startTransaction as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_startTransaction$1 = _class.staticMethodId(
    r'startTransaction',
    r'(Ljava/lang/String;Ljava/lang/String;Lio/sentry/TransactionOptions;)Lio/sentry/ITransaction;',
  );

  static final _startTransaction$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.ITransaction startTransaction(java.lang.String string, java.lang.String string1, io.sentry.TransactionOptions transactionOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject startTransaction$1(
    jni$_.JString string,
    jni$_.JString string1,
    jni$_.JObject transactionOptions,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    final _$transactionOptions = transactionOptions.reference;
    return _startTransaction$1(
            _class.reference.pointer,
            _id_startTransaction$1 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$transactionOptions.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_startTransaction$2 = _class.staticMethodId(
    r'startTransaction',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lio/sentry/TransactionOptions;)Lio/sentry/ITransaction;',
  );

  static final _startTransaction$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.ITransaction startTransaction(java.lang.String string, java.lang.String string1, java.lang.String string2, io.sentry.TransactionOptions transactionOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject startTransaction$2(
    jni$_.JString string,
    jni$_.JString string1,
    jni$_.JString? string2,
    jni$_.JObject transactionOptions,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    final _$transactionOptions = transactionOptions.reference;
    return _startTransaction$2(
            _class.reference.pointer,
            _id_startTransaction$2 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$string2.pointer,
            _$transactionOptions.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_startTransaction$3 = _class.staticMethodId(
    r'startTransaction',
    r'(Lio/sentry/TransactionContext;)Lio/sentry/ITransaction;',
  );

  static final _startTransaction$3 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.ITransaction startTransaction(io.sentry.TransactionContext transactionContext)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject startTransaction$3(
    jni$_.JObject transactionContext,
  ) {
    final _$transactionContext = transactionContext.reference;
    return _startTransaction$3(
            _class.reference.pointer,
            _id_startTransaction$3 as jni$_.JMethodIDPtr,
            _$transactionContext.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_startTransaction$4 = _class.staticMethodId(
    r'startTransaction',
    r'(Lio/sentry/TransactionContext;Lio/sentry/TransactionOptions;)Lio/sentry/ITransaction;',
  );

  static final _startTransaction$4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.ITransaction startTransaction(io.sentry.TransactionContext transactionContext, io.sentry.TransactionOptions transactionOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject startTransaction$4(
    jni$_.JObject transactionContext,
    jni$_.JObject transactionOptions,
  ) {
    final _$transactionContext = transactionContext.reference;
    final _$transactionOptions = transactionOptions.reference;
    return _startTransaction$4(
            _class.reference.pointer,
            _id_startTransaction$4 as jni$_.JMethodIDPtr,
            _$transactionContext.pointer,
            _$transactionOptions.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_startProfiler = _class.staticMethodId(
    r'startProfiler',
    r'()V',
  );

  static final _startProfiler = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public void startProfiler()`
  static void startProfiler() {
    _startProfiler(
            _class.reference.pointer, _id_startProfiler as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_stopProfiler = _class.staticMethodId(
    r'stopProfiler',
    r'()V',
  );

  static final _stopProfiler = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public void stopProfiler()`
  static void stopProfiler() {
    _stopProfiler(
            _class.reference.pointer, _id_stopProfiler as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_getSpan = _class.staticMethodId(
    r'getSpan',
    r'()Lio/sentry/ISpan;',
  );

  static final _getSpan = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.ISpan getSpan()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? getSpan() {
    return _getSpan(_class.reference.pointer, _id_getSpan as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_isCrashedLastRun = _class.staticMethodId(
    r'isCrashedLastRun',
    r'()Ljava/lang/Boolean;',
  );

  static final _isCrashedLastRun = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.lang.Boolean isCrashedLastRun()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JBoolean? isCrashedLastRun() {
    return _isCrashedLastRun(_class.reference.pointer,
            _id_isCrashedLastRun as jni$_.JMethodIDPtr)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_reportFullyDisplayed = _class.staticMethodId(
    r'reportFullyDisplayed',
    r'()V',
  );

  static final _reportFullyDisplayed = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public void reportFullyDisplayed()`
  static void reportFullyDisplayed() {
    _reportFullyDisplayed(_class.reference.pointer,
            _id_reportFullyDisplayed as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_continueTrace = _class.staticMethodId(
    r'continueTrace',
    r'(Ljava/lang/String;Ljava/util/List;)Lio/sentry/TransactionContext;',
  );

  static final _continueTrace = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.TransactionContext continueTrace(java.lang.String string, java.util.List<java.lang.String> list)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? continueTrace(
    jni$_.JString? string,
    jni$_.JList<jni$_.JString?>? list,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _continueTrace(
            _class.reference.pointer,
            _id_continueTrace as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$list.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getTraceparent = _class.staticMethodId(
    r'getTraceparent',
    r'()Lio/sentry/SentryTraceHeader;',
  );

  static final _getTraceparent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.SentryTraceHeader getTraceparent()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? getTraceparent() {
    return _getTraceparent(
            _class.reference.pointer, _id_getTraceparent as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getBaggage = _class.staticMethodId(
    r'getBaggage',
    r'()Lio/sentry/BaggageHeader;',
  );

  static final _getBaggage = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.BaggageHeader getBaggage()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? getBaggage() {
    return _getBaggage(
            _class.reference.pointer, _id_getBaggage as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_captureCheckIn = _class.staticMethodId(
    r'captureCheckIn',
    r'(Lio/sentry/CheckIn;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureCheckIn = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.SentryId captureCheckIn(io.sentry.CheckIn checkIn)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject captureCheckIn(
    jni$_.JObject checkIn,
  ) {
    final _$checkIn = checkIn.reference;
    return _captureCheckIn(_class.reference.pointer,
            _id_captureCheckIn as jni$_.JMethodIDPtr, _$checkIn.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_logger = _class.staticMethodId(
    r'logger',
    r'()Lio/sentry/logger/ILoggerApi;',
  );

  static final _logger = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.logger.ILoggerApi logger()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject logger() {
    return _logger(_class.reference.pointer, _id_logger as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_replay = _class.staticMethodId(
    r'replay',
    r'()Lio/sentry/IReplayApi;',
  );

  static final _replay = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.IReplayApi replay()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject replay() {
    return _replay(_class.reference.pointer, _id_replay as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_showUserFeedbackDialog = _class.staticMethodId(
    r'showUserFeedbackDialog',
    r'()V',
  );

  static final _showUserFeedbackDialog = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public void showUserFeedbackDialog()`
  static void showUserFeedbackDialog() {
    _showUserFeedbackDialog(_class.reference.pointer,
            _id_showUserFeedbackDialog as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_showUserFeedbackDialog$1 = _class.staticMethodId(
    r'showUserFeedbackDialog',
    r'(Lio/sentry/SentryFeedbackOptions$OptionsConfigurator;)V',
  );

  static final _showUserFeedbackDialog$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void showUserFeedbackDialog(io.sentry.SentryFeedbackOptions$OptionsConfigurator optionsConfigurator)`
  static void showUserFeedbackDialog$1(
    jni$_.JObject? optionsConfigurator,
  ) {
    final _$optionsConfigurator =
        optionsConfigurator?.reference ?? jni$_.jNullReference;
    _showUserFeedbackDialog$1(
            _class.reference.pointer,
            _id_showUserFeedbackDialog$1 as jni$_.JMethodIDPtr,
            _$optionsConfigurator.pointer)
        .check();
  }

  static final _id_showUserFeedbackDialog$2 = _class.staticMethodId(
    r'showUserFeedbackDialog',
    r'(Lio/sentry/protocol/SentryId;Lio/sentry/SentryFeedbackOptions$OptionsConfigurator;)V',
  );

  static final _showUserFeedbackDialog$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void showUserFeedbackDialog(io.sentry.protocol.SentryId sentryId, io.sentry.SentryFeedbackOptions$OptionsConfigurator optionsConfigurator)`
  static void showUserFeedbackDialog$2(
    jni$_.JObject? sentryId,
    jni$_.JObject? optionsConfigurator,
  ) {
    final _$sentryId = sentryId?.reference ?? jni$_.jNullReference;
    final _$optionsConfigurator =
        optionsConfigurator?.reference ?? jni$_.jNullReference;
    _showUserFeedbackDialog$2(
            _class.reference.pointer,
            _id_showUserFeedbackDialog$2 as jni$_.JMethodIDPtr,
            _$sentryId.pointer,
            _$optionsConfigurator.pointer)
        .check();
  }
}

final class $Sentry$NullableType extends jni$_.JObjType<Sentry?> {
  @jni$_.internal
  const $Sentry$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Sentry;';

  @jni$_.internal
  @core$_.override
  Sentry? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Sentry.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Sentry?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Sentry$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Sentry$NullableType) &&
        other is $Sentry$NullableType;
  }
}

final class $Sentry$Type extends jni$_.JObjType<Sentry> {
  @jni$_.internal
  const $Sentry$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Sentry;';

  @jni$_.internal
  @core$_.override
  Sentry fromReference(jni$_.JReference reference) => Sentry.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Sentry?> get nullableType => const $Sentry$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Sentry$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Sentry$Type) && other is $Sentry$Type;
  }
}

/// from: `io.sentry.Breadcrumb$Deserializer`
class Breadcrumb$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Breadcrumb$Deserializer> $type;

  @jni$_.internal
  Breadcrumb$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/Breadcrumb$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Breadcrumb$Deserializer$NullableType();
  static const type = $Breadcrumb$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Breadcrumb$Deserializer() {
    return Breadcrumb$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserialize = _class.instanceMethodId(
    r'deserialize',
    r'(Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Lio/sentry/Breadcrumb;',
  );

  static final _deserialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.Breadcrumb deserialize(io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  /// The returned object must be released after use, by calling the [release] method.
  Breadcrumb deserialize(
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserialize(
            reference.pointer,
            _id_deserialize as jni$_.JMethodIDPtr,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }
}

final class $Breadcrumb$Deserializer$NullableType
    extends jni$_.JObjType<Breadcrumb$Deserializer?> {
  @jni$_.internal
  const $Breadcrumb$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Breadcrumb$Deserializer;';

  @jni$_.internal
  @core$_.override
  Breadcrumb$Deserializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Breadcrumb$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Breadcrumb$Deserializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Breadcrumb$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Breadcrumb$Deserializer$NullableType) &&
        other is $Breadcrumb$Deserializer$NullableType;
  }
}

final class $Breadcrumb$Deserializer$Type
    extends jni$_.JObjType<Breadcrumb$Deserializer> {
  @jni$_.internal
  const $Breadcrumb$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Breadcrumb$Deserializer;';

  @jni$_.internal
  @core$_.override
  Breadcrumb$Deserializer fromReference(jni$_.JReference reference) =>
      Breadcrumb$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Breadcrumb$Deserializer?> get nullableType =>
      const $Breadcrumb$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Breadcrumb$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Breadcrumb$Deserializer$Type) &&
        other is $Breadcrumb$Deserializer$Type;
  }
}

/// from: `io.sentry.Breadcrumb$JsonKeys`
class Breadcrumb$JsonKeys extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Breadcrumb$JsonKeys> $type;

  @jni$_.internal
  Breadcrumb$JsonKeys.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/Breadcrumb$JsonKeys');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Breadcrumb$JsonKeys$NullableType();
  static const type = $Breadcrumb$JsonKeys$Type();
  static final _id_TIMESTAMP = _class.staticFieldId(
    r'TIMESTAMP',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TIMESTAMP`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TIMESTAMP =>
      _id_TIMESTAMP.get(_class, const jni$_.JStringNullableType());

  static final _id_MESSAGE = _class.staticFieldId(
    r'MESSAGE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MESSAGE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get MESSAGE =>
      _id_MESSAGE.get(_class, const jni$_.JStringNullableType());

  static final _id_TYPE = _class.staticFieldId(
    r'TYPE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TYPE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TYPE =>
      _id_TYPE.get(_class, const jni$_.JStringNullableType());

  static final _id_DATA = _class.staticFieldId(
    r'DATA',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DATA`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DATA =>
      _id_DATA.get(_class, const jni$_.JStringNullableType());

  static final _id_CATEGORY = _class.staticFieldId(
    r'CATEGORY',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CATEGORY`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CATEGORY =>
      _id_CATEGORY.get(_class, const jni$_.JStringNullableType());

  static final _id_ORIGIN = _class.staticFieldId(
    r'ORIGIN',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ORIGIN`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ORIGIN =>
      _id_ORIGIN.get(_class, const jni$_.JStringNullableType());

  static final _id_LEVEL = _class.staticFieldId(
    r'LEVEL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LEVEL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get LEVEL =>
      _id_LEVEL.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Breadcrumb$JsonKeys() {
    return Breadcrumb$JsonKeys.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $Breadcrumb$JsonKeys$NullableType
    extends jni$_.JObjType<Breadcrumb$JsonKeys?> {
  @jni$_.internal
  const $Breadcrumb$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Breadcrumb$JsonKeys;';

  @jni$_.internal
  @core$_.override
  Breadcrumb$JsonKeys? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Breadcrumb$JsonKeys.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Breadcrumb$JsonKeys?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Breadcrumb$JsonKeys$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Breadcrumb$JsonKeys$NullableType) &&
        other is $Breadcrumb$JsonKeys$NullableType;
  }
}

final class $Breadcrumb$JsonKeys$Type
    extends jni$_.JObjType<Breadcrumb$JsonKeys> {
  @jni$_.internal
  const $Breadcrumb$JsonKeys$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Breadcrumb$JsonKeys;';

  @jni$_.internal
  @core$_.override
  Breadcrumb$JsonKeys fromReference(jni$_.JReference reference) =>
      Breadcrumb$JsonKeys.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Breadcrumb$JsonKeys?> get nullableType =>
      const $Breadcrumb$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Breadcrumb$JsonKeys$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Breadcrumb$JsonKeys$Type) &&
        other is $Breadcrumb$JsonKeys$Type;
  }
}

/// from: `io.sentry.Breadcrumb`
class Breadcrumb extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Breadcrumb> $type;

  @jni$_.internal
  Breadcrumb.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/Breadcrumb');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Breadcrumb$NullableType();
  static const type = $Breadcrumb$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/util/Date;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.util.Date date)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Breadcrumb(
    jni$_.JObject date,
  ) {
    final _$date = date.reference;
    return Breadcrumb.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$date.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(J)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void <init>(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Breadcrumb.new$1(
    int j,
  ) {
    return Breadcrumb.fromReference(
        _new$1(_class.reference.pointer, _id_new$1 as jni$_.JMethodIDPtr, j)
            .reference);
  }

  static final _id_fromMap = _class.staticMethodId(
    r'fromMap',
    r'(Ljava/util/Map;Lio/sentry/SentryOptions;)Lio/sentry/Breadcrumb;',
  );

  static final _fromMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb fromMap(java.util.Map<java.lang.String, java.lang.Object> map, io.sentry.SentryOptions sentryOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb? fromMap(
    jni$_.JMap<jni$_.JString?, jni$_.JObject?> map,
    jni$_.JObject sentryOptions,
  ) {
    final _$map = map.reference;
    final _$sentryOptions = sentryOptions.reference;
    return _fromMap(_class.reference.pointer, _id_fromMap as jni$_.JMethodIDPtr,
            _$map.pointer, _$sentryOptions.pointer)
        .object<Breadcrumb?>(const $Breadcrumb$NullableType());
  }

  static final _id_http = _class.staticMethodId(
    r'http',
    r'(Ljava/lang/String;Ljava/lang/String;)Lio/sentry/Breadcrumb;',
  );

  static final _http = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb http(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb http(
    jni$_.JString string,
    jni$_.JString string1,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    return _http(_class.reference.pointer, _id_http as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_http$1 = _class.staticMethodId(
    r'http',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/Integer;)Lio/sentry/Breadcrumb;',
  );

  static final _http$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb http(java.lang.String string, java.lang.String string1, java.lang.Integer integer)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb http$1(
    jni$_.JString string,
    jni$_.JString string1,
    jni$_.JInteger? integer,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    final _$integer = integer?.reference ?? jni$_.jNullReference;
    return _http$1(_class.reference.pointer, _id_http$1 as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer, _$integer.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_graphqlOperation = _class.staticMethodId(
    r'graphqlOperation',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lio/sentry/Breadcrumb;',
  );

  static final _graphqlOperation = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb graphqlOperation(java.lang.String string, java.lang.String string1, java.lang.String string2)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb graphqlOperation(
    jni$_.JString? string,
    jni$_.JString? string1,
    jni$_.JString? string2,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    return _graphqlOperation(
            _class.reference.pointer,
            _id_graphqlOperation as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$string2.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_graphqlDataFetcher = _class.staticMethodId(
    r'graphqlDataFetcher',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lio/sentry/Breadcrumb;',
  );

  static final _graphqlDataFetcher = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb graphqlDataFetcher(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb graphqlDataFetcher(
    jni$_.JString? string,
    jni$_.JString? string1,
    jni$_.JString? string2,
    jni$_.JString? string3,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    final _$string3 = string3?.reference ?? jni$_.jNullReference;
    return _graphqlDataFetcher(
            _class.reference.pointer,
            _id_graphqlDataFetcher as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$string2.pointer,
            _$string3.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_graphqlDataLoader = _class.staticMethodId(
    r'graphqlDataLoader',
    r'(Ljava/lang/Iterable;Ljava/lang/Class;Ljava/lang/Class;Ljava/lang/String;)Lio/sentry/Breadcrumb;',
  );

  static final _graphqlDataLoader = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb graphqlDataLoader(java.lang.Iterable<?> iterable, java.lang.Class<?> class, java.lang.Class<?> class1, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb graphqlDataLoader(
    jni$_.JObject iterable,
    jni$_.JObject? class$,
    jni$_.JObject? class1,
    jni$_.JString? string,
  ) {
    final _$iterable = iterable.reference;
    final _$class$ = class$?.reference ?? jni$_.jNullReference;
    final _$class1 = class1?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _graphqlDataLoader(
            _class.reference.pointer,
            _id_graphqlDataLoader as jni$_.JMethodIDPtr,
            _$iterable.pointer,
            _$class$.pointer,
            _$class1.pointer,
            _$string.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_navigation = _class.staticMethodId(
    r'navigation',
    r'(Ljava/lang/String;Ljava/lang/String;)Lio/sentry/Breadcrumb;',
  );

  static final _navigation = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb navigation(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb navigation(
    jni$_.JString string,
    jni$_.JString string1,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    return _navigation(
            _class.reference.pointer,
            _id_navigation as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_transaction = _class.staticMethodId(
    r'transaction',
    r'(Ljava/lang/String;)Lio/sentry/Breadcrumb;',
  );

  static final _transaction = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb transaction(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb transaction(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _transaction(_class.reference.pointer,
            _id_transaction as jni$_.JMethodIDPtr, _$string.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_debug = _class.staticMethodId(
    r'debug',
    r'(Ljava/lang/String;)Lio/sentry/Breadcrumb;',
  );

  static final _debug = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb debug(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb debug(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _debug(_class.reference.pointer, _id_debug as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_error = _class.staticMethodId(
    r'error',
    r'(Ljava/lang/String;)Lio/sentry/Breadcrumb;',
  );

  static final _error = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb error(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb error(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _error(_class.reference.pointer, _id_error as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_info = _class.staticMethodId(
    r'info',
    r'(Ljava/lang/String;)Lio/sentry/Breadcrumb;',
  );

  static final _info = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb info(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb info(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _info(_class.reference.pointer, _id_info as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_query = _class.staticMethodId(
    r'query',
    r'(Ljava/lang/String;)Lio/sentry/Breadcrumb;',
  );

  static final _query = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb query(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb query(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _query(_class.reference.pointer, _id_query as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_ui = _class.staticMethodId(
    r'ui',
    r'(Ljava/lang/String;Ljava/lang/String;)Lio/sentry/Breadcrumb;',
  );

  static final _ui = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb ui(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb ui(
    jni$_.JString string,
    jni$_.JString string1,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    return _ui(_class.reference.pointer, _id_ui as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_user = _class.staticMethodId(
    r'user',
    r'(Ljava/lang/String;Ljava/lang/String;)Lio/sentry/Breadcrumb;',
  );

  static final _user = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb user(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb user(
    jni$_.JString string,
    jni$_.JString string1,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    return _user(_class.reference.pointer, _id_user as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_userInteraction = _class.staticMethodId(
    r'userInteraction',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lio/sentry/Breadcrumb;',
  );

  static final _userInteraction = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb userInteraction(java.lang.String string, java.lang.String string1, java.lang.String string2)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb userInteraction(
    jni$_.JString string,
    jni$_.JString? string1,
    jni$_.JString? string2,
  ) {
    final _$string = string.reference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    return _userInteraction(
            _class.reference.pointer,
            _id_userInteraction as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$string2.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_userInteraction$1 = _class.staticMethodId(
    r'userInteraction',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/util/Map;)Lio/sentry/Breadcrumb;',
  );

  static final _userInteraction$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb userInteraction(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.util.Map<java.lang.String, java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb userInteraction$1(
    jni$_.JString string,
    jni$_.JString? string1,
    jni$_.JString? string2,
    jni$_.JString? string3,
    jni$_.JMap<jni$_.JString?, jni$_.JObject?> map,
  ) {
    final _$string = string.reference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    final _$string3 = string3?.reference ?? jni$_.jNullReference;
    final _$map = map.reference;
    return _userInteraction$1(
            _class.reference.pointer,
            _id_userInteraction$1 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$string2.pointer,
            _$string3.pointer,
            _$map.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_userInteraction$2 = _class.staticMethodId(
    r'userInteraction',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/util/Map;)Lio/sentry/Breadcrumb;',
  );

  static final _userInteraction$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.Breadcrumb userInteraction(java.lang.String string, java.lang.String string1, java.lang.String string2, java.util.Map<java.lang.String, java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  static Breadcrumb userInteraction$2(
    jni$_.JString string,
    jni$_.JString? string1,
    jni$_.JString? string2,
    jni$_.JMap<jni$_.JString?, jni$_.JObject?> map,
  ) {
    final _$string = string.reference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    final _$map = map.reference;
    return _userInteraction$2(
            _class.reference.pointer,
            _id_userInteraction$2 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$string2.pointer,
            _$map.pointer)
        .object<Breadcrumb>(const $Breadcrumb$Type());
  }

  static final _id_new$2 = _class.constructorId(
    r'()V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Breadcrumb.new$2() {
    return Breadcrumb.fromReference(
        _new$2(_class.reference.pointer, _id_new$2 as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_new$3 = _class.constructorId(
    r'(Ljava/lang/String;)V',
  );

  static final _new$3 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Breadcrumb.new$3(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return Breadcrumb.fromReference(_new$3(_class.reference.pointer,
            _id_new$3 as jni$_.JMethodIDPtr, _$string.pointer)
        .reference);
  }

  static final _id_getTimestamp = _class.instanceMethodId(
    r'getTimestamp',
    r'()Ljava/util/Date;',
  );

  static final _getTimestamp = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Date getTimestamp()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getTimestamp() {
    return _getTimestamp(
            reference.pointer, _id_getTimestamp as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getMessage = _class.instanceMethodId(
    r'getMessage',
    r'()Ljava/lang/String;',
  );

  static final _getMessage = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getMessage()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getMessage() {
    return _getMessage(reference.pointer, _id_getMessage as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setMessage = _class.instanceMethodId(
    r'setMessage',
    r'(Ljava/lang/String;)V',
  );

  static final _setMessage = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setMessage(java.lang.String string)`
  void setMessage(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setMessage(reference.pointer, _id_setMessage as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getType = _class.instanceMethodId(
    r'getType',
    r'()Ljava/lang/String;',
  );

  static final _getType = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getType()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getType() {
    return _getType(reference.pointer, _id_getType as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setType = _class.instanceMethodId(
    r'setType',
    r'(Ljava/lang/String;)V',
  );

  static final _setType = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setType(java.lang.String string)`
  void setType(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setType(reference.pointer, _id_setType as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getData = _class.instanceMethodId(
    r'getData',
    r'()Ljava/util/Map;',
  );

  static final _getData = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Map<java.lang.String, java.lang.Object> getData()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JObject?> getData() {
    return _getData(reference.pointer, _id_getData as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JString?, jni$_.JObject?>(
                jni$_.JStringNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_getData$1 = _class.instanceMethodId(
    r'getData',
    r'(Ljava/lang/String;)Ljava/lang/Object;',
  );

  static final _getData$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object getData(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getData$1(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getData$1(reference.pointer, _id_getData$1 as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setData = _class.instanceMethodId(
    r'setData',
    r'(Ljava/lang/String;Ljava/lang/Object;)V',
  );

  static final _setData = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setData(java.lang.String string, java.lang.Object object)`
  void setData(
    jni$_.JString? string,
    jni$_.JObject? object,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    _setData(reference.pointer, _id_setData as jni$_.JMethodIDPtr,
            _$string.pointer, _$object.pointer)
        .check();
  }

  static final _id_removeData = _class.instanceMethodId(
    r'removeData',
    r'(Ljava/lang/String;)V',
  );

  static final _removeData = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeData(java.lang.String string)`
  void removeData(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _removeData(reference.pointer, _id_removeData as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getCategory = _class.instanceMethodId(
    r'getCategory',
    r'()Ljava/lang/String;',
  );

  static final _getCategory = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getCategory()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getCategory() {
    return _getCategory(
            reference.pointer, _id_getCategory as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setCategory = _class.instanceMethodId(
    r'setCategory',
    r'(Ljava/lang/String;)V',
  );

  static final _setCategory = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setCategory(java.lang.String string)`
  void setCategory(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setCategory(reference.pointer, _id_setCategory as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getOrigin = _class.instanceMethodId(
    r'getOrigin',
    r'()Ljava/lang/String;',
  );

  static final _getOrigin = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getOrigin()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getOrigin() {
    return _getOrigin(reference.pointer, _id_getOrigin as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setOrigin = _class.instanceMethodId(
    r'setOrigin',
    r'(Ljava/lang/String;)V',
  );

  static final _setOrigin = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setOrigin(java.lang.String string)`
  void setOrigin(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setOrigin(reference.pointer, _id_setOrigin as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getLevel = _class.instanceMethodId(
    r'getLevel',
    r'()Lio/sentry/SentryLevel;',
  );

  static final _getLevel = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryLevel getLevel()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getLevel() {
    return _getLevel(reference.pointer, _id_getLevel as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setLevel = _class.instanceMethodId(
    r'setLevel',
    r'(Lio/sentry/SentryLevel;)V',
  );

  static final _setLevel = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setLevel(io.sentry.SentryLevel sentryLevel)`
  void setLevel(
    jni$_.JObject? sentryLevel,
  ) {
    final _$sentryLevel = sentryLevel?.reference ?? jni$_.jNullReference;
    _setLevel(reference.pointer, _id_setLevel as jni$_.JMethodIDPtr,
            _$sentryLevel.pointer)
        .check();
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getUnknown = _class.instanceMethodId(
    r'getUnknown',
    r'()Ljava/util/Map;',
  );

  static final _getUnknown = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Map<java.lang.String, java.lang.Object> getUnknown()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JObject?>? getUnknown() {
    return _getUnknown(reference.pointer, _id_getUnknown as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JObject?>(
                jni$_.JStringNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_setUnknown = _class.instanceMethodId(
    r'setUnknown',
    r'(Ljava/util/Map;)V',
  );

  static final _setUnknown = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setUnknown(java.util.Map<java.lang.String, java.lang.Object> map)`
  void setUnknown(
    jni$_.JMap<jni$_.JString?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    _setUnknown(reference.pointer, _id_setUnknown as jni$_.JMethodIDPtr,
            _$map.pointer)
        .check();
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Lio/sentry/Breadcrumb;)I',
  );

  static final _compareTo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int compareTo(io.sentry.Breadcrumb breadcrumb)`
  int compareTo(
    Breadcrumb breadcrumb,
  ) {
    final _$breadcrumb = breadcrumb.reference;
    return _compareTo(reference.pointer, _id_compareTo as jni$_.JMethodIDPtr,
            _$breadcrumb.pointer)
        .integer;
  }

  static final _id_serialize = _class.instanceMethodId(
    r'serialize',
    r'(Lio/sentry/ObjectWriter;Lio/sentry/ILogger;)V',
  );

  static final _serialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void serialize(io.sentry.ObjectWriter objectWriter, io.sentry.ILogger iLogger)`
  void serialize(
    jni$_.JObject objectWriter,
    jni$_.JObject iLogger,
  ) {
    final _$objectWriter = objectWriter.reference;
    final _$iLogger = iLogger.reference;
    _serialize(reference.pointer, _id_serialize as jni$_.JMethodIDPtr,
            _$objectWriter.pointer, _$iLogger.pointer)
        .check();
  }

  bool operator <(Breadcrumb breadcrumb) {
    return compareTo(breadcrumb) < 0;
  }

  bool operator <=(Breadcrumb breadcrumb) {
    return compareTo(breadcrumb) <= 0;
  }

  bool operator >(Breadcrumb breadcrumb) {
    return compareTo(breadcrumb) > 0;
  }

  bool operator >=(Breadcrumb breadcrumb) {
    return compareTo(breadcrumb) >= 0;
  }
}

final class $Breadcrumb$NullableType extends jni$_.JObjType<Breadcrumb?> {
  @jni$_.internal
  const $Breadcrumb$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Breadcrumb;';

  @jni$_.internal
  @core$_.override
  Breadcrumb? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Breadcrumb.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Breadcrumb?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Breadcrumb$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Breadcrumb$NullableType) &&
        other is $Breadcrumb$NullableType;
  }
}

final class $Breadcrumb$Type extends jni$_.JObjType<Breadcrumb> {
  @jni$_.internal
  const $Breadcrumb$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Breadcrumb;';

  @jni$_.internal
  @core$_.override
  Breadcrumb fromReference(jni$_.JReference reference) =>
      Breadcrumb.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Breadcrumb?> get nullableType =>
      const $Breadcrumb$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Breadcrumb$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Breadcrumb$Type) && other is $Breadcrumb$Type;
  }
}

/// from: `io.sentry.ScopesAdapter`
class ScopesAdapter extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ScopesAdapter> $type;

  @jni$_.internal
  ScopesAdapter.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/ScopesAdapter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ScopesAdapter$NullableType();
  static const type = $ScopesAdapter$Type();
  static final _id_getInstance = _class.staticMethodId(
    r'getInstance',
    r'()Lio/sentry/ScopesAdapter;',
  );

  static final _getInstance = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public io.sentry.ScopesAdapter getInstance()`
  /// The returned object must be released after use, by calling the [release] method.
  static ScopesAdapter? getInstance() {
    return _getInstance(
            _class.reference.pointer, _id_getInstance as jni$_.JMethodIDPtr)
        .object<ScopesAdapter?>(const $ScopesAdapter$NullableType());
  }

  static final _id_isEnabled = _class.instanceMethodId(
    r'isEnabled',
    r'()Z',
  );

  static final _isEnabled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEnabled()`
  bool isEnabled() {
    return _isEnabled(reference.pointer, _id_isEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_captureEvent = _class.instanceMethodId(
    r'captureEvent',
    r'(Lio/sentry/SentryEvent;Lio/sentry/Hint;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureEvent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureEvent(io.sentry.SentryEvent sentryEvent, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureEvent(
    jni$_.JObject sentryEvent,
    jni$_.JObject? hint,
  ) {
    final _$sentryEvent = sentryEvent.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    return _captureEvent(
            reference.pointer,
            _id_captureEvent as jni$_.JMethodIDPtr,
            _$sentryEvent.pointer,
            _$hint.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureEvent$1 = _class.instanceMethodId(
    r'captureEvent',
    r'(Lio/sentry/SentryEvent;Lio/sentry/Hint;Lio/sentry/ScopeCallback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureEvent$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureEvent(io.sentry.SentryEvent sentryEvent, io.sentry.Hint hint, io.sentry.ScopeCallback scopeCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureEvent$1(
    jni$_.JObject sentryEvent,
    jni$_.JObject? hint,
    ScopeCallback scopeCallback,
  ) {
    final _$sentryEvent = sentryEvent.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    final _$scopeCallback = scopeCallback.reference;
    return _captureEvent$1(
            reference.pointer,
            _id_captureEvent$1 as jni$_.JMethodIDPtr,
            _$sentryEvent.pointer,
            _$hint.pointer,
            _$scopeCallback.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureMessage = _class.instanceMethodId(
    r'captureMessage',
    r'(Ljava/lang/String;Lio/sentry/SentryLevel;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureMessage = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureMessage(java.lang.String string, io.sentry.SentryLevel sentryLevel)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureMessage(
    jni$_.JString string,
    jni$_.JObject sentryLevel,
  ) {
    final _$string = string.reference;
    final _$sentryLevel = sentryLevel.reference;
    return _captureMessage(
            reference.pointer,
            _id_captureMessage as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$sentryLevel.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureMessage$1 = _class.instanceMethodId(
    r'captureMessage',
    r'(Ljava/lang/String;Lio/sentry/SentryLevel;Lio/sentry/ScopeCallback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureMessage$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureMessage(java.lang.String string, io.sentry.SentryLevel sentryLevel, io.sentry.ScopeCallback scopeCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureMessage$1(
    jni$_.JString string,
    jni$_.JObject sentryLevel,
    ScopeCallback scopeCallback,
  ) {
    final _$string = string.reference;
    final _$sentryLevel = sentryLevel.reference;
    final _$scopeCallback = scopeCallback.reference;
    return _captureMessage$1(
            reference.pointer,
            _id_captureMessage$1 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$sentryLevel.pointer,
            _$scopeCallback.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureFeedback = _class.instanceMethodId(
    r'captureFeedback',
    r'(Lio/sentry/protocol/Feedback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureFeedback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureFeedback(io.sentry.protocol.Feedback feedback)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureFeedback(
    jni$_.JObject feedback,
  ) {
    final _$feedback = feedback.reference;
    return _captureFeedback(reference.pointer,
            _id_captureFeedback as jni$_.JMethodIDPtr, _$feedback.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureFeedback$1 = _class.instanceMethodId(
    r'captureFeedback',
    r'(Lio/sentry/protocol/Feedback;Lio/sentry/Hint;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureFeedback$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureFeedback(io.sentry.protocol.Feedback feedback, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureFeedback$1(
    jni$_.JObject feedback,
    jni$_.JObject? hint,
  ) {
    final _$feedback = feedback.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    return _captureFeedback$1(
            reference.pointer,
            _id_captureFeedback$1 as jni$_.JMethodIDPtr,
            _$feedback.pointer,
            _$hint.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureFeedback$2 = _class.instanceMethodId(
    r'captureFeedback',
    r'(Lio/sentry/protocol/Feedback;Lio/sentry/Hint;Lio/sentry/ScopeCallback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureFeedback$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureFeedback(io.sentry.protocol.Feedback feedback, io.sentry.Hint hint, io.sentry.ScopeCallback scopeCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureFeedback$2(
    jni$_.JObject feedback,
    jni$_.JObject? hint,
    ScopeCallback? scopeCallback,
  ) {
    final _$feedback = feedback.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    final _$scopeCallback = scopeCallback?.reference ?? jni$_.jNullReference;
    return _captureFeedback$2(
            reference.pointer,
            _id_captureFeedback$2 as jni$_.JMethodIDPtr,
            _$feedback.pointer,
            _$hint.pointer,
            _$scopeCallback.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureEnvelope = _class.instanceMethodId(
    r'captureEnvelope',
    r'(Lio/sentry/SentryEnvelope;Lio/sentry/Hint;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureEnvelope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureEnvelope(io.sentry.SentryEnvelope sentryEnvelope, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureEnvelope(
    jni$_.JObject sentryEnvelope,
    jni$_.JObject? hint,
  ) {
    final _$sentryEnvelope = sentryEnvelope.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    return _captureEnvelope(
            reference.pointer,
            _id_captureEnvelope as jni$_.JMethodIDPtr,
            _$sentryEnvelope.pointer,
            _$hint.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureException = _class.instanceMethodId(
    r'captureException',
    r'(Ljava/lang/Throwable;Lio/sentry/Hint;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureException = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureException(java.lang.Throwable throwable, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureException(
    jni$_.JObject throwable,
    jni$_.JObject? hint,
  ) {
    final _$throwable = throwable.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    return _captureException(
            reference.pointer,
            _id_captureException as jni$_.JMethodIDPtr,
            _$throwable.pointer,
            _$hint.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureException$1 = _class.instanceMethodId(
    r'captureException',
    r'(Ljava/lang/Throwable;Lio/sentry/Hint;Lio/sentry/ScopeCallback;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureException$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureException(java.lang.Throwable throwable, io.sentry.Hint hint, io.sentry.ScopeCallback scopeCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureException$1(
    jni$_.JObject throwable,
    jni$_.JObject? hint,
    ScopeCallback scopeCallback,
  ) {
    final _$throwable = throwable.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    final _$scopeCallback = scopeCallback.reference;
    return _captureException$1(
            reference.pointer,
            _id_captureException$1 as jni$_.JMethodIDPtr,
            _$throwable.pointer,
            _$hint.pointer,
            _$scopeCallback.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureUserFeedback = _class.instanceMethodId(
    r'captureUserFeedback',
    r'(Lio/sentry/UserFeedback;)V',
  );

  static final _captureUserFeedback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void captureUserFeedback(io.sentry.UserFeedback userFeedback)`
  void captureUserFeedback(
    jni$_.JObject userFeedback,
  ) {
    final _$userFeedback = userFeedback.reference;
    _captureUserFeedback(
            reference.pointer,
            _id_captureUserFeedback as jni$_.JMethodIDPtr,
            _$userFeedback.pointer)
        .check();
  }

  static final _id_startSession = _class.instanceMethodId(
    r'startSession',
    r'()V',
  );

  static final _startSession = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void startSession()`
  void startSession() {
    _startSession(reference.pointer, _id_startSession as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_endSession = _class.instanceMethodId(
    r'endSession',
    r'()V',
  );

  static final _endSession = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void endSession()`
  void endSession() {
    _endSession(reference.pointer, _id_endSession as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_close = _class.instanceMethodId(
    r'close',
    r'(Z)V',
  );

  static final _close = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void close(boolean z)`
  void close(
    bool z,
  ) {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_close$1 = _class.instanceMethodId(
    r'close',
    r'()V',
  );

  static final _close$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void close()`
  void close$1() {
    _close$1(reference.pointer, _id_close$1 as jni$_.JMethodIDPtr).check();
  }

  static final _id_addBreadcrumb = _class.instanceMethodId(
    r'addBreadcrumb',
    r'(Lio/sentry/Breadcrumb;Lio/sentry/Hint;)V',
  );

  static final _addBreadcrumb = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addBreadcrumb(io.sentry.Breadcrumb breadcrumb, io.sentry.Hint hint)`
  void addBreadcrumb(
    Breadcrumb breadcrumb,
    jni$_.JObject? hint,
  ) {
    final _$breadcrumb = breadcrumb.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    _addBreadcrumb(reference.pointer, _id_addBreadcrumb as jni$_.JMethodIDPtr,
            _$breadcrumb.pointer, _$hint.pointer)
        .check();
  }

  static final _id_addBreadcrumb$1 = _class.instanceMethodId(
    r'addBreadcrumb',
    r'(Lio/sentry/Breadcrumb;)V',
  );

  static final _addBreadcrumb$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addBreadcrumb(io.sentry.Breadcrumb breadcrumb)`
  void addBreadcrumb$1(
    Breadcrumb breadcrumb,
  ) {
    final _$breadcrumb = breadcrumb.reference;
    _addBreadcrumb$1(reference.pointer,
            _id_addBreadcrumb$1 as jni$_.JMethodIDPtr, _$breadcrumb.pointer)
        .check();
  }

  static final _id_setLevel = _class.instanceMethodId(
    r'setLevel',
    r'(Lio/sentry/SentryLevel;)V',
  );

  static final _setLevel = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setLevel(io.sentry.SentryLevel sentryLevel)`
  void setLevel(
    jni$_.JObject? sentryLevel,
  ) {
    final _$sentryLevel = sentryLevel?.reference ?? jni$_.jNullReference;
    _setLevel(reference.pointer, _id_setLevel as jni$_.JMethodIDPtr,
            _$sentryLevel.pointer)
        .check();
  }

  static final _id_setTransaction = _class.instanceMethodId(
    r'setTransaction',
    r'(Ljava/lang/String;)V',
  );

  static final _setTransaction = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTransaction(java.lang.String string)`
  void setTransaction(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setTransaction(reference.pointer, _id_setTransaction as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_setUser = _class.instanceMethodId(
    r'setUser',
    r'(Lio/sentry/protocol/User;)V',
  );

  static final _setUser = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setUser(io.sentry.protocol.User user)`
  void setUser(
    User? user,
  ) {
    final _$user = user?.reference ?? jni$_.jNullReference;
    _setUser(reference.pointer, _id_setUser as jni$_.JMethodIDPtr,
            _$user.pointer)
        .check();
  }

  static final _id_setFingerprint = _class.instanceMethodId(
    r'setFingerprint',
    r'(Ljava/util/List;)V',
  );

  static final _setFingerprint = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setFingerprint(java.util.List<java.lang.String> list)`
  void setFingerprint(
    jni$_.JList<jni$_.JString?> list,
  ) {
    final _$list = list.reference;
    _setFingerprint(reference.pointer, _id_setFingerprint as jni$_.JMethodIDPtr,
            _$list.pointer)
        .check();
  }

  static final _id_clearBreadcrumbs = _class.instanceMethodId(
    r'clearBreadcrumbs',
    r'()V',
  );

  static final _clearBreadcrumbs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void clearBreadcrumbs()`
  void clearBreadcrumbs() {
    _clearBreadcrumbs(
            reference.pointer, _id_clearBreadcrumbs as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_setTag = _class.instanceMethodId(
    r'setTag',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setTag = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTag(java.lang.String string, java.lang.String string1)`
  void setTag(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setTag(reference.pointer, _id_setTag as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  static final _id_removeTag = _class.instanceMethodId(
    r'removeTag',
    r'(Ljava/lang/String;)V',
  );

  static final _removeTag = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeTag(java.lang.String string)`
  void removeTag(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _removeTag(reference.pointer, _id_removeTag as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_setExtra = _class.instanceMethodId(
    r'setExtra',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setExtra = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setExtra(java.lang.String string, java.lang.String string1)`
  void setExtra(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setExtra(reference.pointer, _id_setExtra as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  static final _id_removeExtra = _class.instanceMethodId(
    r'removeExtra',
    r'(Ljava/lang/String;)V',
  );

  static final _removeExtra = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeExtra(java.lang.String string)`
  void removeExtra(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _removeExtra(reference.pointer, _id_removeExtra as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getLastEventId = _class.instanceMethodId(
    r'getLastEventId',
    r'()Lio/sentry/protocol/SentryId;',
  );

  static final _getLastEventId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.SentryId getLastEventId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getLastEventId() {
    return _getLastEventId(
            reference.pointer, _id_getLastEventId as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_pushScope = _class.instanceMethodId(
    r'pushScope',
    r'()Lio/sentry/ISentryLifecycleToken;',
  );

  static final _pushScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ISentryLifecycleToken pushScope()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject pushScope() {
    return _pushScope(reference.pointer, _id_pushScope as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_pushIsolationScope = _class.instanceMethodId(
    r'pushIsolationScope',
    r'()Lio/sentry/ISentryLifecycleToken;',
  );

  static final _pushIsolationScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ISentryLifecycleToken pushIsolationScope()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject pushIsolationScope() {
    return _pushIsolationScope(
            reference.pointer, _id_pushIsolationScope as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_popScope = _class.instanceMethodId(
    r'popScope',
    r'()V',
  );

  static final _popScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void popScope()`
  void popScope() {
    _popScope(reference.pointer, _id_popScope as jni$_.JMethodIDPtr).check();
  }

  static final _id_withScope = _class.instanceMethodId(
    r'withScope',
    r'(Lio/sentry/ScopeCallback;)V',
  );

  static final _withScope = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void withScope(io.sentry.ScopeCallback scopeCallback)`
  void withScope(
    ScopeCallback scopeCallback,
  ) {
    final _$scopeCallback = scopeCallback.reference;
    _withScope(reference.pointer, _id_withScope as jni$_.JMethodIDPtr,
            _$scopeCallback.pointer)
        .check();
  }

  static final _id_withIsolationScope = _class.instanceMethodId(
    r'withIsolationScope',
    r'(Lio/sentry/ScopeCallback;)V',
  );

  static final _withIsolationScope = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void withIsolationScope(io.sentry.ScopeCallback scopeCallback)`
  void withIsolationScope(
    ScopeCallback scopeCallback,
  ) {
    final _$scopeCallback = scopeCallback.reference;
    _withIsolationScope(
            reference.pointer,
            _id_withIsolationScope as jni$_.JMethodIDPtr,
            _$scopeCallback.pointer)
        .check();
  }

  static final _id_configureScope = _class.instanceMethodId(
    r'configureScope',
    r'(Lio/sentry/ScopeType;Lio/sentry/ScopeCallback;)V',
  );

  static final _configureScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void configureScope(io.sentry.ScopeType scopeType, io.sentry.ScopeCallback scopeCallback)`
  void configureScope(
    jni$_.JObject? scopeType,
    ScopeCallback scopeCallback,
  ) {
    final _$scopeType = scopeType?.reference ?? jni$_.jNullReference;
    final _$scopeCallback = scopeCallback.reference;
    _configureScope(reference.pointer, _id_configureScope as jni$_.JMethodIDPtr,
            _$scopeType.pointer, _$scopeCallback.pointer)
        .check();
  }

  static final _id_bindClient = _class.instanceMethodId(
    r'bindClient',
    r'(Lio/sentry/ISentryClient;)V',
  );

  static final _bindClient = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void bindClient(io.sentry.ISentryClient iSentryClient)`
  void bindClient(
    jni$_.JObject iSentryClient,
  ) {
    final _$iSentryClient = iSentryClient.reference;
    _bindClient(reference.pointer, _id_bindClient as jni$_.JMethodIDPtr,
            _$iSentryClient.pointer)
        .check();
  }

  static final _id_isHealthy = _class.instanceMethodId(
    r'isHealthy',
    r'()Z',
  );

  static final _isHealthy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isHealthy()`
  bool isHealthy() {
    return _isHealthy(reference.pointer, _id_isHealthy as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_flush = _class.instanceMethodId(
    r'flush',
    r'(J)V',
  );

  static final _flush = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void flush(long j)`
  void flush(
    int j,
  ) {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr, j).check();
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Lio/sentry/IHub;',
  );

  static final _clone = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.IHub clone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject clone() {
    return _clone(reference.pointer, _id_clone as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_forkedScopes = _class.instanceMethodId(
    r'forkedScopes',
    r'(Ljava/lang/String;)Lio/sentry/IScopes;',
  );

  static final _forkedScopes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.IScopes forkedScopes(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject forkedScopes(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _forkedScopes(reference.pointer,
            _id_forkedScopes as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_forkedCurrentScope = _class.instanceMethodId(
    r'forkedCurrentScope',
    r'(Ljava/lang/String;)Lio/sentry/IScopes;',
  );

  static final _forkedCurrentScope = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.IScopes forkedCurrentScope(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject forkedCurrentScope(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _forkedCurrentScope(reference.pointer,
            _id_forkedCurrentScope as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_forkedRootScopes = _class.instanceMethodId(
    r'forkedRootScopes',
    r'(Ljava/lang/String;)Lio/sentry/IScopes;',
  );

  static final _forkedRootScopes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.IScopes forkedRootScopes(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject forkedRootScopes(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _forkedRootScopes(reference.pointer,
            _id_forkedRootScopes as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_makeCurrent = _class.instanceMethodId(
    r'makeCurrent',
    r'()Lio/sentry/ISentryLifecycleToken;',
  );

  static final _makeCurrent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ISentryLifecycleToken makeCurrent()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject makeCurrent() {
    return _makeCurrent(
            reference.pointer, _id_makeCurrent as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getScope = _class.instanceMethodId(
    r'getScope',
    r'()Lio/sentry/IScope;',
  );

  static final _getScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.IScope getScope()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getScope() {
    return _getScope(reference.pointer, _id_getScope as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getIsolationScope = _class.instanceMethodId(
    r'getIsolationScope',
    r'()Lio/sentry/IScope;',
  );

  static final _getIsolationScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.IScope getIsolationScope()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getIsolationScope() {
    return _getIsolationScope(
            reference.pointer, _id_getIsolationScope as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getGlobalScope = _class.instanceMethodId(
    r'getGlobalScope',
    r'()Lio/sentry/IScope;',
  );

  static final _getGlobalScope = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.IScope getGlobalScope()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getGlobalScope() {
    return _getGlobalScope(
            reference.pointer, _id_getGlobalScope as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getParentScopes = _class.instanceMethodId(
    r'getParentScopes',
    r'()Lio/sentry/IScopes;',
  );

  static final _getParentScopes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.IScopes getParentScopes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getParentScopes() {
    return _getParentScopes(
            reference.pointer, _id_getParentScopes as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_isAncestorOf = _class.instanceMethodId(
    r'isAncestorOf',
    r'(Lio/sentry/IScopes;)Z',
  );

  static final _isAncestorOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean isAncestorOf(io.sentry.IScopes iScopes)`
  bool isAncestorOf(
    jni$_.JObject? iScopes,
  ) {
    final _$iScopes = iScopes?.reference ?? jni$_.jNullReference;
    return _isAncestorOf(reference.pointer,
            _id_isAncestorOf as jni$_.JMethodIDPtr, _$iScopes.pointer)
        .boolean;
  }

  static final _id_captureTransaction = _class.instanceMethodId(
    r'captureTransaction',
    r'(Lio/sentry/protocol/SentryTransaction;Lio/sentry/TraceContext;Lio/sentry/Hint;Lio/sentry/ProfilingTraceData;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureTransaction = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureTransaction(io.sentry.protocol.SentryTransaction sentryTransaction, io.sentry.TraceContext traceContext, io.sentry.Hint hint, io.sentry.ProfilingTraceData profilingTraceData)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureTransaction(
    jni$_.JObject sentryTransaction,
    jni$_.JObject? traceContext,
    jni$_.JObject? hint,
    jni$_.JObject? profilingTraceData,
  ) {
    final _$sentryTransaction = sentryTransaction.reference;
    final _$traceContext = traceContext?.reference ?? jni$_.jNullReference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    final _$profilingTraceData =
        profilingTraceData?.reference ?? jni$_.jNullReference;
    return _captureTransaction(
            reference.pointer,
            _id_captureTransaction as jni$_.JMethodIDPtr,
            _$sentryTransaction.pointer,
            _$traceContext.pointer,
            _$hint.pointer,
            _$profilingTraceData.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_captureProfileChunk = _class.instanceMethodId(
    r'captureProfileChunk',
    r'(Lio/sentry/ProfileChunk;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureProfileChunk = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureProfileChunk(io.sentry.ProfileChunk profileChunk)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureProfileChunk(
    jni$_.JObject profileChunk,
  ) {
    final _$profileChunk = profileChunk.reference;
    return _captureProfileChunk(
            reference.pointer,
            _id_captureProfileChunk as jni$_.JMethodIDPtr,
            _$profileChunk.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_startTransaction = _class.instanceMethodId(
    r'startTransaction',
    r'(Lio/sentry/TransactionContext;Lio/sentry/TransactionOptions;)Lio/sentry/ITransaction;',
  );

  static final _startTransaction = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.ITransaction startTransaction(io.sentry.TransactionContext transactionContext, io.sentry.TransactionOptions transactionOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject startTransaction(
    jni$_.JObject transactionContext,
    jni$_.JObject transactionOptions,
  ) {
    final _$transactionContext = transactionContext.reference;
    final _$transactionOptions = transactionOptions.reference;
    return _startTransaction(
            reference.pointer,
            _id_startTransaction as jni$_.JMethodIDPtr,
            _$transactionContext.pointer,
            _$transactionOptions.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_startProfiler = _class.instanceMethodId(
    r'startProfiler',
    r'()V',
  );

  static final _startProfiler = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void startProfiler()`
  void startProfiler() {
    _startProfiler(reference.pointer, _id_startProfiler as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_stopProfiler = _class.instanceMethodId(
    r'stopProfiler',
    r'()V',
  );

  static final _stopProfiler = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void stopProfiler()`
  void stopProfiler() {
    _stopProfiler(reference.pointer, _id_stopProfiler as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_setSpanContext = _class.instanceMethodId(
    r'setSpanContext',
    r'(Ljava/lang/Throwable;Lio/sentry/ISpan;Ljava/lang/String;)V',
  );

  static final _setSpanContext = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setSpanContext(java.lang.Throwable throwable, io.sentry.ISpan iSpan, java.lang.String string)`
  void setSpanContext(
    jni$_.JObject throwable,
    jni$_.JObject iSpan,
    jni$_.JString string,
  ) {
    final _$throwable = throwable.reference;
    final _$iSpan = iSpan.reference;
    final _$string = string.reference;
    _setSpanContext(reference.pointer, _id_setSpanContext as jni$_.JMethodIDPtr,
            _$throwable.pointer, _$iSpan.pointer, _$string.pointer)
        .check();
  }

  static final _id_getSpan = _class.instanceMethodId(
    r'getSpan',
    r'()Lio/sentry/ISpan;',
  );

  static final _getSpan = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ISpan getSpan()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getSpan() {
    return _getSpan(reference.pointer, _id_getSpan as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setActiveSpan = _class.instanceMethodId(
    r'setActiveSpan',
    r'(Lio/sentry/ISpan;)V',
  );

  static final _setActiveSpan = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setActiveSpan(io.sentry.ISpan iSpan)`
  void setActiveSpan(
    jni$_.JObject? iSpan,
  ) {
    final _$iSpan = iSpan?.reference ?? jni$_.jNullReference;
    _setActiveSpan(reference.pointer, _id_setActiveSpan as jni$_.JMethodIDPtr,
            _$iSpan.pointer)
        .check();
  }

  static final _id_getTransaction = _class.instanceMethodId(
    r'getTransaction',
    r'()Lio/sentry/ITransaction;',
  );

  static final _getTransaction = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ITransaction getTransaction()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getTransaction() {
    return _getTransaction(
            reference.pointer, _id_getTransaction as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getOptions = _class.instanceMethodId(
    r'getOptions',
    r'()Lio/sentry/SentryOptions;',
  );

  static final _getOptions = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryOptions getOptions()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getOptions() {
    return _getOptions(reference.pointer, _id_getOptions as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_isCrashedLastRun = _class.instanceMethodId(
    r'isCrashedLastRun',
    r'()Ljava/lang/Boolean;',
  );

  static final _isCrashedLastRun = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Boolean isCrashedLastRun()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? isCrashedLastRun() {
    return _isCrashedLastRun(
            reference.pointer, _id_isCrashedLastRun as jni$_.JMethodIDPtr)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_reportFullyDisplayed = _class.instanceMethodId(
    r'reportFullyDisplayed',
    r'()V',
  );

  static final _reportFullyDisplayed = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void reportFullyDisplayed()`
  void reportFullyDisplayed() {
    _reportFullyDisplayed(
            reference.pointer, _id_reportFullyDisplayed as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_continueTrace = _class.instanceMethodId(
    r'continueTrace',
    r'(Ljava/lang/String;Ljava/util/List;)Lio/sentry/TransactionContext;',
  );

  static final _continueTrace = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.TransactionContext continueTrace(java.lang.String string, java.util.List<java.lang.String> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? continueTrace(
    jni$_.JString? string,
    jni$_.JList<jni$_.JString?>? list,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _continueTrace(
            reference.pointer,
            _id_continueTrace as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$list.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getTraceparent = _class.instanceMethodId(
    r'getTraceparent',
    r'()Lio/sentry/SentryTraceHeader;',
  );

  static final _getTraceparent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryTraceHeader getTraceparent()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getTraceparent() {
    return _getTraceparent(
            reference.pointer, _id_getTraceparent as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getBaggage = _class.instanceMethodId(
    r'getBaggage',
    r'()Lio/sentry/BaggageHeader;',
  );

  static final _getBaggage = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.BaggageHeader getBaggage()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getBaggage() {
    return _getBaggage(reference.pointer, _id_getBaggage as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_captureCheckIn = _class.instanceMethodId(
    r'captureCheckIn',
    r'(Lio/sentry/CheckIn;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureCheckIn = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureCheckIn(io.sentry.CheckIn checkIn)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureCheckIn(
    jni$_.JObject checkIn,
  ) {
    final _$checkIn = checkIn.reference;
    return _captureCheckIn(reference.pointer,
            _id_captureCheckIn as jni$_.JMethodIDPtr, _$checkIn.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getRateLimiter = _class.instanceMethodId(
    r'getRateLimiter',
    r'()Lio/sentry/transport/RateLimiter;',
  );

  static final _getRateLimiter = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.transport.RateLimiter getRateLimiter()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getRateLimiter() {
    return _getRateLimiter(
            reference.pointer, _id_getRateLimiter as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_captureReplay = _class.instanceMethodId(
    r'captureReplay',
    r'(Lio/sentry/SentryReplayEvent;Lio/sentry/Hint;)Lio/sentry/protocol/SentryId;',
  );

  static final _captureReplay = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.SentryId captureReplay(io.sentry.SentryReplayEvent sentryReplayEvent, io.sentry.Hint hint)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject captureReplay(
    jni$_.JObject sentryReplayEvent,
    jni$_.JObject? hint,
  ) {
    final _$sentryReplayEvent = sentryReplayEvent.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    return _captureReplay(
            reference.pointer,
            _id_captureReplay as jni$_.JMethodIDPtr,
            _$sentryReplayEvent.pointer,
            _$hint.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_logger = _class.instanceMethodId(
    r'logger',
    r'()Lio/sentry/logger/ILoggerApi;',
  );

  static final _logger = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.logger.ILoggerApi logger()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject logger() {
    return _logger(reference.pointer, _id_logger as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }
}

final class $ScopesAdapter$NullableType extends jni$_.JObjType<ScopesAdapter?> {
  @jni$_.internal
  const $ScopesAdapter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/ScopesAdapter;';

  @jni$_.internal
  @core$_.override
  ScopesAdapter? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : ScopesAdapter.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ScopesAdapter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ScopesAdapter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ScopesAdapter$NullableType) &&
        other is $ScopesAdapter$NullableType;
  }
}

final class $ScopesAdapter$Type extends jni$_.JObjType<ScopesAdapter> {
  @jni$_.internal
  const $ScopesAdapter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/ScopesAdapter;';

  @jni$_.internal
  @core$_.override
  ScopesAdapter fromReference(jni$_.JReference reference) =>
      ScopesAdapter.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ScopesAdapter?> get nullableType =>
      const $ScopesAdapter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ScopesAdapter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ScopesAdapter$Type) &&
        other is $ScopesAdapter$Type;
  }
}

/// from: `io.sentry.Scope$IWithPropagationContext`
class Scope$IWithPropagationContext extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Scope$IWithPropagationContext> $type;

  @jni$_.internal
  Scope$IWithPropagationContext.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/Scope$IWithPropagationContext');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Scope$IWithPropagationContext$NullableType();
  static const type = $Scope$IWithPropagationContext$Type();
  static final _id_accept = _class.instanceMethodId(
    r'accept',
    r'(Lio/sentry/PropagationContext;)V',
  );

  static final _accept = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void accept(io.sentry.PropagationContext propagationContext)`
  void accept(
    jni$_.JObject propagationContext,
  ) {
    final _$propagationContext = propagationContext.reference;
    _accept(reference.pointer, _id_accept as jni$_.JMethodIDPtr,
            _$propagationContext.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Scope$IWithPropagationContext> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'accept(Lio/sentry/PropagationContext;)V') {
        _$impls[$p]!.accept(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Scope$IWithPropagationContext $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.Scope$IWithPropagationContext',
      $p,
      _$invokePointer,
      [
        if ($impl.accept$async) r'accept(Lio/sentry/PropagationContext;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Scope$IWithPropagationContext.implement(
    $Scope$IWithPropagationContext $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Scope$IWithPropagationContext.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Scope$IWithPropagationContext {
  factory $Scope$IWithPropagationContext({
    required void Function(jni$_.JObject propagationContext) accept,
    bool accept$async,
  }) = _$Scope$IWithPropagationContext;

  void accept(jni$_.JObject propagationContext);
  bool get accept$async => false;
}

final class _$Scope$IWithPropagationContext
    with $Scope$IWithPropagationContext {
  _$Scope$IWithPropagationContext({
    required void Function(jni$_.JObject propagationContext) accept,
    this.accept$async = false,
  }) : _accept = accept;

  final void Function(jni$_.JObject propagationContext) _accept;
  final bool accept$async;

  void accept(jni$_.JObject propagationContext) {
    return _accept(propagationContext);
  }
}

final class $Scope$IWithPropagationContext$NullableType
    extends jni$_.JObjType<Scope$IWithPropagationContext?> {
  @jni$_.internal
  const $Scope$IWithPropagationContext$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Scope$IWithPropagationContext;';

  @jni$_.internal
  @core$_.override
  Scope$IWithPropagationContext? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Scope$IWithPropagationContext.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Scope$IWithPropagationContext?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Scope$IWithPropagationContext$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Scope$IWithPropagationContext$NullableType) &&
        other is $Scope$IWithPropagationContext$NullableType;
  }
}

final class $Scope$IWithPropagationContext$Type
    extends jni$_.JObjType<Scope$IWithPropagationContext> {
  @jni$_.internal
  const $Scope$IWithPropagationContext$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Scope$IWithPropagationContext;';

  @jni$_.internal
  @core$_.override
  Scope$IWithPropagationContext fromReference(jni$_.JReference reference) =>
      Scope$IWithPropagationContext.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Scope$IWithPropagationContext?> get nullableType =>
      const $Scope$IWithPropagationContext$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Scope$IWithPropagationContext$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Scope$IWithPropagationContext$Type) &&
        other is $Scope$IWithPropagationContext$Type;
  }
}

/// from: `io.sentry.Scope$IWithTransaction`
class Scope$IWithTransaction extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Scope$IWithTransaction> $type;

  @jni$_.internal
  Scope$IWithTransaction.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/Scope$IWithTransaction');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Scope$IWithTransaction$NullableType();
  static const type = $Scope$IWithTransaction$Type();
  static final _id_accept = _class.instanceMethodId(
    r'accept',
    r'(Lio/sentry/ITransaction;)V',
  );

  static final _accept = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void accept(io.sentry.ITransaction iTransaction)`
  void accept(
    jni$_.JObject? iTransaction,
  ) {
    final _$iTransaction = iTransaction?.reference ?? jni$_.jNullReference;
    _accept(reference.pointer, _id_accept as jni$_.JMethodIDPtr,
            _$iTransaction.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Scope$IWithTransaction> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'accept(Lio/sentry/ITransaction;)V') {
        _$impls[$p]!.accept(
          $a![0]?.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Scope$IWithTransaction $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.Scope$IWithTransaction',
      $p,
      _$invokePointer,
      [
        if ($impl.accept$async) r'accept(Lio/sentry/ITransaction;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Scope$IWithTransaction.implement(
    $Scope$IWithTransaction $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Scope$IWithTransaction.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Scope$IWithTransaction {
  factory $Scope$IWithTransaction({
    required void Function(jni$_.JObject? iTransaction) accept,
    bool accept$async,
  }) = _$Scope$IWithTransaction;

  void accept(jni$_.JObject? iTransaction);
  bool get accept$async => false;
}

final class _$Scope$IWithTransaction with $Scope$IWithTransaction {
  _$Scope$IWithTransaction({
    required void Function(jni$_.JObject? iTransaction) accept,
    this.accept$async = false,
  }) : _accept = accept;

  final void Function(jni$_.JObject? iTransaction) _accept;
  final bool accept$async;

  void accept(jni$_.JObject? iTransaction) {
    return _accept(iTransaction);
  }
}

final class $Scope$IWithTransaction$NullableType
    extends jni$_.JObjType<Scope$IWithTransaction?> {
  @jni$_.internal
  const $Scope$IWithTransaction$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Scope$IWithTransaction;';

  @jni$_.internal
  @core$_.override
  Scope$IWithTransaction? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Scope$IWithTransaction.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Scope$IWithTransaction?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Scope$IWithTransaction$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Scope$IWithTransaction$NullableType) &&
        other is $Scope$IWithTransaction$NullableType;
  }
}

final class $Scope$IWithTransaction$Type
    extends jni$_.JObjType<Scope$IWithTransaction> {
  @jni$_.internal
  const $Scope$IWithTransaction$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Scope$IWithTransaction;';

  @jni$_.internal
  @core$_.override
  Scope$IWithTransaction fromReference(jni$_.JReference reference) =>
      Scope$IWithTransaction.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Scope$IWithTransaction?> get nullableType =>
      const $Scope$IWithTransaction$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Scope$IWithTransaction$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Scope$IWithTransaction$Type) &&
        other is $Scope$IWithTransaction$Type;
  }
}

/// from: `io.sentry.Scope`
class Scope extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Scope> $type;

  @jni$_.internal
  Scope.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/Scope');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Scope$NullableType();
  static const type = $Scope$Type();
  static final _id_new$ = _class.constructorId(
    r'(Lio/sentry/SentryOptions;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(io.sentry.SentryOptions sentryOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Scope(
    jni$_.JObject sentryOptions,
  ) {
    final _$sentryOptions = sentryOptions.reference;
    return Scope.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$sentryOptions.pointer)
        .reference);
  }

  static final _id_getLevel = _class.instanceMethodId(
    r'getLevel',
    r'()Lio/sentry/SentryLevel;',
  );

  static final _getLevel = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryLevel getLevel()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getLevel() {
    return _getLevel(reference.pointer, _id_getLevel as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setLevel = _class.instanceMethodId(
    r'setLevel',
    r'(Lio/sentry/SentryLevel;)V',
  );

  static final _setLevel = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setLevel(io.sentry.SentryLevel sentryLevel)`
  void setLevel(
    jni$_.JObject? sentryLevel,
  ) {
    final _$sentryLevel = sentryLevel?.reference ?? jni$_.jNullReference;
    _setLevel(reference.pointer, _id_setLevel as jni$_.JMethodIDPtr,
            _$sentryLevel.pointer)
        .check();
  }

  static final _id_getTransactionName = _class.instanceMethodId(
    r'getTransactionName',
    r'()Ljava/lang/String;',
  );

  static final _getTransactionName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getTransactionName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getTransactionName() {
    return _getTransactionName(
            reference.pointer, _id_getTransactionName as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setTransaction = _class.instanceMethodId(
    r'setTransaction',
    r'(Ljava/lang/String;)V',
  );

  static final _setTransaction = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTransaction(java.lang.String string)`
  void setTransaction(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    _setTransaction(reference.pointer, _id_setTransaction as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getSpan = _class.instanceMethodId(
    r'getSpan',
    r'()Lio/sentry/ISpan;',
  );

  static final _getSpan = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ISpan getSpan()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getSpan() {
    return _getSpan(reference.pointer, _id_getSpan as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setActiveSpan = _class.instanceMethodId(
    r'setActiveSpan',
    r'(Lio/sentry/ISpan;)V',
  );

  static final _setActiveSpan = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setActiveSpan(io.sentry.ISpan iSpan)`
  void setActiveSpan(
    jni$_.JObject? iSpan,
  ) {
    final _$iSpan = iSpan?.reference ?? jni$_.jNullReference;
    _setActiveSpan(reference.pointer, _id_setActiveSpan as jni$_.JMethodIDPtr,
            _$iSpan.pointer)
        .check();
  }

  static final _id_setTransaction$1 = _class.instanceMethodId(
    r'setTransaction',
    r'(Lio/sentry/ITransaction;)V',
  );

  static final _setTransaction$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTransaction(io.sentry.ITransaction iTransaction)`
  void setTransaction$1(
    jni$_.JObject? iTransaction,
  ) {
    final _$iTransaction = iTransaction?.reference ?? jni$_.jNullReference;
    _setTransaction$1(reference.pointer,
            _id_setTransaction$1 as jni$_.JMethodIDPtr, _$iTransaction.pointer)
        .check();
  }

  static final _id_getUser = _class.instanceMethodId(
    r'getUser',
    r'()Lio/sentry/protocol/User;',
  );

  static final _getUser = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.User getUser()`
  /// The returned object must be released after use, by calling the [release] method.
  User? getUser() {
    return _getUser(reference.pointer, _id_getUser as jni$_.JMethodIDPtr)
        .object<User?>(const $User$NullableType());
  }

  static final _id_setUser = _class.instanceMethodId(
    r'setUser',
    r'(Lio/sentry/protocol/User;)V',
  );

  static final _setUser = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setUser(io.sentry.protocol.User user)`
  void setUser(
    User? user,
  ) {
    final _$user = user?.reference ?? jni$_.jNullReference;
    _setUser(reference.pointer, _id_setUser as jni$_.JMethodIDPtr,
            _$user.pointer)
        .check();
  }

  static final _id_getScreen = _class.instanceMethodId(
    r'getScreen',
    r'()Ljava/lang/String;',
  );

  static final _getScreen = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getScreen()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getScreen() {
    return _getScreen(reference.pointer, _id_getScreen as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setScreen = _class.instanceMethodId(
    r'setScreen',
    r'(Ljava/lang/String;)V',
  );

  static final _setScreen = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setScreen(java.lang.String string)`
  void setScreen(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setScreen(reference.pointer, _id_setScreen as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getReplayId = _class.instanceMethodId(
    r'getReplayId',
    r'()Lio/sentry/protocol/SentryId;',
  );

  static final _getReplayId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.SentryId getReplayId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getReplayId() {
    return _getReplayId(
            reference.pointer, _id_getReplayId as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setReplayId = _class.instanceMethodId(
    r'setReplayId',
    r'(Lio/sentry/protocol/SentryId;)V',
  );

  static final _setReplayId = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setReplayId(io.sentry.protocol.SentryId sentryId)`
  void setReplayId(
    jni$_.JObject sentryId,
  ) {
    final _$sentryId = sentryId.reference;
    _setReplayId(reference.pointer, _id_setReplayId as jni$_.JMethodIDPtr,
            _$sentryId.pointer)
        .check();
  }

  static final _id_getRequest = _class.instanceMethodId(
    r'getRequest',
    r'()Lio/sentry/protocol/Request;',
  );

  static final _getRequest = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.Request getRequest()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getRequest() {
    return _getRequest(reference.pointer, _id_getRequest as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setRequest = _class.instanceMethodId(
    r'setRequest',
    r'(Lio/sentry/protocol/Request;)V',
  );

  static final _setRequest = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setRequest(io.sentry.protocol.Request request)`
  void setRequest(
    jni$_.JObject? request,
  ) {
    final _$request = request?.reference ?? jni$_.jNullReference;
    _setRequest(reference.pointer, _id_setRequest as jni$_.JMethodIDPtr,
            _$request.pointer)
        .check();
  }

  static final _id_getFingerprint = _class.instanceMethodId(
    r'getFingerprint',
    r'()Ljava/util/List;',
  );

  static final _getFingerprint = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<java.lang.String> getFingerprint()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?> getFingerprint() {
    return _getFingerprint(
            reference.pointer, _id_getFingerprint as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>>(
            const jni$_.JListType<jni$_.JString?>(jni$_.JStringNullableType()));
  }

  static final _id_setFingerprint = _class.instanceMethodId(
    r'setFingerprint',
    r'(Ljava/util/List;)V',
  );

  static final _setFingerprint = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setFingerprint(java.util.List<java.lang.String> list)`
  void setFingerprint(
    jni$_.JList<jni$_.JString?> list,
  ) {
    final _$list = list.reference;
    _setFingerprint(reference.pointer, _id_setFingerprint as jni$_.JMethodIDPtr,
            _$list.pointer)
        .check();
  }

  static final _id_getBreadcrumbs = _class.instanceMethodId(
    r'getBreadcrumbs',
    r'()Ljava/util/Queue;',
  );

  static final _getBreadcrumbs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Queue<io.sentry.Breadcrumb> getBreadcrumbs()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getBreadcrumbs() {
    return _getBreadcrumbs(
            reference.pointer, _id_getBreadcrumbs as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_addBreadcrumb = _class.instanceMethodId(
    r'addBreadcrumb',
    r'(Lio/sentry/Breadcrumb;Lio/sentry/Hint;)V',
  );

  static final _addBreadcrumb = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addBreadcrumb(io.sentry.Breadcrumb breadcrumb, io.sentry.Hint hint)`
  void addBreadcrumb(
    Breadcrumb breadcrumb,
    jni$_.JObject? hint,
  ) {
    final _$breadcrumb = breadcrumb.reference;
    final _$hint = hint?.reference ?? jni$_.jNullReference;
    _addBreadcrumb(reference.pointer, _id_addBreadcrumb as jni$_.JMethodIDPtr,
            _$breadcrumb.pointer, _$hint.pointer)
        .check();
  }

  static final _id_addBreadcrumb$1 = _class.instanceMethodId(
    r'addBreadcrumb',
    r'(Lio/sentry/Breadcrumb;)V',
  );

  static final _addBreadcrumb$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addBreadcrumb(io.sentry.Breadcrumb breadcrumb)`
  void addBreadcrumb$1(
    Breadcrumb breadcrumb,
  ) {
    final _$breadcrumb = breadcrumb.reference;
    _addBreadcrumb$1(reference.pointer,
            _id_addBreadcrumb$1 as jni$_.JMethodIDPtr, _$breadcrumb.pointer)
        .check();
  }

  static final _id_clearBreadcrumbs = _class.instanceMethodId(
    r'clearBreadcrumbs',
    r'()V',
  );

  static final _clearBreadcrumbs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void clearBreadcrumbs()`
  void clearBreadcrumbs() {
    _clearBreadcrumbs(
            reference.pointer, _id_clearBreadcrumbs as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_clearTransaction = _class.instanceMethodId(
    r'clearTransaction',
    r'()V',
  );

  static final _clearTransaction = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void clearTransaction()`
  void clearTransaction() {
    _clearTransaction(
            reference.pointer, _id_clearTransaction as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_getTransaction = _class.instanceMethodId(
    r'getTransaction',
    r'()Lio/sentry/ITransaction;',
  );

  static final _getTransaction = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ITransaction getTransaction()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getTransaction() {
    return _getTransaction(
            reference.pointer, _id_getTransaction as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_clear = _class.instanceMethodId(
    r'clear',
    r'()V',
  );

  static final _clear = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void clear()`
  void clear() {
    _clear(reference.pointer, _id_clear as jni$_.JMethodIDPtr).check();
  }

  static final _id_getTags = _class.instanceMethodId(
    r'getTags',
    r'()Ljava/util/Map;',
  );

  static final _getTags = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> getTags()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?> getTags() {
    return _getTags(reference.pointer, _id_getTags as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
            const jni$_.JMapType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_setTag = _class.instanceMethodId(
    r'setTag',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setTag = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setTag(java.lang.String string, java.lang.String string1)`
  void setTag(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setTag(reference.pointer, _id_setTag as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  static final _id_removeTag = _class.instanceMethodId(
    r'removeTag',
    r'(Ljava/lang/String;)V',
  );

  static final _removeTag = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeTag(java.lang.String string)`
  void removeTag(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _removeTag(reference.pointer, _id_removeTag as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getExtras = _class.instanceMethodId(
    r'getExtras',
    r'()Ljava/util/Map;',
  );

  static final _getExtras = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Map<java.lang.String, java.lang.Object> getExtras()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JObject?> getExtras() {
    return _getExtras(reference.pointer, _id_getExtras as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JString?, jni$_.JObject?>(
                jni$_.JStringNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_setExtra = _class.instanceMethodId(
    r'setExtra',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setExtra = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setExtra(java.lang.String string, java.lang.String string1)`
  void setExtra(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setExtra(reference.pointer, _id_setExtra as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  static final _id_removeExtra = _class.instanceMethodId(
    r'removeExtra',
    r'(Ljava/lang/String;)V',
  );

  static final _removeExtra = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeExtra(java.lang.String string)`
  void removeExtra(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _removeExtra(reference.pointer, _id_removeExtra as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getContexts = _class.instanceMethodId(
    r'getContexts',
    r'()Lio/sentry/protocol/Contexts;',
  );

  static final _getContexts = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.Contexts getContexts()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getContexts() {
    return _getContexts(
            reference.pointer, _id_getContexts as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setContexts = _class.instanceMethodId(
    r'setContexts',
    r'(Ljava/lang/String;Ljava/lang/Object;)V',
  );

  static final _setContexts = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setContexts(java.lang.String string, java.lang.Object object)`
  void setContexts(
    jni$_.JString? string,
    jni$_.JObject? object,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    _setContexts(reference.pointer, _id_setContexts as jni$_.JMethodIDPtr,
            _$string.pointer, _$object.pointer)
        .check();
  }

  static final _id_setContexts$1 = _class.instanceMethodId(
    r'setContexts',
    r'(Ljava/lang/String;Ljava/lang/Boolean;)V',
  );

  static final _setContexts$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setContexts(java.lang.String string, java.lang.Boolean boolean)`
  void setContexts$1(
    jni$_.JString? string,
    jni$_.JBoolean? boolean,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    _setContexts$1(reference.pointer, _id_setContexts$1 as jni$_.JMethodIDPtr,
            _$string.pointer, _$boolean.pointer)
        .check();
  }

  static final _id_setContexts$2 = _class.instanceMethodId(
    r'setContexts',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setContexts$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setContexts(java.lang.String string, java.lang.String string1)`
  void setContexts$2(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setContexts$2(reference.pointer, _id_setContexts$2 as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .check();
  }

  static final _id_setContexts$3 = _class.instanceMethodId(
    r'setContexts',
    r'(Ljava/lang/String;Ljava/lang/Number;)V',
  );

  static final _setContexts$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setContexts(java.lang.String string, java.lang.Number number)`
  void setContexts$3(
    jni$_.JString? string,
    jni$_.JNumber? number,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$number = number?.reference ?? jni$_.jNullReference;
    _setContexts$3(reference.pointer, _id_setContexts$3 as jni$_.JMethodIDPtr,
            _$string.pointer, _$number.pointer)
        .check();
  }

  static final _id_setContexts$4 = _class.instanceMethodId(
    r'setContexts',
    r'(Ljava/lang/String;Ljava/util/Collection;)V',
  );

  static final _setContexts$4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setContexts(java.lang.String string, java.util.Collection<?> collection)`
  void setContexts$4(
    jni$_.JString? string,
    jni$_.JObject? collection,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$collection = collection?.reference ?? jni$_.jNullReference;
    _setContexts$4(reference.pointer, _id_setContexts$4 as jni$_.JMethodIDPtr,
            _$string.pointer, _$collection.pointer)
        .check();
  }

  static final _id_setContexts$5 = _class.instanceMethodId(
    r'setContexts',
    r'(Ljava/lang/String;[Ljava/lang/Object;)V',
  );

  static final _setContexts$5 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setContexts(java.lang.String string, java.lang.Object[] objects)`
  void setContexts$5(
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    _setContexts$5(reference.pointer, _id_setContexts$5 as jni$_.JMethodIDPtr,
            _$string.pointer, _$objects.pointer)
        .check();
  }

  static final _id_setContexts$6 = _class.instanceMethodId(
    r'setContexts',
    r'(Ljava/lang/String;Ljava/lang/Character;)V',
  );

  static final _setContexts$6 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setContexts(java.lang.String string, java.lang.Character character)`
  void setContexts$6(
    jni$_.JString? string,
    jni$_.JCharacter? character,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$character = character?.reference ?? jni$_.jNullReference;
    _setContexts$6(reference.pointer, _id_setContexts$6 as jni$_.JMethodIDPtr,
            _$string.pointer, _$character.pointer)
        .check();
  }

  static final _id_removeContexts = _class.instanceMethodId(
    r'removeContexts',
    r'(Ljava/lang/String;)V',
  );

  static final _removeContexts = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removeContexts(java.lang.String string)`
  void removeContexts(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _removeContexts(reference.pointer, _id_removeContexts as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getAttachments = _class.instanceMethodId(
    r'getAttachments',
    r'()Ljava/util/List;',
  );

  static final _getAttachments = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<io.sentry.Attachment> getAttachments()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getAttachments() {
    return _getAttachments(
            reference.pointer, _id_getAttachments as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_addAttachment = _class.instanceMethodId(
    r'addAttachment',
    r'(Lio/sentry/Attachment;)V',
  );

  static final _addAttachment = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addAttachment(io.sentry.Attachment attachment)`
  void addAttachment(
    jni$_.JObject attachment,
  ) {
    final _$attachment = attachment.reference;
    _addAttachment(reference.pointer, _id_addAttachment as jni$_.JMethodIDPtr,
            _$attachment.pointer)
        .check();
  }

  static final _id_clearAttachments = _class.instanceMethodId(
    r'clearAttachments',
    r'()V',
  );

  static final _clearAttachments = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void clearAttachments()`
  void clearAttachments() {
    _clearAttachments(
            reference.pointer, _id_clearAttachments as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_getEventProcessors = _class.instanceMethodId(
    r'getEventProcessors',
    r'()Ljava/util/List;',
  );

  static final _getEventProcessors = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<io.sentry.EventProcessor> getEventProcessors()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getEventProcessors() {
    return _getEventProcessors(
            reference.pointer, _id_getEventProcessors as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_getEventProcessorsWithOrder = _class.instanceMethodId(
    r'getEventProcessorsWithOrder',
    r'()Ljava/util/List;',
  );

  static final _getEventProcessorsWithOrder =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public java.util.List<io.sentry.internal.eventprocessor.EventProcessorAndOrder> getEventProcessorsWithOrder()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getEventProcessorsWithOrder() {
    return _getEventProcessorsWithOrder(reference.pointer,
            _id_getEventProcessorsWithOrder as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_addEventProcessor = _class.instanceMethodId(
    r'addEventProcessor',
    r'(Lio/sentry/EventProcessor;)V',
  );

  static final _addEventProcessor = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addEventProcessor(io.sentry.EventProcessor eventProcessor)`
  void addEventProcessor(
    jni$_.JObject eventProcessor,
  ) {
    final _$eventProcessor = eventProcessor.reference;
    _addEventProcessor(
            reference.pointer,
            _id_addEventProcessor as jni$_.JMethodIDPtr,
            _$eventProcessor.pointer)
        .check();
  }

  static final _id_withSession = _class.instanceMethodId(
    r'withSession',
    r'(Lio/sentry/Scope$IWithSession;)Lio/sentry/Session;',
  );

  static final _withSession = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.Session withSession(io.sentry.Scope$IWithSession iWithSession)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? withSession(
    jni$_.JObject iWithSession,
  ) {
    final _$iWithSession = iWithSession.reference;
    return _withSession(reference.pointer,
            _id_withSession as jni$_.JMethodIDPtr, _$iWithSession.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_startSession = _class.instanceMethodId(
    r'startSession',
    r'()Lio/sentry/Scope$SessionPair;',
  );

  static final _startSession = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.Scope$SessionPair startSession()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? startSession() {
    return _startSession(
            reference.pointer, _id_startSession as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_endSession = _class.instanceMethodId(
    r'endSession',
    r'()Lio/sentry/Session;',
  );

  static final _endSession = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.Session endSession()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? endSession() {
    return _endSession(reference.pointer, _id_endSession as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_withTransaction = _class.instanceMethodId(
    r'withTransaction',
    r'(Lio/sentry/Scope$IWithTransaction;)V',
  );

  static final _withTransaction = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void withTransaction(io.sentry.Scope$IWithTransaction iWithTransaction)`
  void withTransaction(
    Scope$IWithTransaction iWithTransaction,
  ) {
    final _$iWithTransaction = iWithTransaction.reference;
    _withTransaction(
            reference.pointer,
            _id_withTransaction as jni$_.JMethodIDPtr,
            _$iWithTransaction.pointer)
        .check();
  }

  static final _id_getOptions = _class.instanceMethodId(
    r'getOptions',
    r'()Lio/sentry/SentryOptions;',
  );

  static final _getOptions = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.SentryOptions getOptions()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getOptions() {
    return _getOptions(reference.pointer, _id_getOptions as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getSession = _class.instanceMethodId(
    r'getSession',
    r'()Lio/sentry/Session;',
  );

  static final _getSession = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.Session getSession()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getSession() {
    return _getSession(reference.pointer, _id_getSession as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_clearSession = _class.instanceMethodId(
    r'clearSession',
    r'()V',
  );

  static final _clearSession = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void clearSession()`
  void clearSession() {
    _clearSession(reference.pointer, _id_clearSession as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_setPropagationContext = _class.instanceMethodId(
    r'setPropagationContext',
    r'(Lio/sentry/PropagationContext;)V',
  );

  static final _setPropagationContext = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setPropagationContext(io.sentry.PropagationContext propagationContext)`
  void setPropagationContext(
    jni$_.JObject propagationContext,
  ) {
    final _$propagationContext = propagationContext.reference;
    _setPropagationContext(
            reference.pointer,
            _id_setPropagationContext as jni$_.JMethodIDPtr,
            _$propagationContext.pointer)
        .check();
  }

  static final _id_getPropagationContext = _class.instanceMethodId(
    r'getPropagationContext',
    r'()Lio/sentry/PropagationContext;',
  );

  static final _getPropagationContext = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.PropagationContext getPropagationContext()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getPropagationContext() {
    return _getPropagationContext(
            reference.pointer, _id_getPropagationContext as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_withPropagationContext = _class.instanceMethodId(
    r'withPropagationContext',
    r'(Lio/sentry/Scope$IWithPropagationContext;)Lio/sentry/PropagationContext;',
  );

  static final _withPropagationContext = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.PropagationContext withPropagationContext(io.sentry.Scope$IWithPropagationContext iWithPropagationContext)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject withPropagationContext(
    Scope$IWithPropagationContext iWithPropagationContext,
  ) {
    final _$iWithPropagationContext = iWithPropagationContext.reference;
    return _withPropagationContext(
            reference.pointer,
            _id_withPropagationContext as jni$_.JMethodIDPtr,
            _$iWithPropagationContext.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Lio/sentry/IScope;',
  );

  static final _clone = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.IScope clone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject clone() {
    return _clone(reference.pointer, _id_clone as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_setLastEventId = _class.instanceMethodId(
    r'setLastEventId',
    r'(Lio/sentry/protocol/SentryId;)V',
  );

  static final _setLastEventId = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setLastEventId(io.sentry.protocol.SentryId sentryId)`
  void setLastEventId(
    jni$_.JObject sentryId,
  ) {
    final _$sentryId = sentryId.reference;
    _setLastEventId(reference.pointer, _id_setLastEventId as jni$_.JMethodIDPtr,
            _$sentryId.pointer)
        .check();
  }

  static final _id_getLastEventId = _class.instanceMethodId(
    r'getLastEventId',
    r'()Lio/sentry/protocol/SentryId;',
  );

  static final _getLastEventId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.SentryId getLastEventId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getLastEventId() {
    return _getLastEventId(
            reference.pointer, _id_getLastEventId as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_bindClient = _class.instanceMethodId(
    r'bindClient',
    r'(Lio/sentry/ISentryClient;)V',
  );

  static final _bindClient = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void bindClient(io.sentry.ISentryClient iSentryClient)`
  void bindClient(
    jni$_.JObject iSentryClient,
  ) {
    final _$iSentryClient = iSentryClient.reference;
    _bindClient(reference.pointer, _id_bindClient as jni$_.JMethodIDPtr,
            _$iSentryClient.pointer)
        .check();
  }

  static final _id_getClient = _class.instanceMethodId(
    r'getClient',
    r'()Lio/sentry/ISentryClient;',
  );

  static final _getClient = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.ISentryClient getClient()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getClient() {
    return _getClient(reference.pointer, _id_getClient as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_assignTraceContext = _class.instanceMethodId(
    r'assignTraceContext',
    r'(Lio/sentry/SentryEvent;)V',
  );

  static final _assignTraceContext = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void assignTraceContext(io.sentry.SentryEvent sentryEvent)`
  void assignTraceContext(
    jni$_.JObject sentryEvent,
  ) {
    final _$sentryEvent = sentryEvent.reference;
    _assignTraceContext(reference.pointer,
            _id_assignTraceContext as jni$_.JMethodIDPtr, _$sentryEvent.pointer)
        .check();
  }

  static final _id_setSpanContext = _class.instanceMethodId(
    r'setSpanContext',
    r'(Ljava/lang/Throwable;Lio/sentry/ISpan;Ljava/lang/String;)V',
  );

  static final _setSpanContext = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setSpanContext(java.lang.Throwable throwable, io.sentry.ISpan iSpan, java.lang.String string)`
  void setSpanContext(
    jni$_.JObject throwable,
    jni$_.JObject iSpan,
    jni$_.JString string,
  ) {
    final _$throwable = throwable.reference;
    final _$iSpan = iSpan.reference;
    final _$string = string.reference;
    _setSpanContext(reference.pointer, _id_setSpanContext as jni$_.JMethodIDPtr,
            _$throwable.pointer, _$iSpan.pointer, _$string.pointer)
        .check();
  }

  static final _id_replaceOptions = _class.instanceMethodId(
    r'replaceOptions',
    r'(Lio/sentry/SentryOptions;)V',
  );

  static final _replaceOptions = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void replaceOptions(io.sentry.SentryOptions sentryOptions)`
  void replaceOptions(
    jni$_.JObject sentryOptions,
  ) {
    final _$sentryOptions = sentryOptions.reference;
    _replaceOptions(reference.pointer, _id_replaceOptions as jni$_.JMethodIDPtr,
            _$sentryOptions.pointer)
        .check();
  }
}

final class $Scope$NullableType extends jni$_.JObjType<Scope?> {
  @jni$_.internal
  const $Scope$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Scope;';

  @jni$_.internal
  @core$_.override
  Scope? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Scope.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Scope?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Scope$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Scope$NullableType) &&
        other is $Scope$NullableType;
  }
}

final class $Scope$Type extends jni$_.JObjType<Scope> {
  @jni$_.internal
  const $Scope$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/Scope;';

  @jni$_.internal
  @core$_.override
  Scope fromReference(jni$_.JReference reference) => Scope.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Scope?> get nullableType => const $Scope$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Scope$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Scope$Type) && other is $Scope$Type;
  }
}

/// from: `io.sentry.ScopeCallback`
class ScopeCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ScopeCallback> $type;

  @jni$_.internal
  ScopeCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/ScopeCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ScopeCallback$NullableType();
  static const type = $ScopeCallback$Type();
  static final _id_run = _class.instanceMethodId(
    r'run',
    r'(Lio/sentry/IScope;)V',
  );

  static final _run = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void run(io.sentry.IScope iScope)`
  void run(
    jni$_.JObject iScope,
  ) {
    final _$iScope = iScope.reference;
    _run(reference.pointer, _id_run as jni$_.JMethodIDPtr, _$iScope.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ScopeCallback> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'run(Lio/sentry/IScope;)V') {
        _$impls[$p]!.run(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $ScopeCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.sentry.ScopeCallback',
      $p,
      _$invokePointer,
      [
        if ($impl.run$async) r'run(Lio/sentry/IScope;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ScopeCallback.implement(
    $ScopeCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ScopeCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $ScopeCallback {
  factory $ScopeCallback({
    required void Function(jni$_.JObject iScope) run,
    bool run$async,
  }) = _$ScopeCallback;

  void run(jni$_.JObject iScope);
  bool get run$async => false;
}

final class _$ScopeCallback with $ScopeCallback {
  _$ScopeCallback({
    required void Function(jni$_.JObject iScope) run,
    this.run$async = false,
  }) : _run = run;

  final void Function(jni$_.JObject iScope) _run;
  final bool run$async;

  void run(jni$_.JObject iScope) {
    return _run(iScope);
  }
}

final class $ScopeCallback$NullableType extends jni$_.JObjType<ScopeCallback?> {
  @jni$_.internal
  const $ScopeCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/ScopeCallback;';

  @jni$_.internal
  @core$_.override
  ScopeCallback? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : ScopeCallback.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ScopeCallback?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ScopeCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ScopeCallback$NullableType) &&
        other is $ScopeCallback$NullableType;
  }
}

final class $ScopeCallback$Type extends jni$_.JObjType<ScopeCallback> {
  @jni$_.internal
  const $ScopeCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/ScopeCallback;';

  @jni$_.internal
  @core$_.override
  ScopeCallback fromReference(jni$_.JReference reference) =>
      ScopeCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ScopeCallback?> get nullableType =>
      const $ScopeCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ScopeCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ScopeCallback$Type) &&
        other is $ScopeCallback$Type;
  }
}

/// from: `io.sentry.protocol.User$Deserializer`
class User$Deserializer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<User$Deserializer> $type;

  @jni$_.internal
  User$Deserializer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/protocol/User$Deserializer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $User$Deserializer$NullableType();
  static const type = $User$Deserializer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory User$Deserializer() {
    return User$Deserializer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_deserialize = _class.instanceMethodId(
    r'deserialize',
    r'(Lio/sentry/ObjectReader;Lio/sentry/ILogger;)Lio/sentry/protocol/User;',
  );

  static final _deserialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public io.sentry.protocol.User deserialize(io.sentry.ObjectReader objectReader, io.sentry.ILogger iLogger)`
  /// The returned object must be released after use, by calling the [release] method.
  User deserialize(
    jni$_.JObject objectReader,
    jni$_.JObject iLogger,
  ) {
    final _$objectReader = objectReader.reference;
    final _$iLogger = iLogger.reference;
    return _deserialize(
            reference.pointer,
            _id_deserialize as jni$_.JMethodIDPtr,
            _$objectReader.pointer,
            _$iLogger.pointer)
        .object<User>(const $User$Type());
  }
}

final class $User$Deserializer$NullableType
    extends jni$_.JObjType<User$Deserializer?> {
  @jni$_.internal
  const $User$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/User$Deserializer;';

  @jni$_.internal
  @core$_.override
  User$Deserializer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : User$Deserializer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<User$Deserializer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($User$Deserializer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($User$Deserializer$NullableType) &&
        other is $User$Deserializer$NullableType;
  }
}

final class $User$Deserializer$Type extends jni$_.JObjType<User$Deserializer> {
  @jni$_.internal
  const $User$Deserializer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/User$Deserializer;';

  @jni$_.internal
  @core$_.override
  User$Deserializer fromReference(jni$_.JReference reference) =>
      User$Deserializer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<User$Deserializer?> get nullableType =>
      const $User$Deserializer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($User$Deserializer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($User$Deserializer$Type) &&
        other is $User$Deserializer$Type;
  }
}

/// from: `io.sentry.protocol.User$JsonKeys`
class User$JsonKeys extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<User$JsonKeys> $type;

  @jni$_.internal
  User$JsonKeys.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'io/sentry/protocol/User$JsonKeys');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $User$JsonKeys$NullableType();
  static const type = $User$JsonKeys$Type();
  static final _id_EMAIL = _class.staticFieldId(
    r'EMAIL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EMAIL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EMAIL =>
      _id_EMAIL.get(_class, const jni$_.JStringNullableType());

  static final _id_ID = _class.staticFieldId(
    r'ID',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ID`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ID =>
      _id_ID.get(_class, const jni$_.JStringNullableType());

  static final _id_USERNAME = _class.staticFieldId(
    r'USERNAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String USERNAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get USERNAME =>
      _id_USERNAME.get(_class, const jni$_.JStringNullableType());

  static final _id_IP_ADDRESS = _class.staticFieldId(
    r'IP_ADDRESS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String IP_ADDRESS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get IP_ADDRESS =>
      _id_IP_ADDRESS.get(_class, const jni$_.JStringNullableType());

  static final _id_NAME = _class.staticFieldId(
    r'NAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String NAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get NAME =>
      _id_NAME.get(_class, const jni$_.JStringNullableType());

  static final _id_GEO = _class.staticFieldId(
    r'GEO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String GEO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get GEO =>
      _id_GEO.get(_class, const jni$_.JStringNullableType());

  static final _id_DATA = _class.staticFieldId(
    r'DATA',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DATA`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DATA =>
      _id_DATA.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory User$JsonKeys() {
    return User$JsonKeys.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $User$JsonKeys$NullableType extends jni$_.JObjType<User$JsonKeys?> {
  @jni$_.internal
  const $User$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/User$JsonKeys;';

  @jni$_.internal
  @core$_.override
  User$JsonKeys? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : User$JsonKeys.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<User$JsonKeys?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($User$JsonKeys$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($User$JsonKeys$NullableType) &&
        other is $User$JsonKeys$NullableType;
  }
}

final class $User$JsonKeys$Type extends jni$_.JObjType<User$JsonKeys> {
  @jni$_.internal
  const $User$JsonKeys$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/User$JsonKeys;';

  @jni$_.internal
  @core$_.override
  User$JsonKeys fromReference(jni$_.JReference reference) =>
      User$JsonKeys.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<User$JsonKeys?> get nullableType =>
      const $User$JsonKeys$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($User$JsonKeys$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($User$JsonKeys$Type) &&
        other is $User$JsonKeys$Type;
  }
}

/// from: `io.sentry.protocol.User`
class User extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<User> $type;

  @jni$_.internal
  User.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'io/sentry/protocol/User');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $User$NullableType();
  static const type = $User$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory User() {
    return User.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Lio/sentry/protocol/User;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(io.sentry.protocol.User user)`
  /// The returned object must be released after use, by calling the [release] method.
  factory User.new$1(
    User user,
  ) {
    final _$user = user.reference;
    return User.fromReference(_new$1(_class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr, _$user.pointer)
        .reference);
  }

  static final _id_fromMap = _class.staticMethodId(
    r'fromMap',
    r'(Ljava/util/Map;Lio/sentry/SentryOptions;)Lio/sentry/protocol/User;',
  );

  static final _fromMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public io.sentry.protocol.User fromMap(java.util.Map<java.lang.String, java.lang.Object> map, io.sentry.SentryOptions sentryOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  static User? fromMap(
    jni$_.JMap<jni$_.JString?, jni$_.JObject?> map,
    jni$_.JObject sentryOptions,
  ) {
    final _$map = map.reference;
    final _$sentryOptions = sentryOptions.reference;
    return _fromMap(_class.reference.pointer, _id_fromMap as jni$_.JMethodIDPtr,
            _$map.pointer, _$sentryOptions.pointer)
        .object<User?>(const $User$NullableType());
  }

  static final _id_getEmail = _class.instanceMethodId(
    r'getEmail',
    r'()Ljava/lang/String;',
  );

  static final _getEmail = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getEmail()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getEmail() {
    return _getEmail(reference.pointer, _id_getEmail as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setEmail = _class.instanceMethodId(
    r'setEmail',
    r'(Ljava/lang/String;)V',
  );

  static final _setEmail = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setEmail(java.lang.String string)`
  void setEmail(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setEmail(reference.pointer, _id_setEmail as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getId = _class.instanceMethodId(
    r'getId',
    r'()Ljava/lang/String;',
  );

  static final _getId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getId() {
    return _getId(reference.pointer, _id_getId as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setId = _class.instanceMethodId(
    r'setId',
    r'(Ljava/lang/String;)V',
  );

  static final _setId = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setId(java.lang.String string)`
  void setId(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setId(reference.pointer, _id_setId as jni$_.JMethodIDPtr, _$string.pointer)
        .check();
  }

  static final _id_getUsername = _class.instanceMethodId(
    r'getUsername',
    r'()Ljava/lang/String;',
  );

  static final _getUsername = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getUsername()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getUsername() {
    return _getUsername(
            reference.pointer, _id_getUsername as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setUsername = _class.instanceMethodId(
    r'setUsername',
    r'(Ljava/lang/String;)V',
  );

  static final _setUsername = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setUsername(java.lang.String string)`
  void setUsername(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setUsername(reference.pointer, _id_setUsername as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getIpAddress = _class.instanceMethodId(
    r'getIpAddress',
    r'()Ljava/lang/String;',
  );

  static final _getIpAddress = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getIpAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getIpAddress() {
    return _getIpAddress(
            reference.pointer, _id_getIpAddress as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setIpAddress = _class.instanceMethodId(
    r'setIpAddress',
    r'(Ljava/lang/String;)V',
  );

  static final _setIpAddress = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setIpAddress(java.lang.String string)`
  void setIpAddress(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setIpAddress(reference.pointer, _id_setIpAddress as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getName() {
    return _getName(reference.pointer, _id_getName as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setName = _class.instanceMethodId(
    r'setName',
    r'(Ljava/lang/String;)V',
  );

  static final _setName = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setName(java.lang.String string)`
  void setName(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setName(reference.pointer, _id_setName as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getGeo = _class.instanceMethodId(
    r'getGeo',
    r'()Lio/sentry/protocol/Geo;',
  );

  static final _getGeo = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public io.sentry.protocol.Geo getGeo()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getGeo() {
    return _getGeo(reference.pointer, _id_getGeo as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setGeo = _class.instanceMethodId(
    r'setGeo',
    r'(Lio/sentry/protocol/Geo;)V',
  );

  static final _setGeo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setGeo(io.sentry.protocol.Geo geo)`
  void setGeo(
    jni$_.JObject? geo,
  ) {
    final _$geo = geo?.reference ?? jni$_.jNullReference;
    _setGeo(reference.pointer, _id_setGeo as jni$_.JMethodIDPtr, _$geo.pointer)
        .check();
  }

  static final _id_getData = _class.instanceMethodId(
    r'getData',
    r'()Ljava/util/Map;',
  );

  static final _getData = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> getData()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString>? getData() {
    return _getData(reference.pointer, _id_getData as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString>(
                jni$_.JStringNullableType(), jni$_.JStringType()));
  }

  static final _id_setData = _class.instanceMethodId(
    r'setData',
    r'(Ljava/util/Map;)V',
  );

  static final _setData = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setData(java.util.Map<java.lang.String, java.lang.String> map)`
  void setData(
    jni$_.JMap<jni$_.JString?, jni$_.JString>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    _setData(
            reference.pointer, _id_setData as jni$_.JMethodIDPtr, _$map.pointer)
        .check();
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getUnknown = _class.instanceMethodId(
    r'getUnknown',
    r'()Ljava/util/Map;',
  );

  static final _getUnknown = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Map<java.lang.String, java.lang.Object> getUnknown()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JObject?>? getUnknown() {
    return _getUnknown(reference.pointer, _id_getUnknown as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JObject?>(
                jni$_.JStringNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_setUnknown = _class.instanceMethodId(
    r'setUnknown',
    r'(Ljava/util/Map;)V',
  );

  static final _setUnknown = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setUnknown(java.util.Map<java.lang.String, java.lang.Object> map)`
  void setUnknown(
    jni$_.JMap<jni$_.JString?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    _setUnknown(reference.pointer, _id_setUnknown as jni$_.JMethodIDPtr,
            _$map.pointer)
        .check();
  }

  static final _id_serialize = _class.instanceMethodId(
    r'serialize',
    r'(Lio/sentry/ObjectWriter;Lio/sentry/ILogger;)V',
  );

  static final _serialize = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void serialize(io.sentry.ObjectWriter objectWriter, io.sentry.ILogger iLogger)`
  void serialize(
    jni$_.JObject objectWriter,
    jni$_.JObject iLogger,
  ) {
    final _$objectWriter = objectWriter.reference;
    final _$iLogger = iLogger.reference;
    _serialize(reference.pointer, _id_serialize as jni$_.JMethodIDPtr,
            _$objectWriter.pointer, _$iLogger.pointer)
        .check();
  }
}

final class $User$NullableType extends jni$_.JObjType<User?> {
  @jni$_.internal
  const $User$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/User;';

  @jni$_.internal
  @core$_.override
  User? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : User.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<User?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($User$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($User$NullableType) &&
        other is $User$NullableType;
  }
}

final class $User$Type extends jni$_.JObjType<User> {
  @jni$_.internal
  const $User$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lio/sentry/protocol/User;';

  @jni$_.internal
  @core$_.override
  User fromReference(jni$_.JReference reference) => User.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<User?> get nullableType => const $User$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($User$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($User$Type) && other is $User$Type;
  }
}

/// from: `android.graphics.Bitmap$CompressFormat`
class Bitmap$CompressFormat extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Bitmap$CompressFormat> $type;

  @jni$_.internal
  Bitmap$CompressFormat.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'android/graphics/Bitmap$CompressFormat');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Bitmap$CompressFormat$NullableType();
  static const type = $Bitmap$CompressFormat$Type();
  static final _id_JPEG = _class.staticFieldId(
    r'JPEG',
    r'Landroid/graphics/Bitmap$CompressFormat;',
  );

  /// from: `static public final android.graphics.Bitmap$CompressFormat JPEG`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat get JPEG =>
      _id_JPEG.get(_class, const $Bitmap$CompressFormat$Type());

  static final _id_PNG = _class.staticFieldId(
    r'PNG',
    r'Landroid/graphics/Bitmap$CompressFormat;',
  );

  /// from: `static public final android.graphics.Bitmap$CompressFormat PNG`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat get PNG =>
      _id_PNG.get(_class, const $Bitmap$CompressFormat$Type());

  static final _id_WEBP = _class.staticFieldId(
    r'WEBP',
    r'Landroid/graphics/Bitmap$CompressFormat;',
  );

  /// from: `static public final android.graphics.Bitmap$CompressFormat WEBP`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat get WEBP =>
      _id_WEBP.get(_class, const $Bitmap$CompressFormat$Type());

  static final _id_WEBP_LOSSY = _class.staticFieldId(
    r'WEBP_LOSSY',
    r'Landroid/graphics/Bitmap$CompressFormat;',
  );

  /// from: `static public final android.graphics.Bitmap$CompressFormat WEBP_LOSSY`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat get WEBP_LOSSY =>
      _id_WEBP_LOSSY.get(_class, const $Bitmap$CompressFormat$Type());

  static final _id_WEBP_LOSSLESS = _class.staticFieldId(
    r'WEBP_LOSSLESS',
    r'Landroid/graphics/Bitmap$CompressFormat;',
  );

  /// from: `static public final android.graphics.Bitmap$CompressFormat WEBP_LOSSLESS`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat get WEBP_LOSSLESS =>
      _id_WEBP_LOSSLESS.get(_class, const $Bitmap$CompressFormat$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Landroid/graphics/Bitmap$CompressFormat;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public android.graphics.Bitmap$CompressFormat[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Bitmap$CompressFormat?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<Bitmap$CompressFormat?>?>(
            const jni$_.JArrayNullableType<Bitmap$CompressFormat?>(
                $Bitmap$CompressFormat$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Landroid/graphics/Bitmap$CompressFormat;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap$CompressFormat valueOf(java.lang.String synthetic)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$CompressFormat? valueOf(
    jni$_.JString? synthetic,
  ) {
    final _$synthetic = synthetic?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$synthetic.pointer)
        .object<Bitmap$CompressFormat?>(
            const $Bitmap$CompressFormat$NullableType());
  }
}

final class $Bitmap$CompressFormat$NullableType
    extends jni$_.JObjType<Bitmap$CompressFormat?> {
  @jni$_.internal
  const $Bitmap$CompressFormat$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap$CompressFormat;';

  @jni$_.internal
  @core$_.override
  Bitmap$CompressFormat? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Bitmap$CompressFormat.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Bitmap$CompressFormat?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$CompressFormat$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$CompressFormat$NullableType) &&
        other is $Bitmap$CompressFormat$NullableType;
  }
}

final class $Bitmap$CompressFormat$Type
    extends jni$_.JObjType<Bitmap$CompressFormat> {
  @jni$_.internal
  const $Bitmap$CompressFormat$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap$CompressFormat;';

  @jni$_.internal
  @core$_.override
  Bitmap$CompressFormat fromReference(jni$_.JReference reference) =>
      Bitmap$CompressFormat.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Bitmap$CompressFormat?> get nullableType =>
      const $Bitmap$CompressFormat$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$CompressFormat$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$CompressFormat$Type) &&
        other is $Bitmap$CompressFormat$Type;
  }
}

/// from: `android.graphics.Bitmap$Config`
class Bitmap$Config extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Bitmap$Config> $type;

  @jni$_.internal
  Bitmap$Config.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/graphics/Bitmap$Config');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Bitmap$Config$NullableType();
  static const type = $Bitmap$Config$Type();
  static final _id_ALPHA_8 = _class.staticFieldId(
    r'ALPHA_8',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config ALPHA_8`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get ALPHA_8 =>
      _id_ALPHA_8.get(_class, const $Bitmap$Config$Type());

  static final _id_RGB_565 = _class.staticFieldId(
    r'RGB_565',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config RGB_565`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get RGB_565 =>
      _id_RGB_565.get(_class, const $Bitmap$Config$Type());

  static final _id_ARGB_4444 = _class.staticFieldId(
    r'ARGB_4444',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config ARGB_4444`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get ARGB_4444 =>
      _id_ARGB_4444.get(_class, const $Bitmap$Config$Type());

  static final _id_ARGB_8888 = _class.staticFieldId(
    r'ARGB_8888',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config ARGB_8888`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get ARGB_8888 =>
      _id_ARGB_8888.get(_class, const $Bitmap$Config$Type());

  static final _id_RGBA_F16 = _class.staticFieldId(
    r'RGBA_F16',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config RGBA_F16`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get RGBA_F16 =>
      _id_RGBA_F16.get(_class, const $Bitmap$Config$Type());

  static final _id_HARDWARE = _class.staticFieldId(
    r'HARDWARE',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config HARDWARE`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get HARDWARE =>
      _id_HARDWARE.get(_class, const $Bitmap$Config$Type());

  static final _id_RGBA_1010102 = _class.staticFieldId(
    r'RGBA_1010102',
    r'Landroid/graphics/Bitmap$Config;',
  );

  /// from: `static public final android.graphics.Bitmap$Config RGBA_1010102`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config get RGBA_1010102 =>
      _id_RGBA_1010102.get(_class, const $Bitmap$Config$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Landroid/graphics/Bitmap$Config;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public android.graphics.Bitmap$Config[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Bitmap$Config?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<Bitmap$Config?>?>(
            const jni$_.JArrayNullableType<Bitmap$Config?>(
                $Bitmap$Config$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Landroid/graphics/Bitmap$Config;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap$Config valueOf(java.lang.String synthetic)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap$Config? valueOf(
    jni$_.JString? synthetic,
  ) {
    final _$synthetic = synthetic?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$synthetic.pointer)
        .object<Bitmap$Config?>(const $Bitmap$Config$NullableType());
  }
}

final class $Bitmap$Config$NullableType extends jni$_.JObjType<Bitmap$Config?> {
  @jni$_.internal
  const $Bitmap$Config$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap$Config;';

  @jni$_.internal
  @core$_.override
  Bitmap$Config? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Bitmap$Config.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Bitmap$Config?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$Config$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$Config$NullableType) &&
        other is $Bitmap$Config$NullableType;
  }
}

final class $Bitmap$Config$Type extends jni$_.JObjType<Bitmap$Config> {
  @jni$_.internal
  const $Bitmap$Config$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap$Config;';

  @jni$_.internal
  @core$_.override
  Bitmap$Config fromReference(jni$_.JReference reference) =>
      Bitmap$Config.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Bitmap$Config?> get nullableType =>
      const $Bitmap$Config$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$Config$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$Config$Type) &&
        other is $Bitmap$Config$Type;
  }
}

/// from: `android.graphics.Bitmap`
class Bitmap extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Bitmap> $type;

  @jni$_.internal
  Bitmap.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/graphics/Bitmap');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Bitmap$NullableType();
  static const type = $Bitmap$Type();
  static final _id_CREATOR = _class.staticFieldId(
    r'CREATOR',
    r'Landroid/os/Parcelable$Creator;',
  );

  /// from: `static public final android.os.Parcelable$Creator<android.graphics.Bitmap> CREATOR`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? get CREATOR =>
      _id_CREATOR.get(_class, const jni$_.JObjectNullableType());

  /// from: `static public final int DENSITY_NONE`
  static const DENSITY_NONE = 0;
  static final _id_getDensity = _class.instanceMethodId(
    r'getDensity',
    r'()I',
  );

  static final _getDensity = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getDensity()`
  int getDensity() {
    return _getDensity(reference.pointer, _id_getDensity as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_setDensity = _class.instanceMethodId(
    r'setDensity',
    r'(I)V',
  );

  static final _setDensity = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setDensity(int i)`
  void setDensity(
    int i,
  ) {
    _setDensity(reference.pointer, _id_setDensity as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_reconfigure = _class.instanceMethodId(
    r'reconfigure',
    r'(IILandroid/graphics/Bitmap$Config;)V',
  );

  static final _reconfigure = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void reconfigure(int i, int i1, android.graphics.Bitmap$Config config)`
  void reconfigure(
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    _reconfigure(reference.pointer, _id_reconfigure as jni$_.JMethodIDPtr, i,
            i1, _$config.pointer)
        .check();
  }

  static final _id_setWidth = _class.instanceMethodId(
    r'setWidth',
    r'(I)V',
  );

  static final _setWidth = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setWidth(int i)`
  void setWidth(
    int i,
  ) {
    _setWidth(reference.pointer, _id_setWidth as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_setHeight = _class.instanceMethodId(
    r'setHeight',
    r'(I)V',
  );

  static final _setHeight = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setHeight(int i)`
  void setHeight(
    int i,
  ) {
    _setHeight(reference.pointer, _id_setHeight as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_setConfig = _class.instanceMethodId(
    r'setConfig',
    r'(Landroid/graphics/Bitmap$Config;)V',
  );

  static final _setConfig = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setConfig(android.graphics.Bitmap$Config config)`
  void setConfig(
    Bitmap$Config? config,
  ) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    _setConfig(reference.pointer, _id_setConfig as jni$_.JMethodIDPtr,
            _$config.pointer)
        .check();
  }

  static final _id_recycle = _class.instanceMethodId(
    r'recycle',
    r'()V',
  );

  static final _recycle = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void recycle()`
  void recycle() {
    _recycle(reference.pointer, _id_recycle as jni$_.JMethodIDPtr).check();
  }

  static final _id_isRecycled = _class.instanceMethodId(
    r'isRecycled',
    r'()Z',
  );

  static final _isRecycled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isRecycled()`
  bool isRecycled() {
    return _isRecycled(reference.pointer, _id_isRecycled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getGenerationId = _class.instanceMethodId(
    r'getGenerationId',
    r'()I',
  );

  static final _getGenerationId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getGenerationId()`
  int getGenerationId() {
    return _getGenerationId(
            reference.pointer, _id_getGenerationId as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_copyPixelsToBuffer = _class.instanceMethodId(
    r'copyPixelsToBuffer',
    r'(Ljava/nio/Buffer;)V',
  );

  static final _copyPixelsToBuffer = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void copyPixelsToBuffer(java.nio.Buffer buffer)`
  void copyPixelsToBuffer(
    jni$_.JBuffer? buffer,
  ) {
    final _$buffer = buffer?.reference ?? jni$_.jNullReference;
    _copyPixelsToBuffer(reference.pointer,
            _id_copyPixelsToBuffer as jni$_.JMethodIDPtr, _$buffer.pointer)
        .check();
  }

  static final _id_copyPixelsFromBuffer = _class.instanceMethodId(
    r'copyPixelsFromBuffer',
    r'(Ljava/nio/Buffer;)V',
  );

  static final _copyPixelsFromBuffer = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void copyPixelsFromBuffer(java.nio.Buffer buffer)`
  void copyPixelsFromBuffer(
    jni$_.JBuffer? buffer,
  ) {
    final _$buffer = buffer?.reference ?? jni$_.jNullReference;
    _copyPixelsFromBuffer(reference.pointer,
            _id_copyPixelsFromBuffer as jni$_.JMethodIDPtr, _$buffer.pointer)
        .check();
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(Landroid/graphics/Bitmap$Config;Z)Landroid/graphics/Bitmap;',
  );

  static final _copy = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public android.graphics.Bitmap copy(android.graphics.Bitmap$Config config, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap? copy(
    Bitmap$Config? config,
    bool z,
  ) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _copy(reference.pointer, _id_copy as jni$_.JMethodIDPtr,
            _$config.pointer, z ? 1 : 0)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_asShared = _class.instanceMethodId(
    r'asShared',
    r'()Landroid/graphics/Bitmap;',
  );

  static final _asShared = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public android.graphics.Bitmap asShared()`
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap? asShared() {
    return _asShared(reference.pointer, _id_asShared as jni$_.JMethodIDPtr)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_wrapHardwareBuffer = _class.staticMethodId(
    r'wrapHardwareBuffer',
    r'(Landroid/hardware/HardwareBuffer;Landroid/graphics/ColorSpace;)Landroid/graphics/Bitmap;',
  );

  static final _wrapHardwareBuffer = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap wrapHardwareBuffer(android.hardware.HardwareBuffer hardwareBuffer, android.graphics.ColorSpace colorSpace)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? wrapHardwareBuffer(
    jni$_.JObject? hardwareBuffer,
    jni$_.JObject? colorSpace,
  ) {
    final _$hardwareBuffer = hardwareBuffer?.reference ?? jni$_.jNullReference;
    final _$colorSpace = colorSpace?.reference ?? jni$_.jNullReference;
    return _wrapHardwareBuffer(
            _class.reference.pointer,
            _id_wrapHardwareBuffer as jni$_.JMethodIDPtr,
            _$hardwareBuffer.pointer,
            _$colorSpace.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createScaledBitmap = _class.staticMethodId(
    r'createScaledBitmap',
    r'(Landroid/graphics/Bitmap;IIZ)Landroid/graphics/Bitmap;',
  );

  static final _createScaledBitmap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int, int, int)>();

  /// from: `static public android.graphics.Bitmap createScaledBitmap(android.graphics.Bitmap bitmap, int i, int i1, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createScaledBitmap(
    Bitmap? bitmap,
    int i,
    int i1,
    bool z,
  ) {
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    return _createScaledBitmap(
            _class.reference.pointer,
            _id_createScaledBitmap as jni$_.JMethodIDPtr,
            _$bitmap.pointer,
            i,
            i1,
            z ? 1 : 0)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/graphics/Bitmap;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.graphics.Bitmap bitmap)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap(
    Bitmap? bitmap,
  ) {
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    return _createBitmap(_class.reference.pointer,
            _id_createBitmap as jni$_.JMethodIDPtr, _$bitmap.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$1 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/graphics/Bitmap;IIII)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.graphics.Bitmap bitmap, int i, int i1, int i2, int i3)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$1(
    Bitmap? bitmap,
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    return _createBitmap$1(
            _class.reference.pointer,
            _id_createBitmap$1 as jni$_.JMethodIDPtr,
            _$bitmap.pointer,
            i,
            i1,
            i2,
            i3)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$2 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/graphics/Bitmap;IIIILandroid/graphics/Matrix;Z)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.graphics.Bitmap bitmap, int i, int i1, int i2, int i3, android.graphics.Matrix matrix, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$2(
    Bitmap? bitmap,
    int i,
    int i1,
    int i2,
    int i3,
    jni$_.JObject? matrix,
    bool z,
  ) {
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    final _$matrix = matrix?.reference ?? jni$_.jNullReference;
    return _createBitmap$2(
            _class.reference.pointer,
            _id_createBitmap$2 as jni$_.JMethodIDPtr,
            _$bitmap.pointer,
            i,
            i1,
            i2,
            i3,
            _$matrix.pointer,
            z ? 1 : 0)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$3 = _class.staticMethodId(
    r'createBitmap',
    r'(IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(int i, int i1, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$3(
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$3(_class.reference.pointer,
            _id_createBitmap$3 as jni$_.JMethodIDPtr, i, i1, _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$4 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/util/DisplayMetrics;IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int i, int i1, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$4(
    jni$_.JObject? displayMetrics,
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$4(
            _class.reference.pointer,
            _id_createBitmap$4 as jni$_.JMethodIDPtr,
            _$displayMetrics.pointer,
            i,
            i1,
            _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$5 = _class.staticMethodId(
    r'createBitmap',
    r'(IILandroid/graphics/Bitmap$Config;Z)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$5 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `static public android.graphics.Bitmap createBitmap(int i, int i1, android.graphics.Bitmap$Config config, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$5(
    int i,
    int i1,
    Bitmap$Config? config,
    bool z,
  ) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$5(
            _class.reference.pointer,
            _id_createBitmap$5 as jni$_.JMethodIDPtr,
            i,
            i1,
            _$config.pointer,
            z ? 1 : 0)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$6 = _class.staticMethodId(
    r'createBitmap',
    r'(IILandroid/graphics/Bitmap$Config;ZLandroid/graphics/ColorSpace;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$6 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(int i, int i1, android.graphics.Bitmap$Config config, boolean z, android.graphics.ColorSpace colorSpace)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$6(
    int i,
    int i1,
    Bitmap$Config? config,
    bool z,
    jni$_.JObject? colorSpace,
  ) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    final _$colorSpace = colorSpace?.reference ?? jni$_.jNullReference;
    return _createBitmap$6(
            _class.reference.pointer,
            _id_createBitmap$6 as jni$_.JMethodIDPtr,
            i,
            i1,
            _$config.pointer,
            z ? 1 : 0,
            _$colorSpace.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$7 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/util/DisplayMetrics;IILandroid/graphics/Bitmap$Config;Z)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$7 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int i, int i1, android.graphics.Bitmap$Config config, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$7(
    jni$_.JObject? displayMetrics,
    int i,
    int i1,
    Bitmap$Config? config,
    bool z,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$7(
            _class.reference.pointer,
            _id_createBitmap$7 as jni$_.JMethodIDPtr,
            _$displayMetrics.pointer,
            i,
            i1,
            _$config.pointer,
            z ? 1 : 0)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$8 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/util/DisplayMetrics;IILandroid/graphics/Bitmap$Config;ZLandroid/graphics/ColorSpace;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$8 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int i, int i1, android.graphics.Bitmap$Config config, boolean z, android.graphics.ColorSpace colorSpace)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$8(
    jni$_.JObject? displayMetrics,
    int i,
    int i1,
    Bitmap$Config? config,
    bool z,
    jni$_.JObject? colorSpace,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    final _$colorSpace = colorSpace?.reference ?? jni$_.jNullReference;
    return _createBitmap$8(
            _class.reference.pointer,
            _id_createBitmap$8 as jni$_.JMethodIDPtr,
            _$displayMetrics.pointer,
            i,
            i1,
            _$config.pointer,
            z ? 1 : 0,
            _$colorSpace.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$9 = _class.staticMethodId(
    r'createBitmap',
    r'([IIIIILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$9 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(int[] is, int i, int i1, int i2, int i3, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$9(
    jni$_.JIntArray? is$,
    int i,
    int i1,
    int i2,
    int i3,
    Bitmap$Config? config,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$9(
            _class.reference.pointer,
            _id_createBitmap$9 as jni$_.JMethodIDPtr,
            _$is$.pointer,
            i,
            i1,
            i2,
            i3,
            _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$10 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/util/DisplayMetrics;[IIIIILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$10 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int[] is, int i, int i1, int i2, int i3, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$10(
    jni$_.JObject? displayMetrics,
    jni$_.JIntArray? is$,
    int i,
    int i1,
    int i2,
    int i3,
    Bitmap$Config? config,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$10(
            _class.reference.pointer,
            _id_createBitmap$10 as jni$_.JMethodIDPtr,
            _$displayMetrics.pointer,
            _$is$.pointer,
            i,
            i1,
            i2,
            i3,
            _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$11 = _class.staticMethodId(
    r'createBitmap',
    r'([IIILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$11 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(int[] is, int i, int i1, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$11(
    jni$_.JIntArray? is$,
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$11(
            _class.reference.pointer,
            _id_createBitmap$11 as jni$_.JMethodIDPtr,
            _$is$.pointer,
            i,
            i1,
            _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$12 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/util/DisplayMetrics;[IIILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$12 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int[] is, int i, int i1, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$12(
    jni$_.JObject? displayMetrics,
    jni$_.JIntArray? is$,
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$12(
            _class.reference.pointer,
            _id_createBitmap$12 as jni$_.JMethodIDPtr,
            _$displayMetrics.pointer,
            _$is$.pointer,
            i,
            i1,
            _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$13 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/graphics/Picture;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$13 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.graphics.Picture picture)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$13(
    jni$_.JObject? picture,
  ) {
    final _$picture = picture?.reference ?? jni$_.jNullReference;
    return _createBitmap$13(_class.reference.pointer,
            _id_createBitmap$13 as jni$_.JMethodIDPtr, _$picture.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_createBitmap$14 = _class.staticMethodId(
    r'createBitmap',
    r'(Landroid/graphics/Picture;IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;',
  );

  static final _createBitmap$14 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public android.graphics.Bitmap createBitmap(android.graphics.Picture picture, int i, int i1, android.graphics.Bitmap$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap? createBitmap$14(
    jni$_.JObject? picture,
    int i,
    int i1,
    Bitmap$Config? config,
  ) {
    final _$picture = picture?.reference ?? jni$_.jNullReference;
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _createBitmap$14(
            _class.reference.pointer,
            _id_createBitmap$14 as jni$_.JMethodIDPtr,
            _$picture.pointer,
            i,
            i1,
            _$config.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_getNinePatchChunk = _class.instanceMethodId(
    r'getNinePatchChunk',
    r'()[B',
  );

  static final _getNinePatchChunk = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public byte[] getNinePatchChunk()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? getNinePatchChunk() {
    return _getNinePatchChunk(
            reference.pointer, _id_getNinePatchChunk as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_compress = _class.instanceMethodId(
    r'compress',
    r'(Landroid/graphics/Bitmap$CompressFormat;ILjava/io/OutputStream;)Z',
  );

  static final _compress = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean compress(android.graphics.Bitmap$CompressFormat compressFormat, int i, java.io.OutputStream outputStream)`
  bool compress(
    Bitmap$CompressFormat? compressFormat,
    int i,
    jni$_.JObject? outputStream,
  ) {
    final _$compressFormat = compressFormat?.reference ?? jni$_.jNullReference;
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return _compress(reference.pointer, _id_compress as jni$_.JMethodIDPtr,
            _$compressFormat.pointer, i, _$outputStream.pointer)
        .boolean;
  }

  static final _id_isMutable = _class.instanceMethodId(
    r'isMutable',
    r'()Z',
  );

  static final _isMutable = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isMutable()`
  bool isMutable() {
    return _isMutable(reference.pointer, _id_isMutable as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_isPremultiplied = _class.instanceMethodId(
    r'isPremultiplied',
    r'()Z',
  );

  static final _isPremultiplied = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isPremultiplied()`
  bool isPremultiplied() {
    return _isPremultiplied(
            reference.pointer, _id_isPremultiplied as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setPremultiplied = _class.instanceMethodId(
    r'setPremultiplied',
    r'(Z)V',
  );

  static final _setPremultiplied = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setPremultiplied(boolean z)`
  void setPremultiplied(
    bool z,
  ) {
    _setPremultiplied(reference.pointer,
            _id_setPremultiplied as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getWidth = _class.instanceMethodId(
    r'getWidth',
    r'()I',
  );

  static final _getWidth = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getWidth()`
  int getWidth() {
    return _getWidth(reference.pointer, _id_getWidth as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getHeight = _class.instanceMethodId(
    r'getHeight',
    r'()I',
  );

  static final _getHeight = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getHeight()`
  int getHeight() {
    return _getHeight(reference.pointer, _id_getHeight as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getScaledWidth = _class.instanceMethodId(
    r'getScaledWidth',
    r'(Landroid/graphics/Canvas;)I',
  );

  static final _getScaledWidth = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int getScaledWidth(android.graphics.Canvas canvas)`
  int getScaledWidth(
    jni$_.JObject? canvas,
  ) {
    final _$canvas = canvas?.reference ?? jni$_.jNullReference;
    return _getScaledWidth(reference.pointer,
            _id_getScaledWidth as jni$_.JMethodIDPtr, _$canvas.pointer)
        .integer;
  }

  static final _id_getScaledHeight = _class.instanceMethodId(
    r'getScaledHeight',
    r'(Landroid/graphics/Canvas;)I',
  );

  static final _getScaledHeight = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int getScaledHeight(android.graphics.Canvas canvas)`
  int getScaledHeight(
    jni$_.JObject? canvas,
  ) {
    final _$canvas = canvas?.reference ?? jni$_.jNullReference;
    return _getScaledHeight(reference.pointer,
            _id_getScaledHeight as jni$_.JMethodIDPtr, _$canvas.pointer)
        .integer;
  }

  static final _id_getScaledWidth$1 = _class.instanceMethodId(
    r'getScaledWidth',
    r'(Landroid/util/DisplayMetrics;)I',
  );

  static final _getScaledWidth$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int getScaledWidth(android.util.DisplayMetrics displayMetrics)`
  int getScaledWidth$1(
    jni$_.JObject? displayMetrics,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    return _getScaledWidth$1(
            reference.pointer,
            _id_getScaledWidth$1 as jni$_.JMethodIDPtr,
            _$displayMetrics.pointer)
        .integer;
  }

  static final _id_getScaledHeight$1 = _class.instanceMethodId(
    r'getScaledHeight',
    r'(Landroid/util/DisplayMetrics;)I',
  );

  static final _getScaledHeight$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int getScaledHeight(android.util.DisplayMetrics displayMetrics)`
  int getScaledHeight$1(
    jni$_.JObject? displayMetrics,
  ) {
    final _$displayMetrics = displayMetrics?.reference ?? jni$_.jNullReference;
    return _getScaledHeight$1(
            reference.pointer,
            _id_getScaledHeight$1 as jni$_.JMethodIDPtr,
            _$displayMetrics.pointer)
        .integer;
  }

  static final _id_getScaledWidth$2 = _class.instanceMethodId(
    r'getScaledWidth',
    r'(I)I',
  );

  static final _getScaledWidth$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public int getScaledWidth(int i)`
  int getScaledWidth$2(
    int i,
  ) {
    return _getScaledWidth$2(
            reference.pointer, _id_getScaledWidth$2 as jni$_.JMethodIDPtr, i)
        .integer;
  }

  static final _id_getScaledHeight$2 = _class.instanceMethodId(
    r'getScaledHeight',
    r'(I)I',
  );

  static final _getScaledHeight$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public int getScaledHeight(int i)`
  int getScaledHeight$2(
    int i,
  ) {
    return _getScaledHeight$2(
            reference.pointer, _id_getScaledHeight$2 as jni$_.JMethodIDPtr, i)
        .integer;
  }

  static final _id_getRowBytes = _class.instanceMethodId(
    r'getRowBytes',
    r'()I',
  );

  static final _getRowBytes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getRowBytes()`
  int getRowBytes() {
    return _getRowBytes(
            reference.pointer, _id_getRowBytes as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getByteCount = _class.instanceMethodId(
    r'getByteCount',
    r'()I',
  );

  static final _getByteCount = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getByteCount()`
  int getByteCount() {
    return _getByteCount(
            reference.pointer, _id_getByteCount as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getAllocationByteCount = _class.instanceMethodId(
    r'getAllocationByteCount',
    r'()I',
  );

  static final _getAllocationByteCount = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getAllocationByteCount()`
  int getAllocationByteCount() {
    return _getAllocationByteCount(
            reference.pointer, _id_getAllocationByteCount as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getConfig = _class.instanceMethodId(
    r'getConfig',
    r'()Landroid/graphics/Bitmap$Config;',
  );

  static final _getConfig = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public android.graphics.Bitmap$Config getConfig()`
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap$Config? getConfig() {
    return _getConfig(reference.pointer, _id_getConfig as jni$_.JMethodIDPtr)
        .object<Bitmap$Config?>(const $Bitmap$Config$NullableType());
  }

  static final _id_hasAlpha = _class.instanceMethodId(
    r'hasAlpha',
    r'()Z',
  );

  static final _hasAlpha = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean hasAlpha()`
  bool hasAlpha() {
    return _hasAlpha(reference.pointer, _id_hasAlpha as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setHasAlpha = _class.instanceMethodId(
    r'setHasAlpha',
    r'(Z)V',
  );

  static final _setHasAlpha = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setHasAlpha(boolean z)`
  void setHasAlpha(
    bool z,
  ) {
    _setHasAlpha(
            reference.pointer, _id_setHasAlpha as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_hasMipMap = _class.instanceMethodId(
    r'hasMipMap',
    r'()Z',
  );

  static final _hasMipMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean hasMipMap()`
  bool hasMipMap() {
    return _hasMipMap(reference.pointer, _id_hasMipMap as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setHasMipMap = _class.instanceMethodId(
    r'setHasMipMap',
    r'(Z)V',
  );

  static final _setHasMipMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setHasMipMap(boolean z)`
  void setHasMipMap(
    bool z,
  ) {
    _setHasMipMap(reference.pointer, _id_setHasMipMap as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .check();
  }

  static final _id_getColorSpace = _class.instanceMethodId(
    r'getColorSpace',
    r'()Landroid/graphics/ColorSpace;',
  );

  static final _getColorSpace = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public android.graphics.ColorSpace getColorSpace()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getColorSpace() {
    return _getColorSpace(
            reference.pointer, _id_getColorSpace as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setColorSpace = _class.instanceMethodId(
    r'setColorSpace',
    r'(Landroid/graphics/ColorSpace;)V',
  );

  static final _setColorSpace = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setColorSpace(android.graphics.ColorSpace colorSpace)`
  void setColorSpace(
    jni$_.JObject? colorSpace,
  ) {
    final _$colorSpace = colorSpace?.reference ?? jni$_.jNullReference;
    _setColorSpace(reference.pointer, _id_setColorSpace as jni$_.JMethodIDPtr,
            _$colorSpace.pointer)
        .check();
  }

  static final _id_hasGainmap = _class.instanceMethodId(
    r'hasGainmap',
    r'()Z',
  );

  static final _hasGainmap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean hasGainmap()`
  bool hasGainmap() {
    return _hasGainmap(reference.pointer, _id_hasGainmap as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getGainmap = _class.instanceMethodId(
    r'getGainmap',
    r'()Landroid/graphics/Gainmap;',
  );

  static final _getGainmap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public android.graphics.Gainmap getGainmap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getGainmap() {
    return _getGainmap(reference.pointer, _id_getGainmap as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setGainmap = _class.instanceMethodId(
    r'setGainmap',
    r'(Landroid/graphics/Gainmap;)V',
  );

  static final _setGainmap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setGainmap(android.graphics.Gainmap gainmap)`
  void setGainmap(
    jni$_.JObject? gainmap,
  ) {
    final _$gainmap = gainmap?.reference ?? jni$_.jNullReference;
    _setGainmap(reference.pointer, _id_setGainmap as jni$_.JMethodIDPtr,
            _$gainmap.pointer)
        .check();
  }

  static final _id_eraseColor = _class.instanceMethodId(
    r'eraseColor',
    r'(I)V',
  );

  static final _eraseColor = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void eraseColor(int i)`
  void eraseColor(
    int i,
  ) {
    _eraseColor(reference.pointer, _id_eraseColor as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_eraseColor$1 = _class.instanceMethodId(
    r'eraseColor',
    r'(J)V',
  );

  static final _eraseColor$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void eraseColor(long j)`
  void eraseColor$1(
    int j,
  ) {
    _eraseColor$1(reference.pointer, _id_eraseColor$1 as jni$_.JMethodIDPtr, j)
        .check();
  }

  static final _id_getPixel = _class.instanceMethodId(
    r'getPixel',
    r'(II)I',
  );

  static final _getPixel = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int)>();

  /// from: `public int getPixel(int i, int i1)`
  int getPixel(
    int i,
    int i1,
  ) {
    return _getPixel(
            reference.pointer, _id_getPixel as jni$_.JMethodIDPtr, i, i1)
        .integer;
  }

  static final _id_getColor = _class.instanceMethodId(
    r'getColor',
    r'(II)Landroid/graphics/Color;',
  );

  static final _getColor = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int)>();

  /// from: `public android.graphics.Color getColor(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getColor(
    int i,
    int i1,
  ) {
    return _getColor(
            reference.pointer, _id_getColor as jni$_.JMethodIDPtr, i, i1)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getPixels = _class.instanceMethodId(
    r'getPixels',
    r'([IIIIIII)V',
  );

  static final _getPixels = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              int,
              int)>();

  /// from: `public void getPixels(int[] is, int i, int i1, int i2, int i3, int i4, int i5)`
  void getPixels(
    jni$_.JIntArray? is$,
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    _getPixels(reference.pointer, _id_getPixels as jni$_.JMethodIDPtr,
            _$is$.pointer, i, i1, i2, i3, i4, i5)
        .check();
  }

  static final _id_setPixel = _class.instanceMethodId(
    r'setPixel',
    r'(III)V',
  );

  static final _setPixel = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int, int)>();

  /// from: `public void setPixel(int i, int i1, int i2)`
  void setPixel(
    int i,
    int i1,
    int i2,
  ) {
    _setPixel(reference.pointer, _id_setPixel as jni$_.JMethodIDPtr, i, i1, i2)
        .check();
  }

  static final _id_setPixels = _class.instanceMethodId(
    r'setPixels',
    r'([IIIIIII)V',
  );

  static final _setPixels = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              int,
              int)>();

  /// from: `public void setPixels(int[] is, int i, int i1, int i2, int i3, int i4, int i5)`
  void setPixels(
    jni$_.JIntArray? is$,
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    _setPixels(reference.pointer, _id_setPixels as jni$_.JMethodIDPtr,
            _$is$.pointer, i, i1, i2, i3, i4, i5)
        .check();
  }

  static final _id_describeContents = _class.instanceMethodId(
    r'describeContents',
    r'()I',
  );

  static final _describeContents = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int describeContents()`
  int describeContents() {
    return _describeContents(
            reference.pointer, _id_describeContents as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_writeToParcel = _class.instanceMethodId(
    r'writeToParcel',
    r'(Landroid/os/Parcel;I)V',
  );

  static final _writeToParcel = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public void writeToParcel(android.os.Parcel parcel, int i)`
  void writeToParcel(
    jni$_.JObject? parcel,
    int i,
  ) {
    final _$parcel = parcel?.reference ?? jni$_.jNullReference;
    _writeToParcel(reference.pointer, _id_writeToParcel as jni$_.JMethodIDPtr,
            _$parcel.pointer, i)
        .check();
  }

  static final _id_extractAlpha = _class.instanceMethodId(
    r'extractAlpha',
    r'()Landroid/graphics/Bitmap;',
  );

  static final _extractAlpha = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public android.graphics.Bitmap extractAlpha()`
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap? extractAlpha() {
    return _extractAlpha(
            reference.pointer, _id_extractAlpha as jni$_.JMethodIDPtr)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_extractAlpha$1 = _class.instanceMethodId(
    r'extractAlpha',
    r'(Landroid/graphics/Paint;[I)Landroid/graphics/Bitmap;',
  );

  static final _extractAlpha$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public android.graphics.Bitmap extractAlpha(android.graphics.Paint paint, int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap? extractAlpha$1(
    jni$_.JObject? paint,
    jni$_.JIntArray? is$,
  ) {
    final _$paint = paint?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _extractAlpha$1(
            reference.pointer,
            _id_extractAlpha$1 as jni$_.JMethodIDPtr,
            _$paint.pointer,
            _$is$.pointer)
        .object<Bitmap?>(const $Bitmap$NullableType());
  }

  static final _id_sameAs = _class.instanceMethodId(
    r'sameAs',
    r'(Landroid/graphics/Bitmap;)Z',
  );

  static final _sameAs = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean sameAs(android.graphics.Bitmap bitmap)`
  bool sameAs(
    Bitmap? bitmap,
  ) {
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    return _sameAs(reference.pointer, _id_sameAs as jni$_.JMethodIDPtr,
            _$bitmap.pointer)
        .boolean;
  }

  static final _id_prepareToDraw = _class.instanceMethodId(
    r'prepareToDraw',
    r'()V',
  );

  static final _prepareToDraw = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void prepareToDraw()`
  void prepareToDraw() {
    _prepareToDraw(reference.pointer, _id_prepareToDraw as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_getHardwareBuffer = _class.instanceMethodId(
    r'getHardwareBuffer',
    r'()Landroid/hardware/HardwareBuffer;',
  );

  static final _getHardwareBuffer = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public android.hardware.HardwareBuffer getHardwareBuffer()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getHardwareBuffer() {
    return _getHardwareBuffer(
            reference.pointer, _id_getHardwareBuffer as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $Bitmap$NullableType extends jni$_.JObjType<Bitmap?> {
  @jni$_.internal
  const $Bitmap$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap;';

  @jni$_.internal
  @core$_.override
  Bitmap? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Bitmap.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Bitmap?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$NullableType) &&
        other is $Bitmap$NullableType;
  }
}

final class $Bitmap$Type extends jni$_.JObjType<Bitmap> {
  @jni$_.internal
  const $Bitmap$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Bitmap;';

  @jni$_.internal
  @core$_.override
  Bitmap fromReference(jni$_.JReference reference) => Bitmap.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Bitmap?> get nullableType => const $Bitmap$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bitmap$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap$Type) && other is $Bitmap$Type;
  }
}
