// ignore_for_file: type=lint, unused_element

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _SentryCocoa_wrapListenerBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _SentryCocoa_wrapBlockingBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external ffi.Pointer<objc.ObjCObject> _SentryCocoa_protocolTrampoline_1mbt9g9(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

/// WARNING: NSUUID is a stub. To generate bindings for this class, include
/// NSUUID in your config's objc-interfaces list.
///
/// NSUUID
class NSUUID extends objc.NSObject
    implements objc.NSCopying, objc.NSSecureCoding {
  NSUUID._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSUUID',
        iOS: (false, (6, 0, 0)), macOS: (false, (10, 8, 0)));
  }

  /// Constructs a [NSUUID] that points to the same underlying object as [other].
  NSUUID.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSUUID] that wraps the given raw object pointer.
  NSUUID.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: SentryAppStartMeasurement is a stub. To generate bindings for this class, include
/// SentryAppStartMeasurement in your config's objc-interfaces list.
///
/// SentryAppStartMeasurement
class SentryAppStartMeasurement extends objc.ObjCObjectBase {
  SentryAppStartMeasurement._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryAppStartMeasurement] that points to the same underlying object as [other].
  SentryAppStartMeasurement.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryAppStartMeasurement] that wraps the given raw object pointer.
  SentryAppStartMeasurement.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

void _ObjCBlock_ffiVoid_SentryAppStartMeasurement_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_SentryAppStartMeasurement_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_SentryAppStartMeasurement_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_SentryAppStartMeasurement_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_SentryAppStartMeasurement_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_SentryAppStartMeasurement_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_SentryAppStartMeasurement_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_SentryAppStartMeasurement_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_SentryAppStartMeasurement_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_SentryAppStartMeasurement_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_SentryAppStartMeasurement_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_SentryAppStartMeasurement_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_SentryAppStartMeasurement_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_SentryAppStartMeasurement_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>`.
abstract final class ObjCBlock_ffiVoid_SentryAppStartMeasurement {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_SentryAppStartMeasurement_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>
      fromFunction(void Function(SentryAppStartMeasurement?) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_SentryAppStartMeasurement_closureCallable,
                  (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
                      ? null
                      : SentryAppStartMeasurement.castFromPointer(arg0,
                          retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)> listener(
      void Function(SentryAppStartMeasurement?) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_SentryAppStartMeasurement_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : SentryAppStartMeasurement.castFromPointer(arg0,
                retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _SentryCocoa_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)> blocking(
      void Function(SentryAppStartMeasurement?) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_SentryAppStartMeasurement_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : SentryAppStartMeasurement.castFromPointer(arg0,
                retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_SentryAppStartMeasurement_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : SentryAppStartMeasurement.castFromPointer(arg0,
                retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _SentryCocoa_wrapBlockingBlock_xtuoz7(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>`.
extension ObjCBlock_ffiVoid_SentryAppStartMeasurement_CallExtension
    on objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)> {
  void call(SentryAppStartMeasurement? arg0) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<objc.ObjCObject> arg0)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>)>()(
      ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _class_PrivateSentrySDKOnly = objc.getClass("PrivateSentrySDKOnly");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();

/// WARNING: SentryEnvelope is a stub. To generate bindings for this class, include
/// SentryEnvelope in your config's objc-interfaces list.
///
/// SentryEnvelope
class SentryEnvelope extends objc.ObjCObjectBase {
  SentryEnvelope._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryEnvelope] that points to the same underlying object as [other].
  SentryEnvelope.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryEnvelope] that wraps the given raw object pointer.
  SentryEnvelope.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_storeEnvelope_ = objc.registerName("storeEnvelope:");
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_captureEnvelope_ = objc.registerName("captureEnvelope:");
late final _sel_envelopeWithData_ = objc.registerName("envelopeWithData:");
final _objc_msgSend_1sotr3r = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_getDebugImages = objc.registerName("getDebugImages");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_getDebugImagesCrashed_ =
    objc.registerName("getDebugImagesCrashed:");
final _objc_msgSend_1t6aok9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Bool)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, bool)>();
late final _sel_setSdkName_andVersionString_ =
    objc.registerName("setSdkName:andVersionString:");
final _objc_msgSend_pfv6jd = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_setSdkName_ = objc.registerName("setSdkName:");
late final _sel_getSdkName = objc.registerName("getSdkName");
late final _sel_getSdkVersionString = objc.registerName("getSdkVersionString");
late final _sel_addSdkPackage_version_ =
    objc.registerName("addSdkPackage:version:");
late final _sel_getExtraContext = objc.registerName("getExtraContext");
late final _class_SentryId = objc.getClass("Sentry.SentryId");

/// SentryId
class SentryId extends objc.ObjCObjectBase {
  SentryId._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryId] that points to the same underlying object as [other].
  SentryId.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryId] that wraps the given raw object pointer.
  SentryId.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [SentryId].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_SentryId);
  }
}

/// WARNING: SentrySpanId is a stub. To generate bindings for this class, include
/// SentrySpanId in your config's objc-interfaces list.
///
/// SentrySpanId
class SentrySpanId extends objc.ObjCObjectBase {
  SentrySpanId._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentrySpanId] that points to the same underlying object as [other].
  SentrySpanId.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentrySpanId] that wraps the given raw object pointer.
  SentrySpanId.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_setTrace_spanId_ = objc.registerName("setTrace:spanId:");
late final _sel_startProfilerForTrace_ =
    objc.registerName("startProfilerForTrace:");
final _objc_msgSend_1om1bna = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Uint64 Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_collectProfileBetween_and_forTrace_ =
    objc.registerName("collectProfileBetween:and:forTrace:");
final _objc_msgSend_l3zifn = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Uint64,
                ffi.Uint64,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            int,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_discardProfilerForTrace_ =
    objc.registerName("discardProfilerForTrace:");
late final _sel_onAppStartMeasurementAvailable =
    objc.registerName("onAppStartMeasurementAvailable");
final _objc_msgSend_uwvaik = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCBlockImpl> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setOnAppStartMeasurementAvailable_ =
    objc.registerName("setOnAppStartMeasurementAvailable:");
final _objc_msgSend_f167m6 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_appStartMeasurement = objc.registerName("appStartMeasurement");
late final _sel_installationID = objc.registerName("installationID");

/// WARNING: SentryOptions is a stub. To generate bindings for this class, include
/// SentryOptions in your config's objc-interfaces list.
///
/// SentryOptions
class SentryOptions extends objc.ObjCObjectBase {
  SentryOptions._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryOptions] that points to the same underlying object as [other].
  SentryOptions.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryOptions] that wraps the given raw object pointer.
  SentryOptions.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_options = objc.registerName("options");
late final _sel_appStartMeasurementHybridSDKMode =
    objc.registerName("appStartMeasurementHybridSDKMode");
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setAppStartMeasurementHybridSDKMode_ =
    objc.registerName("setAppStartMeasurementHybridSDKMode:");
final _objc_msgSend_1s56lr9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, bool)>();
late final _sel_appStartMeasurementWithSpans =
    objc.registerName("appStartMeasurementWithSpans");

/// WARNING: SentryUser is a stub. To generate bindings for this class, include
/// SentryUser in your config's objc-interfaces list.
///
/// SentryUser
class SentryUser extends objc.ObjCObjectBase {
  SentryUser._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryUser] that points to the same underlying object as [other].
  SentryUser.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryUser] that wraps the given raw object pointer.
  SentryUser.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_userWithDictionary_ = objc.registerName("userWithDictionary:");

/// WARNING: SentryBreadcrumb is a stub. To generate bindings for this class, include
/// SentryBreadcrumb in your config's objc-interfaces list.
///
/// SentryBreadcrumb
class SentryBreadcrumb extends objc.ObjCObjectBase {
  SentryBreadcrumb._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryBreadcrumb] that points to the same underlying object as [other].
  SentryBreadcrumb.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryBreadcrumb] that wraps the given raw object pointer.
  SentryBreadcrumb.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_breadcrumbWithDictionary_ =
    objc.registerName("breadcrumbWithDictionary:");
typedef instancetype = ffi.Pointer<objc.ObjCObject>;
typedef Dartinstancetype = objc.ObjCObjectBase;
late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.NSZone>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.NSZone>)>();
late final _sel_alloc = objc.registerName("alloc");
late final _sel_self = objc.registerName("self");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_objcObjCObject_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_objcObjCObject_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_objcObjCObject_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_objcObjCObject_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_objcObjCObject_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      fromFunction(objc.ObjCObjectBase Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_objcObjCObject_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_objcObjCObject_ffiVoid_CallExtension on objc
    .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> {
  objc.ObjCObjectBase call(ffi.Pointer<ffi.Void> arg0) => objc.ObjCObjectBase(
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
      retain: true,
      release: true);
}

late final _sel_retain = objc.registerName("retain");
late final _sel_autorelease = objc.registerName("autorelease");

/// @warning This class is reserved for hybrid SDKs. Methods may be changed, renamed or removed
/// without notice. If you want to use one of these methods here please open up an issue and let us
/// know.
/// @note The name of this class is supposed to be a bit weird and ugly. The name starts with private
/// on purpose so users don't see it in code completion when typing Sentry. We also add only at the
/// end to make it more obvious you shouldn't use it.
class PrivateSentrySDKOnly extends objc.NSObject {
  PrivateSentrySDKOnly._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [PrivateSentrySDKOnly] that points to the same underlying object as [other].
  PrivateSentrySDKOnly.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [PrivateSentrySDKOnly] that wraps the given raw object pointer.
  PrivateSentrySDKOnly.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [PrivateSentrySDKOnly].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_PrivateSentrySDKOnly);
  }

  /// For storing an envelope synchronously to disk.
  static void storeEnvelope(SentryEnvelope envelope) {
    _objc_msgSend_xtuoz7(
        _class_PrivateSentrySDKOnly, _sel_storeEnvelope_, envelope.ref.pointer);
  }

  /// captureEnvelope:
  static void captureEnvelope(SentryEnvelope envelope) {
    _objc_msgSend_xtuoz7(_class_PrivateSentrySDKOnly, _sel_captureEnvelope_,
        envelope.ref.pointer);
  }

  /// Create an envelope from @c NSData. Needed for example by Flutter.
  static SentryEnvelope? envelopeWithData(objc.NSData data) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_PrivateSentrySDKOnly, _sel_envelopeWithData_, data.ref.pointer);
    return _ret.address == 0
        ? null
        : SentryEnvelope.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns the current list of debug images. Be aware that the @c SentryDebugMeta is actually
  /// describing a debug image.
  /// @warning This assumes a crash has occurred and attempts to read the crash information from each
  /// image's data segment, which may not be present or be invalid if a crash has not actually
  /// occurred. To avoid this, use the new @c +[getDebugImagesCrashed:] instead.
  static objc.NSArray getDebugImages() {
    final _ret =
        _objc_msgSend_151sglz(_class_PrivateSentrySDKOnly, _sel_getDebugImages);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns the current list of debug images. Be aware that the @c SentryDebugMeta is actually
  /// describing a debug image.
  /// @param isCrash @c YES if we're collecting binary images for a crash report, @c NO if we're
  /// gathering them for other backtrace information, like a performance transaction. If this is for a
  /// crash, each image's data section crash info is also included.
  static objc.NSArray getDebugImagesCrashed(bool isCrash) {
    final _ret = _objc_msgSend_1t6aok9(
        _class_PrivateSentrySDKOnly, _sel_getDebugImagesCrashed_, isCrash);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Override SDK information.
  static void setSdkName(objc.NSString sdkName,
      {required objc.NSString andVersionString}) {
    _objc_msgSend_pfv6jd(
        _class_PrivateSentrySDKOnly,
        _sel_setSdkName_andVersionString_,
        sdkName.ref.pointer,
        andVersionString.ref.pointer);
  }

  /// Override SDK information.
  static void setSdkName$1(objc.NSString sdkName) {
    _objc_msgSend_xtuoz7(
        _class_PrivateSentrySDKOnly, _sel_setSdkName_, sdkName.ref.pointer);
  }

  /// Retrieves the SDK name
  static objc.NSString getSdkName() {
    final _ret =
        _objc_msgSend_151sglz(_class_PrivateSentrySDKOnly, _sel_getSdkName);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Retrieves the SDK version string
  static objc.NSString getSdkVersionString() {
    final _ret = _objc_msgSend_151sglz(
        _class_PrivateSentrySDKOnly, _sel_getSdkVersionString);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Add a package to the SDK packages
  static void addSdkPackage(objc.NSString name,
      {required objc.NSString version}) {
    _objc_msgSend_pfv6jd(_class_PrivateSentrySDKOnly,
        _sel_addSdkPackage_version_, name.ref.pointer, version.ref.pointer);
  }

  /// Retrieves extra context
  static objc.NSDictionary getExtraContext() {
    final _ret = _objc_msgSend_151sglz(
        _class_PrivateSentrySDKOnly, _sel_getExtraContext);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// Allows Hybrids SDKs to thread-safe set the current trace.
  static void setTrace(SentryId traceId, {required SentrySpanId spanId}) {
    _objc_msgSend_pfv6jd(_class_PrivateSentrySDKOnly, _sel_setTrace_spanId_,
        traceId.ref.pointer, spanId.ref.pointer);
  }

  /// Start a profiler session associated with the given @c SentryId.
  /// @return The system time when the profiler session started.
  static int startProfilerForTrace(SentryId traceId) {
    return _objc_msgSend_1om1bna(_class_PrivateSentrySDKOnly,
        _sel_startProfilerForTrace_, traceId.ref.pointer);
  }

  /// Collect a profiler session data associated with the given @c SentryId.
  /// This also discards the profiler.
  static objc.NSMutableDictionary? collectProfileBetween(int startSystemTime,
      {required int and, required SentryId forTrace}) {
    final _ret = _objc_msgSend_l3zifn(
        _class_PrivateSentrySDKOnly,
        _sel_collectProfileBetween_and_forTrace_,
        startSystemTime,
        and,
        forTrace.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSMutableDictionary.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// Discard profiler session data associated with the given @c SentryId.
  /// This only needs to be called in case you haven't collected the profile (and don't intend to).
  static void discardProfilerForTrace(SentryId traceId) {
    _objc_msgSend_xtuoz7(_class_PrivateSentrySDKOnly,
        _sel_discardProfilerForTrace_, traceId.ref.pointer);
  }

  /// onAppStartMeasurementAvailable
  static objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>?
      getOnAppStartMeasurementAvailable() {
    final _ret = _objc_msgSend_uwvaik(
        _class_PrivateSentrySDKOnly, _sel_onAppStartMeasurementAvailable);
    return _ret.address == 0
        ? null
        : ObjCBlock_ffiVoid_SentryAppStartMeasurement.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// setOnAppStartMeasurementAvailable:
  static void setOnAppStartMeasurementAvailable(
      objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>? value) {
    _objc_msgSend_f167m6(
        _class_PrivateSentrySDKOnly,
        _sel_setOnAppStartMeasurementAvailable_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// appStartMeasurement
  static SentryAppStartMeasurement? getAppStartMeasurement() {
    final _ret = _objc_msgSend_151sglz(
        _class_PrivateSentrySDKOnly, _sel_appStartMeasurement);
    return _ret.address == 0
        ? null
        : SentryAppStartMeasurement.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// installationID
  static objc.NSString getInstallationID() {
    final _ret =
        _objc_msgSend_151sglz(_class_PrivateSentrySDKOnly, _sel_installationID);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// options
  static SentryOptions getOptions() {
    final _ret =
        _objc_msgSend_151sglz(_class_PrivateSentrySDKOnly, _sel_options);
    return SentryOptions.castFromPointer(_ret, retain: true, release: true);
  }

  /// If enabled, the SDK won't send the app start measurement with the first transaction. Instead, if
  /// @c enableAutoPerformanceTracing is enabled, the SDK measures the app start and then calls
  /// @c onAppStartMeasurementAvailable. Furthermore, the SDK doesn't set all values for the app start
  /// measurement because the HybridSDKs initialize the Cocoa SDK too late to receive all
  /// notifications. Instead, the SDK sets the @c appStartDuration to @c 0 and the
  /// @c didFinishLaunchingTimestamp to @c timeIntervalSinceReferenceDate.
  /// @note Default is @c NO.
  static bool getAppStartMeasurementHybridSDKMode() {
    return _objc_msgSend_91o635(
        _class_PrivateSentrySDKOnly, _sel_appStartMeasurementHybridSDKMode);
  }

  /// If enabled, the SDK won't send the app start measurement with the first transaction. Instead, if
  /// @c enableAutoPerformanceTracing is enabled, the SDK measures the app start and then calls
  /// @c onAppStartMeasurementAvailable. Furthermore, the SDK doesn't set all values for the app start
  /// measurement because the HybridSDKs initialize the Cocoa SDK too late to receive all
  /// notifications. Instead, the SDK sets the @c appStartDuration to @c 0 and the
  /// @c didFinishLaunchingTimestamp to @c timeIntervalSinceReferenceDate.
  /// @note Default is @c NO.
  static void setAppStartMeasurementHybridSDKMode(bool value) {
    _objc_msgSend_1s56lr9(_class_PrivateSentrySDKOnly,
        _sel_setAppStartMeasurementHybridSDKMode_, value);
  }

  /// appStartMeasurementWithSpans
  static objc.NSDictionary? appStartMeasurementWithSpans() {
    final _ret = _objc_msgSend_151sglz(
        _class_PrivateSentrySDKOnly, _sel_appStartMeasurementWithSpans);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// userWithDictionary:
  static SentryUser userWithDictionary(objc.NSDictionary dictionary) {
    final _ret = _objc_msgSend_1sotr3r(_class_PrivateSentrySDKOnly,
        _sel_userWithDictionary_, dictionary.ref.pointer);
    return SentryUser.castFromPointer(_ret, retain: true, release: true);
  }

  /// breadcrumbWithDictionary:
  static SentryBreadcrumb breadcrumbWithDictionary(
      objc.NSDictionary dictionary) {
    final _ret = _objc_msgSend_1sotr3r(_class_PrivateSentrySDKOnly,
        _sel_breadcrumbWithDictionary_, dictionary.ref.pointer);
    return SentryBreadcrumb.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  PrivateSentrySDKOnly init() {
    objc.checkOsVersionInternal('PrivateSentrySDKOnly.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return PrivateSentrySDKOnly.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static PrivateSentrySDKOnly new$() {
    final _ret = _objc_msgSend_151sglz(_class_PrivateSentrySDKOnly, _sel_new);
    return PrivateSentrySDKOnly.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static PrivateSentrySDKOnly allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_PrivateSentrySDKOnly, _sel_allocWithZone_, zone);
    return PrivateSentrySDKOnly.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static PrivateSentrySDKOnly alloc() {
    final _ret = _objc_msgSend_151sglz(_class_PrivateSentrySDKOnly, _sel_alloc);
    return PrivateSentrySDKOnly.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  PrivateSentrySDKOnly self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return PrivateSentrySDKOnly.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  PrivateSentrySDKOnly retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return PrivateSentrySDKOnly.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  PrivateSentrySDKOnly autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return PrivateSentrySDKOnly.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of PrivateSentrySDKOnly constructed with the default `new` method.
  factory PrivateSentrySDKOnly() => new$();
}

late final _class_SentryId$1 = objc.getClass("Sentry.SentryId");
late final _sel_empty = objc.registerName("empty");
late final _sel_sentryIdString = objc.registerName("sentryIdString");
late final _sel_initWithUuid_ = objc.registerName("initWithUuid:");
late final _sel_initWithUUIDString_ = objc.registerName("initWithUUIDString:");
late final _sel_isEqual_ = objc.registerName("isEqual:");
late final _sel_description = objc.registerName("description");
late final _sel_hash = objc.registerName("hash");
final _objc_msgSend_xw2lbc = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// SentryId
class SentryId$1 extends objc.NSObject {
  SentryId$1._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [SentryId$1] that points to the same underlying object as [other].
  SentryId$1.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryId$1] that wraps the given raw object pointer.
  SentryId$1.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [SentryId$1].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_SentryId$1);
  }

  /// A @c SentryId with an empty UUID “00000000000000000000000000000000”.
  static SentryId$1 getEmpty() {
    final _ret = _objc_msgSend_151sglz(_class_SentryId$1, _sel_empty);
    return SentryId$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a 32 lowercase character hexadecimal string description of the @c SentryId, such as
  /// “12c2d058d58442709aa2eca08bf20986”.
  objc.NSString get sentryIdString {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_sentryIdString);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  SentryId$1 init() {
    objc.checkOsVersionInternal('SentryId.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return SentryId$1.castFromPointer(_ret, retain: false, release: true);
  }

  /// Creates a SentryId with the given UUID.
  SentryId$1 initWithUuid(NSUUID uuid) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithUuid_, uuid.ref.pointer);
    return SentryId$1.castFromPointer(_ret, retain: false, release: true);
  }

  /// Creates a @c SentryId from a 32 character hexadecimal string without dashes such as
  /// “12c2d058d58442709aa2eca08bf20986” or a 36 character hexadecimal string such as such as
  /// “12c2d058-d584-4270-9aa2-eca08bf20986”.
  /// @return SentryId.empty for invalid strings.
  SentryId$1 initWithUUIDString(objc.NSString uuidString) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithUUIDString_, uuidString.ref.pointer);
    return SentryId$1.castFromPointer(_ret, retain: false, release: true);
  }

  /// isEqual:
  bool isEqual(objc.ObjCObjectBase? object) {
    return _objc_msgSend_19nvye5(
        this.ref.pointer, _sel_isEqual_, object?.ref.pointer ?? ffi.nullptr);
  }

  /// description
  objc.NSString get description {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_description);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// hash
  int get hash {
    return _objc_msgSend_xw2lbc(this.ref.pointer, _sel_hash);
  }

  /// new
  static SentryId$1 new$() {
    final _ret = _objc_msgSend_151sglz(_class_SentryId$1, _sel_new);
    return SentryId$1.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SentryId$1 allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_SentryId$1, _sel_allocWithZone_, zone);
    return SentryId$1.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static SentryId$1 alloc() {
    final _ret = _objc_msgSend_151sglz(_class_SentryId$1, _sel_alloc);
    return SentryId$1.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  SentryId$1 self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return SentryId$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  SentryId$1 retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return SentryId$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  SentryId$1 autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return SentryId$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of SentryId$1 constructed with the default `new` method.
  factory SentryId$1() => new$();
}

late final _class_SentryFlutterPlugin = objc.getClass("SentryFlutterPlugin");
late final _sel_loadContextsAsBytes = objc.registerName("loadContextsAsBytes");
late final _sel_loadDebugImagesAsBytes_ =
    objc.registerName("loadDebugImagesAsBytes:");

/// SentryFlutterPlugin
class SentryFlutterPlugin extends objc.NSObject {
  SentryFlutterPlugin._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [SentryFlutterPlugin] that points to the same underlying object as [other].
  SentryFlutterPlugin.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryFlutterPlugin] that wraps the given raw object pointer.
  SentryFlutterPlugin.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [SentryFlutterPlugin].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_SentryFlutterPlugin);
  }

  /// loadContextsAsBytes
  static objc.NSData? loadContextsAsBytes() {
    final _ret = _objc_msgSend_151sglz(
        _class_SentryFlutterPlugin, _sel_loadContextsAsBytes);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// loadDebugImagesAsBytes:
  static objc.NSData? loadDebugImagesAsBytes(objc.NSSet instructionAddresses) {
    final _ret = _objc_msgSend_1sotr3r(_class_SentryFlutterPlugin,
        _sel_loadDebugImagesAsBytes_, instructionAddresses.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  SentryFlutterPlugin init() {
    objc.checkOsVersionInternal('SentryFlutterPlugin.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return SentryFlutterPlugin.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static SentryFlutterPlugin new$() {
    final _ret = _objc_msgSend_151sglz(_class_SentryFlutterPlugin, _sel_new);
    return SentryFlutterPlugin.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static SentryFlutterPlugin allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_SentryFlutterPlugin, _sel_allocWithZone_, zone);
    return SentryFlutterPlugin.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static SentryFlutterPlugin alloc() {
    final _ret = _objc_msgSend_151sglz(_class_SentryFlutterPlugin, _sel_alloc);
    return SentryFlutterPlugin.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  SentryFlutterPlugin self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return SentryFlutterPlugin.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  SentryFlutterPlugin retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return SentryFlutterPlugin.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  SentryFlutterPlugin autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return SentryFlutterPlugin.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of SentryFlutterPlugin constructed with the default `new` method.
  factory SentryFlutterPlugin() => new$();
}
