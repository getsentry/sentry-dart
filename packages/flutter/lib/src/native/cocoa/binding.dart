// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _SentryCocoa_wrapListenerBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _SentryCocoa_wrapBlockingBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external ffi.Pointer<objc.ObjCObject> _SentryCocoa_protocolTrampoline_1mbt9g9(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _SentryCocoa_wrapListenerBlock_15zdkpa(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _SentryCocoa_wrapBlockingBlock_15zdkpa(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

/// WARNING: NSException is a stub. To generate bindings for this class, include
/// NSException in your config's objc-interfaces list.
///
/// NSException
class NSException extends objc.NSObject
    implements objc.NSCopying, objc.NSSecureCoding {
  NSException._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSException] that points to the same underlying object as [other].
  NSException.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSException] that wraps the given raw object pointer.
  NSException.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: NSUUID is a stub. To generate bindings for this class, include
/// NSUUID in your config's objc-interfaces list.
///
/// NSUUID
class NSUUID extends objc.NSObject
    implements objc.NSCopying, objc.NSSecureCoding {
  NSUUID._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSUUID',
        iOS: (false, (6, 0, 0)), macOS: (false, (10, 8, 0)));
  }

  /// Constructs a [NSUUID] that points to the same underlying object as [other].
  NSUUID.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSUUID] that wraps the given raw object pointer.
  NSUUID.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: SentrySpan is a stub. To generate bindings for this class, include
/// SentrySpan in your config's objc-protocols list.
///
/// SentrySpan
interface class SentrySpan extends objc.ObjCProtocolBase {
  SentrySpan._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentrySpan] that points to the same underlying object as [other].
  SentrySpan.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentrySpan] that wraps the given raw object pointer.
  SentrySpan.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

void _ObjCBlock_ffiVoid_idSentrySpan_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_idSentrySpan_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_idSentrySpan_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_idSentrySpan_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_idSentrySpan_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_idSentrySpan_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_idSentrySpan_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_idSentrySpan_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_idSentrySpan_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_idSentrySpan_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_idSentrySpan_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_idSentrySpan_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_idSentrySpan_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_idSentrySpan_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)>`.
abstract final class ObjCBlock_ffiVoid_idSentrySpan {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_idSentrySpan_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)>
      fromFunction(void Function(SentrySpan?) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_idSentrySpan_closureCallable,
                  (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
                      ? null
                      : SentrySpan.castFromPointer(arg0, retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)>
      listener(void Function(SentrySpan?) fn, {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_idSentrySpan_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : SentrySpan.castFromPointer(arg0, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _SentryCocoa_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)>
      blocking(void Function(SentrySpan?) fn, {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_idSentrySpan_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : SentrySpan.castFromPointer(arg0, retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_idSentrySpan_blockingListenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : SentrySpan.castFromPointer(arg0, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _SentryCocoa_wrapBlockingBlock_xtuoz7(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)>`.
extension ObjCBlock_ffiVoid_idSentrySpan_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)> {
  void call(SentrySpan? arg0) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<objc.ObjCObject> arg0)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>)>()(
      ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

/// Sentry level.
sealed class SentryLevel {}

/// WARNING: SentryAppStartMeasurement is a stub. To generate bindings for this class, include
/// SentryAppStartMeasurement in your config's objc-interfaces list.
///
/// SentryAppStartMeasurement
class SentryAppStartMeasurement extends objc.ObjCObjectBase {
  SentryAppStartMeasurement._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryAppStartMeasurement] that points to the same underlying object as [other].
  SentryAppStartMeasurement.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryAppStartMeasurement] that wraps the given raw object pointer.
  SentryAppStartMeasurement.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

void _ObjCBlock_ffiVoid_SentryAppStartMeasurement_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_SentryAppStartMeasurement_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_SentryAppStartMeasurement_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_SentryAppStartMeasurement_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_SentryAppStartMeasurement_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_SentryAppStartMeasurement_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_SentryAppStartMeasurement_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_SentryAppStartMeasurement_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_SentryAppStartMeasurement_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_SentryAppStartMeasurement_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_SentryAppStartMeasurement_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_SentryAppStartMeasurement_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_SentryAppStartMeasurement_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_SentryAppStartMeasurement_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>`.
abstract final class ObjCBlock_ffiVoid_SentryAppStartMeasurement {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_SentryAppStartMeasurement_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>
      fromFunction(void Function(SentryAppStartMeasurement?) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_SentryAppStartMeasurement_closureCallable,
                  (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
                      ? null
                      : SentryAppStartMeasurement.castFromPointer(arg0,
                          retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)> listener(
      void Function(SentryAppStartMeasurement?) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_SentryAppStartMeasurement_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : SentryAppStartMeasurement.castFromPointer(arg0,
                retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _SentryCocoa_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)> blocking(
      void Function(SentryAppStartMeasurement?) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_SentryAppStartMeasurement_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : SentryAppStartMeasurement.castFromPointer(arg0,
                retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_SentryAppStartMeasurement_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : SentryAppStartMeasurement.castFromPointer(arg0,
                retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _SentryCocoa_wrapBlockingBlock_xtuoz7(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>`.
extension ObjCBlock_ffiVoid_SentryAppStartMeasurement_CallExtension
    on objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)> {
  void call(SentryAppStartMeasurement? arg0) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<objc.ObjCObject> arg0)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>)>()(
      ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _class_PrivateSentrySDKOnly = objc.getClass("PrivateSentrySDKOnly");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();

/// WARNING: SentryEnvelope is a stub. To generate bindings for this class, include
/// SentryEnvelope in your config's objc-interfaces list.
///
/// SentryEnvelope
class SentryEnvelope extends objc.ObjCObjectBase {
  SentryEnvelope._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryEnvelope] that points to the same underlying object as [other].
  SentryEnvelope.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryEnvelope] that wraps the given raw object pointer.
  SentryEnvelope.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_storeEnvelope_ = objc.registerName("storeEnvelope:");
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_captureEnvelope_ = objc.registerName("captureEnvelope:");
late final _sel_envelopeWithData_ = objc.registerName("envelopeWithData:");
final _objc_msgSend_1sotr3r = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_getDebugImages = objc.registerName("getDebugImages");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_getDebugImagesCrashed_ =
    objc.registerName("getDebugImagesCrashed:");
final _objc_msgSend_1t6aok9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Bool)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, bool)>();
late final _sel_setSdkName_andVersionString_ =
    objc.registerName("setSdkName:andVersionString:");
final _objc_msgSend_pfv6jd = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_setSdkName_ = objc.registerName("setSdkName:");
late final _sel_getSdkName = objc.registerName("getSdkName");
late final _sel_getSdkVersionString = objc.registerName("getSdkVersionString");
late final _sel_addSdkPackage_version_ =
    objc.registerName("addSdkPackage:version:");
late final _sel_getExtraContext = objc.registerName("getExtraContext");
late final _class_SentryId = objc.getClass("Sentry.SentryId");

/// SentryId
class SentryId extends objc.ObjCObjectBase {
  SentryId._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryId] that points to the same underlying object as [other].
  SentryId.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryId] that wraps the given raw object pointer.
  SentryId.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [SentryId].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_SentryId);
  }
}

/// WARNING: SentrySpanId is a stub. To generate bindings for this class, include
/// SentrySpanId in your config's objc-interfaces list.
///
/// SentrySpanId
class SentrySpanId extends objc.ObjCObjectBase {
  SentrySpanId._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentrySpanId] that points to the same underlying object as [other].
  SentrySpanId.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentrySpanId] that wraps the given raw object pointer.
  SentrySpanId.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_setTrace_spanId_ = objc.registerName("setTrace:spanId:");
late final _sel_startProfilerForTrace_ =
    objc.registerName("startProfilerForTrace:");
final _objc_msgSend_1om1bna = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Uint64 Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_collectProfileBetween_and_forTrace_ =
    objc.registerName("collectProfileBetween:and:forTrace:");
final _objc_msgSend_l3zifn = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Uint64,
                ffi.Uint64,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            int,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_discardProfilerForTrace_ =
    objc.registerName("discardProfilerForTrace:");
late final _sel_onAppStartMeasurementAvailable =
    objc.registerName("onAppStartMeasurementAvailable");
final _objc_msgSend_uwvaik = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCBlockImpl> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setOnAppStartMeasurementAvailable_ =
    objc.registerName("setOnAppStartMeasurementAvailable:");
final _objc_msgSend_f167m6 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_appStartMeasurement = objc.registerName("appStartMeasurement");
late final _sel_installationID = objc.registerName("installationID");

/// WARNING: SentryOptions is a stub. To generate bindings for this class, include
/// SentryOptions in your config's objc-interfaces list.
///
/// SentryOptions
class SentryOptions extends objc.ObjCObjectBase {
  SentryOptions._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryOptions] that points to the same underlying object as [other].
  SentryOptions.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryOptions] that wraps the given raw object pointer.
  SentryOptions.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_options = objc.registerName("options");
late final _sel_appStartMeasurementHybridSDKMode =
    objc.registerName("appStartMeasurementHybridSDKMode");
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setAppStartMeasurementHybridSDKMode_ =
    objc.registerName("setAppStartMeasurementHybridSDKMode:");
final _objc_msgSend_1s56lr9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, bool)>();
late final _sel_appStartMeasurementWithSpans =
    objc.registerName("appStartMeasurementWithSpans");

/// WARNING: SentryUser is a stub. To generate bindings for this class, include
/// SentryUser in your config's objc-interfaces list.
///
/// SentryUser
class SentryUser extends objc.ObjCObjectBase {
  SentryUser._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryUser] that points to the same underlying object as [other].
  SentryUser.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryUser] that wraps the given raw object pointer.
  SentryUser.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_userWithDictionary_ = objc.registerName("userWithDictionary:");

/// WARNING: SentryBreadcrumb is a stub. To generate bindings for this class, include
/// SentryBreadcrumb in your config's objc-interfaces list.
///
/// SentryBreadcrumb
class SentryBreadcrumb extends objc.ObjCObjectBase {
  SentryBreadcrumb._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryBreadcrumb] that points to the same underlying object as [other].
  SentryBreadcrumb.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryBreadcrumb] that wraps the given raw object pointer.
  SentryBreadcrumb.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_breadcrumbWithDictionary_ =
    objc.registerName("breadcrumbWithDictionary:");
typedef instancetype = ffi.Pointer<objc.ObjCObject>;
typedef Dartinstancetype = objc.ObjCObjectBase;
late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.NSZone>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.NSZone>)>();
late final _sel_alloc = objc.registerName("alloc");
late final _sel_self = objc.registerName("self");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_objcObjCObject_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_objcObjCObject_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_objcObjCObject_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_objcObjCObject_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_objcObjCObject_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      fromFunction(objc.ObjCObjectBase Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_objcObjCObject_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_objcObjCObject_ffiVoid_CallExtension on objc
    .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> {
  objc.ObjCObjectBase call(ffi.Pointer<ffi.Void> arg0) => objc.ObjCObjectBase(
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
      retain: true,
      release: true);
}

late final _sel_retain = objc.registerName("retain");
late final _sel_autorelease = objc.registerName("autorelease");

/// @warning This class is reserved for hybrid SDKs. Methods may be changed, renamed or removed
/// without notice. If you want to use one of these methods here please open up an issue and let us
/// know.
/// @note The name of this class is supposed to be a bit weird and ugly. The name starts with private
/// on purpose so users don't see it in code completion when typing Sentry. We also add only at the
/// end to make it more obvious you shouldn't use it.
class PrivateSentrySDKOnly extends objc.NSObject {
  PrivateSentrySDKOnly._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [PrivateSentrySDKOnly] that points to the same underlying object as [other].
  PrivateSentrySDKOnly.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [PrivateSentrySDKOnly] that wraps the given raw object pointer.
  PrivateSentrySDKOnly.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [PrivateSentrySDKOnly].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_PrivateSentrySDKOnly);
  }

  /// For storing an envelope synchronously to disk.
  static void storeEnvelope(SentryEnvelope envelope) {
    _objc_msgSend_xtuoz7(
        _class_PrivateSentrySDKOnly, _sel_storeEnvelope_, envelope.ref.pointer);
  }

  /// captureEnvelope:
  static void captureEnvelope(SentryEnvelope envelope) {
    _objc_msgSend_xtuoz7(_class_PrivateSentrySDKOnly, _sel_captureEnvelope_,
        envelope.ref.pointer);
  }

  /// Create an envelope from @c NSData. Needed for example by Flutter.
  static SentryEnvelope? envelopeWithData(objc.NSData data) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_PrivateSentrySDKOnly, _sel_envelopeWithData_, data.ref.pointer);
    return _ret.address == 0
        ? null
        : SentryEnvelope.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns the current list of debug images. Be aware that the @c SentryDebugMeta is actually
  /// describing a debug image.
  /// @warning This assumes a crash has occurred and attempts to read the crash information from each
  /// image's data segment, which may not be present or be invalid if a crash has not actually
  /// occurred. To avoid this, use the new @c +[getDebugImagesCrashed:] instead.
  static objc.NSArray getDebugImages() {
    final _ret =
        _objc_msgSend_151sglz(_class_PrivateSentrySDKOnly, _sel_getDebugImages);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns the current list of debug images. Be aware that the @c SentryDebugMeta is actually
  /// describing a debug image.
  /// @param isCrash @c YES if we're collecting binary images for a crash report, @c NO if we're
  /// gathering them for other backtrace information, like a performance transaction. If this is for a
  /// crash, each image's data section crash info is also included.
  static objc.NSArray getDebugImagesCrashed(bool isCrash) {
    final _ret = _objc_msgSend_1t6aok9(
        _class_PrivateSentrySDKOnly, _sel_getDebugImagesCrashed_, isCrash);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Override SDK information.
  static void setSdkName(objc.NSString sdkName,
      {required objc.NSString andVersionString}) {
    _objc_msgSend_pfv6jd(
        _class_PrivateSentrySDKOnly,
        _sel_setSdkName_andVersionString_,
        sdkName.ref.pointer,
        andVersionString.ref.pointer);
  }

  /// Override SDK information.
  static void setSdkName$1(objc.NSString sdkName) {
    _objc_msgSend_xtuoz7(
        _class_PrivateSentrySDKOnly, _sel_setSdkName_, sdkName.ref.pointer);
  }

  /// Retrieves the SDK name
  static objc.NSString getSdkName() {
    final _ret =
        _objc_msgSend_151sglz(_class_PrivateSentrySDKOnly, _sel_getSdkName);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Retrieves the SDK version string
  static objc.NSString getSdkVersionString() {
    final _ret = _objc_msgSend_151sglz(
        _class_PrivateSentrySDKOnly, _sel_getSdkVersionString);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Add a package to the SDK packages
  static void addSdkPackage(objc.NSString name,
      {required objc.NSString version}) {
    _objc_msgSend_pfv6jd(_class_PrivateSentrySDKOnly,
        _sel_addSdkPackage_version_, name.ref.pointer, version.ref.pointer);
  }

  /// Retrieves extra context
  static objc.NSDictionary getExtraContext() {
    final _ret = _objc_msgSend_151sglz(
        _class_PrivateSentrySDKOnly, _sel_getExtraContext);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// Allows Hybrids SDKs to thread-safe set the current trace.
  static void setTrace(SentryId traceId, {required SentrySpanId spanId}) {
    _objc_msgSend_pfv6jd(_class_PrivateSentrySDKOnly, _sel_setTrace_spanId_,
        traceId.ref.pointer, spanId.ref.pointer);
  }

  /// Start a profiler session associated with the given @c SentryId.
  /// @return The system time when the profiler session started.
  static int startProfilerForTrace(SentryId traceId) {
    return _objc_msgSend_1om1bna(_class_PrivateSentrySDKOnly,
        _sel_startProfilerForTrace_, traceId.ref.pointer);
  }

  /// Collect a profiler session data associated with the given @c SentryId.
  /// This also discards the profiler.
  static objc.NSMutableDictionary? collectProfileBetween(int startSystemTime,
      {required int and, required SentryId forTrace}) {
    final _ret = _objc_msgSend_l3zifn(
        _class_PrivateSentrySDKOnly,
        _sel_collectProfileBetween_and_forTrace_,
        startSystemTime,
        and,
        forTrace.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSMutableDictionary.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// Discard profiler session data associated with the given @c SentryId.
  /// This only needs to be called in case you haven't collected the profile (and don't intend to).
  static void discardProfilerForTrace(SentryId traceId) {
    _objc_msgSend_xtuoz7(_class_PrivateSentrySDKOnly,
        _sel_discardProfilerForTrace_, traceId.ref.pointer);
  }

  /// onAppStartMeasurementAvailable
  static objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>?
      getOnAppStartMeasurementAvailable() {
    final _ret = _objc_msgSend_uwvaik(
        _class_PrivateSentrySDKOnly, _sel_onAppStartMeasurementAvailable);
    return _ret.address == 0
        ? null
        : ObjCBlock_ffiVoid_SentryAppStartMeasurement.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// setOnAppStartMeasurementAvailable:
  static void setOnAppStartMeasurementAvailable(
      objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>? value) {
    _objc_msgSend_f167m6(
        _class_PrivateSentrySDKOnly,
        _sel_setOnAppStartMeasurementAvailable_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// appStartMeasurement
  static SentryAppStartMeasurement? getAppStartMeasurement() {
    final _ret = _objc_msgSend_151sglz(
        _class_PrivateSentrySDKOnly, _sel_appStartMeasurement);
    return _ret.address == 0
        ? null
        : SentryAppStartMeasurement.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// installationID
  static objc.NSString getInstallationID() {
    final _ret =
        _objc_msgSend_151sglz(_class_PrivateSentrySDKOnly, _sel_installationID);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// options
  static SentryOptions getOptions() {
    final _ret =
        _objc_msgSend_151sglz(_class_PrivateSentrySDKOnly, _sel_options);
    return SentryOptions.castFromPointer(_ret, retain: true, release: true);
  }

  /// If enabled, the SDK won't send the app start measurement with the first transaction. Instead, if
  /// @c enableAutoPerformanceTracing is enabled, the SDK measures the app start and then calls
  /// @c onAppStartMeasurementAvailable. Furthermore, the SDK doesn't set all values for the app start
  /// measurement because the HybridSDKs initialize the Cocoa SDK too late to receive all
  /// notifications. Instead, the SDK sets the @c appStartDuration to @c 0 and the
  /// @c didFinishLaunchingTimestamp to @c timeIntervalSinceReferenceDate.
  /// @note Default is @c NO.
  static bool getAppStartMeasurementHybridSDKMode() {
    return _objc_msgSend_91o635(
        _class_PrivateSentrySDKOnly, _sel_appStartMeasurementHybridSDKMode);
  }

  /// If enabled, the SDK won't send the app start measurement with the first transaction. Instead, if
  /// @c enableAutoPerformanceTracing is enabled, the SDK measures the app start and then calls
  /// @c onAppStartMeasurementAvailable. Furthermore, the SDK doesn't set all values for the app start
  /// measurement because the HybridSDKs initialize the Cocoa SDK too late to receive all
  /// notifications. Instead, the SDK sets the @c appStartDuration to @c 0 and the
  /// @c didFinishLaunchingTimestamp to @c timeIntervalSinceReferenceDate.
  /// @note Default is @c NO.
  static void setAppStartMeasurementHybridSDKMode(bool value) {
    _objc_msgSend_1s56lr9(_class_PrivateSentrySDKOnly,
        _sel_setAppStartMeasurementHybridSDKMode_, value);
  }

  /// appStartMeasurementWithSpans
  static objc.NSDictionary? appStartMeasurementWithSpans() {
    final _ret = _objc_msgSend_151sglz(
        _class_PrivateSentrySDKOnly, _sel_appStartMeasurementWithSpans);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// userWithDictionary:
  static SentryUser userWithDictionary(objc.NSDictionary dictionary) {
    final _ret = _objc_msgSend_1sotr3r(_class_PrivateSentrySDKOnly,
        _sel_userWithDictionary_, dictionary.ref.pointer);
    return SentryUser.castFromPointer(_ret, retain: true, release: true);
  }

  /// breadcrumbWithDictionary:
  static SentryBreadcrumb breadcrumbWithDictionary(
      objc.NSDictionary dictionary) {
    final _ret = _objc_msgSend_1sotr3r(_class_PrivateSentrySDKOnly,
        _sel_breadcrumbWithDictionary_, dictionary.ref.pointer);
    return SentryBreadcrumb.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  PrivateSentrySDKOnly init() {
    objc.checkOsVersionInternal('PrivateSentrySDKOnly.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return PrivateSentrySDKOnly.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static PrivateSentrySDKOnly new$() {
    final _ret = _objc_msgSend_151sglz(_class_PrivateSentrySDKOnly, _sel_new);
    return PrivateSentrySDKOnly.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static PrivateSentrySDKOnly allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_PrivateSentrySDKOnly, _sel_allocWithZone_, zone);
    return PrivateSentrySDKOnly.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static PrivateSentrySDKOnly alloc() {
    final _ret = _objc_msgSend_151sglz(_class_PrivateSentrySDKOnly, _sel_alloc);
    return PrivateSentrySDKOnly.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  PrivateSentrySDKOnly self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return PrivateSentrySDKOnly.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  PrivateSentrySDKOnly retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return PrivateSentrySDKOnly.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  PrivateSentrySDKOnly autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return PrivateSentrySDKOnly.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of PrivateSentrySDKOnly constructed with the default `new` method.
  factory PrivateSentrySDKOnly() => new$();
}

enum SentryFeedbackSource {
  SentryFeedbackSourceWidget(0),
  SentryFeedbackSourceCustom(1);

  final int value;
  const SentryFeedbackSource(this.value);

  static SentryFeedbackSource fromValue(int value) => switch (value) {
        0 => SentryFeedbackSourceWidget,
        1 => SentryFeedbackSourceCustom,
        _ =>
          throw ArgumentError('Unknown value for SentryFeedbackSource: $value'),
      };
}

/// WARNING: SentryFeedback is a stub. To generate bindings for this class, include
/// SentryFeedback in your config's objc-interfaces list.
///
/// SentryFeedback
class SentryFeedback extends objc.NSObject {
  SentryFeedback._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [SentryFeedback] that points to the same underlying object as [other].
  SentryFeedback.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryFeedback] that wraps the given raw object pointer.
  SentryFeedback.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _class_SentryId$1 = objc.getClass("Sentry.SentryId");
late final _sel_empty = objc.registerName("empty");
late final _sel_sentryIdString = objc.registerName("sentryIdString");
late final _sel_initWithUuid_ = objc.registerName("initWithUuid:");
late final _sel_initWithUUIDString_ = objc.registerName("initWithUUIDString:");
late final _sel_isEqual_ = objc.registerName("isEqual:");
late final _sel_description = objc.registerName("description");
late final _sel_hash = objc.registerName("hash");
final _objc_msgSend_xw2lbc = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// SentryId
class SentryId$1 extends objc.NSObject {
  SentryId$1._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [SentryId$1] that points to the same underlying object as [other].
  SentryId$1.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryId$1] that wraps the given raw object pointer.
  SentryId$1.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [SentryId$1].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_SentryId$1);
  }

  /// A @c SentryId with an empty UUID 00000000000000000000000000000000.
  static SentryId$1 getEmpty() {
    final _ret = _objc_msgSend_151sglz(_class_SentryId$1, _sel_empty);
    return SentryId$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a 32 lowercase character hexadecimal string description of the @c SentryId, such as
  /// 12c2d058d58442709aa2eca08bf20986.
  objc.NSString get sentryIdString {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_sentryIdString);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  SentryId$1 init() {
    objc.checkOsVersionInternal('SentryId.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return SentryId$1.castFromPointer(_ret, retain: false, release: true);
  }

  /// Creates a SentryId with the given UUID.
  SentryId$1 initWithUuid(NSUUID uuid) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithUuid_, uuid.ref.pointer);
    return SentryId$1.castFromPointer(_ret, retain: false, release: true);
  }

  /// Creates a @c SentryId from a 32 character hexadecimal string without dashes such as
  /// 12c2d058d58442709aa2eca08bf20986 or a 36 character hexadecimal string such as such as
  /// 12c2d058-d584-4270-9aa2-eca08bf20986.
  /// @return SentryId.empty for invalid strings.
  SentryId$1 initWithUUIDString(objc.NSString uuidString) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithUUIDString_, uuidString.ref.pointer);
    return SentryId$1.castFromPointer(_ret, retain: false, release: true);
  }

  /// isEqual:
  bool isEqual(objc.ObjCObjectBase? object) {
    return _objc_msgSend_19nvye5(
        this.ref.pointer, _sel_isEqual_, object?.ref.pointer ?? ffi.nullptr);
  }

  /// description
  objc.NSString get description {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_description);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// hash
  int get hash {
    return _objc_msgSend_xw2lbc(this.ref.pointer, _sel_hash);
  }

  /// new
  static SentryId$1 new$() {
    final _ret = _objc_msgSend_151sglz(_class_SentryId$1, _sel_new);
    return SentryId$1.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SentryId$1 allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_SentryId$1, _sel_allocWithZone_, zone);
    return SentryId$1.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static SentryId$1 alloc() {
    final _ret = _objc_msgSend_151sglz(_class_SentryId$1, _sel_alloc);
    return SentryId$1.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  SentryId$1 self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return SentryId$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  SentryId$1 retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return SentryId$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  SentryId$1 autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return SentryId$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of SentryId$1 constructed with the default `new` method.
  factory SentryId$1() => new$();
}

enum SentryLevel$1 {
  kSentryLevelNone(0),
  kSentryLevelDebug(1),
  kSentryLevelInfo(2),
  kSentryLevelWarning(3),
  kSentryLevelError(4),
  kSentryLevelFatal(5);

  final int value;
  const SentryLevel$1(this.value);

  static SentryLevel$1 fromValue(int value) => switch (value) {
        0 => kSentryLevelNone,
        1 => kSentryLevelDebug,
        2 => kSentryLevelInfo,
        3 => kSentryLevelWarning,
        4 => kSentryLevelError,
        5 => kSentryLevelFatal,
        _ => throw ArgumentError('Unknown value for SentryLevel\$1: $value'),
      };
}

/// WARNING: SentryLogger is a stub. To generate bindings for this class, include
/// SentryLogger in your config's objc-interfaces list.
///
/// <em>EXPERIMENTAL</em> - A structured logging API for Sentry.
/// <code>SentryLogger</code> provides a structured logging interface that captures log entries
/// and sends them to Sentry. Supports multiple log levels (trace, debug, info, warn,
/// error, fatal) and allows attaching arbitrary attributes for enhanced context.
/// <h2>Supported Attribute Types</h2>
/// note:
/// Sentry Logs is currently in Beta. See the <a href="https://docs.sentry.io/product/explore/logs/">Sentry Logs Documentation</a>.
/// warning:
/// This API is experimental and subject to change without notice.
/// <ul>
/// <li>
/// <code>String</code>, <code>Bool</code>, <code>Int</code>, <code>Double</code>
/// </li>
/// <li>
/// <code>Float</code> (converted to <code>Double</code>)
/// </li>
/// <li>
/// Other types (converted to string)
/// </li>
/// </ul>
/// <h2>Usage</h2>
/// \code
/// let logger = SentrySDK.logger
/// logger.info("User logged in", attributes: ["userId": "12345"])
/// logger.error("Payment failed", attributes: ["errorCode": 500])
///
/// // Structured string interpolation with automatic type detection
/// logger.info("User \(userId) processed \(count) items with \(percentage)% success")
/// logger.debug("Processing \(itemCount) items, active: \(isActive)")
/// logger.warn("Retry attempt \(currentAttempt) of \(maxAttempts) failed")
///
/// \endcode
class SentryLogger extends objc.NSObject {
  SentryLogger._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [SentryLogger] that points to the same underlying object as [other].
  SentryLogger.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryLogger] that wraps the given raw object pointer.
  SentryLogger.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _class_SentrySDK = objc.getClass("Sentry.SentrySDK");

/// WARNING: SentrySpan$1 is a stub. To generate bindings for this class, include
/// SentrySpan in your config's objc-protocols list.
///
/// SentrySpan
interface class SentrySpan$1 extends objc.ObjCProtocolBase {
  SentrySpan$1._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentrySpan$1] that points to the same underlying object as [other].
  SentrySpan$1.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentrySpan$1] that wraps the given raw object pointer.
  SentrySpan$1.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_span = objc.registerName("span");
late final _sel_isEnabled = objc.registerName("isEnabled");
late final _sel_logger = objc.registerName("logger");
late final _sel_startWithOptions_ = objc.registerName("startWithOptions:");
void _ObjCBlock_ffiVoid_ffiInt_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Int> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Int> arg0)>>()
        .asFunction<void Function(ffi.Pointer<ffi.Int>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiInt_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Int>)>(
            _ObjCBlock_ffiVoid_ffiInt_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiInt_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Int> arg0) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Int>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiInt_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Int>)>(
            _ObjCBlock_ffiVoid_ffiInt_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiInt_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Int> arg0) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Int>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Int>)>
    _ObjCBlock_ffiVoid_ffiInt_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Int>)>.listener(
        _ObjCBlock_ffiVoid_ffiInt_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiInt_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Int> arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Int>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int>)>
    _ObjCBlock_ffiVoid_ffiInt_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiInt_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int>)>
    _ObjCBlock_ffiVoid_ffiInt_blockingListenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int>)>.listener(
        _ObjCBlock_ffiVoid_ffiInt_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Int>)>`.
abstract final class ObjCBlock_ffiVoid_ffiInt {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Int>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Int>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Int>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi
                  .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Int> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Int>)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiInt_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Int>)> fromFunction(
          void Function(ffi.Pointer<ffi.Int>) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Int>)>(
          objc.newClosureBlock(_ObjCBlock_ffiVoid_ffiInt_closureCallable,
              (ffi.Pointer<ffi.Int> arg0) => fn(arg0), keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Int>)> listener(
      void Function(ffi.Pointer<ffi.Int>) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiInt_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Int> arg0) => fn(arg0),
        keepIsolateAlive);
    final wrapper = _SentryCocoa_wrapListenerBlock_15zdkpa(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Int>)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Int>)> blocking(
      void Function(ffi.Pointer<ffi.Int>) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiInt_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Int> arg0) => fn(arg0),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiInt_blockingListenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Int> arg0) => fn(arg0),
        keepIsolateAlive);
    final wrapper = _SentryCocoa_wrapBlockingBlock_15zdkpa(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Int>)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Int>)>`.
extension ObjCBlock_ffiVoid_ffiInt_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Int>)> {
  void call(ffi.Pointer<ffi.Int> arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Int> arg0)>>()
      .asFunction<
          void Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Int>)>()(ref.pointer, arg0);
}

late final _sel_startWithConfigureOptions_ =
    objc.registerName("startWithConfigureOptions:");
late final _sel_captureEvent_ = objc.registerName("captureEvent:");
late final _class_SentryScope = objc.getClass("SentryScope");

/// WARNING: SentrySerializable is a stub. To generate bindings for this class, include
/// SentrySerializable in your config's objc-protocols list.
///
/// SentrySerializable
interface class SentrySerializable extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  SentrySerializable._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentrySerializable] that points to the same underlying object as [other].
  SentrySerializable.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentrySerializable] that wraps the given raw object pointer.
  SentrySerializable.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_setSpan_ = objc.registerName("setSpan:");
late final _sel_replayId = objc.registerName("replayId");
late final _sel_setReplayId_ = objc.registerName("setReplayId:");
late final _sel_tags = objc.registerName("tags");
late final _sel_initWithMaxBreadcrumbs_ =
    objc.registerName("initWithMaxBreadcrumbs:");
final _objc_msgSend_qugqlf = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
instancetype _ObjCBlock_instancetype_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                instancetype Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<instancetype Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_instancetype_ffiVoid_fnPtrTrampoline)
        .cast();
instancetype _ObjCBlock_instancetype_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as instancetype Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_instancetype_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_instancetype_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(
              ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(
                      ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<
                  objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(
                      ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(
                  _ObjCBlock_instancetype_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(ffi.Pointer<ffi.Void>)>
      fromFunction(Dartinstancetype Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<
                  objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(
                      ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_instancetype_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndReturnPointer(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_instancetype_ffiVoid_CallExtension on objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(
        ffi.Pointer<ffi.Void>)> {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0) => objc.ObjCObjectBase(
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
      retain: false,
      release: true);
}

late final _sel_initWithScope_ = objc.registerName("initWithScope:");
late final _sel_setUser_ = objc.registerName("setUser:");
late final _sel_setTagValue_forKey_ = objc.registerName("setTagValue:forKey:");
late final _sel_removeTagForKey_ = objc.registerName("removeTagForKey:");
late final _sel_setTags_ = objc.registerName("setTags:");
late final _sel_setExtras_ = objc.registerName("setExtras:");
late final _sel_setExtraValue_forKey_ =
    objc.registerName("setExtraValue:forKey:");
late final _sel_removeExtraForKey_ = objc.registerName("removeExtraForKey:");
late final _sel_setDist_ = objc.registerName("setDist:");
late final _sel_setEnvironment_ = objc.registerName("setEnvironment:");
late final _sel_setFingerprint_ = objc.registerName("setFingerprint:");
late final _sel_setLevel_ = objc.registerName("setLevel:");
final _objc_msgSend_9dwzby = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_addBreadcrumb_ = objc.registerName("addBreadcrumb:");
late final _sel_add_ = objc.registerName("add:");
late final _sel_clearBreadcrumbs = objc.registerName("clearBreadcrumbs");
final _objc_msgSend_1pl9qdv = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_serialize = objc.registerName("serialize");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSDictionary_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSDictionary_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSDictionary_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSDictionary_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSDictionary_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSDictionary_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSDictionary_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_NSDictionary_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>
      fromFunction(objc.NSDictionary Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSDictionary_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSDictionary_ffiVoid_CallExtension
    on objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)> {
  objc.NSDictionary call(ffi.Pointer<ffi.Void> arg0) =>
      objc.NSDictionary.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
          retain: true,
          release: true);
}

late final _sel_setContextValue_forKey_ =
    objc.registerName("setContextValue:forKey:");
late final _sel_removeContextForKey_ =
    objc.registerName("removeContextForKey:");

/// WARNING: SentryAttachment is a stub. To generate bindings for this class, include
/// SentryAttachment in your config's objc-interfaces list.
///
/// SentryAttachment
class SentryAttachment extends objc.ObjCObjectBase {
  SentryAttachment._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryAttachment] that points to the same underlying object as [other].
  SentryAttachment.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryAttachment] that wraps the given raw object pointer.
  SentryAttachment.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_addAttachment_ = objc.registerName("addAttachment:");
late final _sel_includeAttachment_ = objc.registerName("includeAttachment:");
late final _sel_clearAttachments = objc.registerName("clearAttachments");
late final _sel_clear = objc.registerName("clear");
late final _sel_useSpan_ = objc.registerName("useSpan:");

/// SentryScope
class SentryScope extends objc.NSObject implements SentrySerializable {
  SentryScope._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [SentryScope] that points to the same underlying object as [other].
  SentryScope.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryScope] that wraps the given raw object pointer.
  SentryScope.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [SentryScope].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_SentryScope);
  }

  /// Returns current Span or Transaction.
  /// @return current Span or Transaction or null if transaction has not been set.
  SentrySpan? get span {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_span);
    return _ret.address == 0
        ? null
        : SentrySpan.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns current Span or Transaction.
  /// @return current Span or Transaction or null if transaction has not been set.
  set span(SentrySpan? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setSpan_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// The id of current session replay.
  objc.NSString? get replayId {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_replayId);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The id of current session replay.
  set replayId(objc.NSString? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setReplayId_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Gets the dictionary of currently set tags.
  objc.NSDictionary get tags {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_tags);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithMaxBreadcrumbs:
  SentryScope initWithMaxBreadcrumbs(int maxBreadcrumbs) {
    final _ret = _objc_msgSend_qugqlf(this.ref.retainAndReturnPointer(),
        _sel_initWithMaxBreadcrumbs_, maxBreadcrumbs);
    return SentryScope.castFromPointer(_ret, retain: false, release: true);
  }

  /// init
  SentryScope init() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return SentryScope.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithScope:
  SentryScope initWithScope(SentryScope scope) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithScope_, scope.ref.pointer);
    return SentryScope.castFromPointer(_ret, retain: false, release: true);
  }

  /// Set global user -> thus will be sent with every event
  void setUser(SentryUser? user) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setUser_, user?.ref.pointer ?? ffi.nullptr);
  }

  /// Set a global tag. Tags are searchable key/value string pairs attached to
  /// every event.
  void setTagValue(objc.NSString value, {required objc.NSString forKey}) {
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_setTagValue_forKey_,
        value.ref.pointer, forKey.ref.pointer);
  }

  /// Remove the tag for the specified key.
  void removeTagForKey(objc.NSString key) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_removeTagForKey_, key.ref.pointer);
  }

  /// Set global tags. Tags are searchable key/value string pairs attached to every
  /// event.
  void setTags(objc.NSDictionary? tags$1) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTags_, tags$1?.ref.pointer ?? ffi.nullptr);
  }

  /// Set global extra -> these will be sent with every event
  void setExtras(objc.NSDictionary? extras) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setExtras_, extras?.ref.pointer ?? ffi.nullptr);
  }

  /// Set global extra -> these will be sent with every event
  void setExtraValue(objc.ObjCObjectBase? value,
      {required objc.NSString forKey}) {
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_setExtraValue_forKey_,
        value?.ref.pointer ?? ffi.nullptr, forKey.ref.pointer);
  }

  /// Remove the extra for the specified key.
  void removeExtraForKey(objc.NSString key) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_removeExtraForKey_, key.ref.pointer);
  }

  /// Set @c dist in the scope
  void setDist(objc.NSString? dist) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setDist_, dist?.ref.pointer ?? ffi.nullptr);
  }

  /// Set @c environment in the scope
  void setEnvironment(objc.NSString? environment) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setEnvironment_,
        environment?.ref.pointer ?? ffi.nullptr);
  }

  /// Sets the @c fingerprint in the scope
  void setFingerprint(objc.NSArray? fingerprint) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setFingerprint_,
        fingerprint?.ref.pointer ?? ffi.nullptr);
  }

  /// Sets the @c level in the scope
  void setLevel(SentryLevel$1 level) {
    _objc_msgSend_9dwzby(this.ref.pointer, _sel_setLevel_, level.value);
  }

  /// Add a breadcrumb to the scope
  void addBreadcrumb(SentryBreadcrumb crumb) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_addBreadcrumb_, crumb.ref.pointer);
  }

  /// add:
  void add(SentryBreadcrumb crumb) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_add_, crumb.ref.pointer);
  }

  /// Clears all breadcrumbs in the scope
  void clearBreadcrumbs() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_clearBreadcrumbs);
  }

  /// Serialize the contents of the object into an NSDictionary. Make to copy all properties of the
  /// original object so modifications to it don't have an impact on the serialized NSDictionary.
  objc.NSDictionary serialize() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_serialize);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// Sets context values which will overwrite SentryEvent.context when event is
  /// "enriched" with scope before sending event.
  void setContextValue(objc.NSDictionary value,
      {required objc.NSString forKey}) {
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_setContextValue_forKey_,
        value.ref.pointer, forKey.ref.pointer);
  }

  /// Remove the context for the specified key.
  void removeContextForKey(objc.NSString key) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_removeContextForKey_, key.ref.pointer);
  }

  /// Adds an attachment to the Scope's list of attachments. The SDK adds the attachment to every event
  /// sent to Sentry.
  /// @param attachment The attachment to add to the Scope's list of attachments.
  void addAttachment(SentryAttachment attachment) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_addAttachment_, attachment.ref.pointer);
  }

  /// includeAttachment:
  void includeAttachment(SentryAttachment attachment) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_includeAttachment_, attachment.ref.pointer);
  }

  /// Clears all attachments in the scope.
  void clearAttachments() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_clearAttachments);
  }

  /// Clears the current Scope
  void clear() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_clear);
  }

  /// Mutates the current transaction atomically.
  /// @param callback the SentrySpanCallback.
  void useSpan(
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)>
          callback) {
    _objc_msgSend_f167m6(this.ref.pointer, _sel_useSpan_, callback.ref.pointer);
  }

  /// new
  static SentryScope new$() {
    final _ret = _objc_msgSend_151sglz(_class_SentryScope, _sel_new);
    return SentryScope.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SentryScope allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_SentryScope, _sel_allocWithZone_, zone);
    return SentryScope.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static SentryScope alloc() {
    final _ret = _objc_msgSend_151sglz(_class_SentryScope, _sel_alloc);
    return SentryScope.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  SentryScope self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return SentryScope.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  SentryScope retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return SentryScope.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  SentryScope autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return SentryScope.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of SentryScope constructed with the default `new` method.
  factory SentryScope() => new$();
}

late final _sel_captureEvent_withScope_ =
    objc.registerName("captureEvent:withScope:");
final _objc_msgSend_15qeuct = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
void _ObjCBlock_ffiVoid_SentryScope_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_SentryScope_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_SentryScope_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_SentryScope_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_SentryScope_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_SentryScope_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_SentryScope_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_SentryScope_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_SentryScope_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_SentryScope_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_SentryScope_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_SentryScope_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_SentryScope_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_SentryScope_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(SentryScope)>`.
abstract final class ObjCBlock_ffiVoid_SentryScope {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(SentryScope)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(SentryScope)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(SentryScope)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(SentryScope)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_SentryScope_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(SentryScope)> fromFunction(
          void Function(SentryScope) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(SentryScope)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_SentryScope_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0) => fn(
                  SentryScope.castFromPointer(arg0,
                      retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(SentryScope)> listener(
      void Function(SentryScope) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_SentryScope_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) =>
            fn(SentryScope.castFromPointer(arg0, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _SentryCocoa_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(SentryScope)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(SentryScope)> blocking(
      void Function(SentryScope) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_SentryScope_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) =>
            fn(SentryScope.castFromPointer(arg0, retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_SentryScope_blockingListenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) =>
            fn(SentryScope.castFromPointer(arg0, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _SentryCocoa_wrapBlockingBlock_xtuoz7(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(SentryScope)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(SentryScope)>`.
extension ObjCBlock_ffiVoid_SentryScope_CallExtension
    on objc.ObjCBlock<ffi.Void Function(SentryScope)> {
  void call(SentryScope arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<objc.ObjCObject> arg0)>>()
      .asFunction<
          void Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0.ref.pointer);
}

late final _sel_captureEvent_withScopeBlock_ =
    objc.registerName("captureEvent:withScopeBlock:");
final _objc_msgSend_r0bo0s = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_startTransactionWithName_operation_ =
    objc.registerName("startTransactionWithName:operation:");
late final _sel_startTransactionWithName_operation_bindToScope_ =
    objc.registerName("startTransactionWithName:operation:bindToScope:");
final _objc_msgSend_e1g5wl = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();

/// WARNING: SentryTransactionContext is a stub. To generate bindings for this class, include
/// SentryTransactionContext in your config's objc-interfaces list.
///
/// SentryTransactionContext
class SentryTransactionContext extends objc.ObjCObjectBase {
  SentryTransactionContext._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryTransactionContext] that points to the same underlying object as [other].
  SentryTransactionContext.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryTransactionContext] that wraps the given raw object pointer.
  SentryTransactionContext.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_startTransactionWithContext_ =
    objc.registerName("startTransactionWithContext:");
late final _sel_startTransactionWithContext_bindToScope_ =
    objc.registerName("startTransactionWithContext:bindToScope:");
final _objc_msgSend_17amj0z = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_startTransactionWithContext_bindToScope_customSamplingContext_ =
    objc.registerName(
        "startTransactionWithContext:bindToScope:customSamplingContext:");
final _objc_msgSend_1ged0jd = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            bool,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_startTransactionWithContext_customSamplingContext_ =
    objc.registerName("startTransactionWithContext:customSamplingContext:");
late final _sel_captureError_ = objc.registerName("captureError:");
late final _sel_captureError_withScope_ =
    objc.registerName("captureError:withScope:");
late final _sel_captureError_withScopeBlock_ =
    objc.registerName("captureError:withScopeBlock:");
late final _sel_captureException_ = objc.registerName("captureException:");
late final _sel_captureException_withScope_ =
    objc.registerName("captureException:withScope:");
late final _sel_captureException_withScopeBlock_ =
    objc.registerName("captureException:withScopeBlock:");
late final _sel_captureMessage_ = objc.registerName("captureMessage:");
late final _sel_captureMessage_withScope_ =
    objc.registerName("captureMessage:withScope:");
late final _sel_captureMessage_withScopeBlock_ =
    objc.registerName("captureMessage:withScopeBlock:");

/// WARNING: SentryUserFeedback is a stub. To generate bindings for this class, include
/// SentryUserFeedback in your config's objc-interfaces list.
///
/// Adds additional information about what happened to an event.
/// @deprecated Use <code>SentryFeedback</code>.
class SentryUserFeedback extends objc.NSObject {
  SentryUserFeedback._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [SentryUserFeedback] that points to the same underlying object as [other].
  SentryUserFeedback.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryUserFeedback] that wraps the given raw object pointer.
  SentryUserFeedback.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_captureUserFeedback_ =
    objc.registerName("captureUserFeedback:");
late final _sel_captureFeedback_ = objc.registerName("captureFeedback:");
late final _sel_configureScope_ = objc.registerName("configureScope:");
late final _sel_crashedLastRun = objc.registerName("crashedLastRun");
late final _sel_detectedStartUpCrash =
    objc.registerName("detectedStartUpCrash");
late final _sel_startSession = objc.registerName("startSession");
late final _sel_endSession = objc.registerName("endSession");
late final _sel_crash = objc.registerName("crash");
late final _sel_reportFullyDisplayed =
    objc.registerName("reportFullyDisplayed");
late final _sel_pauseAppHangTracking =
    objc.registerName("pauseAppHangTracking");
late final _sel_resumeAppHangTracking =
    objc.registerName("resumeAppHangTracking");
late final _sel_flush_ = objc.registerName("flush:");
final _objc_msgSend_hwm8nu = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Double)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, double)>();
late final _sel_close = objc.registerName("close");
late final _sel_startProfiler = objc.registerName("startProfiler");
late final _sel_stopProfiler = objc.registerName("stopProfiler");
late final _sel_clearLogger = objc.registerName("clearLogger");

/// The main entry point for the Sentry SDK.
/// We recommend using <code>start(configureOptions:)</code> to initialize Sentry.
class SentrySDK extends objc.NSObject {
  SentrySDK._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [SentrySDK] that points to the same underlying object as [other].
  SentrySDK.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentrySDK] that wraps the given raw object pointer.
  SentrySDK.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [SentrySDK].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_SentrySDK);
  }

  /// The current active transaction or span bound to the scope.
  static SentrySpan$1? getSpan() {
    final _ret = _objc_msgSend_151sglz(_class_SentrySDK, _sel_span);
    return _ret.address == 0
        ? null
        : SentrySpan$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// Indicates whether the Sentry SDK is enabled.
  static bool getIsEnabled() {
    return _objc_msgSend_91o635(_class_SentrySDK, _sel_isEnabled);
  }

  /// API to access Sentry logs
  static SentryLogger getLogger() {
    final _ret = _objc_msgSend_151sglz(_class_SentrySDK, _sel_logger);
    return SentryLogger.castFromPointer(_ret, retain: true, release: true);
  }

  /// Inits and configures Sentry (<code>SentryHub</code>, <code>SentryClient</code>) and sets up all integrations. Make sure to
  /// set a valid DSN.
  /// note:
  /// Call this method on the main thread. When calling it from a background thread, the
  /// SDK starts on the main thread async.
  static void startWithOptions(objc.ObjCObjectBase options) {
    _objc_msgSend_xtuoz7(
        _class_SentrySDK, _sel_startWithOptions_, options.ref.pointer);
  }

  /// Inits and configures Sentry (<code>SentryHub</code>, <code>SentryClient</code>) and sets up all integrations. Make sure to
  /// set a valid DSN.
  /// note:
  /// Call this method on the main thread. When calling it from a background thread, the
  /// SDK starts on the main thread async.
  static void startWithConfigureOptions(
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Int>)>
          configureOptions) {
    _objc_msgSend_f167m6(_class_SentrySDK, _sel_startWithConfigureOptions_,
        configureOptions.ref.pointer);
  }

  /// Captures a manually created event and sends it to Sentry.
  /// \param event The event to send to Sentry.
  ///
  ///
  /// returns:
  /// The <code>SentryId</code> of the event or <code>SentryId.empty</code> if the event is not sent.
  static SentryId$1 captureEvent(objc.ObjCObjectBase event) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_SentrySDK, _sel_captureEvent_, event.ref.pointer);
    return SentryId$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// Captures a manually created event and sends it to Sentry. Only the data in this scope object will
  /// be added to the event. The global scope will be ignored.
  /// \param event The event to send to Sentry.
  ///
  /// \param scope The scope containing event metadata.
  ///
  ///
  /// returns:
  /// The <code>SentryId</code> of the event or <code>SentryId.empty</code> if the event is not sent.
  static SentryId$1 captureEvent$1(objc.ObjCObjectBase event,
      {required SentryScope withScope}) {
    final _ret = _objc_msgSend_15qeuct(_class_SentrySDK,
        _sel_captureEvent_withScope_, event.ref.pointer, withScope.ref.pointer);
    return SentryId$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// Captures a manually created event and sends it to Sentry. Maintains the global scope but mutates
  /// scope data for only this call.
  /// \param event The event to send to Sentry.
  ///
  /// \param block The block mutating the scope only for this call.
  ///
  ///
  /// returns:
  /// The <code>SentryId</code> of the event or <code>SentryId.empty</code> if the event is not sent.
  static SentryId$1 captureEvent$2(objc.ObjCObjectBase event,
      {required objc.ObjCBlock<ffi.Void Function(SentryScope)>
          withScopeBlock}) {
    final _ret = _objc_msgSend_r0bo0s(
        _class_SentrySDK,
        _sel_captureEvent_withScopeBlock_,
        event.ref.pointer,
        withScopeBlock.ref.pointer);
    return SentryId$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// Creates a transaction, binds it to the hub and returns the instance.
  /// \param name The transaction name.
  ///
  /// \param operation Short code identifying the type of operation the span is measuring.
  ///
  ///
  /// returns:
  /// The created transaction.
  static SentrySpan$1 startTransactionWithName(objc.NSString name,
      {required objc.NSString operation}) {
    final _ret = _objc_msgSend_15qeuct(
        _class_SentrySDK,
        _sel_startTransactionWithName_operation_,
        name.ref.pointer,
        operation.ref.pointer);
    return SentrySpan$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// Creates a transaction, binds it to the hub and returns the instance.
  /// \param name The transaction name.
  ///
  /// \param operation Short code identifying the type of operation the span is measuring.
  ///
  /// \param bindToScope Indicates whether the SDK should bind the new transaction to the scope.
  ///
  ///
  /// returns:
  /// The created transaction.
  static SentrySpan$1 startTransactionWithName$1(objc.NSString name,
      {required objc.NSString operation, required bool bindToScope}) {
    final _ret = _objc_msgSend_e1g5wl(
        _class_SentrySDK,
        _sel_startTransactionWithName_operation_bindToScope_,
        name.ref.pointer,
        operation.ref.pointer,
        bindToScope);
    return SentrySpan$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// Creates a transaction, binds it to the hub and returns the instance.
  /// \param transactionContext The transaction context.
  ///
  ///
  /// returns:
  /// The created transaction.
  static SentrySpan$1 startTransactionWithContext(
      SentryTransactionContext transactionContext) {
    final _ret = _objc_msgSend_1sotr3r(_class_SentrySDK,
        _sel_startTransactionWithContext_, transactionContext.ref.pointer);
    return SentrySpan$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// Creates a transaction, binds it to the hub and returns the instance.
  /// \param transactionContext The transaction context.
  ///
  /// \param bindToScope Indicates whether the SDK should bind the new transaction to the scope.
  ///
  ///
  /// returns:
  /// The created transaction.
  static SentrySpan$1 startTransactionWithContext$1(
      SentryTransactionContext transactionContext,
      {required bool bindToScope}) {
    final _ret = _objc_msgSend_17amj0z(
        _class_SentrySDK,
        _sel_startTransactionWithContext_bindToScope_,
        transactionContext.ref.pointer,
        bindToScope);
    return SentrySpan$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// Creates a transaction, binds it to the hub and returns the instance.
  /// \param transactionContext The transaction context.
  ///
  /// \param bindToScope Indicates whether the SDK should bind the new transaction to the scope.
  ///
  /// \param customSamplingContext Additional information about the sampling context.
  ///
  ///
  /// returns:
  /// The created transaction.
  static SentrySpan$1 startTransactionWithContext$2(
      SentryTransactionContext transactionContext,
      {required bool bindToScope,
      required objc.NSDictionary customSamplingContext}) {
    final _ret = _objc_msgSend_1ged0jd(
        _class_SentrySDK,
        _sel_startTransactionWithContext_bindToScope_customSamplingContext_,
        transactionContext.ref.pointer,
        bindToScope,
        customSamplingContext.ref.pointer);
    return SentrySpan$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// Creates a transaction, binds it to the hub and returns the instance.
  /// \param transactionContext The transaction context.
  ///
  /// \param customSamplingContext Additional information about the sampling context.
  ///
  ///
  /// returns:
  /// The created transaction.
  static SentrySpan$1 startTransactionWithContext$3(
      SentryTransactionContext transactionContext,
      {required objc.NSDictionary customSamplingContext}) {
    final _ret = _objc_msgSend_15qeuct(
        _class_SentrySDK,
        _sel_startTransactionWithContext_customSamplingContext_,
        transactionContext.ref.pointer,
        customSamplingContext.ref.pointer);
    return SentrySpan$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// Captures an error event and sends it to Sentry.
  /// \param error The error to send to Sentry.
  ///
  ///
  /// returns:
  /// The <code>SentryId</code> of the event or <code>SentryId.empty</code> if the event is not sent.
  static SentryId$1 captureError(objc.NSError error) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_SentrySDK, _sel_captureError_, error.ref.pointer);
    return SentryId$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// Captures an error event and sends it to Sentry. Only the data in this scope object will be added
  /// to the event. The global scope will be ignored.
  /// \param error The error to send to Sentry.
  ///
  /// \param scope The scope containing event metadata.
  ///
  ///
  /// returns:
  /// The <code>SentryId</code> of the event or <code>SentryId.empty</code> if the event is not sent.
  static SentryId$1 captureError$1(objc.NSError error,
      {required SentryScope withScope}) {
    final _ret = _objc_msgSend_15qeuct(_class_SentrySDK,
        _sel_captureError_withScope_, error.ref.pointer, withScope.ref.pointer);
    return SentryId$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// Captures an error event and sends it to Sentry. Maintains the global scope but mutates scope data
  /// for only this call.
  /// \param error The error to send to Sentry.
  ///
  /// \param block The block mutating the scope only for this call.
  ///
  ///
  /// returns:
  /// The <code>SentryId</code> of the event or <code>SentryId.empty</code> if the event is not sent.
  static SentryId$1 captureError$2(objc.NSError error,
      {required objc.ObjCBlock<ffi.Void Function(SentryScope)>
          withScopeBlock}) {
    final _ret = _objc_msgSend_r0bo0s(
        _class_SentrySDK,
        _sel_captureError_withScopeBlock_,
        error.ref.pointer,
        withScopeBlock.ref.pointer);
    return SentryId$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// Captures an exception event and sends it to Sentry.
  /// \param exception The exception to send to Sentry.
  ///
  ///
  /// returns:
  /// The <code>SentryId</code> of the event or <code>SentryId.empty</code> if the event is not sent.
  static SentryId$1 captureException(NSException exception) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_SentrySDK, _sel_captureException_, exception.ref.pointer);
    return SentryId$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// Captures an exception event and sends it to Sentry. Only the data in this scope object will be
  /// added to the event. The global scope will be ignored.
  /// \param exception The exception to send to Sentry.
  ///
  /// \param scope The scope containing event metadata.
  ///
  ///
  /// returns:
  /// The <code>SentryId</code> of the event or <code>SentryId.empty</code> if the event is not sent.
  static SentryId$1 captureException$1(NSException exception,
      {required SentryScope withScope}) {
    final _ret = _objc_msgSend_15qeuct(
        _class_SentrySDK,
        _sel_captureException_withScope_,
        exception.ref.pointer,
        withScope.ref.pointer);
    return SentryId$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// Captures an exception event and sends it to Sentry. Maintains the global scope but mutates scope
  /// data for only this call.
  /// \param exception The exception to send to Sentry.
  ///
  /// \param block The block mutating the scope only for this call.
  ///
  ///
  /// returns:
  /// The <code>SentryId</code> of the event or <code>SentryId.empty</code> if the event is not sent.
  static SentryId$1 captureException$2(NSException exception,
      {required objc.ObjCBlock<ffi.Void Function(SentryScope)>
          withScopeBlock}) {
    final _ret = _objc_msgSend_r0bo0s(
        _class_SentrySDK,
        _sel_captureException_withScopeBlock_,
        exception.ref.pointer,
        withScopeBlock.ref.pointer);
    return SentryId$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// Captures a message event and sends it to Sentry.
  /// \param message The message to send to Sentry.
  ///
  ///
  /// returns:
  /// The <code>SentryId</code> of the event or <code>SentryId.empty</code> if the event is not sent.
  static SentryId$1 captureMessage(objc.NSString message) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_SentrySDK, _sel_captureMessage_, message.ref.pointer);
    return SentryId$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// Captures a message event and sends it to Sentry. Only the data in this scope object will be added
  /// to the event. The global scope will be ignored.
  /// \param message The message to send to Sentry.
  ///
  /// \param scope The scope containing event metadata.
  ///
  ///
  /// returns:
  /// The <code>SentryId</code> of the event or <code>SentryId.empty</code> if the event is not sent.
  static SentryId$1 captureMessage$1(objc.NSString message,
      {required SentryScope withScope}) {
    final _ret = _objc_msgSend_15qeuct(
        _class_SentrySDK,
        _sel_captureMessage_withScope_,
        message.ref.pointer,
        withScope.ref.pointer);
    return SentryId$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// Captures a message event and sends it to Sentry. Maintains the global scope but mutates scope
  /// data for only this call.
  /// \param message The message to send to Sentry.
  ///
  /// \param block The block mutating the scope only for this call.
  ///
  ///
  /// returns:
  /// The <code>SentryId</code> of the event or <code>SentryId.empty</code> if the event is not sent.
  static SentryId$1 captureMessage$2(objc.NSString message,
      {required objc.ObjCBlock<ffi.Void Function(SentryScope)>
          withScopeBlock}) {
    final _ret = _objc_msgSend_r0bo0s(
        _class_SentrySDK,
        _sel_captureMessage_withScopeBlock_,
        message.ref.pointer,
        withScopeBlock.ref.pointer);
    return SentryId$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// Captures user feedback that was manually gathered and sends it to Sentry.
  /// \param userFeedback The user feedback to send to Sentry.
  static void captureUserFeedback(SentryUserFeedback userFeedback) {
    _objc_msgSend_xtuoz7(
        _class_SentrySDK, _sel_captureUserFeedback_, userFeedback.ref.pointer);
  }

  /// Captures user feedback that was manually gathered and sends it to Sentry.
  /// warning:
  /// This is an experimental feature and may still have bugs.
  /// note:
  /// If youd prefer not to have to build the UI required to gather the feedback from the user,
  /// see <code>SentryOptions.configureUserFeedback</code> to customize a fully managed integration. See
  /// https://docs.sentry.io/platforms/apple/user-feedback/ for more information.
  /// \param feedback The feedback to send to Sentry.
  static void captureFeedback(SentryFeedback feedback) {
    _objc_msgSend_xtuoz7(
        _class_SentrySDK, _sel_captureFeedback_, feedback.ref.pointer);
  }

  /// Adds a <code>Breadcrumb</code> to the current <code>Scope</code> of the current <code>Hub</code>. If the total number of breadcrumbs
  /// exceeds the <code>SentryOptions.maxBreadcrumbs</code> the SDK removes the oldest breadcrumb.
  /// \param crumb The <code>Breadcrumb</code> to add to the current <code>Scope</code> of the current <code>Hub</code>.
  static void addBreadcrumb(SentryBreadcrumb crumb) {
    _objc_msgSend_xtuoz7(
        _class_SentrySDK, _sel_addBreadcrumb_, crumb.ref.pointer);
  }

  /// Use this method to modify the current <code>Scope</code> of the current <code>Hub</code>. The SDK uses the <code>Scope</code> to attach
  /// contextual data to events.
  /// \param callback The callback for configuring the current <code>Scope</code> of the current <code>Hub</code>.
  static void configureScope(
      objc.ObjCBlock<ffi.Void Function(SentryScope)> callback) {
    _objc_msgSend_f167m6(
        _class_SentrySDK, _sel_configureScope_, callback.ref.pointer);
  }

  /// Checks if the last program execution terminated with a crash.
  static bool getCrashedLastRun() {
    return _objc_msgSend_91o635(_class_SentrySDK, _sel_crashedLastRun);
  }

  /// Checks if the SDK detected a start-up crash during SDK initialization.
  /// note:
  /// The SDK init waits synchronously for up to 5 seconds to flush out events if the app crashes
  /// within 2 seconds after the SDK init.
  ///
  /// returns:
  /// true if the SDK detected a start-up crash and false if not.
  static bool getDetectedStartUpCrash() {
    return _objc_msgSend_91o635(_class_SentrySDK, _sel_detectedStartUpCrash);
  }

  /// Set <code>user</code> to the current <code>Scope</code> of the current <code>Hub</code>.
  /// note:
  /// You must start the SDK before calling this method, otherwise it doesnt set the user.
  /// \param user The user to set to the current <code>Scope</code>.
  static void setUser(SentryUser? user) {
    _objc_msgSend_xtuoz7(
        _class_SentrySDK, _sel_setUser_, user?.ref.pointer ?? ffi.nullptr);
  }

  /// Starts a new <code>SentrySession</code>. If theres a running <code>SentrySession</code>, it ends it before starting the
  /// new one. You can use this method in combination with <code>endSession</code> to manually track
  /// sessions. The SDK uses <code>SentrySession</code> to inform Sentry about release and project
  /// associated project health.
  static void startSession() {
    _objc_msgSend_1pl9qdv(_class_SentrySDK, _sel_startSession);
  }

  /// Ends the current <code>SentrySession</code>. You can use this method in combination with <code>startSession</code> to
  /// manually track <code>SentrySessions</code>. The SDK uses <code>SentrySession</code> to inform Sentry about release and
  /// project associated project health.
  static void endSession() {
    _objc_msgSend_1pl9qdv(_class_SentrySDK, _sel_endSession);
  }

  /// This forces a crash, useful to test the <code>SentryCrash</code> integration.
  /// note:
  /// The SDK cant report a crash when a debugger is attached. Your application needs to run
  /// without a debugger attached to capture the crash and send it to Sentry the next time you launch
  /// your application.
  static void crash() {
    _objc_msgSend_1pl9qdv(_class_SentrySDK, _sel_crash);
  }

  /// Reports to the ongoing <code>UIViewController</code> transaction
  /// that the screen contents are fully loaded and displayed,
  /// which will create a new span.
  /// seealso:
  ///
  /// https://docs.sentry.io/platforms/cocoa/performance/instrumentation/automatic-instrumentation/#time-to-full-display
  static void reportFullyDisplayed() {
    _objc_msgSend_1pl9qdv(_class_SentrySDK, _sel_reportFullyDisplayed);
  }

  /// Pauses sending detected app hangs to Sentry.
  /// This method doesnt close the detection of app hangs. Instead, the app hang detection
  /// will ignore detected app hangs until you call <code>resumeAppHangTracking</code>.
  static void pauseAppHangTracking() {
    _objc_msgSend_1pl9qdv(_class_SentrySDK, _sel_pauseAppHangTracking);
  }

  /// Resumes sending detected app hangs to Sentry.
  static void resumeAppHangTracking() {
    _objc_msgSend_1pl9qdv(_class_SentrySDK, _sel_resumeAppHangTracking);
  }

  /// Waits synchronously for the SDK to flush out all queued and cached items for up to the specified
  /// timeout in seconds. If there is no internet connection, the function returns immediately. The SDK
  /// doesnt dispose the client or the hub.
  /// \param timeout The time to wait for the SDK to complete the flush.
  static void flush(double timeout) {
    _objc_msgSend_hwm8nu(_class_SentrySDK, _sel_flush_, timeout);
  }

  /// Closes the SDK, uninstalls all the integrations, and calls <code>flush</code> with
  /// <code>SentryOptions.shutdownTimeInterval</code>.
  static void close() {
    _objc_msgSend_1pl9qdv(_class_SentrySDK, _sel_close);
  }

  /// Start a new continuous profiling session if one is not already running.
  /// warning:
  /// Continuous profiling mode is experimental and may still contain bugs.
  /// note:
  /// Unlike transaction-based profiling, continuous profiling does not take into account
  /// <code>SentryOptions.profilesSampleRate</code> or <code>SentryOptions.profilesSampler</code>. If either of those
  /// options are set, this method does nothing.
  /// note:
  /// Taking into account the above note, if <code>SentryOptions.configureProfiling</code> is not set,
  /// calls to this method will always start a profile if one is not already running. This includes app
  /// launch profiles configured with <code>SentryOptions.enableAppLaunchProfiling</code>.
  /// note:
  /// If neither <code>SentryOptions.profilesSampleRate</code> nor <code>SentryOptions.profilesSampler</code> are
  /// set, and <code>SentryOptions.configureProfiling</code> is set, this method does nothing if the profiling
  /// session is not sampled with respect to <code>SentryOptions.profileSessionSampleRate</code>, or if it is
  /// sampled but the profiler is already running.
  /// note:
  /// If neither <code>SentryOptions.profilesSampleRate</code> nor <code>SentryOptions.profilesSampler</code> are
  /// set, and <code>SentryOptions.configureProfiling</code> is set, this method does nothing if
  /// <code>SentryOptions.profileLifecycle</code> is set to <code>trace</code>. In this scenario, the profiler is
  /// automatically started and stopped depending on whether there is an active sampled span, so it is
  /// not permitted to manually start profiling.
  /// note:
  /// Profiling is automatically disabled if a thread sanitizer is attached.
  /// seealso:
  /// https://docs.sentry.io/platforms/apple/guides/ios/profiling/#continuous-profiling
  static void startProfiler() {
    _objc_msgSend_1pl9qdv(_class_SentrySDK, _sel_startProfiler);
  }

  /// Stop a continuous profiling session if there is one ongoing.
  /// warning:
  /// Continuous profiling mode is experimental and may still contain bugs.
  /// note:
  /// Does nothing if <code>SentryOptions.profileLifecycle</code> is set to <code>trace</code>.
  /// note:
  /// Does not immediately stop the profiler. Profiling data is uploaded at regular timed
  /// intervals; when the current interval completes, then the profiler stops and the data gathered
  /// during that last interval is uploaded.
  /// note:
  /// If a new call to <code>startProfiler</code> that would start the profiler is made before the last
  /// interval completes, the profiler will continue running until another call to stop is made.
  /// note:
  /// Profiling is automatically disabled if a thread sanitizer is attached.
  /// seealso:
  /// https://docs.sentry.io/platforms/apple/guides/ios/profiling/#continuous-profiling
  static void stopProfiler() {
    _objc_msgSend_1pl9qdv(_class_SentrySDK, _sel_stopProfiler);
  }

  /// note:
  /// Conceptually internal but needs to be marked public with SPI for ObjC visibility
  static void clearLogger() {
    _objc_msgSend_1pl9qdv(_class_SentrySDK, _sel_clearLogger);
  }

  /// init
  SentrySDK init() {
    objc.checkOsVersionInternal('SentrySDK.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return SentrySDK.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static SentrySDK new$() {
    final _ret = _objc_msgSend_151sglz(_class_SentrySDK, _sel_new);
    return SentrySDK.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SentrySDK allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_SentrySDK, _sel_allocWithZone_, zone);
    return SentrySDK.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static SentrySDK alloc() {
    final _ret = _objc_msgSend_151sglz(_class_SentrySDK, _sel_alloc);
    return SentrySDK.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  SentrySDK self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return SentrySDK.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  SentrySDK retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return SentrySDK.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  SentrySDK autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return SentrySDK.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of SentrySDK constructed with the default `new` method.
  factory SentrySDK() => new$();
}

late final _class_SentryDebugMeta = objc.getClass("SentryDebugMeta");
late final _sel_uuid = objc.registerName("uuid");
late final _sel_setUuid_ = objc.registerName("setUuid:");
late final _sel_debugID = objc.registerName("debugID");
late final _sel_setDebugID_ = objc.registerName("setDebugID:");
late final _sel_type = objc.registerName("type");
late final _sel_setType_ = objc.registerName("setType:");
late final _sel_name = objc.registerName("name");
late final _sel_setName_ = objc.registerName("setName:");
late final _sel_imageSize = objc.registerName("imageSize");
late final _sel_setImageSize_ = objc.registerName("setImageSize:");
late final _sel_imageAddress = objc.registerName("imageAddress");
late final _sel_setImageAddress_ = objc.registerName("setImageAddress:");
late final _sel_imageVmAddress = objc.registerName("imageVmAddress");
late final _sel_setImageVmAddress_ = objc.registerName("setImageVmAddress:");
late final _sel_codeFile = objc.registerName("codeFile");
late final _sel_setCodeFile_ = objc.registerName("setCodeFile:");

/// Contains information about a loaded library in the process and the memory address.
/// @discussion Since 8.2.0, the SDK changed the debug image type from "apple" to "macho". For macho,
/// the SDK now sends @c debugID instead of @c uuid , and @c codeFile instead of @c name . For more
/// information check https://develop.sentry.dev/sdk/event-payloads/debugmeta/#mach-o-images.
/// @todo This class is actually a DebugImage:
/// https://develop.sentry.dev/sdk/event-payloads/debugmeta/#debug-images and should be renamed to
/// @c SentryDebugImage in a future version.
class SentryDebugMeta extends objc.NSObject implements SentrySerializable {
  SentryDebugMeta._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [SentryDebugMeta] that points to the same underlying object as [other].
  SentryDebugMeta.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryDebugMeta] that wraps the given raw object pointer.
  SentryDebugMeta.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [SentryDebugMeta].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_SentryDebugMeta);
  }

  /// The UUID of the image. Use @c debugID when using "macho" as the @c type .
  objc.NSString? get uuid {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_uuid);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The UUID of the image. Use @c debugID when using "macho" as the @c type .
  set uuid(objc.NSString? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setUuid_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Identifier of the dynamic library or executable. It is the value of the @c LC_UUID load command
  /// in the Mach header, formatted as UUID.
  objc.NSString? get debugID {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_debugID);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Identifier of the dynamic library or executable. It is the value of the @c LC_UUID load command
  /// in the Mach header, formatted as UUID.
  set debugID(objc.NSString? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setDebugID_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Type of debug meta. We highly recommend using "macho"; was "apple" previously.
  objc.NSString? get type {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_type);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Type of debug meta. We highly recommend using "macho"; was "apple" previously.
  set type(objc.NSString? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setType_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Name of the image. Use @c codeFile when using "macho" as the @c type .
  objc.NSString? get name {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_name);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Name of the image. Use @c codeFile when using "macho" as the @c type .
  set name(objc.NSString? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setName_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// The size of the image in virtual memory. If missing, Sentry will assume that the image spans up
  /// to the next image, which might lead to invalid stack traces.
  objc.NSNumber? get imageSize {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_imageSize);
    return _ret.address == 0
        ? null
        : objc.NSNumber.castFromPointer(_ret, retain: true, release: true);
  }

  /// The size of the image in virtual memory. If missing, Sentry will assume that the image spans up
  /// to the next image, which might lead to invalid stack traces.
  set imageSize(objc.NSNumber? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setImageSize_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// Memory address, at which the image is mounted in the virtual address space of the process. Should
  /// be a string in hex representation prefixed with "0x".
  objc.NSString? get imageAddress {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_imageAddress);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Memory address, at which the image is mounted in the virtual address space of the process. Should
  /// be a string in hex representation prefixed with "0x".
  set imageAddress(objc.NSString? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setImageAddress_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// Preferred load address of the image in virtual memory, as declared in the headers of the image.
  /// When loading an image, the operating system may still choose to place it at a different address.
  objc.NSString? get imageVmAddress {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_imageVmAddress);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Preferred load address of the image in virtual memory, as declared in the headers of the image.
  /// When loading an image, the operating system may still choose to place it at a different address.
  set imageVmAddress(objc.NSString? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setImageVmAddress_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  ///
  objc.NSString? get codeFile {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_codeFile);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  ///
  set codeFile(objc.NSString? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setCodeFile_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// init
  SentryDebugMeta init() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return SentryDebugMeta.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static SentryDebugMeta new$() {
    final _ret = _objc_msgSend_151sglz(_class_SentryDebugMeta, _sel_new);
    return SentryDebugMeta.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SentryDebugMeta allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_SentryDebugMeta, _sel_allocWithZone_, zone);
    return SentryDebugMeta.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static SentryDebugMeta alloc() {
    final _ret = _objc_msgSend_151sglz(_class_SentryDebugMeta, _sel_alloc);
    return SentryDebugMeta.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  SentryDebugMeta self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return SentryDebugMeta.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  SentryDebugMeta retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return SentryDebugMeta.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  SentryDebugMeta autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return SentryDebugMeta.castFromPointer(_ret, retain: true, release: true);
  }

  /// Serialize the contents of the object into an NSDictionary. Make to copy all properties of the
  /// original object so modifications to it don't have an impact on the serialized NSDictionary.
  objc.NSDictionary serialize() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_serialize);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of SentryDebugMeta constructed with the default `new` method.
  factory SentryDebugMeta() => new$();
}

late final _class_SentryDependencyContainer =
    objc.getClass("SentryDependencyContainer");
late final _sel_sharedInstance = objc.registerName("sharedInstance");
late final _sel_reset = objc.registerName("reset");

/// WARNING: SentryDispatchQueueWrapper is a stub. To generate bindings for this class, include
/// SentryDispatchQueueWrapper in your config's objc-interfaces list.
///
/// SentryDispatchQueueWrapper
class SentryDispatchQueueWrapper extends objc.ObjCObjectBase {
  SentryDispatchQueueWrapper._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryDispatchQueueWrapper] that points to the same underlying object as [other].
  SentryDispatchQueueWrapper.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryDispatchQueueWrapper] that wraps the given raw object pointer.
  SentryDispatchQueueWrapper.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_dispatchQueueWrapper =
    objc.registerName("dispatchQueueWrapper");
late final _sel_setDispatchQueueWrapper_ =
    objc.registerName("setDispatchQueueWrapper:");

/// WARNING: SentryRandom is a stub. To generate bindings for this class, include
/// SentryRandom in your config's objc-protocols list.
///
/// SentryRandom
interface class SentryRandom extends objc.ObjCProtocolBase {
  SentryRandom._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryRandom] that points to the same underlying object as [other].
  SentryRandom.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryRandom] that wraps the given raw object pointer.
  SentryRandom.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_random = objc.registerName("random");
late final _sel_setRandom_ = objc.registerName("setRandom:");

/// WARNING: SentryThreadWrapper is a stub. To generate bindings for this class, include
/// SentryThreadWrapper in your config's objc-interfaces list.
///
/// SentryThreadWrapper
class SentryThreadWrapper extends objc.ObjCObjectBase {
  SentryThreadWrapper._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryThreadWrapper] that points to the same underlying object as [other].
  SentryThreadWrapper.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryThreadWrapper] that wraps the given raw object pointer.
  SentryThreadWrapper.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_threadWrapper = objc.registerName("threadWrapper");
late final _sel_setThreadWrapper_ = objc.registerName("setThreadWrapper:");
late final _class_SentryBinaryImageCache =
    objc.getClass("SentryBinaryImageCache");
late final _sel_start_ = objc.registerName("start:");
late final _sel_stop = objc.registerName("stop");
late final _sel_getAllBinaryImages = objc.registerName("getAllBinaryImages");
late final _class_SentryBinaryImageInfo =
    objc.getClass("SentryBinaryImageInfo");
late final _sel_UUID = objc.registerName("UUID");
late final _sel_setUUID_ = objc.registerName("setUUID:");
late final _sel_vmAddress = objc.registerName("vmAddress");
final _objc_msgSend_9qbz9w = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Uint64 Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setVmAddress_ = objc.registerName("setVmAddress:");
final _objc_msgSend_1xsl7ae = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Uint64)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_address = objc.registerName("address");
late final _sel_setAddress_ = objc.registerName("setAddress:");
late final _sel_size = objc.registerName("size");
late final _sel_setSize_ = objc.registerName("setSize:");

/// SentryBinaryImageInfo
class SentryBinaryImageInfo extends objc.NSObject {
  SentryBinaryImageInfo._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [SentryBinaryImageInfo] that points to the same underlying object as [other].
  SentryBinaryImageInfo.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryBinaryImageInfo] that wraps the given raw object pointer.
  SentryBinaryImageInfo.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [SentryBinaryImageInfo].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_SentryBinaryImageInfo);
  }

  /// name
  objc.NSString get name {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_name);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setName:
  set name(objc.NSString value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setName_, value.ref.pointer);
  }

  /// UUID
  objc.NSString get UUID {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_UUID);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setUUID:
  set UUID(objc.NSString value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setUUID_, value.ref.pointer);
  }

  /// vmAddress
  int get vmAddress {
    return _objc_msgSend_9qbz9w(this.ref.pointer, _sel_vmAddress);
  }

  /// setVmAddress:
  set vmAddress(int value) {
    _objc_msgSend_1xsl7ae(this.ref.pointer, _sel_setVmAddress_, value);
  }

  /// address
  int get address {
    return _objc_msgSend_9qbz9w(this.ref.pointer, _sel_address);
  }

  /// setAddress:
  set address(int value) {
    _objc_msgSend_1xsl7ae(this.ref.pointer, _sel_setAddress_, value);
  }

  /// size
  int get size {
    return _objc_msgSend_9qbz9w(this.ref.pointer, _sel_size);
  }

  /// setSize:
  set size(int value) {
    _objc_msgSend_1xsl7ae(this.ref.pointer, _sel_setSize_, value);
  }

  /// init
  SentryBinaryImageInfo init() {
    objc.checkOsVersionInternal('SentryBinaryImageInfo.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return SentryBinaryImageInfo.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static SentryBinaryImageInfo new$() {
    final _ret = _objc_msgSend_151sglz(_class_SentryBinaryImageInfo, _sel_new);
    return SentryBinaryImageInfo.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static SentryBinaryImageInfo allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_SentryBinaryImageInfo, _sel_allocWithZone_, zone);
    return SentryBinaryImageInfo.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static SentryBinaryImageInfo alloc() {
    final _ret =
        _objc_msgSend_151sglz(_class_SentryBinaryImageInfo, _sel_alloc);
    return SentryBinaryImageInfo.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  SentryBinaryImageInfo self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return SentryBinaryImageInfo.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  SentryBinaryImageInfo retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return SentryBinaryImageInfo.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  SentryBinaryImageInfo autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return SentryBinaryImageInfo.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of SentryBinaryImageInfo constructed with the default `new` method.
  factory SentryBinaryImageInfo() => new$();
}

late final _sel_imageByAddress_ = objc.registerName("imageByAddress:");
final _objc_msgSend_10euuey = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Uint64)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_imagePathsForInAppInclude_ =
    objc.registerName("imagePathsForInAppInclude:");
late final _sel_convertUUID_ = objc.registerName("convertUUID:");
final _objc_msgSend_3koxn2 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.UnsignedChar>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.UnsignedChar>)>();

/// SentryBinaryImageCache
class SentryBinaryImageCache extends objc.NSObject {
  SentryBinaryImageCache._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [SentryBinaryImageCache] that points to the same underlying object as [other].
  SentryBinaryImageCache.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryBinaryImageCache] that wraps the given raw object pointer.
  SentryBinaryImageCache.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [SentryBinaryImageCache].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_SentryBinaryImageCache);
  }

  /// start:
  void start(bool isDebug) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_start_, isDebug);
  }

  /// stop
  void stop() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_stop);
  }

  /// getAllBinaryImages
  objc.NSArray getAllBinaryImages() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_getAllBinaryImages);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageByAddress:
  SentryBinaryImageInfo? imageByAddress(int address) {
    final _ret =
        _objc_msgSend_10euuey(this.ref.pointer, _sel_imageByAddress_, address);
    return _ret.address == 0
        ? null
        : SentryBinaryImageInfo.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// imagePathsForInAppInclude:
  objc.NSSet imagePathsForInAppInclude(objc.NSString inAppInclude) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_imagePathsForInAppInclude_, inAppInclude.ref.pointer);
    return objc.NSSet.castFromPointer(_ret, retain: true, release: true);
  }

  /// convertUUID:
  static objc.NSString? convertUUID(ffi.Pointer<ffi.UnsignedChar> value) {
    final _ret = _objc_msgSend_3koxn2(
        _class_SentryBinaryImageCache, _sel_convertUUID_, value);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  SentryBinaryImageCache init() {
    objc.checkOsVersionInternal('SentryBinaryImageCache.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return SentryBinaryImageCache.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static SentryBinaryImageCache new$() {
    final _ret = _objc_msgSend_151sglz(_class_SentryBinaryImageCache, _sel_new);
    return SentryBinaryImageCache.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static SentryBinaryImageCache allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_SentryBinaryImageCache, _sel_allocWithZone_, zone);
    return SentryBinaryImageCache.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static SentryBinaryImageCache alloc() {
    final _ret =
        _objc_msgSend_151sglz(_class_SentryBinaryImageCache, _sel_alloc);
    return SentryBinaryImageCache.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  SentryBinaryImageCache self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return SentryBinaryImageCache.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  SentryBinaryImageCache retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return SentryBinaryImageCache.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  SentryBinaryImageCache autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return SentryBinaryImageCache.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of SentryBinaryImageCache constructed with the default `new` method.
  factory SentryBinaryImageCache() => new$();
}

late final _sel_binaryImageCache = objc.registerName("binaryImageCache");
late final _sel_setBinaryImageCache_ =
    objc.registerName("setBinaryImageCache:");

/// WARNING: SentryCurrentDateProvider is a stub. To generate bindings for this class, include
/// SentryCurrentDateProvider in your config's objc-protocols list.
///
/// SentryCurrentDateProvider
interface class SentryCurrentDateProvider extends objc.ObjCProtocolBase {
  SentryCurrentDateProvider._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryCurrentDateProvider] that points to the same underlying object as [other].
  SentryCurrentDateProvider.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryCurrentDateProvider] that wraps the given raw object pointer.
  SentryCurrentDateProvider.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_dateProvider = objc.registerName("dateProvider");
late final _sel_setDateProvider_ = objc.registerName("setDateProvider:");

/// WARNING: SentryExtraContextProvider is a stub. To generate bindings for this class, include
/// SentryExtraContextProvider in your config's objc-interfaces list.
///
/// SentryExtraContextProvider
class SentryExtraContextProvider extends objc.ObjCObjectBase {
  SentryExtraContextProvider._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryExtraContextProvider] that points to the same underlying object as [other].
  SentryExtraContextProvider.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryExtraContextProvider] that wraps the given raw object pointer.
  SentryExtraContextProvider.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_extraContextProvider =
    objc.registerName("extraContextProvider");
late final _sel_setExtraContextProvider_ =
    objc.registerName("setExtraContextProvider:");

/// WARNING: SentryNSNotificationCenterWrapper is a stub. To generate bindings for this class, include
/// SentryNSNotificationCenterWrapper in your config's objc-protocols list.
///
/// SentryNSNotificationCenterWrapper
interface class SentryNSNotificationCenterWrapper
    extends objc.ObjCProtocolBase {
  SentryNSNotificationCenterWrapper._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryNSNotificationCenterWrapper] that points to the same underlying object as [other].
  SentryNSNotificationCenterWrapper.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryNSNotificationCenterWrapper] that wraps the given raw object pointer.
  SentryNSNotificationCenterWrapper.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_notificationCenterWrapper =
    objc.registerName("notificationCenterWrapper");
late final _sel_setNotificationCenterWrapper_ =
    objc.registerName("setNotificationCenterWrapper:");

/// WARNING: SentryCrashWrapper is a stub. To generate bindings for this class, include
/// SentryCrashWrapper in your config's objc-interfaces list.
///
/// SentryCrashWrapper
class SentryCrashWrapper extends objc.ObjCObjectBase {
  SentryCrashWrapper._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryCrashWrapper] that points to the same underlying object as [other].
  SentryCrashWrapper.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryCrashWrapper] that wraps the given raw object pointer.
  SentryCrashWrapper.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_crashWrapper = objc.registerName("crashWrapper");
late final _sel_setCrashWrapper_ = objc.registerName("setCrashWrapper:");

/// WARNING: SentryNSProcessInfoWrapper is a stub. To generate bindings for this class, include
/// SentryNSProcessInfoWrapper in your config's objc-interfaces list.
///
/// SentryNSProcessInfoWrapper
class SentryNSProcessInfoWrapper extends objc.ObjCObjectBase {
  SentryNSProcessInfoWrapper._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryNSProcessInfoWrapper] that points to the same underlying object as [other].
  SentryNSProcessInfoWrapper.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryNSProcessInfoWrapper] that wraps the given raw object pointer.
  SentryNSProcessInfoWrapper.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_processInfoWrapper = objc.registerName("processInfoWrapper");
late final _sel_setProcessInfoWrapper_ =
    objc.registerName("setProcessInfoWrapper:");

/// WARNING: SentrySysctl is a stub. To generate bindings for this class, include
/// SentrySysctl in your config's objc-interfaces list.
///
/// SentrySysctl
class SentrySysctl extends objc.ObjCObjectBase {
  SentrySysctl._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentrySysctl] that points to the same underlying object as [other].
  SentrySysctl.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentrySysctl] that wraps the given raw object pointer.
  SentrySysctl.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_sysctlWrapper = objc.registerName("sysctlWrapper");
late final _sel_setSysctlWrapper_ = objc.registerName("setSysctlWrapper:");

/// WARNING: SentryRateLimits is a stub. To generate bindings for this class, include
/// SentryRateLimits in your config's objc-protocols list.
///
/// SentryRateLimits
interface class SentryRateLimits extends objc.ObjCProtocolBase {
  SentryRateLimits._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryRateLimits] that points to the same underlying object as [other].
  SentryRateLimits.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryRateLimits] that wraps the given raw object pointer.
  SentryRateLimits.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_rateLimits = objc.registerName("rateLimits");
late final _sel_setRateLimits_ = objc.registerName("setRateLimits:");

/// WARNING: SentryApplication is a stub. To generate bindings for this class, include
/// SentryApplication in your config's objc-protocols list.
///
/// SentryApplication
interface class SentryApplication extends objc.ObjCProtocolBase {
  SentryApplication._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryApplication] that points to the same underlying object as [other].
  SentryApplication.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryApplication] that wraps the given raw object pointer.
  SentryApplication.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_application = objc.registerName("application");
late final _sel_setApplication_ = objc.registerName("setApplication:");

/// WARNING: SentryReachability is a stub. To generate bindings for this class, include
/// SentryReachability in your config's objc-interfaces list.
///
/// SentryReachability
class SentryReachability extends objc.ObjCObjectBase {
  SentryReachability._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryReachability] that points to the same underlying object as [other].
  SentryReachability.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryReachability] that wraps the given raw object pointer.
  SentryReachability.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_reachability = objc.registerName("reachability");
late final _sel_setReachability_ = objc.registerName("setReachability:");

/// WARNING: SentryFileManager is a stub. To generate bindings for this class, include
/// SentryFileManager in your config's objc-interfaces list.
///
/// SentryFileManager
class SentryFileManager extends objc.ObjCObjectBase {
  SentryFileManager._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryFileManager] that points to the same underlying object as [other].
  SentryFileManager.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryFileManager] that wraps the given raw object pointer.
  SentryFileManager.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_fileManager = objc.registerName("fileManager");
late final _sel_setFileManager_ = objc.registerName("setFileManager:");

/// WARNING: SentryAppStateManager is a stub. To generate bindings for this class, include
/// SentryAppStateManager in your config's objc-interfaces list.
///
/// SentryAppStateManager
class SentryAppStateManager extends objc.ObjCObjectBase {
  SentryAppStateManager._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryAppStateManager] that points to the same underlying object as [other].
  SentryAppStateManager.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryAppStateManager] that wraps the given raw object pointer.
  SentryAppStateManager.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_appStateManager = objc.registerName("appStateManager");
late final _sel_setAppStateManager_ = objc.registerName("setAppStateManager:");

/// WARNING: SentryThreadInspector is a stub. To generate bindings for this class, include
/// SentryThreadInspector in your config's objc-interfaces list.
///
/// SentryThreadInspector
class SentryThreadInspector extends objc.ObjCObjectBase {
  SentryThreadInspector._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryThreadInspector] that points to the same underlying object as [other].
  SentryThreadInspector.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryThreadInspector] that wraps the given raw object pointer.
  SentryThreadInspector.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_threadInspector = objc.registerName("threadInspector");
late final _sel_setThreadInspector_ = objc.registerName("setThreadInspector:");

/// WARNING: SentryFileIOTracker is a stub. To generate bindings for this class, include
/// SentryFileIOTracker in your config's objc-interfaces list.
///
/// SentryFileIOTracker
class SentryFileIOTracker extends objc.ObjCObjectBase {
  SentryFileIOTracker._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryFileIOTracker] that points to the same underlying object as [other].
  SentryFileIOTracker.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryFileIOTracker] that wraps the given raw object pointer.
  SentryFileIOTracker.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_fileIOTracker = objc.registerName("fileIOTracker");
late final _sel_setFileIOTracker_ = objc.registerName("setFileIOTracker:");

/// WARNING: SentryCrash is a stub. To generate bindings for this class, include
/// SentryCrash in your config's objc-interfaces list.
///
/// SentryCrash
class SentryCrash extends objc.ObjCObjectBase {
  SentryCrash._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryCrash] that points to the same underlying object as [other].
  SentryCrash.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryCrash] that wraps the given raw object pointer.
  SentryCrash.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_crashReporter = objc.registerName("crashReporter");
late final _sel_setCrashReporter_ = objc.registerName("setCrashReporter:");

/// WARNING: SentryScopePersistentStore is a stub. To generate bindings for this class, include
/// SentryScopePersistentStore in your config's objc-interfaces list.
///
/// SentryScopePersistentStore
class SentryScopePersistentStore extends objc.ObjCObjectBase {
  SentryScopePersistentStore._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryScopePersistentStore] that points to the same underlying object as [other].
  SentryScopePersistentStore.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryScopePersistentStore] that wraps the given raw object pointer.
  SentryScopePersistentStore.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_scopePersistentStore =
    objc.registerName("scopePersistentStore");
late final _sel_setScopePersistentStore_ =
    objc.registerName("setScopePersistentStore:");
late final _class_SentryDebugImageProvider =
    objc.getClass("SentryDebugImageProvider");

///
extension unnamed on SentryDebugImageProvider {}

late final _sel_getDebugImagesForThreads_ =
    objc.registerName("getDebugImagesForThreads:");
late final _sel_getDebugImagesForThreads_isCrash_ =
    objc.registerName("getDebugImagesForThreads:isCrash:");
late final _sel_getDebugImagesForFrames_ =
    objc.registerName("getDebugImagesForFrames:");
late final _sel_getDebugImagesForFrames_isCrash_ =
    objc.registerName("getDebugImagesForFrames:isCrash:");
late final _sel_getDebugImagesFromCacheForFrames_ =
    objc.registerName("getDebugImagesFromCacheForFrames:");
late final _sel_getDebugImagesFromCacheForThreads_ =
    objc.registerName("getDebugImagesFromCacheForThreads:");
late final _sel_getDebugImagesForImageAddressesFromCache_ =
    objc.registerName("getDebugImagesForImageAddressesFromCache:");
late final _sel_getDebugImagesFromCache =
    objc.registerName("getDebugImagesFromCache");

/// SentryDebugImageProvider
class SentryDebugImageProvider extends objc.NSObject {
  SentryDebugImageProvider._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [SentryDebugImageProvider] that points to the same underlying object as [other].
  SentryDebugImageProvider.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryDebugImageProvider] that wraps the given raw object pointer.
  SentryDebugImageProvider.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [SentryDebugImageProvider].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_SentryDebugImageProvider);
  }

  /// init
  SentryDebugImageProvider init() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return SentryDebugImageProvider.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Returns a list of debug images that are being referenced in the given threads.
  /// @param threads A list of @c SentryThread that may or may not contain stacktraces.
  /// @warning This assumes a crash has occurred and attempts to read the crash information from each
  /// image's data segment, which may not be present or be invalid if a crash has not actually
  /// occurred. To avoid this, use the new @c -[getDebugImagesForThreads:isCrash:] instead.
  /// @deprecated Use @c -[getDebugImagesForThreads:isCrash:] instead.
  objc.NSArray getDebugImagesForThreads(objc.NSArray threads) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_getDebugImagesForThreads_, threads.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a list of debug images that are being referenced in the given threads.
  /// @param threads A list of @c SentryThread that may or may not contain stacktraces.
  /// @param isCrash @c YES if we're collecting binary images for a crash report, @c NO if we're
  /// gathering them for other backtrace information, like a performance transaction. If this is for a
  /// crash, each image's data section crash info is also included.
  objc.NSArray getDebugImagesForThreads$1(objc.NSArray threads,
      {required bool isCrash}) {
    final _ret = _objc_msgSend_17amj0z(this.ref.pointer,
        _sel_getDebugImagesForThreads_isCrash_, threads.ref.pointer, isCrash);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a list of debug images that are being referenced by the given frames.
  /// @param frames A list of stack frames.
  /// @warning This assumes a crash has occurred and attempts to read the crash information from each
  /// image's data segment, which may not be present or be invalid if a crash has not actually
  /// occurred. To avoid this, use the new @c -[getDebugImagesForFrames:isCrash:] instead.
  /// @deprecated Use @c -[getDebugImagesForFrames:isCrash:] instead.
  objc.NSArray getDebugImagesForFrames(objc.NSArray frames) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_getDebugImagesForFrames_, frames.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a list of debug images that are being referenced by the given frames.
  /// @param frames A list of stack frames.
  /// @param isCrash @c YES if we're collecting binary images for a crash report, @c NO if we're
  /// gathering them for other backtrace information, like a performance transaction. If this is for a
  /// crash, each image's data section crash info is also included.
  objc.NSArray getDebugImagesForFrames$1(objc.NSArray frames,
      {required bool isCrash}) {
    final _ret = _objc_msgSend_17amj0z(this.ref.pointer,
        _sel_getDebugImagesForFrames_isCrash_, frames.ref.pointer, isCrash);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns the current list of debug images. Be aware that the @c SentryDebugMeta is actually
  /// describing a debug image.
  /// @warning This assumes a crash has occurred and attempts to read the crash information from each
  /// image's data segment, which may not be present or be invalid if a crash has not actually
  /// occurred. To avoid this, use the new @c -[getDebugImagesCrashed:] instead.
  /// @deprecated Use @c -[getDebugImagesCrashed:] instead.
  objc.NSArray getDebugImages() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_getDebugImages);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns the current list of debug images. Be aware that the @c SentryDebugMeta is actually
  /// describing a debug image.
  /// @param isCrash @c YES if we're collecting binary images for a crash report, @c NO if we're
  /// gathering them for other backtrace information, like a performance transaction. If this is for a
  /// crash, each image's data section crash info is also included.
  ///
  /// @warning This method is slow. Please consider using @c getDebugImagesFromCache.
  objc.NSArray getDebugImagesCrashed(bool isCrash) {
    final _ret = _objc_msgSend_1t6aok9(
        this.ref.pointer, _sel_getDebugImagesCrashed_, isCrash);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static SentryDebugImageProvider new$() {
    final _ret =
        _objc_msgSend_151sglz(_class_SentryDebugImageProvider, _sel_new);
    return SentryDebugImageProvider.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static SentryDebugImageProvider allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_SentryDebugImageProvider, _sel_allocWithZone_, zone);
    return SentryDebugImageProvider.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static SentryDebugImageProvider alloc() {
    final _ret =
        _objc_msgSend_151sglz(_class_SentryDebugImageProvider, _sel_alloc);
    return SentryDebugImageProvider.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  SentryDebugImageProvider self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return SentryDebugImageProvider.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  SentryDebugImageProvider retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return SentryDebugImageProvider.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  SentryDebugImageProvider autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return SentryDebugImageProvider.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a list of debug images that are being referenced by the given frames.
  /// This function uses the @c SentryBinaryImageCache which is significantly faster than @c
  /// SentryCrashDefaultBinaryImageProvider for retrieving binary image information.
  objc.NSArray getDebugImagesFromCacheForFrames(objc.NSArray frames) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_getDebugImagesFromCacheForFrames_, frames.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a list of debug images that are being referenced in the given threads.
  /// This function uses the @c SentryBinaryImageCache which is significantly faster than @c
  /// SentryCrashDefaultBinaryImageProvider for retrieving binary image information.
  objc.NSArray getDebugImagesFromCacheForThreads(objc.NSArray threads) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_getDebugImagesFromCacheForThreads_, threads.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a list of debug images that are being referenced in the given image addresses.
  /// This function uses the @c SentryBinaryImageCache which is significantly faster than @c
  /// SentryCrashDefaultBinaryImageProvider for retrieving binary image information.
  objc.NSArray getDebugImagesForImageAddressesFromCache(
      objc.NSSet imageAddresses) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer,
        _sel_getDebugImagesForImageAddressesFromCache_,
        imageAddresses.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// getDebugImagesFromCache
  objc.NSArray getDebugImagesFromCache() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_getDebugImagesFromCache);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of SentryDebugImageProvider constructed with the default `new` method.
  factory SentryDebugImageProvider() => new$();
}

late final _sel_debugImageProvider = objc.registerName("debugImageProvider");
late final _sel_setDebugImageProvider_ =
    objc.registerName("setDebugImageProvider:");

/// WARNING: SentryANRTracker is a stub. To generate bindings for this class, include
/// SentryANRTracker in your config's objc-protocols list.
///
/// SentryANRTracker
interface class SentryANRTracker extends objc.ObjCProtocolBase {
  SentryANRTracker._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryANRTracker] that points to the same underlying object as [other].
  SentryANRTracker.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryANRTracker] that wraps the given raw object pointer.
  SentryANRTracker.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_getANRTracker_ = objc.registerName("getANRTracker:");
final _objc_msgSend_oa8mke = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Double)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, double)>();

/// WARNING: SentrySystemWrapper is a stub. To generate bindings for this class, include
/// SentrySystemWrapper in your config's objc-interfaces list.
///
/// SentrySystemWrapper
class SentrySystemWrapper extends objc.ObjCObjectBase {
  SentrySystemWrapper._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentrySystemWrapper] that points to the same underlying object as [other].
  SentrySystemWrapper.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentrySystemWrapper] that wraps the given raw object pointer.
  SentrySystemWrapper.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_systemWrapper = objc.registerName("systemWrapper");
late final _sel_setSystemWrapper_ = objc.registerName("setSystemWrapper:");

/// WARNING: SentryDispatchFactory is a stub. To generate bindings for this class, include
/// SentryDispatchFactory in your config's objc-interfaces list.
///
/// SentryDispatchFactory
class SentryDispatchFactory extends objc.ObjCObjectBase {
  SentryDispatchFactory._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryDispatchFactory] that points to the same underlying object as [other].
  SentryDispatchFactory.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryDispatchFactory] that wraps the given raw object pointer.
  SentryDispatchFactory.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_dispatchFactory = objc.registerName("dispatchFactory");
late final _sel_setDispatchFactory_ = objc.registerName("setDispatchFactory:");

/// WARNING: SentryDispatchQueueProviderProtocol is a stub. To generate bindings for this class, include
/// SentryDispatchQueueProviderProtocol in your config's objc-protocols list.
///
/// SentryDispatchQueueProviderProtocol
interface class SentryDispatchQueueProviderProtocol
    extends objc.ObjCProtocolBase {
  SentryDispatchQueueProviderProtocol._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryDispatchQueueProviderProtocol] that points to the same underlying object as [other].
  SentryDispatchQueueProviderProtocol.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryDispatchQueueProviderProtocol] that wraps the given raw object pointer.
  SentryDispatchQueueProviderProtocol.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_dispatchQueueProvider =
    objc.registerName("dispatchQueueProvider");
late final _sel_setDispatchQueueProvider_ =
    objc.registerName("setDispatchQueueProvider:");

/// WARNING: SentryNSTimerFactory is a stub. To generate bindings for this class, include
/// SentryNSTimerFactory in your config's objc-interfaces list.
///
/// SentryNSTimerFactory
class SentryNSTimerFactory extends objc.ObjCObjectBase {
  SentryNSTimerFactory._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryNSTimerFactory] that points to the same underlying object as [other].
  SentryNSTimerFactory.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryNSTimerFactory] that wraps the given raw object pointer.
  SentryNSTimerFactory.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_timerFactory = objc.registerName("timerFactory");
late final _sel_setTimerFactory_ = objc.registerName("setTimerFactory:");

/// WARNING: SentrySwizzleWrapper is a stub. To generate bindings for this class, include
/// SentrySwizzleWrapper in your config's objc-interfaces list.
///
/// SentrySwizzleWrapper
class SentrySwizzleWrapper extends objc.ObjCObjectBase {
  SentrySwizzleWrapper._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentrySwizzleWrapper] that points to the same underlying object as [other].
  SentrySwizzleWrapper.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentrySwizzleWrapper] that wraps the given raw object pointer.
  SentrySwizzleWrapper.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_swizzleWrapper = objc.registerName("swizzleWrapper");
late final _sel_setSwizzleWrapper_ = objc.registerName("setSwizzleWrapper:");

/// WARNING: SentryMXManager is a stub. To generate bindings for this class, include
/// SentryMXManager in your config's objc-interfaces list.
///
/// SentryMXManager
class SentryMXManager extends objc.ObjCObjectBase {
  SentryMXManager._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryMXManager] that points to the same underlying object as [other].
  SentryMXManager.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryMXManager] that wraps the given raw object pointer.
  SentryMXManager.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_metricKitManager = objc.registerName("metricKitManager");
late final _sel_setMetricKitManager_ =
    objc.registerName("setMetricKitManager:");

/// WARNING: SentryObjCRuntimeWrapper is a stub. To generate bindings for this class, include
/// SentryObjCRuntimeWrapper in your config's objc-protocols list.
///
/// SentryObjCRuntimeWrapper
interface class SentryObjCRuntimeWrapper extends objc.ObjCProtocolBase {
  SentryObjCRuntimeWrapper._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryObjCRuntimeWrapper] that points to the same underlying object as [other].
  SentryObjCRuntimeWrapper.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryObjCRuntimeWrapper] that wraps the given raw object pointer.
  SentryObjCRuntimeWrapper.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_objcRuntimeWrapper = objc.registerName("objcRuntimeWrapper");
late final _sel_setObjcRuntimeWrapper_ =
    objc.registerName("setObjcRuntimeWrapper:");

/// WARNING: SentryGlobalEventProcessor is a stub. To generate bindings for this class, include
/// SentryGlobalEventProcessor in your config's objc-interfaces list.
///
/// SentryGlobalEventProcessor
class SentryGlobalEventProcessor extends objc.ObjCObjectBase {
  SentryGlobalEventProcessor._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryGlobalEventProcessor] that points to the same underlying object as [other].
  SentryGlobalEventProcessor.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryGlobalEventProcessor] that wraps the given raw object pointer.
  SentryGlobalEventProcessor.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_globalEventProcessor =
    objc.registerName("globalEventProcessor");
late final _sel_setGlobalEventProcessor_ =
    objc.registerName("setGlobalEventProcessor:");

/// WARNING: SentrySessionTracker is a stub. To generate bindings for this class, include
/// SentrySessionTracker in your config's objc-interfaces list.
///
/// SentrySessionTracker
class SentrySessionTracker extends objc.ObjCObjectBase {
  SentrySessionTracker._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentrySessionTracker] that points to the same underlying object as [other].
  SentrySessionTracker.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentrySessionTracker] that wraps the given raw object pointer.
  SentrySessionTracker.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_getSessionTrackerWithOptions_ =
    objc.registerName("getSessionTrackerWithOptions:");

/// The dependency container is optimized to use as few locks as possible and to only keep the
/// required dependencies in memory. It splits its dependencies into two groups.
///
/// Init Dependencies: These are mandatory dependencies required to run the SDK, no matter the
/// options. The dependency container initializes them in init and uses no locks for efficiency.
///
/// Lazy Dependencies: These dependencies either have some state or aren't always required and,
/// therefore, get initialized lazily to minimize the memory footprint.
class SentryDependencyContainer extends objc.NSObject {
  SentryDependencyContainer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [SentryDependencyContainer] that points to the same underlying object as [other].
  SentryDependencyContainer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryDependencyContainer] that wraps the given raw object pointer.
  SentryDependencyContainer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [SentryDependencyContainer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_SentryDependencyContainer);
  }

  /// init
  SentryDependencyContainer init() {
    objc.checkOsVersionInternal('SentryDependencyContainer.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return SentryDependencyContainer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static SentryDependencyContainer new$() {
    final _ret =
        _objc_msgSend_151sglz(_class_SentryDependencyContainer, _sel_new);
    return SentryDependencyContainer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// sharedInstance
  static SentryDependencyContainer sharedInstance() {
    final _ret = _objc_msgSend_151sglz(
        _class_SentryDependencyContainer, _sel_sharedInstance);
    return SentryDependencyContainer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Resets all dependencies.
  static void reset() {
    _objc_msgSend_1pl9qdv(_class_SentryDependencyContainer, _sel_reset);
  }

  /// dispatchQueueWrapper
  SentryDispatchQueueWrapper get dispatchQueueWrapper {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_dispatchQueueWrapper);
    return SentryDispatchQueueWrapper.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// setDispatchQueueWrapper:
  set dispatchQueueWrapper(SentryDispatchQueueWrapper value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setDispatchQueueWrapper_, value.ref.pointer);
  }

  /// random
  SentryRandom get random {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_random);
    return SentryRandom.castFromPointer(_ret, retain: true, release: true);
  }

  /// setRandom:
  set random(SentryRandom value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setRandom_, value.ref.pointer);
  }

  /// threadWrapper
  SentryThreadWrapper get threadWrapper {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_threadWrapper);
    return SentryThreadWrapper.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// setThreadWrapper:
  set threadWrapper(SentryThreadWrapper value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setThreadWrapper_, value.ref.pointer);
  }

  /// binaryImageCache
  SentryBinaryImageCache get binaryImageCache {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_binaryImageCache);
    return SentryBinaryImageCache.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// setBinaryImageCache:
  set binaryImageCache(SentryBinaryImageCache value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setBinaryImageCache_, value.ref.pointer);
  }

  /// dateProvider
  SentryCurrentDateProvider get dateProvider {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_dateProvider);
    return SentryCurrentDateProvider.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// setDateProvider:
  set dateProvider(SentryCurrentDateProvider value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setDateProvider_, value.ref.pointer);
  }

  /// extraContextProvider
  SentryExtraContextProvider get extraContextProvider {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_extraContextProvider);
    return SentryExtraContextProvider.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// setExtraContextProvider:
  set extraContextProvider(SentryExtraContextProvider value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setExtraContextProvider_, value.ref.pointer);
  }

  /// notificationCenterWrapper
  SentryNSNotificationCenterWrapper get notificationCenterWrapper {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_notificationCenterWrapper);
    return SentryNSNotificationCenterWrapper.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// setNotificationCenterWrapper:
  set notificationCenterWrapper(SentryNSNotificationCenterWrapper value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setNotificationCenterWrapper_,
        value.ref.pointer);
  }

  /// crashWrapper
  SentryCrashWrapper get crashWrapper {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_crashWrapper);
    return SentryCrashWrapper.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// setCrashWrapper:
  set crashWrapper(SentryCrashWrapper value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setCrashWrapper_, value.ref.pointer);
  }

  /// processInfoWrapper
  SentryNSProcessInfoWrapper get processInfoWrapper {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_processInfoWrapper);
    return SentryNSProcessInfoWrapper.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// setProcessInfoWrapper:
  set processInfoWrapper(SentryNSProcessInfoWrapper value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setProcessInfoWrapper_, value.ref.pointer);
  }

  /// sysctlWrapper
  SentrySysctl get sysctlWrapper {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_sysctlWrapper);
    return SentrySysctl.castFromPointer(_ret, retain: true, release: true);
  }

  /// setSysctlWrapper:
  set sysctlWrapper(SentrySysctl value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setSysctlWrapper_, value.ref.pointer);
  }

  /// rateLimits
  SentryRateLimits get rateLimits {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_rateLimits);
    return SentryRateLimits.castFromPointer(_ret, retain: true, release: true);
  }

  /// setRateLimits:
  set rateLimits(SentryRateLimits value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setRateLimits_, value.ref.pointer);
  }

  /// application
  SentryApplication get application {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_application);
    return SentryApplication.castFromPointer(_ret, retain: true, release: true);
  }

  /// setApplication:
  set application(SentryApplication value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setApplication_, value.ref.pointer);
  }

  /// reachability
  SentryReachability get reachability {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_reachability);
    return SentryReachability.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// setReachability:
  set reachability(SentryReachability value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setReachability_, value.ref.pointer);
  }

  /// fileManager
  SentryFileManager? get fileManager {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_fileManager);
    return _ret.address == 0
        ? null
        : SentryFileManager.castFromPointer(_ret, retain: true, release: true);
  }

  /// setFileManager:
  set fileManager(SentryFileManager? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setFileManager_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// appStateManager
  SentryAppStateManager get appStateManager {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_appStateManager);
    return SentryAppStateManager.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// setAppStateManager:
  set appStateManager(SentryAppStateManager value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setAppStateManager_, value.ref.pointer);
  }

  /// threadInspector
  SentryThreadInspector get threadInspector {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_threadInspector);
    return SentryThreadInspector.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// setThreadInspector:
  set threadInspector(SentryThreadInspector value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setThreadInspector_, value.ref.pointer);
  }

  /// fileIOTracker
  SentryFileIOTracker get fileIOTracker {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_fileIOTracker);
    return SentryFileIOTracker.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// setFileIOTracker:
  set fileIOTracker(SentryFileIOTracker value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setFileIOTracker_, value.ref.pointer);
  }

  /// crashReporter
  SentryCrash get crashReporter {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_crashReporter);
    return SentryCrash.castFromPointer(_ret, retain: true, release: true);
  }

  /// setCrashReporter:
  set crashReporter(SentryCrash value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setCrashReporter_, value.ref.pointer);
  }

  /// scopePersistentStore
  SentryScopePersistentStore get scopePersistentStore {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_scopePersistentStore);
    return SentryScopePersistentStore.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// setScopePersistentStore:
  set scopePersistentStore(SentryScopePersistentStore value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setScopePersistentStore_, value.ref.pointer);
  }

  /// debugImageProvider
  SentryDebugImageProvider get debugImageProvider {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_debugImageProvider);
    return SentryDebugImageProvider.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// setDebugImageProvider:
  set debugImageProvider(SentryDebugImageProvider value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setDebugImageProvider_, value.ref.pointer);
  }

  /// getANRTracker:
  SentryANRTracker getANRTracker(double timeout) {
    final _ret =
        _objc_msgSend_oa8mke(this.ref.pointer, _sel_getANRTracker_, timeout);
    return SentryANRTracker.castFromPointer(_ret, retain: true, release: true);
  }

  /// systemWrapper
  SentrySystemWrapper get systemWrapper {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_systemWrapper);
    return SentrySystemWrapper.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// setSystemWrapper:
  set systemWrapper(SentrySystemWrapper value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setSystemWrapper_, value.ref.pointer);
  }

  /// dispatchFactory
  SentryDispatchFactory get dispatchFactory {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_dispatchFactory);
    return SentryDispatchFactory.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// setDispatchFactory:
  set dispatchFactory(SentryDispatchFactory value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setDispatchFactory_, value.ref.pointer);
  }

  /// dispatchQueueProvider
  SentryDispatchQueueProviderProtocol get dispatchQueueProvider {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_dispatchQueueProvider);
    return SentryDispatchQueueProviderProtocol.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// setDispatchQueueProvider:
  set dispatchQueueProvider(SentryDispatchQueueProviderProtocol value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setDispatchQueueProvider_, value.ref.pointer);
  }

  /// timerFactory
  SentryNSTimerFactory get timerFactory {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_timerFactory);
    return SentryNSTimerFactory.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// setTimerFactory:
  set timerFactory(SentryNSTimerFactory value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setTimerFactory_, value.ref.pointer);
  }

  /// swizzleWrapper
  SentrySwizzleWrapper get swizzleWrapper {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_swizzleWrapper);
    return SentrySwizzleWrapper.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// setSwizzleWrapper:
  set swizzleWrapper(SentrySwizzleWrapper value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setSwizzleWrapper_, value.ref.pointer);
  }

  /// metricKitManager
  SentryMXManager get metricKitManager {
    objc.checkOsVersionInternal('SentryDependencyContainer.metricKitManager',
        iOS: (false, (15, 0, 0)), macOS: (false, (12, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_metricKitManager);
    return SentryMXManager.castFromPointer(_ret, retain: true, release: true);
  }

  /// setMetricKitManager:
  set metricKitManager(SentryMXManager value) {
    objc.checkOsVersionInternal(
        'SentryDependencyContainer.setMetricKitManager:',
        iOS: (false, (15, 0, 0)),
        macOS: (false, (12, 0, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setMetricKitManager_, value.ref.pointer);
  }

  /// objcRuntimeWrapper
  SentryObjCRuntimeWrapper get objcRuntimeWrapper {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_objcRuntimeWrapper);
    return SentryObjCRuntimeWrapper.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// setObjcRuntimeWrapper:
  set objcRuntimeWrapper(SentryObjCRuntimeWrapper value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setObjcRuntimeWrapper_, value.ref.pointer);
  }

  /// globalEventProcessor
  SentryGlobalEventProcessor get globalEventProcessor {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_globalEventProcessor);
    return SentryGlobalEventProcessor.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// setGlobalEventProcessor:
  set globalEventProcessor(SentryGlobalEventProcessor value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setGlobalEventProcessor_, value.ref.pointer);
  }

  /// getSessionTrackerWithOptions:
  SentrySessionTracker getSessionTrackerWithOptions(SentryOptions options) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_getSessionTrackerWithOptions_, options.ref.pointer);
    return SentrySessionTracker.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// allocWithZone:
  static SentryDependencyContainer allocWithZone(
      ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_SentryDependencyContainer, _sel_allocWithZone_, zone);
    return SentryDependencyContainer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static SentryDependencyContainer alloc() {
    final _ret =
        _objc_msgSend_151sglz(_class_SentryDependencyContainer, _sel_alloc);
    return SentryDependencyContainer.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  SentryDependencyContainer self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return SentryDependencyContainer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  SentryDependencyContainer retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return SentryDependencyContainer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  SentryDependencyContainer autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return SentryDependencyContainer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of SentryDependencyContainer constructed with the default `new` method.
  factory SentryDependencyContainer() => new$();
}
