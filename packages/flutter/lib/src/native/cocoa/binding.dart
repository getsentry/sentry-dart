// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _SentryCocoa_wrapListenerBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _SentryCocoa_wrapBlockingBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external ffi.Pointer<objc.ObjCObject> _SentryCocoa_protocolTrampoline_1mbt9g9(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

/// WARNING: NSUUID is a stub. To generate bindings for this class, include
/// NSUUID in your config's objc-interfaces list.
///
/// NSUUID
class NSUUID extends objc.NSObject
    implements objc.NSCopying, objc.NSSecureCoding {
  NSUUID._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSUUID',
        iOS: (false, (6, 0, 0)), macOS: (false, (10, 8, 0)));
  }

  /// Constructs a [NSUUID] that points to the same underlying object as [other].
  NSUUID.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSUUID] that wraps the given raw object pointer.
  NSUUID.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

/// Sentry level.
sealed class SentryLevel {}

/// WARNING: SentryAppStartMeasurement is a stub. To generate bindings for this class, include
/// SentryAppStartMeasurement in your config's objc-interfaces list.
///
/// SentryAppStartMeasurement
class SentryAppStartMeasurement extends objc.ObjCObjectBase {
  SentryAppStartMeasurement._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryAppStartMeasurement] that points to the same underlying object as [other].
  SentryAppStartMeasurement.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryAppStartMeasurement] that wraps the given raw object pointer.
  SentryAppStartMeasurement.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

void _ObjCBlock_ffiVoid_SentryAppStartMeasurement_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_SentryAppStartMeasurement_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_SentryAppStartMeasurement_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_SentryAppStartMeasurement_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_SentryAppStartMeasurement_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_SentryAppStartMeasurement_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_SentryAppStartMeasurement_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_SentryAppStartMeasurement_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_SentryAppStartMeasurement_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_SentryAppStartMeasurement_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_SentryAppStartMeasurement_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_SentryAppStartMeasurement_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_SentryAppStartMeasurement_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_SentryAppStartMeasurement_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>`.
abstract final class ObjCBlock_ffiVoid_SentryAppStartMeasurement {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_SentryAppStartMeasurement_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>
      fromFunction(void Function(SentryAppStartMeasurement?) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_SentryAppStartMeasurement_closureCallable,
                  (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
                      ? null
                      : SentryAppStartMeasurement.castFromPointer(arg0,
                          retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)> listener(
      void Function(SentryAppStartMeasurement?) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_SentryAppStartMeasurement_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : SentryAppStartMeasurement.castFromPointer(arg0,
                retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _SentryCocoa_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)> blocking(
      void Function(SentryAppStartMeasurement?) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_SentryAppStartMeasurement_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : SentryAppStartMeasurement.castFromPointer(arg0,
                retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_SentryAppStartMeasurement_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : SentryAppStartMeasurement.castFromPointer(arg0,
                retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _SentryCocoa_wrapBlockingBlock_xtuoz7(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>`.
extension ObjCBlock_ffiVoid_SentryAppStartMeasurement_CallExtension
    on objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)> {
  void call(SentryAppStartMeasurement? arg0) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<objc.ObjCObject> arg0)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>)>()(
      ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _class_PrivateSentrySDKOnly = objc.getClass("PrivateSentrySDKOnly");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();

/// WARNING: SentryEnvelope is a stub. To generate bindings for this class, include
/// SentryEnvelope in your config's objc-interfaces list.
///
/// SentryEnvelope
class SentryEnvelope extends objc.ObjCObjectBase {
  SentryEnvelope._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryEnvelope] that points to the same underlying object as [other].
  SentryEnvelope.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryEnvelope] that wraps the given raw object pointer.
  SentryEnvelope.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_storeEnvelope_ = objc.registerName("storeEnvelope:");
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_captureEnvelope_ = objc.registerName("captureEnvelope:");
late final _sel_envelopeWithData_ = objc.registerName("envelopeWithData:");
final _objc_msgSend_1sotr3r = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_getDebugImages = objc.registerName("getDebugImages");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_getDebugImagesCrashed_ =
    objc.registerName("getDebugImagesCrashed:");
final _objc_msgSend_1t6aok9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Bool)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, bool)>();
late final _sel_setSdkName_andVersionString_ =
    objc.registerName("setSdkName:andVersionString:");
final _objc_msgSend_pfv6jd = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_setSdkName_ = objc.registerName("setSdkName:");
late final _sel_getSdkName = objc.registerName("getSdkName");
late final _sel_getSdkVersionString = objc.registerName("getSdkVersionString");
late final _sel_addSdkPackage_version_ =
    objc.registerName("addSdkPackage:version:");
late final _sel_getExtraContext = objc.registerName("getExtraContext");
late final _class_SentryId = objc.getClass("Sentry.SentryId");

/// SentryId
class SentryId extends objc.ObjCObjectBase {
  SentryId._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryId] that points to the same underlying object as [other].
  SentryId.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryId] that wraps the given raw object pointer.
  SentryId.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [SentryId].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_SentryId);
  }
}

/// WARNING: SentrySpanId is a stub. To generate bindings for this class, include
/// SentrySpanId in your config's objc-interfaces list.
///
/// SentrySpanId
class SentrySpanId extends objc.ObjCObjectBase {
  SentrySpanId._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentrySpanId] that points to the same underlying object as [other].
  SentrySpanId.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentrySpanId] that wraps the given raw object pointer.
  SentrySpanId.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_setTrace_spanId_ = objc.registerName("setTrace:spanId:");
late final _sel_startProfilerForTrace_ =
    objc.registerName("startProfilerForTrace:");
final _objc_msgSend_1om1bna = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Uint64 Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_collectProfileBetween_and_forTrace_ =
    objc.registerName("collectProfileBetween:and:forTrace:");
final _objc_msgSend_l3zifn = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Uint64,
                ffi.Uint64,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            int,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_discardProfilerForTrace_ =
    objc.registerName("discardProfilerForTrace:");
late final _sel_onAppStartMeasurementAvailable =
    objc.registerName("onAppStartMeasurementAvailable");
final _objc_msgSend_uwvaik = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCBlockImpl> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setOnAppStartMeasurementAvailable_ =
    objc.registerName("setOnAppStartMeasurementAvailable:");
final _objc_msgSend_f167m6 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_appStartMeasurement = objc.registerName("appStartMeasurement");
late final _sel_installationID = objc.registerName("installationID");
late final _class_SentryOptions = objc.getClass("SentryOptions");
late final _sel_integrations = objc.registerName("integrations");

/// SentryOptions
class SentryOptions extends objc.NSObject {
  SentryOptions._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [SentryOptions] that points to the same underlying object as [other].
  SentryOptions.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryOptions] that wraps the given raw object pointer.
  SentryOptions.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [SentryOptions].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_SentryOptions);
  }

  /// Array of integrations to install.
  objc.NSArray? get integrations {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_integrations);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_options = objc.registerName("options");
late final _sel_appStartMeasurementHybridSDKMode =
    objc.registerName("appStartMeasurementHybridSDKMode");
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setAppStartMeasurementHybridSDKMode_ =
    objc.registerName("setAppStartMeasurementHybridSDKMode:");
final _objc_msgSend_1s56lr9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, bool)>();
late final _sel_appStartMeasurementWithSpans =
    objc.registerName("appStartMeasurementWithSpans");

/// WARNING: SentryUser is a stub. To generate bindings for this class, include
/// SentryUser in your config's objc-interfaces list.
///
/// SentryUser
class SentryUser extends objc.ObjCObjectBase {
  SentryUser._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryUser] that points to the same underlying object as [other].
  SentryUser.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryUser] that wraps the given raw object pointer.
  SentryUser.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_userWithDictionary_ = objc.registerName("userWithDictionary:");

/// WARNING: SentryBreadcrumb is a stub. To generate bindings for this class, include
/// SentryBreadcrumb in your config's objc-interfaces list.
///
/// SentryBreadcrumb
class SentryBreadcrumb extends objc.ObjCObjectBase {
  SentryBreadcrumb._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentryBreadcrumb] that points to the same underlying object as [other].
  SentryBreadcrumb.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryBreadcrumb] that wraps the given raw object pointer.
  SentryBreadcrumb.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_breadcrumbWithDictionary_ =
    objc.registerName("breadcrumbWithDictionary:");
typedef instancetype = ffi.Pointer<objc.ObjCObject>;
typedef Dartinstancetype = objc.ObjCObjectBase;
late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.NSZone>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.NSZone>)>();
late final _sel_alloc = objc.registerName("alloc");
late final _sel_self = objc.registerName("self");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_objcObjCObject_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_objcObjCObject_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_objcObjCObject_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_objcObjCObject_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_objcObjCObject_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      fromFunction(objc.ObjCObjectBase Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_objcObjCObject_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_objcObjCObject_ffiVoid_CallExtension on objc
    .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> {
  objc.ObjCObjectBase call(ffi.Pointer<ffi.Void> arg0) => objc.ObjCObjectBase(
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
      retain: true,
      release: true);
}

late final _sel_retain = objc.registerName("retain");
late final _sel_autorelease = objc.registerName("autorelease");

/// @warning This class is reserved for hybrid SDKs. Methods may be changed, renamed or removed
/// without notice. If you want to use one of these methods here please open up an issue and let us
/// know.
/// @note The name of this class is supposed to be a bit weird and ugly. The name starts with private
/// on purpose so users don't see it in code completion when typing Sentry. We also add only at the
/// end to make it more obvious you shouldn't use it.
class PrivateSentrySDKOnly extends objc.NSObject {
  PrivateSentrySDKOnly._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [PrivateSentrySDKOnly] that points to the same underlying object as [other].
  PrivateSentrySDKOnly.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [PrivateSentrySDKOnly] that wraps the given raw object pointer.
  PrivateSentrySDKOnly.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [PrivateSentrySDKOnly].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_PrivateSentrySDKOnly);
  }

  /// For storing an envelope synchronously to disk.
  static void storeEnvelope(SentryEnvelope envelope) {
    _objc_msgSend_xtuoz7(
        _class_PrivateSentrySDKOnly, _sel_storeEnvelope_, envelope.ref.pointer);
  }

  /// captureEnvelope:
  static void captureEnvelope(SentryEnvelope envelope) {
    _objc_msgSend_xtuoz7(_class_PrivateSentrySDKOnly, _sel_captureEnvelope_,
        envelope.ref.pointer);
  }

  /// Create an envelope from @c NSData. Needed for example by Flutter.
  static SentryEnvelope? envelopeWithData(objc.NSData data) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_PrivateSentrySDKOnly, _sel_envelopeWithData_, data.ref.pointer);
    return _ret.address == 0
        ? null
        : SentryEnvelope.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns the current list of debug images. Be aware that the @c SentryDebugMeta is actually
  /// describing a debug image.
  /// @warning This assumes a crash has occurred and attempts to read the crash information from each
  /// image's data segment, which may not be present or be invalid if a crash has not actually
  /// occurred. To avoid this, use the new @c +[getDebugImagesCrashed:] instead.
  static objc.NSArray getDebugImages() {
    final _ret =
        _objc_msgSend_151sglz(_class_PrivateSentrySDKOnly, _sel_getDebugImages);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns the current list of debug images. Be aware that the @c SentryDebugMeta is actually
  /// describing a debug image.
  /// @param isCrash @c YES if we're collecting binary images for a crash report, @c NO if we're
  /// gathering them for other backtrace information, like a performance transaction. If this is for a
  /// crash, each image's data section crash info is also included.
  static objc.NSArray getDebugImagesCrashed(bool isCrash) {
    final _ret = _objc_msgSend_1t6aok9(
        _class_PrivateSentrySDKOnly, _sel_getDebugImagesCrashed_, isCrash);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Override SDK information.
  static void setSdkName(objc.NSString sdkName,
      {required objc.NSString andVersionString}) {
    _objc_msgSend_pfv6jd(
        _class_PrivateSentrySDKOnly,
        _sel_setSdkName_andVersionString_,
        sdkName.ref.pointer,
        andVersionString.ref.pointer);
  }

  /// Override SDK information.
  static void setSdkName$1(objc.NSString sdkName) {
    _objc_msgSend_xtuoz7(
        _class_PrivateSentrySDKOnly, _sel_setSdkName_, sdkName.ref.pointer);
  }

  /// Retrieves the SDK name
  static objc.NSString getSdkName() {
    final _ret =
        _objc_msgSend_151sglz(_class_PrivateSentrySDKOnly, _sel_getSdkName);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Retrieves the SDK version string
  static objc.NSString getSdkVersionString() {
    final _ret = _objc_msgSend_151sglz(
        _class_PrivateSentrySDKOnly, _sel_getSdkVersionString);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Add a package to the SDK packages
  static void addSdkPackage(objc.NSString name,
      {required objc.NSString version}) {
    _objc_msgSend_pfv6jd(_class_PrivateSentrySDKOnly,
        _sel_addSdkPackage_version_, name.ref.pointer, version.ref.pointer);
  }

  /// Retrieves extra context
  static objc.NSDictionary getExtraContext() {
    final _ret = _objc_msgSend_151sglz(
        _class_PrivateSentrySDKOnly, _sel_getExtraContext);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// Allows Hybrids SDKs to thread-safe set the current trace.
  static void setTrace(SentryId traceId, {required SentrySpanId spanId}) {
    _objc_msgSend_pfv6jd(_class_PrivateSentrySDKOnly, _sel_setTrace_spanId_,
        traceId.ref.pointer, spanId.ref.pointer);
  }

  /// Start a profiler session associated with the given @c SentryId.
  /// @return The system time when the profiler session started.
  static int startProfilerForTrace(SentryId traceId) {
    return _objc_msgSend_1om1bna(_class_PrivateSentrySDKOnly,
        _sel_startProfilerForTrace_, traceId.ref.pointer);
  }

  /// Collect a profiler session data associated with the given @c SentryId.
  /// This also discards the profiler.
  static objc.NSMutableDictionary? collectProfileBetween(int startSystemTime,
      {required int and, required SentryId forTrace}) {
    final _ret = _objc_msgSend_l3zifn(
        _class_PrivateSentrySDKOnly,
        _sel_collectProfileBetween_and_forTrace_,
        startSystemTime,
        and,
        forTrace.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSMutableDictionary.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// Discard profiler session data associated with the given @c SentryId.
  /// This only needs to be called in case you haven't collected the profile (and don't intend to).
  static void discardProfilerForTrace(SentryId traceId) {
    _objc_msgSend_xtuoz7(_class_PrivateSentrySDKOnly,
        _sel_discardProfilerForTrace_, traceId.ref.pointer);
  }

  /// onAppStartMeasurementAvailable
  static objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>?
      getOnAppStartMeasurementAvailable() {
    final _ret = _objc_msgSend_uwvaik(
        _class_PrivateSentrySDKOnly, _sel_onAppStartMeasurementAvailable);
    return _ret.address == 0
        ? null
        : ObjCBlock_ffiVoid_SentryAppStartMeasurement.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// setOnAppStartMeasurementAvailable:
  static void setOnAppStartMeasurementAvailable(
      objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>? value) {
    _objc_msgSend_f167m6(
        _class_PrivateSentrySDKOnly,
        _sel_setOnAppStartMeasurementAvailable_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// appStartMeasurement
  static SentryAppStartMeasurement? getAppStartMeasurement() {
    final _ret = _objc_msgSend_151sglz(
        _class_PrivateSentrySDKOnly, _sel_appStartMeasurement);
    return _ret.address == 0
        ? null
        : SentryAppStartMeasurement.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// installationID
  static objc.NSString getInstallationID() {
    final _ret =
        _objc_msgSend_151sglz(_class_PrivateSentrySDKOnly, _sel_installationID);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// options
  static SentryOptions getOptions() {
    final _ret =
        _objc_msgSend_151sglz(_class_PrivateSentrySDKOnly, _sel_options);
    return SentryOptions.castFromPointer(_ret, retain: true, release: true);
  }

  /// If enabled, the SDK won't send the app start measurement with the first transaction. Instead, if
  /// @c enableAutoPerformanceTracing is enabled, the SDK measures the app start and then calls
  /// @c onAppStartMeasurementAvailable. Furthermore, the SDK doesn't set all values for the app start
  /// measurement because the HybridSDKs initialize the Cocoa SDK too late to receive all
  /// notifications. Instead, the SDK sets the @c appStartDuration to @c 0 and the
  /// @c didFinishLaunchingTimestamp to @c timeIntervalSinceReferenceDate.
  /// @note Default is @c NO.
  static bool getAppStartMeasurementHybridSDKMode() {
    return _objc_msgSend_91o635(
        _class_PrivateSentrySDKOnly, _sel_appStartMeasurementHybridSDKMode);
  }

  /// If enabled, the SDK won't send the app start measurement with the first transaction. Instead, if
  /// @c enableAutoPerformanceTracing is enabled, the SDK measures the app start and then calls
  /// @c onAppStartMeasurementAvailable. Furthermore, the SDK doesn't set all values for the app start
  /// measurement because the HybridSDKs initialize the Cocoa SDK too late to receive all
  /// notifications. Instead, the SDK sets the @c appStartDuration to @c 0 and the
  /// @c didFinishLaunchingTimestamp to @c timeIntervalSinceReferenceDate.
  /// @note Default is @c NO.
  static void setAppStartMeasurementHybridSDKMode(bool value) {
    _objc_msgSend_1s56lr9(_class_PrivateSentrySDKOnly,
        _sel_setAppStartMeasurementHybridSDKMode_, value);
  }

  /// appStartMeasurementWithSpans
  static objc.NSDictionary? appStartMeasurementWithSpans() {
    final _ret = _objc_msgSend_151sglz(
        _class_PrivateSentrySDKOnly, _sel_appStartMeasurementWithSpans);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// userWithDictionary:
  static SentryUser userWithDictionary(objc.NSDictionary dictionary) {
    final _ret = _objc_msgSend_1sotr3r(_class_PrivateSentrySDKOnly,
        _sel_userWithDictionary_, dictionary.ref.pointer);
    return SentryUser.castFromPointer(_ret, retain: true, release: true);
  }

  /// breadcrumbWithDictionary:
  static SentryBreadcrumb breadcrumbWithDictionary(
      objc.NSDictionary dictionary) {
    final _ret = _objc_msgSend_1sotr3r(_class_PrivateSentrySDKOnly,
        _sel_breadcrumbWithDictionary_, dictionary.ref.pointer);
    return SentryBreadcrumb.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  PrivateSentrySDKOnly init() {
    objc.checkOsVersionInternal('PrivateSentrySDKOnly.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return PrivateSentrySDKOnly.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static PrivateSentrySDKOnly new$() {
    final _ret = _objc_msgSend_151sglz(_class_PrivateSentrySDKOnly, _sel_new);
    return PrivateSentrySDKOnly.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static PrivateSentrySDKOnly allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_PrivateSentrySDKOnly, _sel_allocWithZone_, zone);
    return PrivateSentrySDKOnly.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static PrivateSentrySDKOnly alloc() {
    final _ret = _objc_msgSend_151sglz(_class_PrivateSentrySDKOnly, _sel_alloc);
    return PrivateSentrySDKOnly.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  PrivateSentrySDKOnly self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return PrivateSentrySDKOnly.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  PrivateSentrySDKOnly retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return PrivateSentrySDKOnly.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  PrivateSentrySDKOnly autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return PrivateSentrySDKOnly.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of PrivateSentrySDKOnly constructed with the default `new` method.
  factory PrivateSentrySDKOnly() => new$();
}

late final _class_SentryId$1 = objc.getClass("Sentry.SentryId");
late final _sel_empty = objc.registerName("empty");
late final _sel_sentryIdString = objc.registerName("sentryIdString");
late final _sel_initWithUuid_ = objc.registerName("initWithUuid:");
late final _sel_initWithUUIDString_ = objc.registerName("initWithUUIDString:");
late final _sel_isEqual_ = objc.registerName("isEqual:");
late final _sel_description = objc.registerName("description");
late final _sel_hash = objc.registerName("hash");
final _objc_msgSend_xw2lbc = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// SentryId
class SentryId$1 extends objc.NSObject {
  SentryId$1._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [SentryId$1] that points to the same underlying object as [other].
  SentryId$1.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryId$1] that wraps the given raw object pointer.
  SentryId$1.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [SentryId$1].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_SentryId$1);
  }

  /// A @c SentryId with an empty UUID “00000000000000000000000000000000”.
  static SentryId$1 getEmpty() {
    final _ret = _objc_msgSend_151sglz(_class_SentryId$1, _sel_empty);
    return SentryId$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a 32 lowercase character hexadecimal string description of the @c SentryId, such as
  /// “12c2d058d58442709aa2eca08bf20986”.
  objc.NSString get sentryIdString {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_sentryIdString);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  SentryId$1 init() {
    objc.checkOsVersionInternal('SentryId.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return SentryId$1.castFromPointer(_ret, retain: false, release: true);
  }

  /// Creates a SentryId with the given UUID.
  SentryId$1 initWithUuid(NSUUID uuid) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithUuid_, uuid.ref.pointer);
    return SentryId$1.castFromPointer(_ret, retain: false, release: true);
  }

  /// Creates a @c SentryId from a 32 character hexadecimal string without dashes such as
  /// “12c2d058d58442709aa2eca08bf20986” or a 36 character hexadecimal string such as such as
  /// “12c2d058-d584-4270-9aa2-eca08bf20986”.
  /// @return SentryId.empty for invalid strings.
  SentryId$1 initWithUUIDString(objc.NSString uuidString) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithUUIDString_, uuidString.ref.pointer);
    return SentryId$1.castFromPointer(_ret, retain: false, release: true);
  }

  /// isEqual:
  bool isEqual(objc.ObjCObjectBase? object) {
    return _objc_msgSend_19nvye5(
        this.ref.pointer, _sel_isEqual_, object?.ref.pointer ?? ffi.nullptr);
  }

  /// description
  objc.NSString get description {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_description);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// hash
  int get hash {
    return _objc_msgSend_xw2lbc(this.ref.pointer, _sel_hash);
  }

  /// new
  static SentryId$1 new$() {
    final _ret = _objc_msgSend_151sglz(_class_SentryId$1, _sel_new);
    return SentryId$1.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SentryId$1 allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_SentryId$1, _sel_allocWithZone_, zone);
    return SentryId$1.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static SentryId$1 alloc() {
    final _ret = _objc_msgSend_151sglz(_class_SentryId$1, _sel_alloc);
    return SentryId$1.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  SentryId$1 self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return SentryId$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  SentryId$1 retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return SentryId$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  SentryId$1 autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return SentryId$1.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of SentryId$1 constructed with the default `new` method.
  factory SentryId$1() => new$();
}

enum SentryLevel$1 {
  kSentryLevelNone(0),
  kSentryLevelDebug(1),
  kSentryLevelInfo(2),
  kSentryLevelWarning(3),
  kSentryLevelError(4),
  kSentryLevelFatal(5);

  final int value;
  const SentryLevel$1(this.value);

  static SentryLevel$1 fromValue(int value) => switch (value) {
        0 => kSentryLevelNone,
        1 => kSentryLevelDebug,
        2 => kSentryLevelInfo,
        3 => kSentryLevelWarning,
        4 => kSentryLevelError,
        5 => kSentryLevelFatal,
        _ => throw ArgumentError('Unknown value for SentryLevel\$1: $value'),
      };
}

late final _class_SentrySDK = objc.getClass("Sentry.SentrySDK");
late final _class_SentryScope = objc.getClass("SentryScope");

/// WARNING: SentrySerializable is a stub. To generate bindings for this class, include
/// SentrySerializable in your config's objc-protocols list.
///
/// SentrySerializable
interface class SentrySerializable extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  SentrySerializable._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [SentrySerializable] that points to the same underlying object as [other].
  SentrySerializable.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentrySerializable] that wraps the given raw object pointer.
  SentrySerializable.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_serialize = objc.registerName("serialize");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSDictionary_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSDictionary_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSDictionary_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSDictionary_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSDictionary_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSDictionary_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSDictionary_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_NSDictionary_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>
      fromFunction(objc.NSDictionary Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSDictionary_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSDictionary_ffiVoid_CallExtension
    on objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)> {
  objc.NSDictionary call(ffi.Pointer<ffi.Void> arg0) =>
      objc.NSDictionary.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
          retain: true,
          release: true);
}

/// SentryScope
class SentryScope extends objc.NSObject implements SentrySerializable {
  SentryScope._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [SentryScope] that points to the same underlying object as [other].
  SentryScope.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryScope] that wraps the given raw object pointer.
  SentryScope.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [SentryScope].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_SentryScope);
  }

  /// Serialize the contents of the object into an NSDictionary. Make to copy all properties of the
  /// original object so modifications to it don't have an impact on the serialized NSDictionary.
  objc.NSDictionary serialize() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_serialize);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }
}

void _ObjCBlock_ffiVoid_SentryScope_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_SentryScope_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_SentryScope_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_SentryScope_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_SentryScope_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_SentryScope_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_SentryScope_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_SentryScope_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_SentryScope_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_SentryScope_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_SentryScope_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_SentryScope_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_SentryScope_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_SentryScope_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(SentryScope)>`.
abstract final class ObjCBlock_ffiVoid_SentryScope {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(SentryScope)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(SentryScope)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(SentryScope)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(SentryScope)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_SentryScope_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(SentryScope)> fromFunction(
          void Function(SentryScope) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(SentryScope)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_SentryScope_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0) => fn(
                  SentryScope.castFromPointer(arg0,
                      retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(SentryScope)> listener(
      void Function(SentryScope) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_SentryScope_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) =>
            fn(SentryScope.castFromPointer(arg0, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _SentryCocoa_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(SentryScope)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(SentryScope)> blocking(
      void Function(SentryScope) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_SentryScope_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) =>
            fn(SentryScope.castFromPointer(arg0, retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_SentryScope_blockingListenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) =>
            fn(SentryScope.castFromPointer(arg0, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _SentryCocoa_wrapBlockingBlock_xtuoz7(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(SentryScope)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(SentryScope)>`.
extension ObjCBlock_ffiVoid_SentryScope_CallExtension
    on objc.ObjCBlock<ffi.Void Function(SentryScope)> {
  void call(SentryScope arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<objc.ObjCObject> arg0)>>()
      .asFunction<
          void Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0.ref.pointer);
}

late final _sel_configureScope_ = objc.registerName("configureScope:");

/// The main entry point for the Sentry SDK.
/// We recommend using <code>start(configureOptions:)</code> to initialize Sentry.
class SentrySDK extends objc.NSObject {
  SentrySDK._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [SentrySDK] that points to the same underlying object as [other].
  SentrySDK.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentrySDK] that wraps the given raw object pointer.
  SentrySDK.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [SentrySDK].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_SentrySDK);
  }

  /// Use this method to modify the current <code>Scope</code> of the current <code>Hub</code>. The SDK uses the <code>Scope</code> to attach
  /// contextual data to events.
  /// \param callback The callback for configuring the current <code>Scope</code> of the current <code>Hub</code>.
  static void configureScope(
      objc.ObjCBlock<ffi.Void Function(SentryScope)> callback) {
    _objc_msgSend_f167m6(
        _class_SentrySDK, _sel_configureScope_, callback.ref.pointer);
  }
}

late final _class_SentryDebugMeta = objc.getClass("SentryDebugMeta");
late final _sel_uuid = objc.registerName("uuid");
late final _sel_setUuid_ = objc.registerName("setUuid:");
late final _sel_debugID = objc.registerName("debugID");
late final _sel_setDebugID_ = objc.registerName("setDebugID:");
late final _sel_type = objc.registerName("type");
late final _sel_setType_ = objc.registerName("setType:");
late final _sel_name = objc.registerName("name");
late final _sel_setName_ = objc.registerName("setName:");
late final _sel_imageSize = objc.registerName("imageSize");
late final _sel_setImageSize_ = objc.registerName("setImageSize:");
late final _sel_imageAddress = objc.registerName("imageAddress");
late final _sel_setImageAddress_ = objc.registerName("setImageAddress:");
late final _sel_imageVmAddress = objc.registerName("imageVmAddress");
late final _sel_setImageVmAddress_ = objc.registerName("setImageVmAddress:");
late final _sel_codeFile = objc.registerName("codeFile");
late final _sel_setCodeFile_ = objc.registerName("setCodeFile:");
instancetype _ObjCBlock_instancetype_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                instancetype Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<instancetype Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_instancetype_ffiVoid_fnPtrTrampoline)
        .cast();
instancetype _ObjCBlock_instancetype_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as instancetype Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_instancetype_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_instancetype_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(
              ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(
                      ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<
                  objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(
                      ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(
                  _ObjCBlock_instancetype_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(ffi.Pointer<ffi.Void>)>
      fromFunction(Dartinstancetype Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<
                  objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(
                      ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_instancetype_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndReturnPointer(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_instancetype_ffiVoid_CallExtension on objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(
        ffi.Pointer<ffi.Void>)> {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0) => objc.ObjCObjectBase(
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
      retain: false,
      release: true);
}

/// Contains information about a loaded library in the process and the memory address.
/// @discussion Since 8.2.0, the SDK changed the debug image type from "apple" to "macho". For macho,
/// the SDK now sends @c debugID instead of @c uuid , and @c codeFile instead of @c name . For more
/// information check https://develop.sentry.dev/sdk/event-payloads/debugmeta/#mach-o-images.
/// @todo This class is actually a DebugImage:
/// https://develop.sentry.dev/sdk/event-payloads/debugmeta/#debug-images and should be renamed to
/// @c SentryDebugImage in a future version.
class SentryDebugMeta extends objc.NSObject implements SentrySerializable {
  SentryDebugMeta._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [SentryDebugMeta] that points to the same underlying object as [other].
  SentryDebugMeta.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryDebugMeta] that wraps the given raw object pointer.
  SentryDebugMeta.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [SentryDebugMeta].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_SentryDebugMeta);
  }

  /// The UUID of the image. Use @c debugID when using "macho" as the @c type .
  objc.NSString? get uuid {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_uuid);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The UUID of the image. Use @c debugID when using "macho" as the @c type .
  set uuid(objc.NSString? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setUuid_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Identifier of the dynamic library or executable. It is the value of the @c LC_UUID load command
  /// in the Mach header, formatted as UUID.
  objc.NSString? get debugID {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_debugID);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Identifier of the dynamic library or executable. It is the value of the @c LC_UUID load command
  /// in the Mach header, formatted as UUID.
  set debugID(objc.NSString? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setDebugID_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Type of debug meta. We highly recommend using "macho"; was "apple" previously.
  objc.NSString? get type {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_type);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Type of debug meta. We highly recommend using "macho"; was "apple" previously.
  set type(objc.NSString? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setType_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Name of the image. Use @c codeFile when using "macho" as the @c type .
  objc.NSString? get name {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_name);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Name of the image. Use @c codeFile when using "macho" as the @c type .
  set name(objc.NSString? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setName_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// The size of the image in virtual memory. If missing, Sentry will assume that the image spans up
  /// to the next image, which might lead to invalid stack traces.
  objc.NSNumber? get imageSize {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_imageSize);
    return _ret.address == 0
        ? null
        : objc.NSNumber.castFromPointer(_ret, retain: true, release: true);
  }

  /// The size of the image in virtual memory. If missing, Sentry will assume that the image spans up
  /// to the next image, which might lead to invalid stack traces.
  set imageSize(objc.NSNumber? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setImageSize_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// Memory address, at which the image is mounted in the virtual address space of the process. Should
  /// be a string in hex representation prefixed with "0x".
  objc.NSString? get imageAddress {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_imageAddress);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Memory address, at which the image is mounted in the virtual address space of the process. Should
  /// be a string in hex representation prefixed with "0x".
  set imageAddress(objc.NSString? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setImageAddress_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// Preferred load address of the image in virtual memory, as declared in the headers of the image.
  /// When loading an image, the operating system may still choose to place it at a different address.
  objc.NSString? get imageVmAddress {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_imageVmAddress);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Preferred load address of the image in virtual memory, as declared in the headers of the image.
  /// When loading an image, the operating system may still choose to place it at a different address.
  set imageVmAddress(objc.NSString? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setImageVmAddress_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  ///
  objc.NSString? get codeFile {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_codeFile);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  ///
  set codeFile(objc.NSString? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setCodeFile_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// init
  SentryDebugMeta init() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return SentryDebugMeta.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static SentryDebugMeta new$() {
    final _ret = _objc_msgSend_151sglz(_class_SentryDebugMeta, _sel_new);
    return SentryDebugMeta.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SentryDebugMeta allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_SentryDebugMeta, _sel_allocWithZone_, zone);
    return SentryDebugMeta.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static SentryDebugMeta alloc() {
    final _ret = _objc_msgSend_151sglz(_class_SentryDebugMeta, _sel_alloc);
    return SentryDebugMeta.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  SentryDebugMeta self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return SentryDebugMeta.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  SentryDebugMeta retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return SentryDebugMeta.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  SentryDebugMeta autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return SentryDebugMeta.castFromPointer(_ret, retain: true, release: true);
  }

  /// Serialize the contents of the object into an NSDictionary. Make to copy all properties of the
  /// original object so modifications to it don't have an impact on the serialized NSDictionary.
  objc.NSDictionary serialize() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_serialize);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of SentryDebugMeta constructed with the default `new` method.
  factory SentryDebugMeta() => new$();
}

late final _class_SentryDependencyContainer =
    objc.getClass("SentryDependencyContainer");
late final _sel_sharedInstance = objc.registerName("sharedInstance");
late final _class_SentryBinaryImageCache =
    objc.getClass("SentryBinaryImageCache");
late final _class_SentryBinaryImageInfo =
    objc.getClass("SentryBinaryImageInfo");
late final _sel_UUID = objc.registerName("UUID");
late final _sel_setUUID_ = objc.registerName("setUUID:");
late final _sel_vmAddress = objc.registerName("vmAddress");
final _objc_msgSend_9qbz9w = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Uint64 Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setVmAddress_ = objc.registerName("setVmAddress:");
final _objc_msgSend_1xsl7ae = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Uint64)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_address = objc.registerName("address");
late final _sel_setAddress_ = objc.registerName("setAddress:");
late final _sel_size = objc.registerName("size");
late final _sel_setSize_ = objc.registerName("setSize:");

/// SentryBinaryImageInfo
class SentryBinaryImageInfo extends objc.NSObject {
  SentryBinaryImageInfo._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [SentryBinaryImageInfo] that points to the same underlying object as [other].
  SentryBinaryImageInfo.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryBinaryImageInfo] that wraps the given raw object pointer.
  SentryBinaryImageInfo.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [SentryBinaryImageInfo].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_SentryBinaryImageInfo);
  }

  /// name
  objc.NSString get name {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_name);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setName:
  set name(objc.NSString value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setName_, value.ref.pointer);
  }

  /// UUID
  objc.NSString get UUID {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_UUID);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setUUID:
  set UUID(objc.NSString value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setUUID_, value.ref.pointer);
  }

  /// vmAddress
  int get vmAddress {
    return _objc_msgSend_9qbz9w(this.ref.pointer, _sel_vmAddress);
  }

  /// setVmAddress:
  set vmAddress(int value) {
    _objc_msgSend_1xsl7ae(this.ref.pointer, _sel_setVmAddress_, value);
  }

  /// address
  int get address {
    return _objc_msgSend_9qbz9w(this.ref.pointer, _sel_address);
  }

  /// setAddress:
  set address(int value) {
    _objc_msgSend_1xsl7ae(this.ref.pointer, _sel_setAddress_, value);
  }

  /// size
  int get size {
    return _objc_msgSend_9qbz9w(this.ref.pointer, _sel_size);
  }

  /// setSize:
  set size(int value) {
    _objc_msgSend_1xsl7ae(this.ref.pointer, _sel_setSize_, value);
  }

  /// init
  SentryBinaryImageInfo init() {
    objc.checkOsVersionInternal('SentryBinaryImageInfo.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return SentryBinaryImageInfo.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static SentryBinaryImageInfo new$() {
    final _ret = _objc_msgSend_151sglz(_class_SentryBinaryImageInfo, _sel_new);
    return SentryBinaryImageInfo.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static SentryBinaryImageInfo allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_SentryBinaryImageInfo, _sel_allocWithZone_, zone);
    return SentryBinaryImageInfo.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static SentryBinaryImageInfo alloc() {
    final _ret =
        _objc_msgSend_151sglz(_class_SentryBinaryImageInfo, _sel_alloc);
    return SentryBinaryImageInfo.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  SentryBinaryImageInfo self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return SentryBinaryImageInfo.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  SentryBinaryImageInfo retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return SentryBinaryImageInfo.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  SentryBinaryImageInfo autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return SentryBinaryImageInfo.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of SentryBinaryImageInfo constructed with the default `new` method.
  factory SentryBinaryImageInfo() => new$();
}

late final _sel_imageByAddress_ = objc.registerName("imageByAddress:");
final _objc_msgSend_10euuey = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Uint64)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();

/// SentryBinaryImageCache
class SentryBinaryImageCache extends objc.NSObject {
  SentryBinaryImageCache._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [SentryBinaryImageCache] that points to the same underlying object as [other].
  SentryBinaryImageCache.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryBinaryImageCache] that wraps the given raw object pointer.
  SentryBinaryImageCache.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [SentryBinaryImageCache].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_SentryBinaryImageCache);
  }

  /// imageByAddress:
  SentryBinaryImageInfo? imageByAddress(int address) {
    final _ret =
        _objc_msgSend_10euuey(this.ref.pointer, _sel_imageByAddress_, address);
    return _ret.address == 0
        ? null
        : SentryBinaryImageInfo.castFromPointer(_ret,
            retain: true, release: true);
  }
}

late final _sel_binaryImageCache = objc.registerName("binaryImageCache");
late final _class_SentryDebugImageProvider =
    objc.getClass("SentryDebugImageProvider");

///
extension unnamed on SentryDebugImageProvider {}

late final _sel_getDebugImagesForImageAddressesFromCache_ =
    objc.registerName("getDebugImagesForImageAddressesFromCache:");

/// SentryDebugImageProvider
class SentryDebugImageProvider extends objc.NSObject {
  SentryDebugImageProvider._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [SentryDebugImageProvider] that points to the same underlying object as [other].
  SentryDebugImageProvider.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryDebugImageProvider] that wraps the given raw object pointer.
  SentryDebugImageProvider.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [SentryDebugImageProvider].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_SentryDebugImageProvider);
  }

  /// Returns a list of debug images that are being referenced in the given image addresses.
  /// This function uses the @c SentryBinaryImageCache which is significantly faster than @c
  /// SentryCrashDefaultBinaryImageProvider for retrieving binary image information.
  objc.NSArray getDebugImagesForImageAddressesFromCache(
      objc.NSSet imageAddresses) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer,
        _sel_getDebugImagesForImageAddressesFromCache_,
        imageAddresses.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_debugImageProvider = objc.registerName("debugImageProvider");

/// The dependency container is optimized to use as few locks as possible and to only keep the
/// required dependencies in memory. It splits its dependencies into two groups.
///
/// Init Dependencies: These are mandatory dependencies required to run the SDK, no matter the
/// options. The dependency container initializes them in init and uses no locks for efficiency.
///
/// Lazy Dependencies: These dependencies either have some state or aren't always required and,
/// therefore, get initialized lazily to minimize the memory footprint.
class SentryDependencyContainer extends objc.NSObject {
  SentryDependencyContainer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [SentryDependencyContainer] that points to the same underlying object as [other].
  SentryDependencyContainer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [SentryDependencyContainer] that wraps the given raw object pointer.
  SentryDependencyContainer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [SentryDependencyContainer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_SentryDependencyContainer);
  }

  /// sharedInstance
  static SentryDependencyContainer sharedInstance() {
    final _ret = _objc_msgSend_151sglz(
        _class_SentryDependencyContainer, _sel_sharedInstance);
    return SentryDependencyContainer.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// binaryImageCache
  SentryBinaryImageCache get binaryImageCache {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_binaryImageCache);
    return SentryBinaryImageCache.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// debugImageProvider
  SentryDebugImageProvider get debugImageProvider {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_debugImageProvider);
    return SentryDebugImageProvider.castFromPointer(_ret,
        retain: true, release: true);
  }
}
