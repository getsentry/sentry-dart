// ignore_for_file: type=lint, unused_element

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: unused_import
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;
import 'package:ffi/ffi.dart' as pkg_ffi;

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _SentryCocoa_wrapListenerBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _SentryCocoa_wrapBlockingBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

/// WARNING: NSUUID is a stub. To generate bindings for this class, include
/// NSUUID in your config's objc-interfaces list.
///
/// NSUUID
extension type NSUUID._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSCopying,
        objc.NSSecureCoding {
  /// Constructs a [NSUUID] that points to the same underlying object as [other].
  NSUUID.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSUUID',
        iOS: (false, (6, 0, 0)), macOS: (false, (10, 8, 0)));
  }

  /// Constructs a [NSUUID] that wraps the given raw object pointer.
  NSUUID.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false})
      : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSUUID',
        iOS: (false, (6, 0, 0)), macOS: (false, (10, 8, 0)));
  }
}

/// WARNING: SentryAppStartMeasurement is a stub. To generate bindings for this class, include
/// SentryAppStartMeasurement in your config's objc-interfaces list.
///
/// SentryAppStartMeasurement
extension type SentryAppStartMeasurement._(objc.ObjCObject object$)
    implements objc.ObjCObject {
  /// Constructs a [SentryAppStartMeasurement] that points to the same underlying object as [other].
  SentryAppStartMeasurement.as(objc.ObjCObject other) : object$ = other {}

  /// Constructs a [SentryAppStartMeasurement] that wraps the given raw object pointer.
  SentryAppStartMeasurement.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false})
      : object$ = objc.ObjCObject(other, retain: retain, release: release) {}
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>`.
abstract final class ObjCBlock_ffiVoid_SentryAppStartMeasurement {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>
      fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(
                              ffi.Pointer<objc.ObjCObjectImpl> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>(
              objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>
      fromFunction(void Function(SentryAppStartMeasurement?) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>(
              objc.newClosureBlock(
                  _closureCallable,
                  (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(arg0.address == 0
                      ? null
                      : SentryAppStartMeasurement.fromPointer(arg0,
                          retain: true, release: true)),
                  keepIsolateAlive),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)> listener(
      void Function(SentryAppStartMeasurement?) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(arg0.address == 0
            ? null
            : SentryAppStartMeasurement.fromPointer(arg0,
                retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _SentryCocoa_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)> blocking(
      void Function(SentryAppStartMeasurement?) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(arg0.address == 0
            ? null
            : SentryAppStartMeasurement.fromPointer(arg0,
                retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _blockingListenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(arg0.address == 0
            ? null
            : SentryAppStartMeasurement.fromPointer(arg0,
                retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _SentryCocoa_wrapBlockingBlock_xtuoz7(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>(
        wrapper,
        retain: false,
        release: true);
  }

  static void _listenerTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block,
      ffi.Pointer<objc.ObjCObjectImpl> arg0) {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>)>
      _listenerCallable = ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>)>.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block,
      ffi.Pointer<ffi.Void> waiter, ffi.Pointer<objc.ObjCObjectImpl> arg0) {
    try {
      (objc.getBlockClosure(block) as void Function(
          ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)>
      _blockingCallable = ffi.NativeCallable<
              ffi.Void Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>)>.isolateLocal(
          _blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)>
      _blockingListenerCallable = ffi.NativeCallable<
          ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>)>.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block,
          ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
      block.ref.target
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)>>()
          .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable = ffi.Pointer.fromFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>)>(_fnPtrTrampoline)
      .cast();
  static void _closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block,
          ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
      (objc.getBlockClosure(block) as void Function(
          ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable = ffi.Pointer.fromFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>)>(_closureTrampoline)
      .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>`.
extension ObjCBlock_ffiVoid_SentryAppStartMeasurement$CallExtension
    on objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)> {
  void call(SentryAppStartMeasurement? arg0) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<objc.ObjCObjectImpl> arg0)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>)>()(
      ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _class_PrivateSentrySDKOnly = objc.getClass("PrivateSentrySDKOnly");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObjectImpl>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObjectImpl>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObjectImpl>)>();

/// WARNING: SentryEnvelope is a stub. To generate bindings for this class, include
/// SentryEnvelope in your config's objc-interfaces list.
///
/// SentryEnvelope
extension type SentryEnvelope._(objc.ObjCObject object$)
    implements objc.ObjCObject {
  /// Constructs a [SentryEnvelope] that points to the same underlying object as [other].
  SentryEnvelope.as(objc.ObjCObject other) : object$ = other {}

  /// Constructs a [SentryEnvelope] that wraps the given raw object pointer.
  SentryEnvelope.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false})
      : object$ = objc.ObjCObject(other, retain: retain, release: release) {}
}

late final _sel_storeEnvelope_ = objc.registerName("storeEnvelope:");
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObjectImpl>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObjectImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObjectImpl>)>();
late final _sel_captureEnvelope_ = objc.registerName("captureEnvelope:");
late final _sel_envelopeWithData_ = objc.registerName("envelopeWithData:");
final _objc_msgSend_1sotr3r = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
                ffi.Pointer<objc.ObjCObjectImpl>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObjectImpl>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObjectImpl>)>();
late final _sel_getDebugImages = objc.registerName("getDebugImages");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
                ffi.Pointer<objc.ObjCObjectImpl>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_getDebugImagesCrashed_ =
    objc.registerName("getDebugImagesCrashed:");
final _objc_msgSend_1t6aok9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
                ffi.Pointer<objc.ObjCObjectImpl>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Bool)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCSelector>,
            bool)>();
late final _sel_setSdkName_andVersionString_ =
    objc.registerName("setSdkName:andVersionString:");
final _objc_msgSend_pfv6jd = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObjectImpl>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObjectImpl>,
                ffi.Pointer<objc.ObjCObjectImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>)>();
late final _sel_setSdkName_ = objc.registerName("setSdkName:");
late final _sel_getSdkName = objc.registerName("getSdkName");
late final _sel_getSdkVersionString = objc.registerName("getSdkVersionString");
late final _sel_addSdkPackage_version_ =
    objc.registerName("addSdkPackage:version:");
late final _sel_getExtraContext = objc.registerName("getExtraContext");
late final _class_SentryId = objc.getClass("Sentry.SentryId");

/// SentryId
extension type SentryId._(objc.ObjCObject object$) implements objc.ObjCObject {
  /// Constructs a [SentryId] that points to the same underlying object as [other].
  SentryId.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [SentryId] that wraps the given raw object pointer.
  SentryId.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false})
      : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SentryId].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
      obj.ref.pointer, _sel_isKindOfClass_, _class_SentryId);
}

extension SentryId$Methods on SentryId {}

/// WARNING: SentrySpanId is a stub. To generate bindings for this class, include
/// SentrySpanId in your config's objc-interfaces list.
///
/// SentrySpanId
extension type SentrySpanId._(objc.ObjCObject object$)
    implements objc.ObjCObject {
  /// Constructs a [SentrySpanId] that points to the same underlying object as [other].
  SentrySpanId.as(objc.ObjCObject other) : object$ = other {}

  /// Constructs a [SentrySpanId] that wraps the given raw object pointer.
  SentrySpanId.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false})
      : object$ = objc.ObjCObject(other, retain: retain, release: release) {}
}

late final _sel_setTrace_spanId_ = objc.registerName("setTrace:spanId:");
late final _sel_startProfilerForTrace_ =
    objc.registerName("startProfilerForTrace:");
final _objc_msgSend_1om1bna = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Uint64 Function(
                ffi.Pointer<objc.ObjCObjectImpl>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObjectImpl>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObjectImpl>)>();
late final _sel_collectProfileBetween_and_forTrace_ =
    objc.registerName("collectProfileBetween:and:forTrace:");
final _objc_msgSend_l3zifn = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
                ffi.Pointer<objc.ObjCObjectImpl>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Uint64,
                ffi.Uint64,
                ffi.Pointer<objc.ObjCObjectImpl>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            int,
            ffi.Pointer<objc.ObjCObjectImpl>)>();
late final _sel_discardProfilerForTrace_ =
    objc.registerName("discardProfilerForTrace:");
late final _sel_onAppStartMeasurementAvailable =
    objc.registerName("onAppStartMeasurementAvailable");
final _objc_msgSend_uwvaik = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCBlockImpl> Function(
                ffi.Pointer<objc.ObjCObjectImpl>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setOnAppStartMeasurementAvailable_ =
    objc.registerName("setOnAppStartMeasurementAvailable:");
final _objc_msgSend_f167m6 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObjectImpl>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_appStartMeasurement = objc.registerName("appStartMeasurement");
late final _sel_installationID = objc.registerName("installationID");

/// WARNING: SentryOptions is a stub. To generate bindings for this class, include
/// SentryOptions in your config's objc-interfaces list.
///
/// SentryOptions
extension type SentryOptions._(objc.ObjCObject object$)
    implements objc.ObjCObject {
  /// Constructs a [SentryOptions] that points to the same underlying object as [other].
  SentryOptions.as(objc.ObjCObject other) : object$ = other {}

  /// Constructs a [SentryOptions] that wraps the given raw object pointer.
  SentryOptions.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false})
      : object$ = objc.ObjCObject(other, retain: retain, release: release) {}
}

late final _sel_options = objc.registerName("options");
late final _sel_appStartMeasurementHybridSDKMode =
    objc.registerName("appStartMeasurementHybridSDKMode");
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setAppStartMeasurementHybridSDKMode_ =
    objc.registerName("setAppStartMeasurementHybridSDKMode:");
final _objc_msgSend_1s56lr9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCSelector>, bool)>();
late final _sel_appStartMeasurementWithSpans =
    objc.registerName("appStartMeasurementWithSpans");

/// WARNING: SentryUser is a stub. To generate bindings for this class, include
/// SentryUser in your config's objc-interfaces list.
///
/// SentryUser
extension type SentryUser._(objc.ObjCObject object$)
    implements objc.ObjCObject {
  /// Constructs a [SentryUser] that points to the same underlying object as [other].
  SentryUser.as(objc.ObjCObject other) : object$ = other {}

  /// Constructs a [SentryUser] that wraps the given raw object pointer.
  SentryUser.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false})
      : object$ = objc.ObjCObject(other, retain: retain, release: release) {}
}

late final _sel_userWithDictionary_ = objc.registerName("userWithDictionary:");

/// WARNING: SentryBreadcrumb is a stub. To generate bindings for this class, include
/// SentryBreadcrumb in your config's objc-interfaces list.
///
/// SentryBreadcrumb
extension type SentryBreadcrumb._(objc.ObjCObject object$)
    implements objc.ObjCObject {
  /// Constructs a [SentryBreadcrumb] that points to the same underlying object as [other].
  SentryBreadcrumb.as(objc.ObjCObject other) : object$ = other {}

  /// Constructs a [SentryBreadcrumb] that wraps the given raw object pointer.
  SentryBreadcrumb.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false})
      : object$ = objc.ObjCObject(other, retain: retain, release: release) {}
}

late final _sel_breadcrumbWithDictionary_ =
    objc.registerName("breadcrumbWithDictionary:");
typedef instancetype = ffi.Pointer<objc.ObjCObjectImpl>;
typedef Dartinstancetype = objc.ObjCObject;
late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
                ffi.Pointer<objc.ObjCObjectImpl>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.NSZone>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.NSZone>)>();
late final _sel_alloc = objc.registerName("alloc");

/// @warning This class is reserved for hybrid SDKs. Methods may be changed, renamed or removed
/// without notice. If you want to use one of these methods here please open up an issue and let us
/// know.
/// @note The name of this class is supposed to be a bit weird and ugly. The name starts with private
/// on purpose so users don't see it in code completion when typing Sentry. We also add only at the
/// end to make it more obvious you shouldn't use it.
extension type PrivateSentrySDKOnly._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [PrivateSentrySDKOnly] that points to the same underlying object as [other].
  PrivateSentrySDKOnly.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [PrivateSentrySDKOnly] that wraps the given raw object pointer.
  PrivateSentrySDKOnly.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false})
      : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [PrivateSentrySDKOnly].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
      obj.ref.pointer, _sel_isKindOfClass_, _class_PrivateSentrySDKOnly);

  /// Add a package to the SDK packages
  static void addSdkPackage(objc.NSString name,
      {required objc.NSString version}) {
    _objc_msgSend_pfv6jd(_class_PrivateSentrySDKOnly,
        _sel_addSdkPackage_version_, name.ref.pointer, version.ref.pointer);
  }

  /// alloc
  static PrivateSentrySDKOnly alloc() {
    final $ret = _objc_msgSend_151sglz(_class_PrivateSentrySDKOnly, _sel_alloc);
    return PrivateSentrySDKOnly.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static PrivateSentrySDKOnly allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
        _class_PrivateSentrySDKOnly, _sel_allocWithZone_, zone);
    return PrivateSentrySDKOnly.fromPointer($ret, retain: false, release: true);
  }

  /// appStartMeasurement
  static SentryAppStartMeasurement? getAppStartMeasurement() {
    final $ret = _objc_msgSend_151sglz(
        _class_PrivateSentrySDKOnly, _sel_appStartMeasurement);
    return $ret.address == 0
        ? null
        : SentryAppStartMeasurement.fromPointer($ret,
            retain: true, release: true);
  }

  /// If enabled, the SDK won't send the app start measurement with the first transaction. Instead, if
  /// @c enableAutoPerformanceTracing is enabled, the SDK measures the app start and then calls
  /// @c onAppStartMeasurementAvailable. Furthermore, the SDK doesn't set all values for the app start
  /// measurement because the HybridSDKs initialize the Cocoa SDK too late to receive all
  /// notifications. Instead, the SDK sets the @c appStartDuration to @c 0 and the
  /// @c didFinishLaunchingTimestamp to @c timeIntervalSinceReferenceDate.
  /// @note Default is @c NO.
  static bool getAppStartMeasurementHybridSDKMode() {
    return _objc_msgSend_91o635(
        _class_PrivateSentrySDKOnly, _sel_appStartMeasurementHybridSDKMode);
  }

  /// appStartMeasurementWithSpans
  static objc.NSDictionary? appStartMeasurementWithSpans() {
    final $ret = _objc_msgSend_151sglz(
        _class_PrivateSentrySDKOnly, _sel_appStartMeasurementWithSpans);
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// breadcrumbWithDictionary:
  static SentryBreadcrumb breadcrumbWithDictionary(
      objc.NSDictionary dictionary) {
    final $ret = _objc_msgSend_1sotr3r(_class_PrivateSentrySDKOnly,
        _sel_breadcrumbWithDictionary_, dictionary.ref.pointer);
    return SentryBreadcrumb.fromPointer($ret, retain: true, release: true);
  }

  /// captureEnvelope:
  static void captureEnvelope(SentryEnvelope envelope) {
    _objc_msgSend_xtuoz7(_class_PrivateSentrySDKOnly, _sel_captureEnvelope_,
        envelope.ref.pointer);
  }

  /// Collect a profiler session data associated with the given @c SentryId.
  /// This also discards the profiler.
  static objc.NSMutableDictionary? collectProfileBetween(int startSystemTime,
      {required int and, required SentryId forTrace}) {
    final $ret = _objc_msgSend_l3zifn(
        _class_PrivateSentrySDKOnly,
        _sel_collectProfileBetween_and_forTrace_,
        startSystemTime,
        and,
        forTrace.ref.pointer);
    return $ret.address == 0
        ? null
        : objc.NSMutableDictionary.fromPointer($ret,
            retain: true, release: true);
  }

  /// Discard profiler session data associated with the given @c SentryId.
  /// This only needs to be called in case you haven't collected the profile (and don't intend to).
  static void discardProfilerForTrace(SentryId traceId) {
    _objc_msgSend_xtuoz7(_class_PrivateSentrySDKOnly,
        _sel_discardProfilerForTrace_, traceId.ref.pointer);
  }

  /// Create an envelope from @c NSData. Needed for example by Flutter.
  static SentryEnvelope? envelopeWithData(objc.NSData data) {
    final $ret = _objc_msgSend_1sotr3r(
        _class_PrivateSentrySDKOnly, _sel_envelopeWithData_, data.ref.pointer);
    return $ret.address == 0
        ? null
        : SentryEnvelope.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the current list of debug images. Be aware that the @c SentryDebugMeta is actually
  /// describing a debug image.
  /// @warning This assumes a crash has occurred and attempts to read the crash information from each
  /// image's data segment, which may not be present or be invalid if a crash has not actually
  /// occurred. To avoid this, use the new @c +[getDebugImagesCrashed:] instead.
  static objc.NSArray getDebugImages() {
    final $ret =
        _objc_msgSend_151sglz(_class_PrivateSentrySDKOnly, _sel_getDebugImages);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the current list of debug images. Be aware that the @c SentryDebugMeta is actually
  /// describing a debug image.
  /// @param isCrash @c YES if we're collecting binary images for a crash report, @c NO if we're
  /// gathering them for other backtrace information, like a performance transaction. If this is for a
  /// crash, each image's data section crash info is also included.
  static objc.NSArray getDebugImagesCrashed(bool isCrash) {
    final $ret = _objc_msgSend_1t6aok9(
        _class_PrivateSentrySDKOnly, _sel_getDebugImagesCrashed_, isCrash);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// Retrieves extra context
  static objc.NSDictionary getExtraContext() {
    final $ret = _objc_msgSend_151sglz(
        _class_PrivateSentrySDKOnly, _sel_getExtraContext);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// Retrieves the SDK name
  static objc.NSString getSdkName() {
    final $ret =
        _objc_msgSend_151sglz(_class_PrivateSentrySDKOnly, _sel_getSdkName);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// Retrieves the SDK version string
  static objc.NSString getSdkVersionString() {
    final $ret = _objc_msgSend_151sglz(
        _class_PrivateSentrySDKOnly, _sel_getSdkVersionString);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// installationID
  static objc.NSString getInstallationID() {
    final $ret =
        _objc_msgSend_151sglz(_class_PrivateSentrySDKOnly, _sel_installationID);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// new
  static PrivateSentrySDKOnly new$() {
    final $ret = _objc_msgSend_151sglz(_class_PrivateSentrySDKOnly, _sel_new);
    return PrivateSentrySDKOnly.fromPointer($ret, retain: false, release: true);
  }

  /// onAppStartMeasurementAvailable
  static objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>?
      getOnAppStartMeasurementAvailable() {
    final $ret = _objc_msgSend_uwvaik(
        _class_PrivateSentrySDKOnly, _sel_onAppStartMeasurementAvailable);
    return $ret.address == 0
        ? null
        : ObjCBlock_ffiVoid_SentryAppStartMeasurement.fromPointer($ret,
            retain: true, release: true);
  }

  /// options
  static SentryOptions getOptions() {
    final $ret =
        _objc_msgSend_151sglz(_class_PrivateSentrySDKOnly, _sel_options);
    return SentryOptions.fromPointer($ret, retain: true, release: true);
  }

  /// If enabled, the SDK won't send the app start measurement with the first transaction. Instead, if
  /// @c enableAutoPerformanceTracing is enabled, the SDK measures the app start and then calls
  /// @c onAppStartMeasurementAvailable. Furthermore, the SDK doesn't set all values for the app start
  /// measurement because the HybridSDKs initialize the Cocoa SDK too late to receive all
  /// notifications. Instead, the SDK sets the @c appStartDuration to @c 0 and the
  /// @c didFinishLaunchingTimestamp to @c timeIntervalSinceReferenceDate.
  /// @note Default is @c NO.
  static void setAppStartMeasurementHybridSDKMode(bool value) {
    _objc_msgSend_1s56lr9(_class_PrivateSentrySDKOnly,
        _sel_setAppStartMeasurementHybridSDKMode_, value);
  }

  /// setOnAppStartMeasurementAvailable:
  static void setOnAppStartMeasurementAvailable(
      objc.ObjCBlock<ffi.Void Function(SentryAppStartMeasurement?)>? value) {
    _objc_msgSend_f167m6(
        _class_PrivateSentrySDKOnly,
        _sel_setOnAppStartMeasurementAvailable_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// Override SDK information.
  static void setSdkName(objc.NSString sdkName) {
    _objc_msgSend_xtuoz7(
        _class_PrivateSentrySDKOnly, _sel_setSdkName_, sdkName.ref.pointer);
  }

  /// Override SDK information.
  static void setSdkName$1(objc.NSString sdkName,
      {required objc.NSString andVersionString}) {
    _objc_msgSend_pfv6jd(
        _class_PrivateSentrySDKOnly,
        _sel_setSdkName_andVersionString_,
        sdkName.ref.pointer,
        andVersionString.ref.pointer);
  }

  /// Allows Hybrids SDKs to thread-safe set the current trace.
  static void setTrace(SentryId traceId, {required SentrySpanId spanId}) {
    _objc_msgSend_pfv6jd(_class_PrivateSentrySDKOnly, _sel_setTrace_spanId_,
        traceId.ref.pointer, spanId.ref.pointer);
  }

  /// Start a profiler session associated with the given @c SentryId.
  /// @return The system time when the profiler session started.
  static int startProfilerForTrace(SentryId traceId) {
    return _objc_msgSend_1om1bna(_class_PrivateSentrySDKOnly,
        _sel_startProfilerForTrace_, traceId.ref.pointer);
  }

  /// For storing an envelope synchronously to disk.
  static void storeEnvelope(SentryEnvelope envelope) {
    _objc_msgSend_xtuoz7(
        _class_PrivateSentrySDKOnly, _sel_storeEnvelope_, envelope.ref.pointer);
  }

  /// userWithDictionary:
  static SentryUser userWithDictionary(objc.NSDictionary dictionary) {
    final $ret = _objc_msgSend_1sotr3r(_class_PrivateSentrySDKOnly,
        _sel_userWithDictionary_, dictionary.ref.pointer);
    return SentryUser.fromPointer($ret, retain: true, release: true);
  }

  /// Returns a new instance of PrivateSentrySDKOnly constructed with the default `new` method.
  PrivateSentrySDKOnly() : this.as(new$().object$);
}

extension PrivateSentrySDKOnly$Methods on PrivateSentrySDKOnly {
  /// init
  PrivateSentrySDKOnly init() {
    objc.checkOsVersionInternal('PrivateSentrySDKOnly.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret =
        _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return PrivateSentrySDKOnly.fromPointer($ret, retain: false, release: true);
  }
}

late final _class_SentryId$1 = objc.getClass("Sentry.SentryId");
late final _sel_empty = objc.registerName("empty");
late final _sel_sentryIdString = objc.registerName("sentryIdString");
late final _sel_initWithUuid_ = objc.registerName("initWithUuid:");
late final _sel_initWithUUIDString_ = objc.registerName("initWithUUIDString:");
late final _sel_isEqual_ = objc.registerName("isEqual:");
late final _sel_description = objc.registerName("description");
late final _sel_hash = objc.registerName("hash");
final _objc_msgSend_xw2lbc = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObjectImpl>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCSelector>)>();

/// SentryId
extension type SentryId$1._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SentryId$1] that points to the same underlying object as [other].
  SentryId$1.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [SentryId$1] that wraps the given raw object pointer.
  SentryId$1.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false})
      : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SentryId$1].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
      obj.ref.pointer, _sel_isKindOfClass_, _class_SentryId$1);

  /// alloc
  static SentryId$1 alloc() {
    final $ret = _objc_msgSend_151sglz(_class_SentryId$1, _sel_alloc);
    return SentryId$1.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SentryId$1 allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret =
        _objc_msgSend_1cwp428(_class_SentryId$1, _sel_allocWithZone_, zone);
    return SentryId$1.fromPointer($ret, retain: false, release: true);
  }

  /// A @c SentryId with an empty UUID “00000000000000000000000000000000”.
  static SentryId$1 getEmpty() {
    final $ret = _objc_msgSend_151sglz(_class_SentryId$1, _sel_empty);
    return SentryId$1.fromPointer($ret, retain: true, release: true);
  }

  /// new
  static SentryId$1 new$() {
    final $ret = _objc_msgSend_151sglz(_class_SentryId$1, _sel_new);
    return SentryId$1.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of SentryId$1 constructed with the default `new` method.
  SentryId$1() : this.as(new$().object$);
}

extension SentryId$1$Methods on SentryId$1 {
  /// description
  objc.NSString get description$1 {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_description);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// hash
  int get hash$1 {
    return _objc_msgSend_xw2lbc(object$.ref.pointer, _sel_hash);
  }

  /// init
  SentryId$1 init() {
    objc.checkOsVersionInternal('SentryId.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret =
        _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return SentryId$1.fromPointer($ret, retain: false, release: true);
  }

  /// Creates a @c SentryId from a 32 character hexadecimal string without dashes such as
  /// “12c2d058d58442709aa2eca08bf20986” or a 36 character hexadecimal string such as such as
  /// “12c2d058-d584-4270-9aa2-eca08bf20986”.
  /// @return SentryId.empty for invalid strings.
  SentryId$1 initWithUUIDString(objc.NSString uuidString) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(),
        _sel_initWithUUIDString_, uuidString.ref.pointer);
    return SentryId$1.fromPointer($ret, retain: false, release: true);
  }

  /// Creates a SentryId with the given UUID.
  SentryId$1 initWithUuid(NSUUID uuid) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(),
        _sel_initWithUuid_, uuid.ref.pointer);
    return SentryId$1.fromPointer($ret, retain: false, release: true);
  }

  /// isEqual:
  bool isEqual(objc.ObjCObject? object) {
    return _objc_msgSend_19nvye5(
        object$.ref.pointer, _sel_isEqual_, object?.ref.pointer ?? ffi.nullptr);
  }

  /// Returns a 32 lowercase character hexadecimal string description of the @c SentryId, such as
  /// “12c2d058d58442709aa2eca08bf20986”.
  objc.NSString get sentryIdString {
    final $ret =
        _objc_msgSend_151sglz(object$.ref.pointer, _sel_sentryIdString);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }
}

late final _class_SentryFlutterPlugin = objc.getClass("SentryFlutterPlugin");
late final _sel_loadContextsAsBytes = objc.registerName("loadContextsAsBytes");
late final _sel_loadDebugImagesAsBytes_ =
    objc.registerName("loadDebugImagesAsBytes:");

/// SentryFlutterPlugin
extension type SentryFlutterPlugin._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SentryFlutterPlugin] that points to the same underlying object as [other].
  SentryFlutterPlugin.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [SentryFlutterPlugin] that wraps the given raw object pointer.
  SentryFlutterPlugin.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other,
      {bool retain = false, bool release = false})
      : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SentryFlutterPlugin].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
      obj.ref.pointer, _sel_isKindOfClass_, _class_SentryFlutterPlugin);

  /// alloc
  static SentryFlutterPlugin alloc() {
    final $ret = _objc_msgSend_151sglz(_class_SentryFlutterPlugin, _sel_alloc);
    return SentryFlutterPlugin.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SentryFlutterPlugin allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
        _class_SentryFlutterPlugin, _sel_allocWithZone_, zone);
    return SentryFlutterPlugin.fromPointer($ret, retain: false, release: true);
  }

  /// loadContextsAsBytes
  static objc.NSData? loadContextsAsBytes() {
    final $ret = _objc_msgSend_151sglz(
        _class_SentryFlutterPlugin, _sel_loadContextsAsBytes);
    return $ret.address == 0
        ? null
        : objc.NSData.fromPointer($ret, retain: true, release: true);
  }

  /// loadDebugImagesAsBytes:
  static objc.NSData? loadDebugImagesAsBytes(objc.NSSet instructionAddresses) {
    final $ret = _objc_msgSend_1sotr3r(_class_SentryFlutterPlugin,
        _sel_loadDebugImagesAsBytes_, instructionAddresses.ref.pointer);
    return $ret.address == 0
        ? null
        : objc.NSData.fromPointer($ret, retain: true, release: true);
  }

  /// new
  static SentryFlutterPlugin new$() {
    final $ret = _objc_msgSend_151sglz(_class_SentryFlutterPlugin, _sel_new);
    return SentryFlutterPlugin.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of SentryFlutterPlugin constructed with the default `new` method.
  SentryFlutterPlugin() : this.as(new$().object$);
}

extension SentryFlutterPlugin$Methods on SentryFlutterPlugin {
  /// init
  SentryFlutterPlugin init() {
    objc.checkOsVersionInternal('SentryFlutterPlugin.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret =
        _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return SentryFlutterPlugin.fromPointer($ret, retain: false, release: true);
  }
}
